{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Open Source Core Network Implementation <p>free5GC is a Linux Foundation project dedicated to implementing 3GPP Release 15 and beyond core networks</p> Get Started How to Contribute Your Roadmap to 5G Expertise Starts Here \u2014 And It\u2019s Free! <p>Linux Foundation Education has launched Introduction to free5GC (LFS114), a free, self-paced course designed for developers, network engineers, and technologists who want to deepen their 5G expertise and work directly with modern 5G Core architecture. In just a few focused hours, you\u2019ll learn how free5GC is built, how its core functions operate, and how to navigate and engage with the codebase \u2014 giving you a real advantage in today\u2019s cloud native networking landscape.</p> <p>For more details, please visit the Introduction to free5GC (LFS114).</p> Latest News: free5GC v4.2.0 Released! <p>We have fixed a series of bugs in version 4.2.0 to improve stability and introduce a new feature: BSF.</p> <p>For more details, please see the history page.</p> View Version History \u2192 \ud83d\udcf1 Complete 5G Core Implementation <p>Compliant with 3GPP R15+ standards, providing comprehensive 5G core network functionalities</p> \ud83c\udf10 Service-Based Architecture <p>Built on Service-Based Architecture (SBA) for modular and scalable deployments</p> \ud83d\ude80 Containerized Deployment <p>Supports Kubernetes and Docker deployments, easily integrating with modern cloud-native environments</p> \ud83d\udd13 Open Source <p>Licensed under Apache 2.0, free for both commercial and non-commercial use with no restrictions</p> <p>The free5GC (a Linux Foundation project) is an open-source project for 5th generation (5G) mobile core networks. The ultimate goal of this project is to implement the 5G core network (5GC) defined in 3GPP Release 15 (R15) and beyond.</p> <p>Currently, the major contributors are from National Yang Ming Chiao Tung University (NYCU).</p> <ul> <li>The source code of the latest version of free5GC can be downloaded from here.</li> <li>Information about TSC (Technical Steering Committee) can be found at free5gc/governance.</li> <li>Follow our LinkedIn page to get the news about free5GC.</li> <li>Please refer to our roadmap for the features of each release.</li> </ul> <p>Note</p> <ul> <li>The Linux Foundation announced that free5GC officially joined the Linux Foundation on September 16, 2024, during the Open Source Summit Europe in Vienna, Austria. Check out the press release here.</li> <li>Please check out the Google Scholar page here for publications using free5GC.</li> </ul>"},{"location":"#connecting-to-the-future","title":"Connecting to the Future!","text":"<p>We remain committed to enhancing free5GC with new features, and we have a roadmap in place to support the following functionalities:</p> <ul> <li>CNTi</li> <li>UE Parallel Registratioin</li> </ul> Learn More About free5GC Development Plans"},{"location":"forum/","title":"The 1st free5GC World Forum 2025The 1st free5GC World Forum","text":"<p>In conjunction with ACM CCS 2025</p> <p>October 13, 2025 \u2022 Taipei, Taiwan</p> Visit ACM CCS 2025"},{"location":"forum/#about-the-forum","title":"About the ForumCall for Papers","text":"<p>We invite submissions for the 1st free5GC World Forum. The forum seeks original, unpublished papers focusing on security, architecture, innovation, and real-world applications of 5G core networks, particularly those leveraging the free5GC platform.</p> <p>Submission deadline: June 20 July 12, 2025</p>      Download CFP PDF    <p>We are pleased to announce the 1st free5GC World Forum, to be held in conjunction with ACM Conference on Computer and Communications Security (CCS) 2025 (https://www.sigsac.org/ccs/CCS2025/), one of the premier conferences in cybersecurity. This forum will bring together researchers, industry professionals, and open-source contributors to explore the challenges and recent advancements in 5G core networks, with a particular focus on security and the transformative role of free5GC, the leading open-source 5G Standalone (SA) core network. </p> <p>free5GC (https://free5gc.org/), a project hosted by the Linux Foundation, is a fully 3GPP-compliant open-source 5G core network platform. It empowers researchers, developers, and businesses to drive innovation in 5G systems, providing a robust prototyping environment for next-generation connectivity solutions. Recent notable architectures such as L25GC+ (https://github.com/nycu-ucr/L25GC-plus), which aim to significantly reduce control plane latency while maintaining 3GPP compliance, exemplify how free5GC facilitates the development and testing of cutting-edge ideas on a production-grade 5G core.</p> <p>The forum will provide a unique opportunity for participants to share insights, present innovations, and shape the future direction of free5GC and next-generation mobile networks.</p> <p>Submissions will be evaluated based on technical rigor, novelty, and relevance to 5G core networks. Priority will be given to papers that demonstrate practical security implications, novel attack models, performance improvements, or defense mechanisms applicable to free5GC, L25GC+, and related platforms.</p>"},{"location":"forum/#program","title":"Program","text":"<p>The following times are on GMT+8.</p> Time Session Title Authors/Speaker 10:00\u201310:10 Opening Opening Remarks 10:10\u201310:30 Keynote Recent Research and Development of free5GC Prof. Jyh-Cheng Chen, Lifetime Chair Professor, National Yang Ming Chiao Tung University 10:30\u201311:00 Break Morning Tea Break 11:00\u201312:00 Session I Rethinking 5G Core for Performance, Fairness, and Flexibility Yang-Zhe Lin, Chun-Ting Lin, Po-Yi Lin (National Yang Ming Chiao Tung University), Shixiong Qi (University of Kentucky), Jyh-Cheng Chen (National Yang Ming Chiao Tung University), K. K. Ramakrishnan (University of California, Riverside) A Machine Learning-Driven NWDAF Architecture For Intelligent 5G Core Networks Tsung-Fang Chen, Chien Chen, Jyh-Cheng Chen (National Yang Ming Chiao Tung University) Federated Spectrum Poisoning: Attacks and Defenses Ngoc Duy Pham, Thusitha Dayaratne (Monash University), Viet Vo (Swinburne University of Technology), Blake Haydon (Monash University), Shangqi Lai, Alsharif Abuadbba, Hajime Suzuki (CSIRO's Data61), Carsten Rudolph (Monash University), Xingliang Yuan (The University of Melbourne) 12:00\u201313:30 Break Lunch 13:30\u201315:00 Session II Saving 5G Core from Cryptocrastination Aditya Koranga (NgKore, OpenSSL and Post-Quantum Cryptography Alliance) Implementing EAP-TLS in free5GC for Non-SIM Device Connectivity Chuan-Yi Cheng, Yu-Xun Tang, Ping-Tsan Liu, Chi-Yu Li (National Yang Ming Chiao Tung University) Design and Implementation of Accounting Manipulation over PFCP in 5G Core Networks Jia-Ding Lin, Peng-Yu Chen, Chin-Ya Huang (National Taiwan University of Science and Technology) P4-enabled Trusted WLAN Access Network with Edge Computing Ze-yu Jin, Wai-Lok Shum, Li-Hsing Yen, Chien-Chao Tseng (National Yang Ming Chiao Tung University) Robust Anomaly Detection in O-RAN: Leveraging LLMs against Data Manipulation Attacks Thusitha Dayaratne, Ngoc Duy Pham (Monash University), Viet Vo (Swinburne University of Technology), Shangqi Lai, Sharif Abuadbba, Hajime Suzuki (CSIRO's Data61), Xingliang Yuan (The University of Melbourne), Carsten Rudolph (Monash University) 15:00\u201315:30 Break Afternoon Tea Break 15:30\u201316:20 Session III Creation and Support of 5G Core Network Slices with a focus on eMBB Meng-Ting Hsieh, Fuchun Joseph Lin, Chien Chen, Jyh-Cheng Chen (National Yang Ming Chiao Tung University) Performance and Viability Analysis of Deploying Cloud-native 5G Autoscaling Platforms Amber Yucebas, Ruoting Xiong, Yi Ren, Xu Zhang (University of East Anglia) Creation and Support of 5G Edge Network Slicing \u2013 Focusing on URLLC Slicing Wei-Cheng Lai, Fuchun Joseph Lin, Jyh-Cheng Chen, Chien Chen (National Yang Ming Chiao Tung University) Support New Radio Dual Connectivity (NR-DC) in free5GC Core Network Feng Tu, Chien Chen, Jyh-Cheng Chen (National Yang Ming Chiao Tung University) 16:20\u201316:30 Closing Concluding Remarks"},{"location":"forum/#topics-of-interest","title":"Topics of Interest","text":"<p>We invite original research papers, technical reports, and case studies in, but not limited to, the following areas:</p> 5G Security <ul> <li>Security and Privacy in 5G Core Networks</li> <li>Threat Modeling and Attack Detection for free5GC</li> <li>Secure Network Slicing and Isolation</li> <li>Authentication and Access Control in 5G</li> <li>Zero Trust Architectures for 5G Core Networks</li> <li>AI/ML for Anomaly Detection in free5GC</li> <li>Denial-of-Service (DoS) Mitigation in 5G Core</li> <li>End-to-End Security in 5G and Beyond</li> <li>Post-Quantum Cryptography for 5G Core</li> <li>Security of Interoperability Between 5G and Legacy Networks</li> <li>Forensics and Incident Response in 5G Core Networks</li> </ul> Network Architecture and Innovation <ul> <li>NFV and Container Security in 5G Deployments</li> <li>Low-Latency 5G Core Architectures (e.g., L25GC+)</li> <li>free5GC Development and Enhancements</li> <li>5G Standalone (SA) Core Networks</li> <li>Next-Generation Cellular Network Architectures</li> <li>Network Slicing and Virtualized Core Networks</li> <li>Edge Computing and MEC Integration</li> <li>AI/ML for Network Optimization</li> <li>6G Vision and Future Core Networks</li> <li>Interoperability and Multi-Vendor Deployments</li> <li>5G Core Support for Private Cellular Networks</li> <li>5G Core Support in Multi-Operator Network Scenarios</li> </ul> Real-World Use Cases of free5GC <ul> <li>Real-World Deployments and Use Cases of free5GC</li> <li>Open-Source Project integration with free5GC</li> </ul>"},{"location":"forum/#submission-guidelines","title":"Submission Guidelines","text":"<ul> <li>Submitted papers must not substantially overlap papers that have been published or that are simultaneously submitted to a journal or a conference with proceedings.</li> <li>Long papers: Maximum 12 pages for review, with the final camera-ready version limited to 9 pages. Submissions should be no more than 12 pages in the ACM double-column format, excluding the bibliography and well-marked appendix. Committee members are not required to read the appendices, so the paper should be understandable without them. For accepted papers, the final camera-ready version may be limited to 9 pages, including the bibliography, appendix, and all content.</li> <li>Short papers: 4 pages for both review and final camera-ready submission. The forum also welcomes short submissions of up to 4 pages for preliminary results or concise contributions that can be clearly described in a few pages.</li> <li>Authors of long-paper submissions may indicate in a footnote on the first page if they would like their paper to also be considered for publication as a short paper (4 pages in the proceedings).</li> <li>Submissions must be PDF files in the ACM double-column format (https://www.acm.org/publications/proceedings-template) using the \u201csigconf\u201d template. Authors should not modify the font or margins of the ACM format. The CCS information such as concepts, keywords, or rights management data (e.g., DOI, ISBN) must be included. A teaser figure is optional. Please refer to sample-sigconf.tex and sample-sigconf.pdf in the ACM LaTeX package (https://www.overleaf.com/latex/templates/association-for-computing-machinery-acm-sig-proceedings-template/bmvfhcdnxfty) for formatting examples. Submissions not following the required format may be rejected without review.</li> <li>Submissions should not be anonymized.</li> <li>Submissions are to be made to the submission website at HotCRP (https://free5gc-2025.hotcrp.com/). Only PDF files will be accepted. Submissions not meeting these guidelines risk rejection without consideration of their merits.</li> <li>Authors of accepted papers must ensure that their paper will be presented at the forum by at least one of the authors.</li> </ul> <p>Note</p> <p>Authors of accepted papers must guarantee that their paper will be presented at the workshop.</p>"},{"location":"forum/#important-dates","title":"Important Dates","text":"Paper Submission Deadline <p>June 20 July 12, 2025</p> Notification of Acceptance <p>August 8, 2025</p> Camera-Ready Papers Due <p>August 22, 2025</p> Forum Date <p>October 13, 2025</p>"},{"location":"forum/#venue","title":"Venue","text":"<p>The 1st free5GC World Forum will take place in conjunction with ACM CCS 2025 in Taipei, Taiwan, offering opportunities for in-depth discussions and collaboration on securing 5G core networks.</p>"},{"location":"forum/#visa","title":"Visa","text":"<p>Before traveling to Taiwan, please review the visa requirements and ensure that you have a valid visa. For detailed information, please visit: https://www.sigsac.org/ccs/CCS2025/visa/.</p>"},{"location":"forum/#organizing-committee","title":"Organizing Committee","text":"General Chairs Jyh-Cheng Chen <p>National Yang Ming Chiao Tung University (NYCU)</p> K. K. Ramakrishnan <p>University of California, Riverside</p> International Advisory Committee Falko Dressler <p>TU Berlin</p> Tommaso Melodia <p>Northeastern University</p> Akihiro Nakao <p>The University of Tokyo</p> Shivendra Panwar <p>Tandon School of Engineering of New York University</p> Ashutosh Sabharwal <p>Rice University</p> Gil Zussman <p>Columbia University</p> Technical Program Committee Chair Chien Chen <p>National Yang Ming Chiao Tung University (NYCU)</p> Publicity Chairs Chi-Yu Li <p>National Yang Ming Chiao Tung University (NYCU)</p> Shixiong Qi <p>University of Kentucky</p> Web Chair Yi Chen <p>National Yang Ming Chiao Tung University (NYCU)</p> Program Committee Members <p>Chien Chen, National Yang Ming Chiao Tung University (NYCU)</p> <p>Yi Chen, National Yang Ming Chiao Tung University (NYCU)</p> <p>Nakjung Choi, Nokia Bell Labs</p> <p>Rahman Doost-Mohammady, Rice University</p> <p>Ashutosh Dutta, Johns Hopkins University</p> <p>Xinyu Lei, Michigan Technological University</p> <p>Chi-Yu Li, National Yang Ming Chiao Tung University (NYCU)</p> <p>Fuchun Joseph Lin, National Yang Ming Chiao Tung University (NYCU)</p> <p>Yang Lou, National Yang Ming Chiao Tung University (NYCU)</p> <p>Chunyi Peng, Purdue University</p> <p>Shixiong Qi, University of Kentucky</p> <p>Edwin Ren, University of East Anglia</p> <p>Yuji Sekiya, The University of Tokyo</p> <p>Ivan Seskar, Rutgers University</p> <p>Zhaowei Tan, University of California, Riverside</p> <p>Chien-Chao Tseng,  National Yang Ming Chiao Tung University (NYCU)</p> <p>Guan-Hua Tu, Michigan State University</p> <p>Hiroki Watanabe, SoftBank Corp.</p> <p>Yang Xiao, University of Kentucky</p> <p>Tian Xie, Utah State University</p> <p>Li-Hsing Yen, National Yang Ming Chiao Tung University (NYCU)</p> <p>Antonia Zhai, University of Minnesota</p> <p>Zhi-Li Zhang, University of Minnesota</p> <p>\u00a9 2025 free5GC World Forum. All rights reserved.</p>"},{"location":"history/","title":"History","text":""},{"location":"history/#2026-roadmap","title":"2026 Roadmap","text":""},{"location":"history/#january-13-2026-v420","title":"January 13, 2026: v4.2.0","text":"<p>In the release v4.2.0 of free5GC, we have fixed s series of bugs, upgrade go versioin to 1.25.5, and also introduce new features:</p> <ul> <li>BSF</li> </ul>"},{"location":"history/#2025-roadmap","title":"2025 Roadmap","text":""},{"location":"history/#augest-29-2025-v410","title":"Augest 29, 2025: v4.1.0","text":"<p>In the release v4.1.0 of free5GC, we have fixed a series of bugs, which including:</p> <ul> <li>Encryption Method in TNGF</li> <li>Nil expiry in NSSAIAvailability POST api request</li> <li>Unsafe bdt type assertion</li> <li>Wrong response code in policydata bdt put procedure</li> <li>Non 3GPP reconnection fail</li> </ul> <p>In addition, we also introduce new features:</p> <ul> <li>NR-DC</li> <li>Prometheus metrics</li> </ul>"},{"location":"history/#april-22-2025-v401","title":"April 22, 2025: v4.0.1","text":"<p>In the release v4.0.1 of free5GC, we have fixed a series of bugs, which including:</p> <ul> <li>Kernel panic issue in GTP5G</li> <li>CGF Passive port range should be configurable</li> <li>Registration is possible even if the IMSI (first part) and PLMN (MCC/MNC) do not match.</li> <li>fix: race condition in OpenCDR()</li> </ul> <p>Moreover, we also enhanced our integration test framework, which now supports the TNGF registration.</p>"},{"location":"history/#march-3-2025-v400","title":"March 3, 2025: v4.0.0","text":"<p>The release v4.0.0 of free5GC upgrade the SBI server/consumer implementaions for All of NFs (except for NEF) to 3GPP R17 standards. The NEF upgrade is ongoing, and the R17 support will be released in v4.0.2.</p>"},{"location":"history/#feb-26-2025-v345","title":"Feb 26, 2025: v3.4.5","text":"<p>The release v3.4.5 of free5GC fixed a series of bugs, which including:</p> <ul> <li>Online Charging feature with ULCL deployment</li> <li>SMF #71: SM contexts collection Response not compliant to standard</li> <li>free5GC #627: There is an error in the information listed for QoS-related parameters</li> <li>free5GC #630: Regarding the PDU session release process during IDLE state</li> <li>free5GC Issue #617 - #620, #635 - #638</li> </ul> <p>Besides, the version v3.4.5 is the final release for 3GPP R15. We're no longer maintain the 3GPP R15 branch, any technical issue/vulnerability/feature will be added in the 3GPP R17 branch only.</p>"},{"location":"history/#2024-roadmap","title":"2024 Roadmap","text":""},{"location":"history/#nov-12-2024-v344","title":"Nov 12, 2024: v3.4.4","text":"<p>The release of free5GC v3.4.4 includes several new features, including default profile values in the Webconsole, a search bar for profiles and subscribers, NEF support for Traffic Influence, and NAT-T support for N3IWUE in N3IWF. The N3IWF configuration file has been refactored. Bug fixes address SMF ULCL charging issues, AMF authentication procedures, UE RAT type determination, and a UDM SUCI profile B decrypt error, along with other issues reported on GitHub and the free5GC forum.</p> <p>[Features]</p> <ul> <li>Add Profile(default values) for create subscriber in Webconsole</li> <li>Add Webconsole Search Bar for Profiles and Subscribers</li> <li>Released NEF that supporting Traffic Influence</li> <li>N3IWF support NAT-T with N3IWUE</li> <li>Go-UPF with v0.9.3 GTP5G Version</li> <li>SMF support SDM Subscription and Unsubscription for UE Session #123</li> </ul> <p>[Refactor]</p> <ul> <li>N3IWF Refactor, including the configuration file #618</li> <li>SMF Refactor, using Go context to track UPF association state #122</li> </ul> <p>[Bugs]</p> <ul> <li>SMF ULCL Charging Bugs</li> <li>AMF authentication procedure and UE RAT type determination issues.</li> <li>UDM SUCI profile B decrypt error #41</li> <li>Fix some bug reports from\u00a0Issues\u00a0or\u00a0Forum</li> </ul>"},{"location":"history/#sep-5-2024-v343","title":"Sep 5, 2024: v3.4.3","text":"<p>The release of free5GC v3.4.3 includes several new features, such as new network function TNGF, support for an empty SD value in SNSSAI, and the ability to disable CGF in CHF. It also features a refactored Subscriber Modal Page in the Webconsole. Additionally, several bugs have been fixed, including issues with double registration with N3IWF and unauthorized UE context releases, along with other bug fixes reported via GitHub issues and the free5GC forum.</p> <p>[Features]</p> <ul> <li>Release TNGF &amp; TNGFUE</li> <li>Support empty SD value (SNSSAI)</li> <li>Support disable CGF in CHF</li> </ul> <p>[Refactor]</p> <ul> <li>Refactor Subscriber Modal Page in Webconsole</li> </ul> <p>[Bugs]</p> <ul> <li>Fix can't registration with N3IWF twice problems</li> <li>Fix UEs can be context released by a second UE without authentication (src: Issue)</li> <li>Fix some bug reports from Issues or Forum</li> </ul>"},{"location":"history/#july-3-2024-v342","title":"July 3, 2024: v3.4.2","text":"<p>The free5GC v3.4.2 includes a Go version update to 1.21 and refactoring all Network Functions. New features include setting static IPs for UEs and OAuth2 authentication for the webconsole, plus a ULCL example in free5gc-compose. Bug fixes and a new commit message check are also included.</p> <p>[Refactor]</p> <ul> <li>Go version bump to Go1.21</li> <li>Refactor NFs for preparation upgrading openapi to Release17</li> </ul> <p>[Features]</p> <ul> <li>Set Static-IP for UE in webconsole </li> <li>Webconsole acts as AF and uses OAuth2 authentication to get OAM service from NFs</li> <li>Add ULCL docker-compose example in free5gc-compose</li> <li>Session AMBR in Data Plane</li> <li>CHF on k8s</li> </ul> <p>[Bugs]</p> <ul> <li>Fix N3IWUE fails to ping when having flow rules(v1.0.1)</li> <li>Fix some bug reports from Issues or Forum</li> </ul> <p>[Chore]</p> <ul> <li>Apply Conventional Commit Message check in Pull Request</li> </ul>"},{"location":"history/#march-28-2024-v341","title":"March 28, 2024: v3.4.1","text":"<p>In free5GC v3.4.1, Convergent Charging on PDU Session will be fully supported! Users will see the data usage on the webconsole after the PDU Session is created (please note that: The charging method (Online/Offline) needs to be determined during the subscription creation).</p> <p></p> <p>If you're interested in the implementation details, please visit the CHF design document.</p>"},{"location":"history/#feb-16-2024-v340","title":"Feb 16, 2024: v3.4.0","text":"<p>We are delighted to unveil the release of free5GC v3.4.0! In this latest version, free5GC now boasts support for OAuth within the Service-Based Architecture (SBA), marking a significant advancement in its capabilities. Furthermore, we have diligently addressed several issues and bugs that were reported by the Open-Source community, ensuring a smoother and more reliable user experience.</p> <ul> <li>OAuth Support<ul> <li>NRF acts as authorization server</li> <li>All Services in AMF, SMF, NRF, PCF, UDR, UDM, AUSF, NSSF are supported to validate/request access token</li> </ul> </li> <li>Implicit De-registration<ul> <li>Use case: UE has registered on Old AMF and send registration request to new AMF<ul> <li>New AMF is able to get the UE context by asking the old AMF, and old AMF will do the implicit de-registration.</li> </ul> </li> </ul> </li> <li>Support NAS Reroute (Issue #413)</li> <li>Support NITZ (Network Identiy and Time Zone) in UE Configuration Update Command (Issue #113)</li> <li>Bugfix<ul> <li>Issue #421</li> <li>Issue #387</li> </ul> </li> <li>Release N3IWUE<ul> <li>Source code: https://github.com/free5gc/n3iwue</li> </ul> </li> </ul>"},{"location":"publication/","title":"Relavent Publications","text":""},{"location":"publication/#publications-using-free5gc","title":"Publications using free5GC","text":"<ul> <li>Google Scholar</li> <li>ACM Library</li> <li>IEEE Xplore</li> </ul>"},{"location":"videos/","title":"Other Videos","text":""},{"location":"videos/#other-videos-showing-free5gc","title":"Other videos showing free5GC","text":"<ol> <li> <p>Complete Free5GC Installation on Kubernetes Cluster (Step-by-Step), September 13, 2023</p> </li> <li> <p>Akraino Blueprints: Integrated Cloud Native Private Wireless, The Linux Foundation, October 11, 2021</p> </li> <li> <p>SD Core Techinar July 7 2021, Open Networking Foundation, July 13, 2021</p> </li> <li> <p>Aarna Networks MWC 2021 Demo, Aarna Networks Channel, June 27, 2021</p> </li> <li> <p>OpenStack Tacker Demo, Open Infrastructure Foundation, April 26, 2021</p> </li> <li> <p>OpenNess Tungsten Fabric free5GC demo, Aarna Networks Channel, February 16, 2021</p> </li> <li> <p>5G Core on Diamanti, Diamanti, Inc., February 3, 2021</p> </li> <li> <p>free5GC (5G Core) Orchestration on Kubernetes with Tungsten Fabric CNI and Testing, Aarna Networks Channel, December 2, 2020</p> </li> <li> <p>IoT LoRa (sensors and gateway in hardware), RAN in hardware (SDR) and software, and the free5GC, LABORA Research Group, July 3, 2020</p> </li> <li> <p>UE and eNodeB in Hardware (conventional cell phone + SDR) and free5GC: a pratical approach in 5G, LABORA Research Group, July 3, 2020</p> </li> <li> <p>OpenAirInterface and free5GC: a pratical approach in 5G networks, LABORA Research Group, June 29, 2020</p> </li> </ol>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blogs","title":"Blogs","text":""},{"location":"blog/#official","title":"Official","text":"<ul> <li>2026/02/11: 5G-DPOP: eBPF-Based UPF Data Plane Observability Platform</li> <li>2026/02/04: PFCP Session Lifecycle in free5GC: Establish, Modify, and Release Explained</li> <li>2026/01/28: Network Function NSSF Introduction</li> <li>2026/01/21: Analyzing NF Discovery Requests:  Step-by-Step Trace of NFSelect Queries</li> <li>2026/01/14: Introduction of iperf3 and iftop  </li> <li>2026/01/07: MCP Server Integration with free5GC: Architecture and Use Cases</li> <li>2025/12/31: Beyond Standard Networking: Implementing 5G VRF Isolation in Go</li> <li>2025/12/24: Tracing the latency of the 5G Registration Procedure with eBPF</li> <li>2025/12/10: GTP5G Netlink Protocol Decoder: Implementation and Message Analysis</li> <li>2025/12/02: Introduction to BSF</li> <li>2025/11/26: Implementing GTP-driven Automatic Scheduling Optimization with eBPF-based Scheduler</li> <li>2025/11/19: NEF PFD Management Implementation and Testing</li> <li>2025/11/12: Getting Started with go-gtp5gnl: Userspace Control of GTP-U for free5GC UPF</li> <li>2025/11/05: Introduction of Xn and NG(N2) based handover</li> <li>2025/10/29: Introduction to 5G AKA</li> <li>2025/10/15: NGAP Introduction</li> <li>2025/10/08: Getting Started with ns-3: A Guide to Network Simulation and 5G Modeling</li> <li>2025/10/03: Visualizing 5G Core Metrics with Prometheus and Grafana on free5gc-helm</li> <li>2025/09/13: GTP5G-Tracer: Detailed Project Explanation and Expand</li> <li>2025/09/03: Handover in Non-Terrestrial Networks</li> <li>2025/07/26: Improving Network Performance with Custom eBPF-based Schedulers, [zh-tw]</li> <li>2025/07/23: Flexible GTP-U Handling: A Userspace Implementation</li> <li>2025/07/09: Time Synchronization with Linux Precision Time Protocol</li> <li>2025/07/03: A Practical Guide to Network Slicing and Traffic Steering with free5GC and OAI-MEC</li> <li>2025/05/21: Go context in free5GC</li> <li>2025/05/09: Hands-On with sched_ext: Building Custom eBPF CPU Schedulers</li> <li>2025/04/30: Namespace-Based GTP5G Conflict Resolution for free5GC and PacketRusher</li> <li>2025/04/29: Introduction to TNGF</li> <li>2025/04/24: Multi-node And Local UE free5GC Helm Installation</li> <li>2025/04/19: Unit test in free5GC's Network Function</li> <li>2025/03/19: Introduction of 5G Roaming</li> <li>2025/03/12: SCP introduction</li> <li>2025/03/06: Install Free5GC with LoxiLB NGAP load-balancing</li> <li>2025/03/05: Exploring sched_ext: BPF-Powered CPU Schedulers in the Linux Kernel</li> <li>2025/02/19: Introducing NR-DC: Dual Connectivity for Next-Gen 5G Capabilities</li> <li>2025/01/23: Network Devices in Linux</li> <li>2025/01/22: 5G LAN-type service</li> <li>2024/12/30: 5G Network Slicing</li> <li>2024/12/24: Debug gtp5g kernel module using stacktrace and eBPF</li> <li>2024/12/04: Paging in 5G Network</li> <li>2024/12/03: Loxilb eBPF</li> <li>2024/11/27: NWDAF introduction</li> <li>2024/11/13: Mapping PCC Rules into Session Rules: Policy Application in 5G Networks</li> <li>2024/11/08: Modeling Digital Twins in 5G Networks: A Glimpse into the Future of Intelligent Network Management</li> <li>2024/09/18: How L25GC+ achieved the low-latency communication</li> <li>2024/06/28: Introduction to 5G-QoS</li> <li>2024/06/26: NTN Overview</li> <li>2024/05/21: Introduction to Onos</li> <li>2024/03/27: Introduction of IP Multimedia Subsystem Part 3</li> <li>2024/02/21: Effective Network Management for Cloud-Native 5G Networks with eBPF</li> <li>2024/01/19: Registration Procedures</li> <li>2024/01/10: PacketRusher: A new UE/gNB simulator and CP/UP load tester</li> <li>2024/01/03: UE-initiated PLR Measurement Procedure in PMFP Procedure</li> <li>2023/12/13: Article Sharing: Evaluating Dedicated Slices of Different Configurations in 5G Core</li> <li>2023/12/06: Introduction of IP Multimedia Subsystem Part 2</li> <li>2023/11/29: Basic concept of RCU: Read, Copy, Update</li> <li>2023/11/22: Nephio: a Cloud Native Network Automation Linux Foundation Project</li> <li>2023/11/15: free5GC OAuth2 Procedure</li> <li>2023/11/08: Introduction of IP Multimedia Subsystem Part 1</li> <li>2023/10/18: LTE Authentication Introduction: EPS-AKA'</li> <li>2023/10/4: Introduction of MPTCP</li> <li>2023/9/27: Support of Time Sensitive Communication and Time Synchronization in 5G system - Introduction (Rel-17)</li> <li>2023/9/20: Introduction of gtp5g and some kernel concepts</li> <li>2023/9/13: CHarging Function(CHF) Overview</li> <li>2023/9/6: The role of VNFD and NSD in 5G Network Slicing</li> <li>2023/8/30: Article Sharing: eBPF: A New Approach to Cloud-Native Observability, Networking and Security for Current (5G) and Future Mobile Networks (6G and Beyond)</li> <li>2023/8/23: Web security: CSRF vulnerability in webconsole</li> <li>2023/8/16: Introduce Kubernetes and Deployment free5GC on Kubernetes with helm</li> <li>2023/8/9: Fuzz Testing in Go: Discovering Vulnerabilities and Analyzing a Real Case (CVE-2022-43677)</li> <li>2023/8/2: Authentication Mechanism in NRF: What Is OAuth?</li> <li>2023/7/26: How to deploy free5GC network slice on OpenStack</li> <li>2023/7/19: Network function UDM introduction</li> <li>2023/7/12: Time-Sensitive Networking over 5G system - Introduction (Rel-16)</li> <li>2023/7/5: Use network namespace to separate the 5GC and RAN simulator</li> <li>2023/6/21: 5G SCTP LoadBalancer Using LoxiLB Applying on free5GC</li> </ul>"},{"location":"blog/#external","title":"External","text":"<ul> <li>free5GC 5GC &amp; UERANSIM UE / RAN Sample Configuration - VPP-UPF with DPDK</li> <li>Deploy eBPF-based UPF with free5GC</li> <li>Introduce to 5GC (written in traditional chinese)</li> <li>Free5GC v3.4.3 source code study (written in simplified Chinese)</li> <li>Deploying 5G core network with Free5GC, Kubernetes and Helm</li> <li>Running Free5GC on Platform9 Managed Kubernetes</li> <li>Try iPhone connection with free5GC and real gNB(written in japanese)</li> </ul>"},{"location":"blog/20230705/1-free5gc-with-namespace/","title":"1 free5gc with namespace","text":""},{"location":"blog/20230705/1-free5gc-with-namespace/#use-network-namespace-to-separate-the-5g-core-5gc-and-ran-simulator","title":"Use network namespace to separate the 5G core (5GC) and RAN simulator","text":"<p>Note</p> <p>Author: Jimmy Chang Date: 2023/7/5</p>"},{"location":"blog/20230705/1-free5gc-with-namespace/#overview","title":"Overview","text":"<p>This technique leverages namespace to run UERANSIM, an opensource 5G-UE and RAN(gNodeB) simulator, and connect to free5GC. UERANSIM follows the 3GPP specification for developing and can support multiple 5G core (5GC) including free5GC.</p> <p>Why are we using namespace? Well, you can follow ULCL and free5GC compose to set up the environment with VM and docker, but there are limitations for hardware\u2019s capability. With network namespace, you can have different and separate network instances of network interfaces and routing tables that operate independently.</p> <p>So, what is network namespace? Network namespace makes a copy of network stack with its own routing table, firewall and devices. A named network namespace is an object at <code>/var/run/netns/</code>. The file descriptor resulting from opening <code>/var/run/netns/</code> refers to the specified network namespace. Holding that file descriptor open keeps the network namespace alive.</p> <p>And how to make both namespaces communicating? A virtual Ethernet device (veth) pair provides the abstraction that can be used to create tunnels between network namespaces, and can be used to create bridge to a physical network device in another namespace. Veth pair also be used as standalone network devices. When the namespace freed, veth device which attatch to would be destroyed.</p> <p>The environment is as follow. Suppose you have already installed as well as set up free5GC and UERANSIM properly.</p> <ul> <li>free5GC v3.3.0</li> <li>UERANSIM v3.1.0</li> </ul> <p>Note</p> <p>Namespace free5GC represents host network namespace. And enp0s5 is an ethernet interface connectting to external.</p> <p></p> <pre><code>Each devices as follow\n| Device        | IP             |\n| ------------- | -------------  |\n| veth0         | 10.200.200.1   |\n| veth1         | 10.200.200.2   |\n| br-veth0      | none           |\n| br-veth1      | none           |\n| enp0s5        | 10.211.55.23   |\n\n\nUE information in UERANSIM as follow. Already\n| IMSI             | DNN           |\n| ---------------- | ------------- |\n| 208930000000003  | internet      |\n</code></pre>"},{"location":"blog/20230705/1-free5gc-with-namespace/#configuration-file-of-free5gc-and-ueransim","title":"Configuration file of free5GC and UERANSIM","text":""},{"location":"blog/20230705/1-free5gc-with-namespace/#free5gc","title":"free5GC","text":"<ul> <li>free5gc/config/amfcfg.yaml</li> </ul> <p>Replace ngapIpList IP from <code>127.0.0.18</code> to <code>10.200.200.2</code>:</p> <p><pre><code>info:\n  version: 1.0.9\n  description: AMF initial local configuration\n\nconfiguration:\n  amfName: AMF # the name of this AMF\n  ngapIpList:  # the IP list of N2 interfaces on this AMF\n    - 10.200.200.2 # 127.0.0.18\n  ngapPort: 38412 # the SCTP port listened by NGAP\n  sbi: # Service-based interface information\n    scheme: http # the protocol for sbi (http or https)\n    registerIPv4: 127.0.0.18 # IP used to register to NRF\n    bindingIPv4: 127.0.0.18  # IP used to bind the service\n    port: 8000 # port used to bind the service\n    tls: # the local path of TLS key\n      pem: cert/amf.pem # AMF TLS Certificate\n      key: cert/amf.key # AMF TLS Private key\n  serviceNameList: # the SBI services provided by this AMF, refer to TS 29.518\n    - namf-comm # Namf_Communication service\n    - namf-evts # Namf_EventExposure service\n    - namf-mt   # Namf_MT service\n    - namf-loc  # Namf_Location service\n    - namf-oam  # OAM service\n  servedGuamiList: # Guami (Globally Unique AMF ID) list supported by this AMF\n    # &lt;GUAMI&gt; = &lt;MCC&gt;&lt;MNC&gt;&lt;AMF ID&gt;\n    - plmnId: # Public Land Mobile Network ID, &lt;PLMN ID&gt; = &lt;MCC&gt;&lt;MNC&gt;\n        mcc: 208 # Mobile Country Code (3 digits string, digit: 0~9)\n        mnc: 93 # Mobile Network Code (2 or 3 digits string, digit: 0~9)\n      amfId: cafe00 # AMF identifier (3 bytes hex string, range: 000000~FFFFFF)\n  supportTaiList:  # the TAI (Tracking Area Identifier) list supported by this AMF\n    - plmnId: # Public Land Mobile Network ID, &lt;PLMN ID&gt; = &lt;MCC&gt;&lt;MNC&gt;\n        mcc: 208 # Mobile Country Code (3 digits string, digit: 0~9)\n        mnc: 93 # Mobile Network Code (2 or 3 digits string, digit: 0~9)\n      tac: 000001 # Tracking Area Code (3 bytes hex string, range: 000000~FFFFFF)\n  plmnSupportList: # the PLMNs (Public land mobile network) list supported by this AMF\n    - plmnId: # Public Land Mobile Network ID, &lt;PLMN ID&gt; = &lt;MCC&gt;&lt;MNC&gt;\n        mcc: 208 # Mobile Country Code (3 digits string, digit: 0~9)\n        mnc: 93 # Mobile Network Code (2 or 3 digits string, digit: 0~9)\n      snssaiList: # the S-NSSAI (Single Network Slice Selection Assistance Information) list supported by this AMF\n        - sst: 1 # Slice/Service Type (uinteger, range: 0~255)\n          sd: 010203 # Slice Differentiator (3 bytes hex string, range: 000000~FFFFFF)\n        - sst: 1 # Slice/Service Type (uinteger, range: 0~255)\n          sd: 112233 # Slice Differentiator (3 bytes hex string, range: 000000~FFFFFF)\n  supportDnnList:  # the DNN (Data Network Name) list supported by this AMF\n    - internet\n  nrfUri: http://127.0.0.10:8000 # a valid URI of NRF\n  security:  # NAS security parameters\n    integrityOrder: # the priority of integrity algorithms\n      - NIA2\n      # - NIA0\n    cipheringOrder: # the priority of ciphering algorithms\n      - NEA0\n      # - NEA2\n  networkName:  # the name of this core network\n    full: free5GC\n    short: free\n  ngapIE: # Optional NGAP IEs\n    mobilityRestrictionList: # Mobility Restriction List IE, refer to TS 38.413\n      enable: true # append this IE in related message or not\n    maskedIMEISV: # Masked IMEISV IE, refer to TS 38.413\n      enable: true # append this IE in related message or not\n    redirectionVoiceFallback: # Redirection Voice Fallback IE, refer to TS 38.413\n      enable: false # append this IE in related message or not\n  nasIE: # Optional NAS IEs\n    networkFeatureSupport5GS: # 5gs Network Feature Support IE, refer to TS 24.501\n      enable: true # append this IE in Registration accept or not\n      length: 1 # IE content length (uinteger, range: 1~3)\n      imsVoPS: 0 # IMS voice over PS session indicator (uinteger, range: 0~1)\n      emc: 0 # Emergency service support indicator for 3GPP access (uinteger, range: 0~3)\n      emf: 0 # Emergency service fallback indicator for 3GPP access (uinteger, range: 0~3)\n      iwkN26: 0 # Interworking without N26 interface indicator (uinteger, range: 0~1)\n      mpsi: 0 # MPS indicator (uinteger, range: 0~1)\n      emcN3: 0 # Emergency service support indicator for Non-3GPP access (uinteger, range: 0~1)\n      mcsi: 0 # MCS indicator (uinteger, range: 0~1)\n  t3502Value: 720  # timer value (seconds) at UE side\n  t3512Value: 3600 # timer value (seconds) at UE side\n  non3gppDeregTimerValue: 3240 # timer value (seconds) at UE side\n  # retransmission timer for paging message\n  t3513:\n    enable: true     # true or false\n    expireTime: 6s   # default is 6 seconds\n    maxRetryTimes: 4 # the max number of retransmission\n  # retransmission timer for NAS Deregistration Request message\n  t3522:\n    enable: true     # true or false\n    expireTime: 6s   # default is 6 seconds\n    maxRetryTimes: 4 # the max number of retransmission\n  # retransmission timer for NAS Registration Accept message\n  t3550:\n    enable: true     # true or false\n    expireTime: 6s   # default is 6 seconds\n    maxRetryTimes: 4 # the max number of retransmission\n  # retransmission timer for NAS Authentication Request/Security Mode Command message\n  t3560:\n    enable: true     # true or false\n    expireTime: 6s   # default is 6 seconds\n    maxRetryTimes: 4 # the max number of retransmission\n  # retransmission timer for NAS Notification message\n  t3565:\n    enable: true     # true or false\n    expireTime: 6s   # default is 6 seconds\n    maxRetryTimes: 4 # the max number of retransmission\n  # retransmission timer for NAS Identity Request message\n  t3570:\n    enable: true     # true or false\n    expireTime: 6s   # default is 6 seconds\n    maxRetryTimes: 4 # the max number of retransmission\n  locality: area1 # Name of the location where a set of AMF, SMF, PCF and UPFs are located\n  sctp: # set the sctp server setting &lt;optinal&gt;, once this field is set, please also add maxInputStream, maxOsStream, maxAttempts, maxInitTimeOut\n    numOstreams: 3 # the maximum out streams of each sctp connection\n    maxInstreams: 5 # the maximum in streams of each sctp connection\n    maxAttempts: 2 # the maximum attempts of each sctp connection\n    maxInitTimeout: 2 # the maximum init timeout of each sctp connection\n  defaultUECtxReq: false # the default value of UE Context Request to decide when triggering Initial Context Setup procedure\n\nlogger: # log output setting\n  enable: true # true or false\n  level: info # how detailed to output, value: trace, debug, info, warn, error, fatal, panic\n  reportCaller: false # enable the caller report or not, value: true or false\n</code></pre> - free5gc/config/smfcfg.yaml</p> <p>Replace userplaneInformation / upNodes / UPF / interfaces / endpoints from <code>127.0.0.8</code> to <code>10.200.200.2</code>:</p> <p><pre><code>info:\n  version: 1.0.7\n  description: SMF initial local configuration\n\nconfiguration:\n  smfName: SMF # the name of this SMF\n  sbi: # Service-based interface information\n    scheme: http # the protocol for sbi (http or https)\n    registerIPv4: 127.0.0.2 # IP used to register to NRF\n    bindingIPv4: 127.0.0.2 # IP used to bind the service\n    port: 8000 # Port used to bind the service\n    tls: # the local path of TLS key\n      key: cert/smf.key # SMF TLS Certificate\n      pem: cert/smf.pem # SMF TLS Private key\n  serviceNameList: # the SBI services provided by this SMF, refer to TS 29.502\n    - nsmf-pdusession # Nsmf_PDUSession service\n    - nsmf-event-exposure # Nsmf_EventExposure service\n    - nsmf-oam # OAM service\n  snssaiInfos: # the S-NSSAI (Single Network Slice Selection Assistance Information) list supported by this AMF\n    - sNssai: # S-NSSAI (Single Network Slice Selection Assistance Information)\n        sst: 1 # Slice/Service Type (uinteger, range: 0~255)\n        sd: 010203 # Slice Differentiator (3 bytes hex string, range: 000000~FFFFFF)\n      dnnInfos: # DNN information list\n        - dnn: internet # Data Network Name\n          dns: # the IP address of DNS\n            ipv4: 8.8.8.8\n            ipv6: 2001:4860:4860::8888\n    - sNssai: # S-NSSAI (Single Network Slice Selection Assistance Information)\n        sst: 1 # Slice/Service Type (uinteger, range: 0~255)\n        sd: 112233 # Slice Differentiator (3 bytes hex string, range: 000000~FFFFFF)\n      dnnInfos: # DNN information list\n        - dnn: internet # Data Network Name\n          dns: # the IP address of DNS\n            ipv4: 8.8.8.8\n            ipv6: 2001:4860:4860::8888\n  plmnList: # the list of PLMN IDs that this SMF belongs to (optional, remove this key when unnecessary)\n    - mcc: 208 # Mobile Country Code (3 digits string, digit: 0~9)\n      mnc: 93 # Mobile Network Code (2 or 3 digits string, digit: 0~9)\n  locality: area1 # Name of the location where a set of AMF, SMF, PCF and UPFs are located\n  pfcp: # the IP address of N4 interface on this SMF (PFCP)\n    # addr config is deprecated in smf config v1.0.3, please use the following config\n    nodeID: 127.0.0.1 # the Node ID of this SMF\n    listenAddr: 127.0.0.1 # the IP/FQDN of N4 interface on this SMF (PFCP)\n    externalAddr: 127.0.0.1 # the IP/FQDN of N4 interface on this SMF (PFCP)\n  userplaneInformation: # list of userplane information\n    upNodes: # information of userplane node (AN or UPF)\n      gNB1: # the name of the node\n        type: AN # the type of the node (AN or UPF)\n      UPF: # the name of the node\n        type: UPF # the type of the node (AN or UPF)\n        nodeID: 127.0.0.8 # the Node ID of this UPF\n        addr: 127.0.0.8 # the IP/FQDN of N4 interface on this UPF (PFCP)\n        sNssaiUpfInfos: # S-NSSAI information list for this UPF\n          - sNssai: # S-NSSAI (Single Network Slice Selection Assistance Information)\n              sst: 1 # Slice/Service Type (uinteger, range: 0~255)\n              sd: 010203 # Slice Differentiator (3 bytes hex string, range: 000000~FFFFFF)\n            dnnUpfInfoList: # DNN information list for this S-NSSAI\n              - dnn: internet\n                pools:\n                  - cidr: 10.60.0.0/16\n                staticPools:\n                  - cidr: 10.60.100.0/24\n          - sNssai: # S-NSSAI (Single Network Slice Selection Assistance Information)\n              sst: 1 # Slice/Service Type (uinteger, range: 0~255)\n              sd: 112233 # Slice Differentiator (3 bytes hex string, range: 000000~FFFFFF)\n            dnnUpfInfoList: # DNN information list for this S-NSSAI\n              - dnn: internet\n                pools:\n                  - cidr: 10.61.0.0/16\n                staticPools:\n                  - cidr: 10.61.100.0/24\n        interfaces: # Interface list for this UPF\n          - interfaceType: N3 # the type of the interface (N3 or N9)\n            endpoints: # the IP address of this N3/N9 interface on this UPF\n              - 10.200.200.2 # 127.0.0.8\n            networkInstances:  # Data Network Name (DNN)\n              - internet\n    links: # the topology graph of userplane, A and B represent the two nodes of each link\n      - A: gNB1\n        B: UPF\n  # retransmission timer for pdu session modification command\n  t3591:\n    enable: true     # true or false\n    expireTime: 16s   # default is 6 seconds\n    maxRetryTimes: 3 # the max number of retransmission\n  # retransmission timer for pdu session release command\n  t3592:\n    enable: true     # true or false\n    expireTime: 16s   # default is 6 seconds\n    maxRetryTimes: 3 # the max number of retransmission\n  nrfUri: http://127.0.0.10:8000 # a valid URI of NRF\n  #urrPeriod: 10 # default usage report period in seconds\n  #urrThreshold: 1000 # default usage report threshold in bytes\n\nlogger: # log output setting\n  enable: true # true or false\n  level: info # how detailed to output, value: trace, debug, info, warn, error, fatal, panic\n  reportCaller: false # enable the caller report or not, value: true or false\n</code></pre> - free5gc/config/upfcfg.yaml</p> <p>Replace gtpu from <code>127.0.0.8</code>to <code>10.200.200.2</code>:</p> <pre><code>version: 1.0.3\ndescription: UPF initial local configuration\n\n# The listen IP and nodeID of the N4 interface on this UPF (Can't set to 0.0.0.0)\npfcp:\n  addr: 127.0.0.8   # IP addr for listening\n  nodeID: 127.0.0.8 # External IP or FQDN can be reached\n  retransTimeout: 1s # retransmission timeout\n  maxRetrans: 3 # the max number of retransmission\n\ngtpu:\n  forwarder: gtp5g\n  # The IP list of the N3/N9 interfaces on this UPF\n  # If there are multiple connection, set addr to 0.0.0.0 or list all the addresses\n  ifList:\n    - addr: 10.200.200.2 # 127.0.0.8\n      type: N3\n      # name: upf.5gc.nctu.me\n      # ifname: gtpif\n      # mtu: 1400\n\n# The DNN list supported by UPF\ndnnList:\n  - dnn: internet # Data Network Name\n    cidr: 10.60.0.0/24 # Classless Inter-Domain Routing for assigned IPv4 pool of UE\n    # natifname: eth0\n\nlogger: # log output setting\n  enable: true # true or false\n  level: info # how detailed to output, value: trace, debug, info, warn, error, fatal, panic\n  reportCaller: false # enable the caller report or not, value: true or false\n</code></pre>"},{"location":"blog/20230705/1-free5gc-with-namespace/#ueransim","title":"UERANSIM","text":"<ul> <li> <p>UERANSIM/config/free5gc-gnb.yaml</p> </li> <li> <p>Replace ngapIp from <code>127.0.0.1</code>to <code>10.200.200.1</code></p> </li> <li> <p>Replace gtpIp from <code>127.0.0.1</code>to <code>10.200.200.1</code></p> </li> <li> <p>Replace amfConfigs / address from <code>127.0.0.1</code>to <code>10.200.200.2</code></p> </li> </ul> <p><pre><code>mcc: '208'          # Mobile Country Code value\nmnc: '93'           # Mobile Network Code value (2 or 3 digits)\n\nnci: '0x000000010'  # NR Cell Identity (36-bit)\nidLength: 32        # NR gNB ID length in bits [22...32]\ntac: 1              # Tracking Area Code\n\nlinkIp: 127.0.0.1   # gNB's local IP address for Radio Link Simulation (Usually same with local IP)\nngapIp: 10.200.200.1 # 127.0.0.1   # gNB's local IP address for N2 Interface (Usually same with local IP)\ngtpIp: 10.200.200.1 # 127.0.0.1    # gNB's local IP address for N3 Interface (Usually same with local IP)\n\n# List of AMF address information\namfConfigs:\n  - address: 10.200.200.2 # 127.0.0.1\n    port: 38412\n\n# List of supported S-NSSAIs by this gNB\nslices:\n  - sst: 0x1\n    sd: 0x010203\n\n# Indicates whether or not SCTP stream number errors should be ignored.\nignoreStreamIds: true\n</code></pre> - UERANSIM/config/free5gc-ue.yaml <pre><code># IMSI number of the UE. IMSI = [MCC|MNC|MSISDN] (In total 15 or 16 digits)\nsupi: 'imsi-208930000000003'\n# Mobile Country Code value\nmcc: '208'\n# Mobile Network Code value (2 or 3 digits)\nmnc: '93'\n\n# Permanent subscription key\nkey: '8baf473f2f8fd09487cccbd7097c6862'\n# Operator code (OP or OPC) of the UE\nop: '8e27b6af0e692e750f32667a3b14605d'\n# This value specifies the OP type and it can be either 'OP' or 'OPC'\nopType: 'OP'\n# Authentication Management Field (AMF) value\namf: '8000'\n# IMEI number of the device. It is used if no SUPI is provided\nimei: '356938035643803'\n# IMEISV number of the device. It is used if no SUPI and IMEI is provided\nimeiSv: '4370816125816151'\n\n# List of gNB IP addresses for Radio Link Simulation\ngnbSearchList:\n  - 127.0.0.1\n\n# Initial PDU sessions to be established\nsessions:\n  - type: 'IPv4'\n    apn: 'internet'\n    slice:\n      sst: 0x01\n      sd: 0x010203\n\n# List of requested S-NSSAIs by this UE\nslices:\n  - sst: 0x01\n    sd: 0x010203\n\n# Supported encryption and integrity algorithms by this UE\nintegrity:\n  IA1: true\n  IA2: true\n  IA3: true\nciphering:\n  EA1: true\n  EA2: true\n  EA3: true\n</code></pre></p>"},{"location":"blog/20230705/1-free5gc-with-namespace/#environment-set-up-of-free5gc-and-ueransim","title":"Environment set up of free5GC and UERANSIM","text":"<p>First, create a namespace:</p> <p>Note</p> <p>Assume that you are either running as root, or it behoves you to prepend <code>sudo</code> to commands as necessary.</p> <p><pre><code>ip netns add ueransim\n</code></pre> Next, add the bridge: <pre><code>ip link add free5gc-br type bridge\n</code></pre> Add two pairs of veth: <pre><code>ip link add veth0 type veth peer name br-veth0\nip link add veth1 type veth peer name br-veth1\n</code></pre> Now, it could be like: <pre><code>root@free5gc:~# ip a\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n2: enp0s5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000\n    link/ether 00:1c:42:b1:ba:f4 brd ff:ff:ff:ff:ff:ff\n    inet 10.211.55.23/24 brd 10.211.55.255 scope global dynamic enp0s5\n       valid_lft 1714sec preferred_lft 1714sec\n    inet6 fdb2:2c26:f4e4:0:21c:42ff:feb1:baf4/64 scope global dynamic mngtmpaddr noprefixroute\n       valid_lft 2591750sec preferred_lft 604550sec\n    inet6 fe80::21c:42ff:feb1:baf4/64 scope link\n       valid_lft forever preferred_lft forever\n3: enp0s6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000\n    link/ether 00:1c:42:f1:11:c6 brd ff:ff:ff:ff:ff:ff\n    inet 10.37.129.20/24 brd 10.37.129.255 scope global enp0s6\n       valid_lft forever preferred_lft forever\n    inet6 fdb2:2c26:f4e4:1:21c:42ff:fef1:11c6/64 scope global dynamic mngtmpaddr noprefixroute\n       valid_lft 2591750sec preferred_lft 604550sec\n    inet6 fe80::21c:42ff:fef1:11c6/64 scope link\n       valid_lft forever preferred_lft forever\n4: free5gc-br: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000\n    link/ether 4e:f6:d7:9c:50:de brd ff:ff:ff:ff:ff:ff\n5: br-veth0@veth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000\n    link/ether c2:31:0c:5f:45:81 brd ff:ff:ff:ff:ff:ff\n6: veth0@br-veth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000\n    link/ether 4a:0f:1e:80:9b:be brd ff:ff:ff:ff:ff:ff\n7: br-veth1@veth1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000\n    link/ether 56:99:b0:82:78:0d brd ff:ff:ff:ff:ff:ff\n8: veth1@br-veth1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000\n    link/ether 12:5a:56:00:5b:be brd ff:ff:ff:ff:ff:ff\n</code></pre></p> <p>Next, assign interface to namespace: <pre><code>ip link set dev veth0 netns ueransim\n</code></pre> Set ip address: <pre><code>ip netns exec ueransim ip a add 10.200.200.1/24 dev veth0\n</code></pre> Enable both interface. Don't forget lo: <pre><code>ip netns exec ueransim ip link set lo up\nip netns exec ueransim ip link set veth0 up\n</code></pre> Check with <code>ip a</code>: <pre><code>root@free5gc:~# ip netns exec ueransim ip a\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n6: veth0@if5: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state LOWERLAYERDOWN group default qlen 1000\n    link/ether 4a:0f:1e:80:9b:be brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 10.200.200.1/24 scope global veth0\n       valid_lft forever preferred_lft forever\n</code></pre> Set for veth1 as well: <pre><code>ip a add 10.200.200.2/24 dev veth1\nip link set veth1 up\n</code></pre> Let two interfaces attatch to bridge: <pre><code>ip link set dev br-veth0 master free5gc-br\nip link set dev br-veth1 master free5gc-br\nip link set br-veth0 up\nip link set br-veth1 up\nip link set free5gc-br up\n</code></pre> Using <code>bridge link</code> to check: <pre><code>root@free5gc:~# bridge link\n5: br-veth0@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 master free5gc-br state forwarding priority 32 cost 2\n7: br-veth1@veth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 master free5gc-br state forwarding priority 32 cost 2\n</code></pre> Now it looks like: <pre><code>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n2: enp0s5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000\n    link/ether 00:1c:42:b1:ba:f4 brd ff:ff:ff:ff:ff:ff\n    inet 10.211.55.23/24 brd 10.211.55.255 scope global dynamic enp0s5\n       valid_lft 1000sec preferred_lft 1000sec\n    inet6 fdb2:2c26:f4e4:0:21c:42ff:feb1:baf4/64 scope global dynamic mngtmpaddr noprefixroute\n       valid_lft 2591870sec preferred_lft 604670sec\n    inet6 fe80::21c:42ff:feb1:baf4/64 scope link\n       valid_lft forever preferred_lft forever\n3: enp0s6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000\n    link/ether 00:1c:42:f1:11:c6 brd ff:ff:ff:ff:ff:ff\n    inet 10.37.129.20/24 brd 10.37.129.255 scope global enp0s6\n       valid_lft forever preferred_lft forever\n    inet6 fdb2:2c26:f4e4:1:21c:42ff:fef1:11c6/64 scope global dynamic mngtmpaddr noprefixroute\n       valid_lft 2591870sec preferred_lft 604670sec\n    inet6 fe80::21c:42ff:fef1:11c6/64 scope link\n       valid_lft forever preferred_lft forever\n4: free5gc-br: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n    link/ether 56:99:b0:82:78:0d brd ff:ff:ff:ff:ff:ff\n    inet6 fe80::5499:b0ff:fe82:780d/64 scope link\n       valid_lft forever preferred_lft forever\n5: br-veth0@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master free5gc-br state UP group default qlen 1000\n    link/ether c2:31:0c:5f:45:81 brd ff:ff:ff:ff:ff:ff link-netns ueransim\n    inet6 fe80::c031:cff:fe5f:4581/64 scope link\n       valid_lft forever preferred_lft forever\n7: br-veth1@veth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master free5gc-br state UP group default qlen 1000\n    link/ether 56:99:b0:82:78:0d brd ff:ff:ff:ff:ff:ff\n    inet6 fe80::5499:b0ff:fe82:780d/64 scope link\n       valid_lft forever preferred_lft forever\n8: veth1@br-veth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n    link/ether 12:5a:56:00:5b:be brd ff:ff:ff:ff:ff:ff\n    inet 10.200.200.2/24 scope global veth1\n       valid_lft forever preferred_lft forever\n    inet6 fe80::105a:56ff:fe00:5bbe/64 scope link\n       valid_lft forever preferred_lft forever\n</code></pre> Let's test it:</p> <p>Note</p> <p>You can perform <code>ip netns exec ueransim /bin/bash --rcfile &lt;(echo \"PS1=\\\"ueransim&gt; \\\"\")</code> to enter namespace and modify shell prefix.</p> <p><pre><code>root@free5gc:~# ip netns exec ueransim /bin/bash --rcfile &lt;(echo \"PS1=\\\"ueransim&gt; \\\"\")\nueransim&gt; ping -c2 10.200.200.2\nPING 10.200.200.2 (10.200.200.2) 56(84) bytes of data.\n64 bytes from 10.200.200.2: icmp_seq=1 ttl=64 time=0.089 ms\n64 bytes from 10.200.200.2: icmp_seq=2 ttl=64 time=0.226 ms\n\n--- 10.200.200.2 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1020ms\nrtt min/avg/max/mdev = 0.089/0.157/0.226/0.068 ms\n</code></pre> Insert default routing rule: <pre><code>ueransim&gt; ip route add default via 10.200.200.2\nueransim&gt; netstat -rn\nKernel IP routing table\nDestination     Gateway         Genmask         Flags   MSS Window  irtt Iface\n0.0.0.0         10.200.200.2    0.0.0.0         UG        0 0          0 veth0\n10.200.200.0    0.0.0.0         255.255.255.0   U         0 0          0 veth0\n</code></pre> Try to ping 8.8.8.8: <pre><code>ueransim&gt; ping -c2 8.8.8.8\nPING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.\n\n--- 8.8.8.8 ping statistics ---\n2 packets transmitted, 0 received, 100% packet loss, time 1028ms\n</code></pre> It is because the main host must translate the source addresses. Besides, the main host need to forward packet: <pre><code>root@free5gc:~# iptables -t nat -A POSTROUTING -o enp0s5 -j MASQUERADE\nroot@free5gc:~# sysctl -w net.ipv4.ip_forward=1\nroot@free5gc:~# sudo iptables -I FORWARD 1 -j ACCEPT\n</code></pre> And then: <pre><code>ueransim&gt; ping -c2 8.8.8.8\nPING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.\n64 bytes from 8.8.8.8: icmp_seq=1 ttl=127 time=13.9 ms\n64 bytes from 8.8.8.8: icmp_seq=2 ttl=127 time=28.0 ms\n\n--- 8.8.8.8 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1002ms\nrtt min/avg/max/mdev = 13.866/20.939/28.012/7.073 ms\n</code></pre></p> <p>After free5GC execute <code>run.sh</code>, it's time for UERANSIM:</p> <p>In terminal 1: <pre><code>ueransim&gt; build/nr-gnb -c config/free5gc-gnb.yaml\nUERANSIM v3.1.0\n[2023-07-05 19:58:26.368] [sctp] [info] Trying to establish SCTP connection... (10.200.200.2:38412)\n[2023-07-05 19:58:26.373] [sctp] [info] SCTP connection established (10.200.200.2:38412)\n[2023-07-05 19:58:26.374] [sctp] [debug] SCTP association setup ascId[3]\n[2023-07-05 19:58:26.375] [ngap] [debug] Sending NG Setup Request\n[2023-07-05 19:58:26.380] [ngap] [debug] NG Setup Response received\n[2023-07-05 19:58:26.380] [ngap] [info] NG Setup procedure is successful\n[2023-07-05 19:58:35.804] [mr] [info] New UE connected to gNB. Total number of UEs is now: 1\n[2023-07-05 19:58:35.806] [rrc] [debug] Sending RRC Setup for UE[3]\n[2023-07-05 19:58:35.807] [ngap] [debug] Initial NAS message received from UE 3\n[2023-07-05 19:58:35.869] [ngap] [debug] Initial Context Setup Request received\n[2023-07-05 19:58:36.108] [ngap] [info] PDU session resource is established for UE[3] count[1]\n</code></pre> In terminal 2: <pre><code>ueransim&gt; sudo build/nr-ue -c config/free5gc-ue.yaml\nUERANSIM v3.1.0\n[2023-07-05 19:58:35.803] [nas] [debug] NAS layer started\n[2023-07-05 19:58:35.803] [rrc] [debug] RRC layer started\n[2023-07-05 19:58:35.804] [nas] [info] UE switches to state: MM-DEREGISTERED/PLMN-SEARCH\n[2023-07-05 19:58:35.804] [nas] [info] UE connected to gNB\n[2023-07-05 19:58:35.804] [nas] [info] UE switches to state: MM-DEREGISTERED/NORMAL-SERVICE\n[2023-07-05 19:58:35.804] [nas] [info] UE switches to state: MM-REGISTERED-INITIATED/NA\n[2023-07-05 19:58:35.805] [rrc] [debug] Sending RRC Setup Request\n[2023-07-05 19:58:35.806] [rrc] [info] RRC connection established\n[2023-07-05 19:58:35.806] [nas] [info] UE switches to state: CM-CONNECTED\n[2023-07-05 19:58:35.838] [nas] [debug] Received rand[61262F32A617D0BAD716603B1CBDA477] autn[44778026F4238000FC14B59D68855328]\n[2023-07-05 19:58:35.838] [nas] [debug] Calculated res[47759045F5ACEA59] ck[1C559301F29EF49572F5D150B3B99288] ik[D223317F752F233CE4C7AA253644D882] ak[528433D1FBE6] mac_a[FC14B59D68855328]\n[2023-07-05 19:58:35.838] [nas] [debug] Used snn[5G:mnc093.mcc208.3gppnetwork.org] sqn[16F3B3F70FC5]\n[2023-07-05 19:58:35.838] [nas] [debug] Derived kSeaf[7FC8B7FB1B141B6579B9C0FAEB9CCF1312FE9F9634868E234756DE49FD67C5F1] kAusf[FA0402A892E6046D52F4DECACA40B2A75B698FCEAD5EB320139FC69B77BD4C46] kAmf[3D4AD68E153B9642ACBECC67AD399015F7CB578F9DF4C88A35EED99C72C9B95B]\n[2023-07-05 19:58:35.843] [nas] [debug] Derived kNasEnc[1F829EB2BA238DD0226C3484E6A79D1F] kNasInt[251C0412B1BAD88A9DD0008F32D6F216]\n[2023-07-05 19:58:35.843] [nas] [debug] Selected integrity[2] ciphering[0]\n[2023-07-05 19:58:35.869] [nas] [debug] T3512 started with int[3600]\n[2023-07-05 19:58:35.869] [nas] [info] UE switches to state: MM-REGISTERED/NORMAL-SERVICE\n[2023-07-05 19:58:35.869] [nas] [info] Initial Registration is successful\n[2023-07-05 19:58:35.869] [nas] [info] Initial PDU sessions are establishing [1#]\n[2023-07-05 19:58:35.869] [nas] [debug] Sending PDU session establishment request\n[2023-07-05 19:58:36.108] [nas] [info] PDU Session establishment is successful PSI[1]\n[2023-07-05 19:58:36.113] [app] [info] Connection setup for PDU session[1] is successful, TUN interface[uesimtun0, 10.60.0.1] is up.\n</code></pre> In terminal 3: <pre><code>ueransim&gt; ip a\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n2: uesimtun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 500\n    link/none\n    inet 10.60.0.1/32 scope global uesimtun0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::b5ef:5b4:e3f6:af64/64 scope link stable-privacy\n       valid_lft forever preferred_lft forever\n6: veth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n    link/ether 4a:0f:1e:80:9b:be brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 10.200.200.1/24 scope global veth0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::480f:1eff:fe80:9bbe/64 scope link\n       valid_lft forever preferred_lft forever\nueransim&gt; ping -c2 -I uesimtun0 8.8.8.8\nPING 8.8.8.8 (8.8.8.8) from 10.60.0.1 uesimtun0: 56(84) bytes of data.\n64 bytes from 8.8.8.8: icmp_seq=1 ttl=127 time=19.5 ms\n64 bytes from 8.8.8.8: icmp_seq=2 ttl=127 time=33.2 ms\n\n--- 8.8.8.8 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1006ms\nrtt min/avg/max/mdev = 19.478/26.348/33.219/6.870 ms\n</code></pre> Also ping to google.com: <pre><code>ueransim&gt; ping -c2 -I uesimtun0 google.com\nPING google.com (172.217.160.110) from 10.60.0.1 uesimtun0: 56(84) bytes of data.\n64 bytes from tsa03s06-in-f14.1e100.net (172.217.160.110): icmp_seq=1 ttl=127 time=17.3 ms\n64 bytes from tsa03s06-in-f14.1e100.net (172.217.160.110): icmp_seq=2 ttl=127 time=29.5 ms\n\n--- google.com ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1005ms\nrtt min/avg/max/mdev = 17.295/23.385/29.476/6.090 ms\n</code></pre></p>"},{"location":"blog/20230705/1-free5gc-with-namespace/#what-if-two-ueransims-with-two-namespaces","title":"What if two UERANSIMs with two namespaces?","text":"<p>Same as before, you should create another namespace for UERANSIM, called it ueransim2: <pre><code>root@free5gc:~# ip netns ls\nueransim2 (id: 1)\nueransim (id: 0)\n</code></pre> And then: <pre><code>ip link add veth2 type veth peer name br-veth2\nip link set dev veth2 netns ueransim2\nip link set br-veth2 master free5gc-br\nip link set br-veth2 up\nip netns exec ueransim2 ip a add 10.200.200.3/24 dev veth2\nip netns exec ueransim2 ip link set lo up\nip netns exec ueransim2 ip link set veth2 up\nip netns exec ueransim2 ip route add default via 10.200.200.2\n</code></pre></p> <p>Copy UERANSIM/config/free5gc-gnb.yaml and UERANSIM/config/free5gc-ue.yaml to free5gc-gnb2.yaml and free5gc-ue2.yaml, modify:</p> <p>free5gc-gnb2.yaml</p> <ul> <li>Replace ngapIp from <code>127.0.0.1</code> to <code>10.200.200.3</code></li> <li>Replace gtpIp from <code>127.0.0.1</code> to <code>10.200.200.3</code></li> </ul> <p><pre><code>...\nngapIp: 10.200.200.3 # 127.0.0.1   # gNB's local IP address for N2 Interface (Usually same with local IP)\ngtpIp: 10.200.200.3 # 127.0.0.1    # gNB's local IP address for N3 Interface (Usually same with local IP)\n\n# List of AMF address information\namfConfigs:\n  - address: 10.200.200.2 # 127.0.0.1\n    port: 38412\n...\n</code></pre> free5gc-ue2.yaml</p> <p><code>supi</code> change to <code>imsi-208930000000004</code></p> <pre><code>...\n# IMSI number of the UE. IMSI = [MCC|MNC|MSISDN] (In total 15 or 16 digits)\nsupi: 'imsi-208930000000004'\n...\n</code></pre> <p>Note</p> <p>Should register ue to webconsole first.</p> <p>The result: <pre><code>ueransim&gt; ip a\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n6: veth0@if5: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n    link/ether 4a:0f:1e:80:9b:be brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 10.200.200.1/24 scope global veth0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::480f:1eff:fe80:9bbe/64 scope link\n       valid_lft forever preferred_lft forever\n7: uesimtun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 500\n    link/none\n    inet 10.60.0.1/32 scope global uesimtun0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::f6d7:dd81:fe7f:496a/64 scope link stable-privacy\n       valid_lft forever preferred_lft forever\nueransim&gt; ping -c2 -I uesimtun0 google.com\nPING google.com (172.217.160.110) from 10.60.0.1 uesimtun0: 56(84) bytes of data.\n64 bytes from tsa03s06-in-f14.1e100.net (172.217.160.110): icmp_seq=1 ttl=127 time=17.2 ms\n64 bytes from tsa03s06-in-f14.1e100.net (172.217.160.110): icmp_seq=2 ttl=127 time=28.5 ms\n\n--- google.com ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1003ms\nrtt min/avg/max/mdev = 17.200/22.863/28.527/5.663 ms\n</code></pre></p> <pre><code>ueransim2&gt; ip a\n1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n5: uesimtun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 500\n    link/none\n    inet 10.60.0.2/32 scope global uesimtun0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::16a4:523a:a86:bf83/64 scope link stable-privacy\n       valid_lft forever preferred_lft forever\n12: veth2@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000\n    link/ether fa:12:bb:9c:fa:40 brd ff:ff:ff:ff:ff:ff link-netnsid 0\n    inet 10.200.200.3/24 scope global veth2\n       valid_lft forever preferred_lft forever\n    inet6 fe80::f812:bbff:fe9c:fa40/64 scope link\n       valid_lft forever preferred_lft forever\nueransim2&gt; ping -c2 -I uesimtun0 google.com\nPING google.com (172.217.160.110) from 10.60.0.2 uesimtun0: 56(84) bytes of data.\n64 bytes from tsa03s06-in-f14.1e100.net (172.217.160.110): icmp_seq=1 ttl=127 time=18.9 ms\n64 bytes from tsa03s06-in-f14.1e100.net (172.217.160.110): icmp_seq=2 ttl=127 time=15.8 ms\n\n--- google.com ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1002ms\nrtt min/avg/max/mdev = 15.786/17.353/18.921/1.567 ms\n</code></pre>"},{"location":"blog/20230705/1-free5gc-with-namespace/#about","title":"About","text":"<p>Hi, my name is Jimmy Chang. The current research topic is 5G LAN with a focus on the 5G Data Plane. Any questions or errors in the article are welcome for correction. Please feel free to send an email to provide feedback.</p> <ul> <li>Graduate student major in 5GC Research</li> <li>LinkedIn</li> </ul>"},{"location":"blog/20230705/1-free5gc-with-namespace/#reference","title":"Reference","text":"<ul> <li>https://github.com/s5uishida/free5gc_ueransim_ulcl_sample_config</li> <li>https://github.com/free5gc/free5gc/blob/main/test_ulcl.sh</li> <li>https://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/</li> <li>https://man7.org/linux/man-pages/man7/namespaces.7.html</li> <li>https://linux.die.net/man/8/iptables</li> </ul>"},{"location":"blog/20230712/TSN/","title":"Time-Sensitive Networking over 5G system - Introduction (Rel-16)","text":"<p>Note</p> <p>Author: Ya-shih Tseng Date: 2023/7/12</p> <p>This blog focuses on the role of the 5G system in 3GPP Release 16 TSN (Time-Sensitive Networking).</p>"},{"location":"blog/20230712/TSN/#what-is-time-sensitive-network-tsn","title":"What is Time-Sensitive Network (TSN)","text":"<p>Traditional Ethernet technology can only achieve \"best-effort\" communication and cannot meet the high reliability and low latency requirements of industrial manufacturing applications. Therefore, in the context of industrial automation, there is a need to upgrade the traditional \"best-effort\" Ethernet to provide \"deterministic\" services.</p> <p>Time Sensitive Networking (TSN) brings determinism and real-time communication to standard Ethernet through mechanisms and protocols defined by the IEEE 802.1 standard, which is used by Audio Video Bridging (AVB) and TSN. It offers reliable message delivery, minimized jitter, and guaranteed delivery through central management, time scheduling, and other key features. The introduction of TSN technology holds great potential and benefits for real-time applications in industrial control, automation, and other fields. </p> <p>TSN_OSI_layer</p>"},{"location":"blog/20230712/TSN/#tsn-standard","title":"TSN Standard","text":"<p>There are a lot of standards that TSN task group has completed or ongoing projects. Here are some base standards.</p> Standard Title IEEE 1588 V2 Precision Clock Synchronization Protocol for Networked Measurement and Control Systems IEEE 802.1Q-2022 Bridges and Bridged Networks IEEE 802.1AB-2016 Station and Media Access Control Connectivity Discovery (specifies the Link Layer Discovery Protocol (LLDP)) IEEE 802.1AS-2020 Timing and Synchronization for Time-Sensitive Applications IEEE 802.1AX-2020 Link Aggregation IEEE 802.1CB-2017 Frame Replication and Elimination for Reliability IEEE 802.1CS-2020 Link-local Registration Protocol"},{"location":"blog/20230712/TSN/#the-role-of-5g-system-in-tsn","title":"The role of 5G system in TSN","text":"<p>With the increasing demands for wireless control in applications such as industrial automation, remote surgical operations, smart grid distribution automation, transportation safety, autonomous driving, and more, there is a growing need to meet the low-latency requirements of these applications while achieving management, scheduling, and traffic planning. Time synchronization becomes a critical aspect. The following will explain how the interaction between TSN and 5G systems enables time synchronization.</p>"},{"location":"blog/20230712/TSN/#time-synchronization","title":"Time Synchronization","text":"<p>To achieve time synchronization between TSN and 5G systems, TSN utilizes the time synchronization method defined in IEEE 802.1AS, which is the generalized Precision Time Protocol (gPTP). gPTP supports time synchronization for Time-aware end stations and Time-aware Bridges in Layer 2.  In the 3GPP TS23.501 release 16 specification, the 5G system plays the role of a \"Time-aware system\" as defined in IEEE 802.1AS and is designated as a Logical bridge, connecting TSN system end stations.</p> <p>Note</p> <p>gPTP is an extended version of PTP (Precision Time Protocol) that primarily expands support for second-layer network devices.</p> <p>How can we synchronize the time of two end stations into the same time domain?</p> <p>First, the time synchronization architecture includes Master clocks and Slave clocks. The Master regularly sends sync messages to allow the Slave to obtain the Master's time. The Slave, in turn, periodically sends peer delay requests to exchange messages with the Master, obtaining the delay time between the two devices for time correction. Additionally, the resident time, which is the message propagation delay introduced by bridges, should also be taken into account. By considering all these factors, the time synchronization of both sides can be achieved within the TSN time domain. </p> <p>Time Synchronization process of gPTP</p> <p>Check the link for more detail about how PTP works.</p>"},{"location":"blog/20230712/TSN/#intergration-of-tsn-and-5g","title":"Intergration of TSN and 5G","text":"<p>By now, I believe you have gained an understanding of the time synchronization mechanism in TSN. Let's briefly explain how the 5G system supports TSN as a logical TSN bridge. The 3GPP has defined new functionalities such as NW-TT, DS-TT, and TSN-AF, as well as TSN control nodes like CUC and CNC. Please check TS 23.501 Release 16 for more details. </p> <p>System architecture of 5G support TSN</p>"},{"location":"blog/20230712/TSN/#support-ethernet-type-pdu-session","title":"Support Ethernet type PDU session","text":"<p>To archive the intergration, 5G system should support ingress port and egress port pair via an Ethernet Type PDU session between the corresponding UE and UPF. As mentioned above, gPTP supports layer 2 (Ethernet) only.</p>"},{"location":"blog/20230712/TSN/#ds-tt-and-nw-tt","title":"DS-TT and NW-TT","text":"<p>In the 5G system, DS-TT (Device-side TSN translator) and NW-TT (Network-side TSN translator) serve as TSN translators. DS-TT is responsible for connecting TSN Slave endpoints with the UE, while NW-TT connects TSN Master endpoints with the UPF.</p> <p>When the sync message generated by the Master clock reaches the bridge, NW-TT captures its Ingress Timestamp and measures the delay between NW-TT and the Master clock. These timestamps are then embedded within the sync message and transmitted to the UE. Once the UE receives the sync message, DS-TT calculates the resident time by subtracting the Ingress Timestamp provided in the sync message, from the Egress Timestamp which represents the time of sync message reception. The resident time is added to the delay time mentioned in the sync message to determine the corrected time. Through the assistance of the TSN translators, the Slave endpoint receives the message and obtains information about time deviation and other relevant data for further adjustment.</p> <p>Note</p> <p>DS-TT and NW-TT enable the 5G system to function as a virtual bridge. The bridge is also called \"Transparent clock\" which is definded in IEEE 1588 and required in IEEE 802.1AS. You can say that Master and Slaver don't know the exist of the 5G TSN bridge, since it's logical transparent.</p> <p>\"Transparent clocks are used to route timing messages within a network. Used when: Ethernet timing must pass through switches.\" - different type of clocks</p>"},{"location":"blog/20230712/TSN/#tsn-af","title":"TSN-AF","text":"<p>With TSN-AF, CNC can manage the 5G system functioning as a logical bridge and achieve the integration of the 5G TSN bridge with the TSN network in collaboration with NW-TT and DS-TT. Additionally, TSN-AF gathers information and capability lists of the 5G TSN Bridge and transmits them to CNC.</p>"},{"location":"blog/20230712/TSN/#tsn-control-nodes","title":"TSN control nodes","text":"<p>To meet the requirements of application services and control TSN, there are two key functions utilized in the TSN system. CNC (Centralized Network Controller), as the central controller in the TSN system, receives the information from CUC (Centralized User Configuration) and performs scheduling and planning tasks. It calculates the optimal transmission schedule for the TSN traffic based on factors such as bandwidth requirements, latency constraints, and network conditions. Once the transmission schedule is computed and confirmed, CNC proceeds to deploy the necessary network resource configuration on the TSN switches. This ensures that the TSN network operates efficiently and effectively in delivering the required QoS (Quality of Service) for the application services.</p>"},{"location":"blog/20230712/TSN/#reference","title":"Reference","text":"<ul> <li>IEEE Std 802.1AS-2020: \u201cIEEE Standard for Local and metropolitan area networks--Timing and Synchronization for Time-Sensitive Applications\u201d.</li> <li>IEEE Std 1588: \u201cIEEE Standard for a Precision Clock Synchronization Protocol for Networked Measurement and Control Systems\u201d, Edition 2019.</li> <li>3GPP TS 23.501 Release 16</li> <li>Time-Sensitive Networking - Wikipedia</li> <li>Time-Sensitive Networking (TSN) Task Group | - IEEE 802.1</li> </ul>"},{"location":"blog/20230712/TSN/#about","title":"About","text":"<p>Hi, This is Ya-shih Tseng. I am currently researching the implementation of 5G TSN (Time-Sensitive Networking) as part of my master's studies. In the future, I will introduce more information about TSN. Hope you enjoy it.</p>"},{"location":"blog/20230719/UDM_introduce/","title":"Network function UDM introduction","text":"<p>Note</p> <p>Author: \u5f35\u54f2\u777f Date: 2023/7/19</p>"},{"location":"blog/20230719/UDM_introduce/#overview","title":"Overview","text":"<p>In this article, I will introduce UDM and its three services that will be used in the general UE registration procedure (Nudm_UECM service, Nudm_SubscriberDataManagement Service, and Nudm_UEAuthentication service) to let everyone understand UDM more clearly.</p>"},{"location":"blog/20230719/UDM_introduce/#udm","title":"UDM","text":"<p>Unified Data Management is responsible for managing information related to UE. When other NFs need to use the UE subscription information, they will obtain it from UDM through the SBI of UDM.</p>"},{"location":"blog/20230719/UDM_introduce/#nudm_ueauthentication-service","title":"Nudm_UEAuthentication Service","text":"<p>This service is used by AUSF to retrieve authentication-related information and, after authentication, confirm the result.</p> <p></p> <p>3GPP TS33.501 v15.2.0</p> <p>In Authentication, AUSF uses the GET operation to retrieve authentication information for the UE. The request contains the UE\u2019s identity (supi or suci) and the serving network name. The serving network name is used in the derivation of the anchor key, which is used by subsensual authentication. UE\u2019s identity will be contained in the URI, and the serving network name will be contained in the request body.</p> <p>Upon reception of the Nudm_UEAuthentication_Get Request, the UDM shall de-conceal SUCI to gain SUPI if SUCI is received. At this time, UDM will query the authentication subscription data from UDR. Then, UDM shall select the authentication method based on SUPI, and if required (e.g., 5G-AKA), UDM will calculate the authentication vector and pass it to AUSF.</p> <ul> <li>SUPI: A globally unique 5G Subscription Permanent Identifier, used to identify UE.</li> <li>SUCI: Subscription concealed identifier, obtained by encrypting supi through the Home Network Public Key so that supi will not be obtained by a third party on the network.</li> </ul> <pre><code>logger.UeauLog.Traceln(\"In GenerateAuthDataProcedure\")\n\nresponse = &amp;models.AuthenticationInfoResult{}\nrand.Seed(time.Now().UnixNano())\nsupi, err := suci.ToSupi(supiOrSuci, udm_context.Getself().SuciProfiles)\nif err != nil {\n    problemDetails = &amp;models.ProblemDetails{\n        Status: http.StatusForbidden,\n        Cause:  authenticationRejected,\n        Detail: err.Error(),\n    }\n\n    logger.UeauLog.Errorln(\"suciToSupi error: \", err.Error())\n    return nil, problemDetails\n}\n\nlogger.UeauLog.Tracef(\"supi conversion =&gt; [%s]\", supi)\n\nclient, err := createUDMClientToUDR(supi)\nif err != nil {\n    return nil, openapi.ProblemDetailsSystemFailure(err.Error())\n}\nauthSubs, res, err := client.AuthenticationDataDocumentApi.QueryAuthSubsData(context.Background(), supi, nil)\n\n//in the udm/internal/sbi/producer/generate_auth_data.go, GenerateAuthDataProcedure function.\n</code></pre> <p>From the code, we can see UDM first de-conceal SUCI (line 5), then use QueryAuthSubsData to get authSub from UDR. After that, UDM uses this information to create the authentication vector.</p> <p>Then we record the packet sent in the registration process and find the packet according to the URI specified by the specification. We can find the packet corresponding to this service.</p> <p></p> <p>Open the response packet, and we can see the response body matches the AuthenticationInfoResult data type.</p> <p></p> <p></p> <p>3GPP TS29.503 v15.2.1</p> <p>After AUSF authenticates the UE, it will confirm the result with UDM. These details will be used in linking authentication confirmation to the Nudm_UECM_Registration procedure from AMF.</p> <pre><code>func communicateWithUDM(ue *context.AmfUe, accessType models.AccessType) error {\n    ue.GmmLog.Debugln(\"communicateWithUDM\")\n    amfSelf := context.GetSelf()\n\n    // UDM selection described in TS 23.501 6.3.8\n    // TODO: consider udm group id, Routing ID part of SUCI, GPSI or External Group ID (e.g., by the NEF)\n    param := Nnrf_NFDiscovery.SearchNFInstancesParamOpts{\n        Supi: optional.NewString(ue.Supi),\n    }\n    resp, err := consumer.SendSearchNFInstances(amfSelf.NrfUri, models.NfType_UDM, models.NfType_AMF, &amp;param)\n    if err != nil {\n        return errors.Errorf(\"AMF can not select an UDM by NRF: SendSearchNFInstances failed\")\n    }\n\n    var uecmUri, sdmUri string\n    for _, nfProfile := range resp.NfInstances {\n        ue.UdmId = nfProfile.NfInstanceId\n        uecmUri = util.SearchNFServiceUri(nfProfile, models.ServiceName_NUDM_UECM, models.NfServiceStatus_REGISTERED)\n        sdmUri = util.SearchNFServiceUri(nfProfile, models.ServiceName_NUDM_SDM, models.NfServiceStatus_REGISTERED)\n        if uecmUri != \"\" &amp;&amp; sdmUri != \"\" {\n            break\n        }\n    }\n    ue.NudmUECMUri = uecmUri\n    ue.NudmSDMUri = sdmUri\n    if ue.NudmUECMUri == \"\" || ue.NudmSDMUri == \"\" {\n        return errors.Errorf(\"AMF can not select an UDM by NRF: SearchNFServiceUri failed\")\n    }\n\n    problemDetails, err := consumer.UeCmRegistration(ue, accessType, true)\n    if problemDetails != nil {\n        return errors.Errorf(problemDetails.Cause)\n    } else if err != nil {\n        return errors.Wrap(err, \"UECM_Registration Error\")\n    }\n\n    // TS 23.502 4.2.2.2.1 14a-c.\n    // \"After a successful response is received, the AMF subscribes to be notified\n    //      using Nudm_SDM_Subscribe when the data requested is modified\"\n    problemDetails, err = consumer.SDMGetAmData(ue)\n    if problemDetails != nil {\n        return errors.Errorf(problemDetails.Cause)\n    } else if err != nil {\n        return errors.Wrap(err, \"SDM_Get AmData Error\")\n    }\n\n    problemDetails, err = consumer.SDMGetSmfSelectData(ue)\n    if problemDetails != nil {\n        return errors.Errorf(problemDetails.Cause)\n    } else if err != nil {\n        return errors.Wrap(err, \"SDM_Get SmfSelectData Error\")\n    }\n\n    problemDetails, err = consumer.SDMGetUeContextInSmfData(ue)\n    if problemDetails != nil {\n        return errors.Errorf(problemDetails.Cause)\n    } else if err != nil {\n        return errors.Wrap(err, \"SDM_Get UeContextInSmfData Error\")\n    }\n\n    problemDetails, err = consumer.SDMSubscribe(ue)\n    if problemDetails != nil {\n        return errors.Errorf(problemDetails.Cause)\n    } else if err != nil {\n        return errors.Wrap(err, \"SDM Subscribe Error\")\n    }\n    ue.ContextValid = true\n    return nil\n}\n\n\n//in the amf/internal/gmm/handler.go.\n</code></pre> <p>Next, let's take a look at this function. It is called in HandleInitialRegistration, which handles UE's initial registration. UeCmRegistration will use the Nudm_UECM (UECM) service to store related UE Context Management information in UDM. In lines 40, 47, and 54, AMF uses the Nudm_SubscriberDataManagement (SDM) Service to get some subscribe data.</p>"},{"location":"blog/20230719/UDM_introduce/#nudm_uecontextmanagement-service","title":"Nudm_UEContextManagement Service","text":"<p>In the UeCmRegistration function, AMF registers as UE's serving NF on UDM and stores related UE Context Management information in UDM. Looking at the packet, you can see that the request body contains <code>amfInstanceId</code> and <code>guami</code>, representing the amf identity, and <code>ratType</code>, representing the radio access technology type used by UE.</p> <p></p> <pre><code>// TS 29.503 5.3.2.2.2\nfunc RegistrationAmf3gppAccessProcedure(registerRequest models.Amf3GppAccessRegistration, ueID string) (\n    header http.Header, response *models.Amf3GppAccessRegistration, problemDetails *models.ProblemDetails,\n) {\n    // TODO: EPS interworking with N26 is not supported yet in this stage\n    var oldAmf3GppAccessRegContext *models.Amf3GppAccessRegistration\n    if udm_context.Getself().UdmAmf3gppRegContextExists(ueID) {\n        ue, _ := udm_context.Getself().UdmUeFindBySupi(ueID)\n        oldAmf3GppAccessRegContext = ue.Amf3GppAccessRegistration\n    }\n\n    udm_context.Getself().CreateAmf3gppRegContext(ueID, registerRequest)\n\n    clientAPI, err := createUDMClientToUDR(ueID)\n    if err != nil {\n        return nil, nil, openapi.ProblemDetailsSystemFailure(err.Error())\n    }\n\n    var createAmfContext3gppParamOpts Nudr_DataRepository.CreateAmfContext3gppParamOpts\n    optInterface := optional.NewInterface(registerRequest)\n    createAmfContext3gppParamOpts.Amf3GppAccessRegistration = optInterface\n    resp, err := clientAPI.AMF3GPPAccessRegistrationDocumentApi.CreateAmfContext3gpp(context.Background(),\n        ueID, &amp;createAmfContext3gppParamOpts)\n    if err != nil {\n        logger.UecmLog.Errorln(\"CreateAmfContext3gpp error : \", err)\n        problemDetails = &amp;models.ProblemDetails{\n            Status: int32(resp.StatusCode),\n            Cause:  err.(openapi.GenericOpenAPIError).Model().(models.ProblemDetails).Cause,\n            Detail: err.Error(),\n        }\n        return nil, nil, problemDetails\n    }\n    defer func() {\n        if rspCloseErr := resp.Body.Close(); rspCloseErr != nil {\n            logger.UecmLog.Errorf(\"CreateAmfContext3gpp response body cannot close: %+v\", rspCloseErr)\n        }\n    }()\n\n    // TS 23.502 4.2.2.2.2 14d: UDM initiate a Nudm_UECM_DeregistrationNotification to the old AMF\n    // corresponding to the same (e.g. 3GPP) access, if one exists\n    if oldAmf3GppAccessRegContext != nil {\n        deregistData := models.DeregistrationData{\n            DeregReason: models.DeregistrationReason_SUBSCRIPTION_WITHDRAWN,\n            AccessType:  models.AccessType__3_GPP_ACCESS,\n        }\n        callback.SendOnDeregistrationNotification(ueID, oldAmf3GppAccessRegContext.DeregCallbackUri,\n            deregistData) // Deregistration Notify Triggered\n\n        return nil, nil, nil\n    } else {\n        header = make(http.Header)\n        udmUe, _ := udm_context.Getself().UdmUeFindBySupi(ueID)\n        header.Set(\"Location\", udmUe.GetLocationURI(udm_context.LocationUriAmf3GppAccessRegistration))\n        return header, &amp;registerRequest, nil\n    }\n}\n\n//in the udm/internal/sbi/producer/ue_context_management.go\n</code></pre> <p>In the RegistrationAmf3gppAccessProcedure function, UDM first checks whether the context has been established for that UE; if UDM has such a context, it initiates a Nudm_UECM_DeregistrationNotification to the old AMF later. UDM used the received information to create context and stored it in UDR.</p>"},{"location":"blog/20230719/UDM_introduce/#nudm_subscriberdatamanagement-sdm-service","title":"Nudm_SubscriberDataManagement (SDM) Service","text":"<p>The SDM service is used to retrieve the UE's individual subscription data relevant to the consumer's NF from the UDM. In the SDMGetAmData function, AMF gets subscription data used in registration and mobility management. In the response packet, AMF got <code>gpsis</code>, <code>subscribedUeAmbr</code>, and <code>nssai</code>.</p> <p></p> <p>The GPSI (Generic Public Subscription Identifier) is used to address a 3GPP subscription in data networks outside the realms of a 3GPP system. It contains either an External ID or an MSISDN \uff08Mobile Subscriber ISDN Number\uff09.The <code>subscribedUeAmbr</code> is The Maximum Aggregated uplink and downlink MBRs (max. bit rate) to be shared across all Non-GBR (non-guaranteed Bit Rate) QoS Flows according to the subscription of the user.</p> <p></p> <p>In the SDMGetSmfSelectData function, AMF gets subscribed S-NSSAIs (Single Network Slice Selection Assistance Information) and Data Network Names for these S-NSSAIs. AMF will use this information to select an SMF that manages the PDU Session.</p> <pre><code>func HandleInitialRegistration(ue *context.AmfUe, anType models.AccessType) error {\n    ue.GmmLog.Infoln(\"Handle InitialRegistration\")\n\n    amfSelf := context.GetSelf()\n\n    // update Kgnb/Kn3iwf\n    ue.UpdateSecurityContext(anType)\n\n    // Registration with AMF re-allocation (TS 23.502 4.2.2.2.3)\n    if len(ue.SubscribedNssai) == 0 {\n        getSubscribedNssai(ue)\n    }\n\n    if err := handleRequestedNssai(ue, anType); err != nil {\n        return err\n    }\n\n//in the amf/internal/gmm/handler.go.\n</code></pre> <p>In the initialization of HandleInitialRegistration, AMF sends a request to the UDM to receive the UE's NSSAI (Network Slice Selection Assistance Information). After receiving subscribed NSSAI, AMF will compare it to UE's requested NSSAI. If there is a S-NSSAI that has not been subscribed before, AMF will request NSSF for Allowed NSSAI.</p> <pre><code>func handleRequestedNssai(ue *context.AmfUe, anType models.AccessType) error {\n    amfSelf := context.GetSelf()\n\n    if ue.RegistrationRequest.RequestedNSSAI != nil {\n        requestedNssai, err := nasConvert.RequestedNssaiToModels(ue.RegistrationRequest.RequestedNSSAI)\n        if err != nil {\n            return fmt.Errorf(\"Decode failed at RequestedNSSAI[%s]\", err)\n        }\n\n        needSliceSelection := false\n        for _, requestedSnssai := range requestedNssai {\n            ue.GmmLog.Infof(\"RequestedNssai - ServingSnssai: %+v, HomeSnssai: %+v\",\n                requestedSnssai.ServingSnssai, requestedSnssai.HomeSnssai)\n            if ue.InSubscribedNssai(*requestedSnssai.ServingSnssai) {\n                allowedSnssai := models.AllowedSnssai{\n                    AllowedSnssai: &amp;models.Snssai{\n                        Sst: requestedSnssai.ServingSnssai.Sst,\n                        Sd:  requestedSnssai.ServingSnssai.Sd,\n                    },\n                    MappedHomeSnssai: requestedSnssai.HomeSnssai,\n                }\n                if !ue.InAllowedNssai(*allowedSnssai.AllowedSnssai, anType) {\n                    ue.AllowedNssai[anType] = append(ue.AllowedNssai[anType], allowedSnssai)\n                }\n            } else {\n                needSliceSelection = true\n                break\n            }\n        }\n\n        if needSliceSelection {\n            if ue.NssfUri == \"\" {\n                for {\n                    err := consumer.SearchNssfNSSelectionInstance(ue, amfSelf.NrfUri, models.NfType_NSSF, models.NfType_AMF, nil)\n                    if err != nil {\n                        ue.GmmLog.Errorf(\"AMF can not select an NSSF Instance by NRF[Error: %+v]\", err)\n                        time.Sleep(2 * time.Second)\n                    } else {\n                        break\n                    }\n                }\n            }\n\n            // Step 4\n            problemDetails, err := consumer.NSSelectionGetForRegistration(ue, requestedNssai)\n            if problemDetails != nil {\n                ue.GmmLog.Errorf(\"NSSelection Get Failed Problem[%+v]\", problemDetails)\n                gmm_message.SendRegistrationReject(ue.RanUe[anType], nasMessage.Cause5GMMProtocolErrorUnspecified, \"\")\n                return fmt.Errorf(\"Handle Requested Nssai of UE failed\")\n            } else if err != nil {\n                ue.GmmLog.Errorf(\"NSSelection Get Error[%+v]\", err)\n                gmm_message.SendRegistrationReject(ue.RanUe[anType], nasMessage.Cause5GMMProtocolErrorUnspecified, \"\")\n                return fmt.Errorf(\"Handle Requested Nssai of UE failed\")\n            }\n\n//in the amf/internal/gmm/handler.go.\n</code></pre> <pre><code>if param.SliceInfoRequestForRegistration.RequestedNssai != nil &amp;&amp;\n    len(param.SliceInfoRequestForRegistration.RequestedNssai) != 0 {\n    // Requested NSSAI is provided\n    // Verify which S-NSSAI(s) in the Requested NSSAI are permitted based on comparing the Subscribed S-NSSAI(s)\n    if param.Tai != nil &amp;&amp;\n        !util.CheckSupportedNssaiInPlmn(param.SliceInfoRequestForRegistration.RequestedNssai, *param.Tai.PlmnId) {\n        // Return ProblemDetails indicating S-NSSAI is not supported\n        // TODO: Based on TS 23.501 V15.2.0, if the Requested NSSAI includes an S-NSSAI that is not valid in the\n        //       Serving PLMN, the NSSF may derive the Configured NSSAI for Serving PLMN\n        *problemDetails = models.ProblemDetails{\n            Title:  util.UNSUPPORTED_RESOURCE,\n            Status: http.StatusForbidden,\n            Detail: \"S-NSSAI in Requested NSSAI is not supported in PLMN\",\n            Cause:  \"SNSSAI_NOT_SUPPORTED\",\n        }\n\n        status = http.StatusForbidden\n        return status\n    }\n\n    // Check if any Requested S-NSSAIs is present in Subscribed S-NSSAIs\n    checkIfRequestAllowed := false\n\n    for _, requestedSnssai := range param.SliceInfoRequestForRegistration.RequestedNssai {\n        if param.Tai != nil &amp;&amp; !util.CheckSupportedSnssaiInTa(requestedSnssai, *param.Tai) {\n            // Requested S-NSSAI does not supported in UE's current TA\n            // Add it to Rejected NSSAI in TA\n            authorizedNetworkSliceInfo.RejectedNssaiInTa = append(\n                authorizedNetworkSliceInfo.RejectedNssaiInTa,\n                requestedSnssai)\n            continue\n        }\n\n        var mappingOfRequestedSnssai models.Snssai\n        // TODO: Compared with Restricted S-NSSAI list in configuration under roaming scenario\n        if param.HomePlmnId != nil &amp;&amp; !util.CheckStandardSnssai(requestedSnssai) {\n            // Standard S-NSSAIs are supported to be commonly decided by all roaming partners\n            // Only non-standard S-NSSAIs are required to find mappings\n            targetMapping, found := util.FindMappingWithServingSnssai(requestedSnssai,\n                param.SliceInfoRequestForRegistration.MappingOfNssai)\n\n            if !found {\n                // No mapping of Requested S-NSSAI to HPLMN S-NSSAI is provided by UE\n                // TODO: Search for local configuration if there is no provided mapping from UE, and update UE's\n                //       Configured NSSAI\n                checkInvalidRequestedNssai = true\n                authorizedNetworkSliceInfo.RejectedNssaiInPlmn = append(\n                    authorizedNetworkSliceInfo.RejectedNssaiInPlmn,\n                    requestedSnssai)\n                continue\n            } else {\n                // TODO: Check if mappings of S-NSSAIs are correct\n                //       If not, update UE's Configured NSSAI\n                mappingOfRequestedSnssai = *targetMapping.HomeSnssai\n            }\n        } else {\n            mappingOfRequestedSnssai = requestedSnssai\n        }\n\n        hitSubscription := false\n        for _, subscribedSnssai := range param.SliceInfoRequestForRegistration.SubscribedNssai {\n            if mappingOfRequestedSnssai == *subscribedSnssai.SubscribedSnssai {\n                // Requested S-NSSAI matches one of Subscribed S-NSSAI\n                // Add it to Allowed NSSAI list\n                hitSubscription = true\n\n                var allowedSnssaiElement models.AllowedSnssai\n                allowedSnssaiElement.AllowedSnssai = new(models.Snssai)\n                *allowedSnssaiElement.AllowedSnssai = requestedSnssai\n                nsiInformationList := util.GetNsiInformationListFromConfig(requestedSnssai)\n                if nsiInformationList != nil {\n                    // TODO: `NsiInformationList` should be slice in `AllowedSnssai` instead of pointer of slice\n                    allowedSnssaiElement.NsiInformationList = append(\n                        allowedSnssaiElement.NsiInformationList,\n                        nsiInformationList...)\n                }\n                if param.HomePlmnId != nil &amp;&amp; !util.CheckStandardSnssai(requestedSnssai) {\n                    allowedSnssaiElement.MappedHomeSnssai = new(models.Snssai)\n                    *allowedSnssaiElement.MappedHomeSnssai = *subscribedSnssai.SubscribedSnssai\n                }\n\n                // Default Access Type is set to 3GPP Access if no TAI is provided\n                // TODO: Depend on operator implementation, it may also return S-NSSAIs in all valid Access Type if\n                //       UE's Access Type could not be identified\n                var accessType models.AccessType = models.AccessType__3_GPP_ACCESS\n                if param.Tai != nil {\n                    accessType = util.GetAccessTypeFromConfig(*param.Tai)\n                }\n\n                util.AddAllowedSnssai(allowedSnssaiElement, accessType, authorizedNetworkSliceInfo)\n\n                checkIfRequestAllowed = true\n                break\n            }\n        }\n\n        if !hitSubscription {\n            // Requested S-NSSAI does not match any Subscribed S-NSSAI\n            // Add it to Rejected NSSAI in PLMN\n            checkInvalidRequestedNssai = true\n            authorizedNetworkSliceInfo.RejectedNssaiInPlmn = append(\n                authorizedNetworkSliceInfo.RejectedNssaiInPlmn,\n                requestedSnssai)\n        }\n    }\n\n    if !checkIfRequestAllowed {\n        // No S-NSSAI from Requested NSSAI is present in Subscribed S-NSSAIs\n        // Subscribed S-NSSAIs marked as default are used\n        useDefaultSubscribedSnssai(param, authorizedNetworkSliceInfo)\n    }\n} else {\n    // No Requested NSSAI is provided\n    // Subscribed S-NSSAIs marked as default are used\n    checkInvalidRequestedNssai = true\n    useDefaultSubscribedSnssai(param, authorizedNetworkSliceInfo)\n}\n\n//in the nssf/internal/sbi/producer/nsselection_for_registration.go, nsselectionForRegistration funcion.\n</code></pre> <p>If NSSF needs to select S-NSSAI, it first finds the mapping of requested NSSAI to configured NSSAI for the HPLMN and converts requested S-NSSAI to S-NSSAI in configured NSSAI for the HPLMN. Then compare these S-NSSAIs with Subscribed S-NSSAIs; if NSSF find one match, set it as <code>AllowedSnssai</code>. If NSSF can't find such a mapping or no S-NSSAI in the mapping matches subscribed S-NSSAIs, it will use default subscribed S-NSSAIs.</p>"},{"location":"blog/20230719/UDM_introduce/#reference","title":"Reference","text":"<ul> <li>3GPP TS29.503 v15.2.1</li> <li>3GPP TS23.502 v15.2.0</li> <li>3GPP TS23.501 v15.2.0</li> <li>3GPP TS33.501 v15.2.0</li> <li>free5GC v3.3.0</li> </ul>"},{"location":"blog/20230719/UDM_introduce/#about","title":"About","text":"<p>Hello! My name is \u5f35\u54f2\u777f, and my current research topic is ATSSS (Access Traffic Steering, Switching and Splitting), I will continue to write articles related to 5G networks in the future. If you find any mistakes in my articles or have any topics you want to know about, please contact me.</p> <ul> <li>Linkedln</li> </ul>"},{"location":"blog/20230726/network_slice/","title":"How to deploy a free5GC network slice on OpenStack","text":"<p>Note</p> <p>Author: Daniel Hsieh Date: 2023/7/26</p>"},{"location":"blog/20230726/network_slice/#whats-network-slicing","title":"What's Network Slicing","text":"<p>Network slicing allows for the creation of multiple logical, isolated, and independent virtual networks that can coexist within a shared physical infrastructure. Each network slice provides dedicated and customized network resources to meet the specific requirements of different services The main elements of a network slice include:</p> <ul> <li> <p>Virtualized Network Functions (VNFs): Each network slice can include a set of virtualized network functions that provide specific network capabilities and services. These VNFs can include functions like routing, switching, firewalling, load balancing, or any other network service required by the slice.</p> </li> <li> <p>Isolation and Resource Allocation: Network slicing ensures the isolation of resources between slices, preventing interference and conflicts. It allows for the allocation of dedicated and optimized resources such as bandwidth, processing power, and storage to each slice based on its specific needs.</p> </li> <li> <p>Orchestration and Management: Network slice orchestration involves the creation, provisioning, and management of network slices. It involves configuring the appropriate VNFs, assigning resources, and establishing connectivity between the different components of a slice.</p> </li> </ul> <p></p> <p>NFV Enabling Network Slicing for 5G</p> <p>Take Figure 1 as an example. The first slice is designed for mobile devices such as smartphones. Such slice requires a huge diversity of VNFs, and virtual links with high speed and low latency to support the broadband service of smartphones. In 5G network, Those slices are referred to as eMBB (enhanced mobile broadband) slices.</p> <p>The second slice is designed for autonomous driving. In such scenario, extremely low latency and high reliability are paramount to ensure the vehicles' operability, smoothness and safety. To achieve low latency, some of the NFs should be deployed close to the access node,i.e. on edge cloud. To achieve high reliability, a NF should have multiple instances on available physical resources to make the slice more fault tolerant. Such slice is referred to as URLLC (Ultra-Reliable Low-Latency Communications) slice.</p> <p>The third slice is designed for massive IoT. IoT devices are expected to not move and send very small amount of data intermittently. Due to the nature of such devices, functions that handle mobiltiy and always-on connections are not needed. Such slices are referred to as mIoT (massive IoT) slices.</p>"},{"location":"blog/20230726/network_slice/#mano-architecture","title":"MANO Architecture","text":"<p>In this article, we utilize MANO network function virtualization (NFV) architecture to deploy virtual network function (VNF). It plays the role of creating, deploying, and managing VNFs. MANO consists of three main functional components: NFV Orchestrator (NFVO), Virtualized Infrastructure Manager (VIM), and Virtual Network Function Manager (VNFM).</p> <p></p> <p>NFV MANO Architecture</p> <ul> <li> <p>NFVO manages the underlying resource by coordinating VIM and VNFM. It handles tasks such as receiving requests, service instantiation, scaling, termination, and monitoring.</p> </li> <li> <p>VNFM manages the lifecycle of VNF instances. It interacts with the VIM to instantiate, configure, monitor, and terminate VNF instances.</p> </li> <li> <p>VIM is responsible for managing the underlying virtualized infrastructure that hosts the VNFs. It abstracts the physical resources, such as compute, storage, and networking, and provides a unified view to the NFVO. The VIM handles tasks like resource allocation, performance monitoring, fault management, and virtualization management.</p> </li> </ul> <p>For VIM, we use OpenStack, an open-source software that provides IaaS, to utilize the physical resources. For VNFM and NFVO, we use Tacker, a service component of OpenStack, to manage VNFs.</p>"},{"location":"blog/20230726/network_slice/#openstack","title":"OpenStack","text":"<p>OpenStack is an open-source cloud computing platform that provides a set of software tools for building and managing customized clouds. OpenStack offers a infrastructure-as-a-service (IaaS) solution, enabling organizations to create and manage virtualized resources in a cloud environment. It is designed to be modular and consists of various components that work together to deliver a comprehensive cloud computing platform. Some of the key components include:</p> <ul> <li> <p>Nova: Nova is the computing component of OpenStack and serves as the main compute engine. It manages the creation, scheduling, and management of virtual machines (VMs) and provides APIs for controlling and interacting with the compute resources.</p> </li> <li> <p>Cinder: Cinder is the block storage component of OpenStack. It provides persistent storage for virtual machines. With Cinder, users can create and manage volumes that can be attached to instances, allowing for flexible and scalable storage options.</p> </li> <li> <p>Neutron: Neutron is the networking component of OpenStack. It provides a networking-as-a-service (NaaS) solution, allowing users to define and manage network resources. Neutron supports virtual LANs, software-defined networking (SDN), and network function virtualization (NFV), etc.</p> </li> <li> <p>Keystone: Keystone is the identity service component of OpenStack. It provides authentication and authorization services, enabling users to securely access and manage resources within the cloud. Keystone supports multiple authentication mechanisms, including username/password, token-based, and external identity providers.</p> </li> <li> <p>Horizon: Horizon is the web-based dashboard for OpenStack. It provides a user-friendly interface for managing and monitoring the cloud infrastructure. With Horizon, users can perform various tasks, such as launching instances, managing storage resources, and configuring networking options.</p> </li> </ul> <p></p> <p>OpenStack Architecture</p> <p>OpenStack is highly flexible and customizable, allowing organizations to tailor the cloud infrastructure to their specific needs. It supports multiple hypervisors, including KVM, VMware, and Hyper-V.</p>"},{"location":"blog/20230726/network_slice/#tacker","title":"Tacker","text":"<p>To enable NFV, we need another service component of OpenStack called Tacker. Tacker is designed to simplify the deployment and lifecycle management of VNFs and network service functions (NSFs) in a cloud infrastructure. It leverages OpenStack's existing components, such as Nova, Neutron, and Heat, to provide a comprehensive solution for network service orchestration. Tacker provides several key features and functionalities:</p> <ul> <li> <p>Service Templates: Tacker uses service templates to define the composition and behavior of network services. These templates describe the VNFs and NSFs involved, their interconnections, resource requirements, etc. Service templates are written using the TOSCA (Topology and Orchestration Specification for Cloud Applications) standard.</p> </li> <li> <p>Lifecycle Management: Tacker automates the entire lifecycle of network services, including provisioning, scaling, healing, and termination. It leverages Heat, OpenStack's orchestration service, to manage the underlying infrastructure resources required by the services and handle dynamic scaling of VNFs based on traffic demands.</p> </li> <li> <p>VNF Manager: Tacker includes a VNF Manager component responsible for managing the lifecycle of VNFs. It interacts with OpenStack's compute and networking services, to instantiate and manage VNF instances.</p> </li> <li> <p>Multi-VIM Support: Tacker supports multiple virtual infrastructure managers  to accommodate different cloud platforms and environments. It can interact with OpenStack, VMware vSphere and Kubernetes and so on, enabling operators to deploy network services across heterogeneous infrastructure environments.</p> </li> </ul> <p></p> <p>Tacker Architecture</p>"},{"location":"blog/20230726/network_slice/#deploy-a-free5gc-network-slice","title":"Deploy a free5GC Network Slice","text":"<ol> <li> <p>In our implementation, we install OpenStack and Tacker on two different virtual machines for resource utilization reasons, but in fact, they can be installed on the same virtual machine.</p> </li> <li> <p>we need to install OpenStack on a virtual machine. Specific details and corresponding compatibility can be found on OpenStack official website. Using devstack scripts for installation enables operators to customize the environment based on their needs, such as extra plugins (softwares that extends the functionality of OpenStack environment) and overcommit (allows deploying NFs that require more resource than existing physical resourcce) functionality. Upon completion, a web UI enabled by Horizon can be used  to access and operate on your own personalized OpenStack cloud. </p> </li> <li> <p>Install Tacker on another virtual machine, which requires four OpenStack service components, Keystone, Mistral, Barbican and Horizon. Once the installation is completed, we can register our OpenStack VIM on Tacker using <code>openstack vim register</code>command.</p> </li> <li> <p>Create two instances that will be used as images (one for control plane VNFs, one for UPF) for the VNFs that we will create. Then, <code>ssh</code> into those instances to set up the configurations for the VNFs, such as, installing required packages (go language, mongodb, libtool, etc.) and <code>git clone</code> free5GC source code. Once all the configurations are done, use OpenStack dashboard to take snapshots of these instances, which will be used as the images for VNFs.</p> </li> <li> <p>Import all the VNF descriptors (VNFD) of the VNFs we need by using <code>openstack vnf descriptor create</code> command. VNFDs should be written in accordance with TOSCA format. TOSCA format allows you to define the virtual links (a virtual network VNFs will be running in) and virtual deployment unit (operation unit of a VNF).     Below is an example of UPF VNFD: <pre><code>tosca_definitions_version: tosca_simple_profile_for_nfv_1_0_0\ndescription: description\nnode_types:\n  tosca.nodes.nfv.VNF11:\n    requirements:\n    - virtualLink1:\n        type: tosca.nodes.nfv.VL\n        required: true\nmetadata:\n  template_name: free5GCSetup\ntopology_template:\n  substitution_mappings:\n    node_type: tosca.nodes.nfv.VNF11\n  node_templates:\n    VDU1:\n      type: tosca.nodes.nfv.VDU.Tacker\n      properties:\n        name: free5gc-upf1-VNF\n        image: stage3-up\n        flavor: free5gc\n        availability_zone: nova\n        mgmt_driver: noop\n        key_name: free5gc\n        user_data_format: RAW\n        user_data: |\n          #!/bin/sh\n          cd /home/ubuntu/free5gc/src/upf/build\n          cat &gt; config/upfcfg.yaml &lt;&lt;- EOM\n          info:\n            version: 1.0.0\n            description: UPF configuration\n\n          configuration:\n            # debugLevel: panic|fatal|error|warn|info|debug|trace\n            debugLevel: info\n\n            pfcp:\n              - addr: 192.168.2.111\n\n            gtpu:\n              - addr: 192.168.2.111\n              # [optional] gtpu.name\n              # - name: upf.5gc.nctu.me\n              # [optional] gtpu.ifname\n              # - ifname: gtpif\n\n            apn_list:\n              - apn: internet\n                cidr: 60.60.0.0/24\n                # [optional] apn_list[*].natifname\n                # natifname: eth0\n          EOM\n          #sudo ./bin/free5gc-upfd -f config/upfcfg.yaml\n\n    CP1:\n      type: tosca.nodes.nfv.CP.Tacker\n      properties:\n        ip_address: 192.168.2.111\n        management: true\n      requirements:\n      - virtualLink:\n          node: VL1\n      - virtualBinding:\n          node: VDU1\n    VL1:\n      type: tosca.nodes.nfv.VL\n      properties:\n        network_name: 5GC\n        vendor: Tacker\n    FIP1:\n      type: tosca.nodes.network.FloatingIP\n      properties:\n        floating_network: public\n        floating_ip_address: 172.24.4.111\n      requirements:\n      - link:\n          node: CP1\n</code></pre></p> </li> <li>Import the network service descriptor (NSD) using <code>openstack ns descriptor create</code> command. The NSD should also be written in accordance with TOSCA format. Once all the VNFDs and NSD are all successfully imported, we can use <code>openstack ns create</code> to deploy the network slice. The VNFs specified in the NSD will also be instantiated along with the network slice. Their instances can be viewed on OpenStack dashboard enabled by Horizon or just use <code>openstack vnf list</code> to check the status of the VNFs.     Below is an example of NSD <pre><code>tosca_definitions_version: tosca_simple_profile_for_nfv_1_0_0\ndescription: Import Common Slice VNFDs (already on-boarded)\nimports:\n  - mongo\n  - nrf\n  - amf\n  - smf\n  - udr\n  - pcf\n  - udm\n  - nssf\n  - ausf\ntopology_template:\n  node_templates:\n    VNF0:\n      type: tosca.nodes.nfv.VNF0\n    VNF1:\n      type: tosca.nodes.nfv.VNF1\n    VNF2:\n      type: tosca.nodes.nfv.VNF2\n    VNF3:\n      type: tosca.nodes.nfv.VNF3\n    VNF4:\n      type: tosca.nodes.nfv.VNF4\n    VNF5:\n      type: tosca.nodes.nfv.VNF5\n    VNF6:\n      type: tosca.nodes.nfv.VNF6\n    VNF7:\n      type: tosca.nodes.nfv.VNF7\n    VNF8:\n      type: tosca.nodes.nfv.VNF8\n</code></pre></li> <li><code>ssh</code> into the VNF instances to make the necessary configuration for each VNF and start the free5GC VNF.</li> <li>Voila! Now we have a fully functional free5GC network slice.</li> </ol> <p>There are many other ways to set up a network slice. For example, we can deploy VNFs of the same network slice on different VIMs, or we can deploy all the network slices on the same VIM, as long as it is specified in the VNFDs.</p>"},{"location":"blog/20230726/network_slice/#about","title":"About","text":"<p>Hi, my name is Daniel Hsieh. I am a CS major graduate student. My research field is network slicing. If there are any questions about the article, please feel free to contact.</p> <ul> <li>email: e657shai@gmail.com</li> </ul>"},{"location":"blog/20230726/network_slice/#reference","title":"Reference","text":"<ul> <li> <p>https://www.acecloudhosting.com/blog/openstack-the-catalyst-of-the-public-cloud-market/</p> </li> <li> <p>https://telcocloudbridge.com/blog/a-beginners-guide-to-nfv-management-orchestration-mano/</p> </li> <li> <p>https://wiki.openstack.org/wiki/Tacker</p> </li> <li> <p>B. Chatras, U. S. Tsang Kwong and N. Bihannic, \"NFV enabling network slicing for 5G,\" 2017 20th Conference on Innovations in Clouds, Internet and Networks (ICIN), Paris, France, 2017, pp. 219-225, doi: 10.1109/ICIN.2017.7899415.</p> </li> </ul>"},{"location":"blog/20230802/20230802/","title":"Authentication Mechanism in NRF: What Is OAuth?","text":"<p>Note</p> <p>Author: Wilson Date: 2023/8/2</p>"},{"location":"blog/20230802/20230802/#abstract","title":"Abstract","text":"<p>Regarding the theme this time, I will briefly introduce OAuth. OAuth 2.0 defines four types of authorization flows. I choose the Client Credentials Flow to explain because the authentication mechanism in NRF is closely related to the Client Credentials Flow.</p> <p>Next, I will explain how to apply the concept of the Client Credentials Flow to NRF and introduce <code>Nnrf_AccessToken Service</code>, because <code>Nnrf_AccessToken Service</code> is closely related to the Client Credentials Flow.</p> <p>Finally, I will make a simple experiment of the authentication mechanism in NRF and share the environment settings and methods of operation.</p>"},{"location":"blog/20230802/20230802/#oauth","title":"OAuth","text":"<p>Before explaining the authentication mechanism in NRF, I will introduce OAuth. Regarding the OAuth flow, we can log in to the account through the platform before accessing an application. After logging in, we agree that an application can limitedly obtain the information of the user on the platform. The application can be LinkedIn, YouTube, etc. The platform can be Google, Facebook, etc.</p> <p>The full English name of OAuth is Open standard Authorization. OAuth is an open standard, and it's used to deal with authorization-related behaviors. OAuth 2.0 defines four types of authorization flows. The four types of the authorization flows are:</p> <ul> <li>Authorization Code</li> <li>Implicit</li> <li>Resource Owner Password Credentials</li> <li>Client Credentials</li> </ul> <p>This article explains the entire authorization of the Client Credentials Flow only, because the authentication mechanism in NRF adopts the Client Credentials.</p> <p>If you're interested in how authorization mechanism works, please refer to this article for more details.</p>"},{"location":"blog/20230802/20230802/#client-credentials-flow","title":"Client Credentials Flow","text":"<p> Figure 1. Client Credentials Flow</p> <p>Referring to the Figure 1, the Client Credentials Flow is mainly composed of:</p> <ul> <li>Client</li> <li>Authorization Server</li> <li>Resource Server</li> </ul> <p>The entire authorization of the Client Credentials Flow can be devided into 3 steps:</p> <ul> <li>First, the Client provdies Client ID, Client Secret Token, Scope, and Grant Type to the Authorization Server.</li> <li>Second, the Authorization Server verifies the information provided by the Client. After the Authorization Server verifies the information, it signs with the private key and sends the Access Token to the Client.</li> <li>Third, the Client obtains resources from the Resource Server with the Access Token.</li> </ul> <p>In addition, the Client and the Authorization Server have their own Scope list. The Scope list records a series of the actions. The Client or the Authorization Server is permitted to do the actions for obtaining the user\u2019s name, deleting posts, etc.</p> <p>Below I will explain how to apply the Client Credentials Flow to NRF after talking about the Client Credentials Flow.</p>"},{"location":"blog/20230802/20230802/#client-credentials-flow-in-nrf","title":"Client Credentials Flow in NRF","text":"<p>The Figure 2 and the Figure 3 originate from the Figure 13.4.1.1-1 and the Figure 13.4.1.1-2 of the TS 33.501.</p> <p> Figure 2. NF Service Consumer Obtaining Access Token before NF Service Access</p> <p>The entire flow in Figure 2 is the same as Step 1 and Step 2 in the Figure 1. The role of the Client is played by the NF Service Consumer, and the role of the Authorization Server is played by the NRF.</p> <p>First, the NF Service Consumer registers with NRF. Then the NF Service Consumer sends the <code>Nnrf_AccessToken_Get Request</code> to NRF. The <code>Nnrf_AccessToken_Get Request</code> includes:</p> <ul> <li>Consumer NF Type</li> <li>Expected NF Type</li> <li>Expected NF Service Name</li> <li>Client ID</li> </ul> <p>The NF Type can be AMF, SMF, etc. , and the NF Service Name can be <code>namf-comm</code>, <code>nsmf-pdusession</code>, etc.</p> <p>NRF verifies the information provided by the NF Service Consumer after it receives the <code>Nnrf_AccessToken_Get Request</code>. NRF generates an Access Token and uses the NRF private key to sign on the Access Token after the verification is successful.</p> <p>Finally, NRF returns the <code>Nnrf_AccessToken_Get Response</code> to the NF Service Consumer. The NF Service Consumer stores the Access Token within the validity period after it gets the Access Token. The services provided by the NF Service Producer are in the Expected NF Service Name. The NF Service Consumer doesn\u2019t need to verify again when it wants to use the services provided by the NF Service Producer.</p> <p> Figure 3. NF Service Consumer Requesting Service Access with an Access Token</p> <p>The entire flow in Figure 3 is the same as Step 3 in the Figure 1. The role of the Client is played by the NF Service Consumer, and the role of the Resource Server is played by the NF Service Producer.</p> <p>First, the NF Service Consumer sends the <code>NF Service Request</code> to the NF Service Producer with the Access Token. Simply put, the NF Service Consumer wants to consume the service provided by the NF Service Producer.</p> <p>The NF Service Producer uses the NRF public key to verify the signed Access Token after it receives the <code>NF Service Request</code>. If the verification is successful, the NF Service Producer will send the <code>NF Service Response</code> to the NF Service Consumer.</p> <p>Now I will talk about the <code>Nnrf_AccessToken Service</code> after explaining how to apply the Client Credentials Flow to NRF.</p>"},{"location":"blog/20230802/20230802/#nnrf_accesstoken-service","title":"Nnrf_AccessToken Service","text":"<p> Figure 4. Access Token Request</p> <p>The Figure 4 originates from the Figure 5.4.2.2.1-1 of the TS 29.510.</p> <p>First, the NF Service Consumer sends the POST <code>/oauth2/token</code> to NRF, and the data is stored in the <code>AccessTokenReq</code>. The attribute name, the data type, and the formulation rule of the <code>AccessTokenReq</code> are shown in the Table 1. The Table 1 originates from the Table 6.3.5.2.2-1 of the TS 29.510.</p> <p> Table 1. Definition of Type AccessTokenReq</p> <p>Definition of type <code>AccessTokenReq</code>:</p> <ul> <li><code>grant_type</code>: The value must be set to the client_credentials, and it is checked in the Snippet 1.</li> <li><code>nfInstanceId</code>: The value stores the ID of the NF Service Consumer.</li> <li><code>targetNfInstanceId</code>: The value stores the ID of the NF Service Producer.</li> <li><code>nfType</code>: The value stores the network function name of the NF Service Consumer. The network function name can be the AMF, SMF, etc.</li> <li><code>targetNfType</code>: The value stores the network function name of the NF Service Producer.</li> <li><code>scope</code>: It stores the services. The services can be the <code>namf-comm</code>, <code>nsmf-pdusession</code>, etc. When the NF Service Consumer requests the services. The services will be provided by the NF Service Producer.</li> <li><code>requesterPlmn</code>: It is mainly used in the roaming.</li> <li><code>targetPlmn</code>: It is mainly used in the roaming.</li> </ul> <p><pre><code>if reqGrantType != \"client_credentials\" {\n    return &amp;models.AccessTokenErr{\n        Error: \"unsupported_grant_type\",\n    }\n}\n</code></pre> Snippet 1. Grant Type Value Checking</p> <p>NRF sends <code>AccessTokenRsp</code> to the NF Service Consumer in the Step 2a of the Figure 4. The attribute name, the data type, and the formulation rule of the <code>AccessTokenRsp</code> are shown in the Table 2. The Table 2 originates from the Table 6.3.5.2.3-1 of the TS 29.510.</p> <p> Table 2. Definition of Type AccessTokenRsp</p> <p>The <code>AccessTokenRsp</code> contains four attribute names. The four attribute names are:</p> <ul> <li><code>access_token</code>: It stores all the attribute names and values of the AccessTokenClaims in the Table 3. The Table 3 originates form the Table 6.3.5.2.4-1 of the TS 29.510.</li> <li><code>token_type</code>: It must be set to the Bearer and can be seen in the Snippet 2.</li> <li><code>expires_in</code>: It stores information related to the expiration date.</li> <li><code>scope</code>: The NF Service Consumer and the NF Service Producer have their own scope list. The scope in the <code>AccessTokenRsp</code> has a series of these services, and the NF Service Producer is permitted to consume these services.</li> </ul> <p> Table 3. Definition of Type AccessTokenClaims</p> <p>Definition of Type <code>AccessTokenClaims</code>:</p> <ul> <li><code>iss</code>: It is called issuer, and the content usually stores the ID of NRF.</li> <li><code>sub</code>: It is called subject, and the content stores the ID of the NF Service Consumer.</li> <li><code>aud</code>: It is called audience, and the content stores the ID of the NF Service Producer.</li> <li><code>scope</code>: The scope in the <code>AccessTokenClaims</code> has a series of these services, and the NF Service Consumer is authorized by the NF Service Producer and permitted to consume these services.</li> <li><code>exp</code>: It stores information related to the validity period.</li> </ul> <p><pre><code>func AccessTokenProcedure(request models.AccessTokenReq) (\n    *models.AccessTokenRsp, *models.AccessTokenErr,\n) {\n    logger.AccTokenLog.Infoln(\"In AccessTokenProcedure\")\n\n    var expiration int32 = 1000\n    scope := request.Scope\n    tokenType := \"Bearer\"\n    now := int32(time.Now().Unix())\n\n    errResponse := AccessTokenScopeCheck(request)\n    if errResponse != nil {\n        return nil, errResponse\n    }\n\n    // Create AccessToken\n    nrfCtx := nrf_context.GetSelf()\n    accessTokenClaims := models.AccessTokenClaims{\n        Iss:            nrfCtx.Nrf_NfInstanceID,    // NF instance id of the NRF\n        Sub:            request.NfInstanceId,       // nfInstanceId of service consumer\n        Aud:            request.TargetNfInstanceId, // nfInstanceId of service producer\n        Scope:          request.Scope,              // TODO: the name of the NF services for which the\n        Exp:            now + expiration,           // access_token is authorized for use\n        StandardClaims: jwt.StandardClaims{},\n    }\n    accessTokenClaims.IssuedAt = int64(now)\n\n    // Use NRF private key to sign AccessToken\n    token := jwt.NewWithClaims(jwt.GetSigningMethod(\"RS512\"), accessTokenClaims)\n    accessToken, err := token.SignedString(nrfCtx.NrfPrivKey)\n    if err != nil {\n        logger.AccTokenLog.Warnln(\"Signed string error: \", err)\n        return nil, &amp;models.AccessTokenErr{\n            Error: \"invalid_request\",\n        }\n    }\n\n    response := &amp;models.AccessTokenRsp{\n        AccessToken: accessToken,\n        TokenType:   tokenType,\n        ExpiresIn:   expiration,\n        Scope:       scope,\n    }\n    return response, nil\n}\n</code></pre> Snippet 2. AccessTokenProcedure Function</p> <p>The Snippet 2 is the <code>AccessTokenProcedure()</code> function. The function is executed in NRF.</p> <p>The function mainly processes:</p> <ol> <li>The NRF receives the <code>AccessTokenReq</code> sent by the NF Service Consumer.</li> <li>The function calls the <code>AccessTokenScopeCheck()</code> function. The <code>AccessTokenScopeCheck()</code> function checks whether the content of the attribute name in the <code>AccessTokenReq</code> complies with the requirements of the TS 29.510. If not, the <code>AccessTokenProcedure()</code> function immediately returns the <code>AccessTokenErr</code> to the NF Service Consumer.</li> <li>The function starts to create the Access Token. The Access Token is stored in the <code>AccessTokenRsp</code>. The <code>AccessTokenRsp</code> is sent back to the NF Service Consumer. The <code>Iss</code> in the AccessToken obtains its own ID in NRF. The <code>Sub</code> and <code>Aud</code> are obtained from the <code>NfInstancedId</code> and the <code>TargetNfInstanceId</code> in the <code>AccessTokenReq</code> respectively. The <code>Scope</code> is obtained from the <code>scope</code> in the <code>AccessTokenReq</code>. The expiration is set to the 1000 in the Snippet 2. Therefore, the value of the <code>exp</code> is the current time + 1000.</li> <li>After the Access Token is created, the function uses the NRF private key to sign on the Access Token. After signing, the function checks whether there is an error. If so, the function immediately sends the <code>AccessTokenErr</code> to the NF Service Consumer.</li> <li>The function puts the signed Access Token into the <code>AccessTokenRsp</code>. The value of the <code>TokenType</code> is set to the Bearer by the function. The function sets the <code>ExprieIn</code> and the <code>Scope</code> in the Snippet 2.</li> </ol> <p>Finally, I make a simple experiment about the Access Token and share the environment setting and method of operation with you.</p>"},{"location":"blog/20230802/20230802/#experiment","title":"Experiment","text":"<p>The Table 4 is my environment setting. I provide the Table 4 for you. You can refer it.</p> <p> Table 4. Environment</p> <p>Remove the part of the <code>tls</code> and add the content of the <code>cert</code>, <code>rootcert</code> and <code>oauth</code> under <code>sbi</code> in the <code>nrfcfg.yaml</code> before implementing about the Access Token.</p> <p><pre><code>info:\n  version: 1.0.2\n  description: NRF initial local configuration\n\nconfiguration:\n  MongoDBName: free5gc # database name in MongoDB\n  MongoDBUrl: mongodb://127.0.0.1:27017 # a valid URL of the mongodb\n  sbi: # Service-based interface information\n    scheme: http # the protocol for sbi (http or https)\n    registerIPv4: 127.0.0.10 # IP used to serve NFs or register to another NRF\n    bindingIPv4: 127.0.0.10  # IP used to bind the service\n    port: 8000 # port used to bind the service\n    cert:\n      pem: cert/nrf.pem\n      key: cert/nrf.key\n    rootcert:\n      pem: cert/nrf.pem\n      key: cert/nrf.key\n    oauth: true\n  DefaultPlmnId:\n    mcc: 208 # Mobile Country Code (3 digits string, digit: 0~9)\n    mnc: 93 # Mobile Network Code (2 or 3 digits string, digit: 0~9)\n  serviceNameList: # the SBI services provided by this NRF, refer to TS 29.510\n    - nnrf-nfm # Nnrf_NFManagement service\n    - nnrf-disc # Nnrf_NFDiscovery service\n\nlogger: # log output setting\n  enable: true # true or false\n  level: info # how detailed to output, value: trace, debug, info, warn, error, fatal, panic\n  reportCaller: false # enable the caller report or not, value: true or false\n</code></pre> nrfcfg.yaml</p> <p>Find the <code>http://127.0.0.10:8000/nnrf-nfm/v1/nf-instances/8f7891b4-b127-4f59-9ec2-b5e6aade5531</code> in the NRF log, and you will get the <code>8f7891b4-b127-4f59-9ec2-b5e6aade5531</code>. The <code>8f7891b4-b127-4f59-9ec2-b5e6aade5531</code> is the <code>nfInstanceID</code>.</p> <pre><code>2023-08-02T20:07:43.300826205Z [INFO][NRF][NFM] Handle NFRegisterRequest\n2023-08-02T20:07:43.308259291Z [INFO][NRF][NFM] urilist create\n2023-08-02T20:07:43.311674255Z [INFO][NRF][NFM] Create NF Profile\n2023-08-02T20:07:43.318192771Z [INFO][NRF][NFM] Location header:  http://127.0.0.10:8000/nnrf-nfm/v1/nf-instances/8f7891b4-b127-4f59-9ec2-b5e6aade5531\n2023-08-02T20:07:43.325073275Z [INFO][NRF][GIN] | 201 |       127.0.0.1 | PUT     | /nnrf-nfm/v1/nf-instances/8f7891b4-b127-4f59-9ec2-b5e6aade5531 |\n</code></pre> <p>Execute <code>$ curl -X GET {apiRoot}/nnrf-nfm/v1/nf-instances/{nfInstanceID}</code>, and you will obtain the detail information about the <code>nfInstanceID</code>. You can see the <code>nfType</code> of the <code>nfInstanceID</code> is NSSF, and the information about the <code>nfInstanceID</code> is used when you implement the Access Token.</p> <pre><code>ubuntu@free5GC:~/free5gc/NFs/nrf$ curl -X GET http://127.0.0.10:8000/nnrf-nfm/v1/nf-instances/8f7891b4-b127-4f59-9ec2-b5e6aade5531\n{\"ipv4Addresses\":[\"127.0.0.31\"],\"nfInstanceId\":\"8f7891b4-b127-4f59-9ec2-b5e6aade5531\",\"nfServices\":[{\"apiPrefix\":\"http://127.0.0.31:8000\",\"ipEndPoints\":[{\"ipv4Address\":\"127.0.0.31\",\"port\":8000,\"transport\":\"TCP\"}],\"nfServiceStatus\":\"REGISTERED\",\"scheme\":\"http\",\"serviceInstanceId\":\"0\",\"serviceName\":\"nnssf-nsselection\",\"versions\":[{\"apiFullVersion\":\"1.0.2\",\"apiVersionInUri\":\"v1\"}]},{\"apiPrefix\":\"http://127.0.0.31:8000\",\"ipEndPoints\":[{\"ipv4Address\":\"127.0.0.31\",\"port\":8000,\"transport\":\"TCP\"}],\"nfServiceStatus\":\"REGISTERED\",\"scheme\":\"http\",\"serviceInstanceId\":\"1\",\"serviceName\":\"nnssf-nssaiavailability\",\"versions\":[{\"apiFullVersion\":\"1.0.2\",\"apiVersionInUri\":\"v1\"}]}],\"nfStatus\":\"REGISTERED\",\"nfType\":\"NSSF\",\"plmnList\":[{\"mcc\":\"208\",\"mnc\":\"93\"}]}\n</code></pre> <p>Then you execute this command, see below. <pre><code>$ curl -X POST -H \"Content-Type: application/json\" -d '{\"nfInstanceId\": {nfInstanceID}, \"grant_type\": \"client_credentials\", \"nfType\": {nfType}, \"targetNfType\": \"UDR\", \"scope\": \"nudr-dr\"}' {apiRoot}/oauth2/token\n</code></pre> You will get the long symbols. The long symbols is that the Access Token is encrypted by the private key of NRF and stored in the <code>AccessTokenRsp</code>.</p> <pre><code>ubuntu@free5GC:~/free5gc/NFs/nrf$ curl -X POST -H \"Content-Type: application/json\" -d '{\"nfInstanceId\": \"8f7891b4-b127-4f59-9ec2-b5e6aade5531\", \"grant_type\": \"client_credentials\", \"nfType\": \"NSSF\", \"targetNfType\": \"UDR\", \"scope\": \"nudr-dr\"}' http://127.0.0.10:8000/oauth2/token\n\"eyJhY2Nlc3NfdG9rZW4iOiJleUpoYkdjaU9pSlNVelV4TWlJc0luUjVjQ0k2SWtwWFZDSjkuZXlKcGMzTWlPaUlpTENKemRXSWlPaUk0WmpjNE9URmlOQzFpTVRJM0xUUm1OVGt0T1dWak1pMWlOV1UyWVdGa1pUVTFNekVpTENKaGRXUWlPaUlpTENKelkyOXdaU0k2SW01MVpISXRaSElpTENKbGVIQWlPakUyT1RFd01EZzBPRGdzSW1saGRDSTZNVFk1TVRBd056UTRPSDAuY3VHSkkwTndfV280S2lQbS1fZEZVdnVTQWM1WVEwMmRKYk5PTUhmMV9IOHdIZ2JKWFhUam9xU1Y2OTNYSmFKemkweGIxdC1DMW14TWhVZkZjbXpNMC1Nd2oxTXZYaWhyTTktdDFRUFItSFcxQlBlN0tHMUxBV3d5MEJfcXpIalltRlR6eGhONVlyNkpURDhBbkMxaFJFeEh4WHBjV1NqbV9vZnV0NVhfUFRFRkZtaHZrbmtVbU8waWFrTmdRWElRVTc1NnlvZ29ZTlFDRnJvSmRWamJMdnpFdkJLYTVFN0hQeXc3RkRDRHpTZU5WT2t2WTlobU11eldYZ3dOVmRIT3c1c2lNbmppbTlmTVZ0RTFxS1hjWDlScXlUdXlsWjM2ZlJ1QjdVZ2hkLU15Q19xd2VJRE41ZFdYOWZqdnA3VUNZZ01mVHhSLUI2M3d5OWFjQ183eThRIiwidG9rZW5fdHlwZSI6IkJlYXJlciIsImV4cGlyZXNfaW4iOjEwMDAsInNjb3BlIjoibnVkci1kciJ9\"\n</code></pre> <p>NSSF sends the <code>AccessTokenReq</code> to NRF after you execute the above command. In the <code>AccessTokenReq</code>, the <code>nfInstanceId</code> is set to <code>8f7891b4-b127-4f59-9ec2-b5e6aade5531</code>. The <code>grant_type</code> is set to the client_credentials. The <code>nfType</code> is set to NSSF. The <code>targetNfType</code> is set to UDR. The <code>scope</code> is set to <code>nudr-dr</code>. The information is shown in the NRF log. The value of the <code>targetNfInstanceId</code>, <code>requesterPlmn</code>, and <code>targetPlmn</code> is empty because they are not set.</p> <pre><code>2023-08-02T20:18:08.127557565Z [INFO][NRF][Token] In AccessTokenProcedure\n2023-08-02T20:18:08.127586736Z [INFO][NRF][Token] Access Token Request\n2023-08-02T20:18:08.127611885Z [INFO][NRF][Token] Grant Type: client_credentials\n2023-08-02T20:18:08.127637480Z [INFO][NRF][Token] NF Instance ID: 8f7891b4-b127-4f59-9ec2-b5e6aade5531\n2023-08-02T20:18:08.127664415Z [INFO][NRF][Token] Target NF Instance ID:\n2023-08-02T20:18:08.127689792Z [INFO][NRF][Token] NF Type: NSSF\n2023-08-02T20:18:08.127712916Z [INFO][NRF][Token] Target NF Type: UDR\n2023-08-02T20:18:08.127734827Z [INFO][NRF][Token] Scope: nudr-dr\n2023-08-02T20:18:08.127758317Z [INFO][NRF][Token] Requester PLMN: &lt;nil&gt;\n2023-08-02T20:18:08.127781052Z [INFO][NRF][Token] Target PLMN: &lt;nil&gt;\n</code></pre> <p>Next, you can see the Access Token in the NRF log. The value of the <code>Sub</code> is <code>8f7891b4-b127-4f59-9ec2-b5e6aade5531</code>. The <code>Sub</code> represents NSSF, and NSSF belongs to the NF Service Consumer. The value of the <code>Scope</code> is the <code>nudr-dr</code>. The value of the <code>Exp</code> is 1691008488.</p> <pre><code>2023-08-02T20:18:08.134096785Z [INFO][NRF][Token] Access Token Claims\n2023-08-02T20:18:08.138100978Z [INFO][NRF][Token] Iss:\n2023-08-02T20:18:08.138185972Z [INFO][NRF][Token] Sub: 8f7891b4-b127-4f59-9ec2-b5e6aade5531\n2023-08-02T20:18:08.138228925Z [INFO][NRF][Token] Aud:\n2023-08-02T20:18:08.138264519Z [INFO][NRF][Token] Scope: nudr-dr\n2023-08-02T20:18:08.138298628Z [INFO][NRF][Token] Exp: 1691008488\n</code></pre> <p>Next, you can see the <code>AccessTokenRsp</code>. You can see that the Access Token has become the long symbols. The value of the <code>Token Type</code> is set to the Bearer. The value of the <code>ExpiresIn</code> is set to 1000. The value of the <code>Scope</code> is set to <code>nudr-dr</code>.</p> <pre><code>2023-08-02T20:18:08.149587382Z [INFO][NRF][Token] Access Token Response\n2023-08-02T20:18:08.150006665Z [INFO][NRF][Token] Access Token: eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiIiLCJzdWIiOiI4Zjc4OTFiNC1iMTI3LTRmNTktOWVjMi1iNWU2YWFkZTU1MzEiLCJhdWQiOiIiLCJzY29wZSI6Im51ZHItZHIiLCJleHAiOjE2OTEwMDg0ODgsImlhdCI6MTY5MTAwNzQ4OH0.cuGJI0Nw_Wo4KiPm-_dFUvuSAc5YQ02dJbNOMHf1_H8wHgbJXXTjoqSV693XJaJzi0xb1t-C1mxMhUfFcmzM0-Mwj1MvXihrM9-t1QPR-HW1BPe7KG1LAWwy0B_qzHjYmFTzxhN5Yr6JTD8AnC1hRExHxXpcWSjm_ofut5X_PTEFFmhvknkUmO0iakNgQXIQU756yogoYNQCFroJdVjbLvzEvBKa5E7HPyw7FDCDzSeNVOkvY9hmMuzWXgwNVdHOw5siMnjim9fMVtE1qKXcX9RqyTuylZ36fRuB7Ughd-MyC_qweIDN5dWX9fjvp7UCYgMfTxR-B63wy9acC_7y8Q\n2023-08-02T20:18:08.150094277Z [INFO][NRF][Token] Token Type: Bearer\n2023-08-02T20:18:08.150133189Z [INFO][NRF][Token] Expires In: 1000\n2023-08-02T20:18:08.150167371Z [INFO][NRF][Token] Scope: nudr-dr\n</code></pre> <p>Finally, you can see 200. 200 means that AUSF sends the <code>AccessTokenReq</code> to NRF. NRF successfully sends to AUSF after verification.</p> <pre><code>2023-08-02T20:18:08.150302345Z [INFO][NRF][GIN] | 200 |       127.0.0.1 | POST    | /oauth2/token |\n</code></pre>"},{"location":"blog/20230802/20230802/#reference","title":"Reference","text":"<ul> <li>TS 29.510</li> <li>TS 33.501</li> <li>[Notes] Understanding OAuth 2.0: Understand the differences of each role and each type of process at one time</li> <li>https://blog.techbridge.cc/2019/02/01/linux-curl-command-tutorial/</li> <li>https://github.com/free5gc/free5gc/issues/434</li> </ul>"},{"location":"blog/20230802/20230802/#about","title":"About","text":"<p>Hi, my name is Wilson. I am a master\u2019s student. My main area of research is network slicing. In the future, I will introduce more information about 5G. Hope you enjoy it.</p>"},{"location":"blog/20230809/main/","title":"Fuzz Testing in Go: Discovering Vulnerabilities and Analyzing a Real Case (CVE-2022-43677)","text":"<p>Note</p> <p>Author: Yu-Sheng Liu Date: 2023/8/9</p>"},{"location":"blog/20230809/main/#overview","title":"Overview","text":"<p>In this article, we begin by introducing the concept of fuzz testing and its significance in software testing. Subsequently, we present Go Fuzzing as an illustrative example to demonstrate how to implement fuzz testing in Go. Lastly, we showcase a practical case, CVE-2022-43677, to exemplify how we conduct fuzz testing on the free5GC system.</p>"},{"location":"blog/20230809/main/#fuzz-testing","title":"Fuzz Testing","text":""},{"location":"blog/20230809/main/#what-is-fuzz-testing-fuzzing","title":"What is Fuzz Testing (Fuzzing)?","text":"<p>Fuzz testing, commonly known as fuzzing, is an automated software testing technique used to uncover vulnerabilities, defects, and unexpected behavior in computer systems, applications, and networks. The primary objective of fuzzing is to identify security flaws, crashes, or abnormal program behavior caused by invalid or unexpected inputs.</p>"},{"location":"blog/20230809/main/#how-fuzz-testing-works","title":"How Fuzz Testing Works","text":"<p>Fuzz testing involves subjecting the target software or system to a large number of inputs, including random or malformed data, to see how it handles them. The idea is to explore edge cases and input combinations that may not have been adequately tested during traditional software testing. Here's how the fuzzing process typically works:</p> <ol> <li> <p>Test Input Generation:</p> <ul> <li>Fuzzing tools generate test inputs based on various techniques, which can be broadly categorized as:<ul> <li>Random Fuzzing: The simplest approach where random data is generated as input.</li> <li>Mutation-Based Fuzzing: Starting with valid inputs, the tool applies mutations to create variations of the original data.</li> <li>Grammar-Based Fuzzing: Using a predefined grammar or structure to generate valid and invalid inputs.</li> <li>Seed Corpus: Using existing inputs (e.g., files, network packets) as the starting set for mutation.</li> </ul> </li> </ul> </li> <li> <p>Test Execution:</p> <ul> <li>The generated inputs are provided as input to the target application, component, or system.</li> <li>The application is executed with each input, and its behavior is monitored during runtime.</li> </ul> </li> <li> <p>Monitoring and Analysis:</p> <ul> <li>The fuzzer observes the application's behavior, including any crashes, exceptions, hangs, or memory-related issues.</li> <li>Code coverage analysis is often performed to determine which parts of the code were exercised during the testing.</li> </ul> </li> <li> <p>Feedback and Iteration:</p> <ul> <li>Fuzzing tools use feedback mechanisms to prioritize and select inputs that lead to new code paths or unique behavior.</li> <li>The process is iterated with refined inputs to continue exploring deeper into the application.</li> </ul> </li> </ol>"},{"location":"blog/20230809/main/#types-of-fuzz-testing","title":"Types of Fuzz Testing","text":"<ol> <li> <p>Black Box Fuzzing:</p> <ul> <li>The tester has no access to the application's internal code or design.</li> <li>Random or mutated inputs are provided to the application to observe its behavior.</li> <li>Suitable for testing closed-source software or systems where the tester has limited knowledge.</li> </ul> </li> <li> <p>White Box Fuzzing:</p> <ul> <li>The tester has access to the application's source code and can leverage this knowledge for targeted testing.</li> <li>Inputs can be intelligently crafted to explore specific code paths and functions.</li> <li>Provides more in-depth coverage but requires access to the application's code.</li> </ul> </li> <li> <p>Grey Box Fuzzing:</p> <ul> <li>A combination of black box and white box approaches.</li> <li>The tester has partial knowledge of the application, such as certain APIs or protocols, but not complete access to the source code.</li> <li>Offers a balance between targeted testing and exploration of unknown behaviors.</li> </ul> </li> </ol>"},{"location":"blog/20230809/main/#advantages-of-fuzz-testing","title":"Advantages of Fuzz Testing","text":"<ol> <li> <p>Bug and Vulnerability Discovery:</p> <ul> <li>Fuzzing can uncover previously unknown security vulnerabilities and software defects, including memory corruption errors and input validation issues.</li> </ul> </li> <li> <p>Automation and Efficiency:</p> <ul> <li>Fuzzing is an automated testing process, which allows it to scale and test large codebases quickly and efficiently.</li> </ul> </li> <li> <p>Diverse Test Inputs:</p> <ul> <li>Fuzzing generates a wide range of test inputs, exploring various edge cases that might not be covered by manual testing.</li> </ul> </li> <li> <p>Early Vulnerability Detection:</p> <ul> <li>Fuzzing can be integrated into the development process, enabling early detection and mitigation of vulnerabilities before deployment.</li> </ul> </li> </ol>"},{"location":"blog/20230809/main/#conclusion-for-fuzz-testing","title":"Conclusion for fuzz testing","text":"<p>Fuzz testing, or fuzzing, is a powerful and essential technique in the realm of software security testing. By providing a diverse set of inputs and exploring uncharted code paths, fuzz testing uncovers vulnerabilities and defects that might otherwise remain hidden.</p> <p>Next, we will use Go fuzzing as an example to introduce how to develop a fuzzing in Go.</p>"},{"location":"blog/20230809/main/#go-fuzzing","title":"Go Fuzzing","text":"<p>Go officially supports fuzzing starting from Go 1.18, and its official figure provides a brief and clear summary of the fuzzing function components. </p> <p>Similar to Go's unit test functions, the fuzzing function in Go must follow the naming convention <code>FuzzXxx</code> and take an argument of type <code>*testing.F</code>. This argument has two main functions, <code>Add</code> and <code>Fuzz</code>.</p> <ol> <li> <p><code>Add</code> Function:</p> <ul> <li>You can use the <code>Add</code> function to add your own test data to the seed corpus for fuzz testing. The seed corpus is the initial set of inputs that <code>go-fuzz</code> will use to start the fuzzing process.</li> </ul> </li> <li> <p><code>Fuzz</code> Function:</p> <ul> <li>The <code>Fuzz</code> function will be the target function that you want to test using fuzzing. It must have <code>*testing.T</code> as its first argument, similar to regular unit tests.</li> <li>Additionally, the <code>Fuzz</code> function supports variadic arguments with the following basic data types:<ul> <li><code>string</code>, <code>[]byte</code></li> <li><code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32/rune</code>, <code>int64</code></li> <li><code>uint</code>, <code>uint8/byte</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code></li> <li><code>float32</code>, <code>float64</code></li> <li><code>bool</code></li> </ul> </li> </ul> </li> </ol> <p>These data types represent the different kinds of input data that can be passed to the <code>Fuzz</code> function during the fuzzing process. The fuzzer will generate and mutate inputs of these types to explore different code paths and uncover bugs or unexpected behavior in the target function.</p> <p>In summary, when writing fuzzing functions in Go, remember to use the <code>FuzzXxx</code> naming pattern, accept <code>*testing.F</code> as an argument, utilize the <code>Add</code> function to customize the seed corpus, and use the <code>Fuzz</code> function with supported basic data types to perform fuzz testing on your target functions.</p> <p>You can use the command to execute the fuzz testing: <pre><code>go test -fuzz=&lt;regex&gt; -fuzztime=&lt;duration or times&gt;\n\n# Execute the fuzz testing until it crashs or finding some errors\ngo test -fuzz=Fuzz\n\n# Execute the fuzz testing ten iterations\ngo test -fuzz=Fuzz -fuzztime=10x\n\n# Execute the fuzz testing twenty seconds\ngo test -fuzz=Fuzz -fuzztime=20s\n</code></pre></p>"},{"location":"blog/20230809/main/#simple-example-division","title":"Simple Example - Division","text":"<p>We have developed a very simple function called <code>Division</code> that accepts two arguments, <code>dividend</code> and <code>divisor</code>, and then returns two results: <code>quotient</code> and <code>remainder</code>.</p> <pre><code>func Division(dividend, divisor int32) (\n    quotient, remainder int32,\n) {\n    quotient = dividend / divisor\n    remainder = dividend % divisor\n\n    return\n}\n</code></pre> <p>In the <code>FuzzDivision</code> function, we utilize the data generated by the Go fuzzer to test our <code>Division</code> function.</p> <pre><code>func FuzzDivision(f *testing.F) {\n    f.Fuzz(func(t *testing.T,\n        n1, n2 int32,\n    ) {\n        q, r := Division(n1, n2)\n\n        require.Equal(t, n1, n2*q+r)\n    })\n}\n</code></pre> <p>We expected to see: <pre><code>n1 / n2 = q ... r\nn1 = n2 * q + r\n</code></pre></p> <p>There should not be any problems with this implementation.</p> <p>Then we can use the following command to start the fuzz testing.</p> <pre><code>go test -fuzz=^FuzzDivision$\n</code></pre> <p>The fuzz testing reports the error \"integer divide by zero\".</p> <p></p> <p>As a normal user, we understand that the divisor cannot be zero. However, the input data may not always be as expected. This is precisely why we use fuzz testing\u2014to help us find edge cases and uncover unexpected behavior.</p> <p>Go stores the data that caused the fuzz testing to fail. You can check them using the following command.     * Note: The file name, <code>29bf8459dc5d452f64d41eb8a253f6a672939b146b07fcced0b17e99729e9b91</code>, may not be the same.</p> <pre><code>cat testdata/fuzz/FuzzDivision/29bf8459dc5d452f64d41eb8a253f6a672939b146b07fcced0b17e99729e9b91\n</code></pre> <p>The content of the file is as follows: <pre><code>go test fuzz v1\nint32(-7)\nrune('\\x00')\n</code></pre></p> <p>The first line indicates the encoding version, and the subsequent lines represent the argument values that triggered the error during the fuzz testing.</p> <p>Now we can modify our <code>Division</code> function to check the <code>divisor</code> if it is zero.</p> <pre><code>var ErrorDivideByZero = fmt.Errorf(\"integer divide by zero\")\n\nfunc Division(dividend, divisor int32) (\n    quotient, remainder int32, err error,\n) {\n    if divisor == 0 {\n        err = ErrorDivideByZero\n        return\n    }\n\n    quotient = dividend / divisor\n    remainder = dividend % divisor\n\n    return\n}\n</code></pre> <p>Similarly, the <code>FuzzDivision</code> fuzzing function now checks for the presence of the <code>ErrorDivideByZero</code> error.</p> <pre><code>func FuzzDivision(f *testing.F) {\n    f.Add(int32(67), int32(3))\n\n    f.Fuzz(func(t *testing.T,\n        n1, n2 int32,\n    ) {\n        if q, r, err := Division(n1, n2); err != ErrorDivideByZero {\n            require.Equal(t, n1, n2*q+r)\n        }\n    })\n}\n</code></pre> <p>Now, we can use the following command to re-test the failing case.</p> <pre><code>go test -run=FuzzDivision/29bf8459dc5d452f64d41eb8a253f6a672939b146b07fcced0b17e99729e9b91\n</code></pre>"},{"location":"blog/20230809/main/#conclusion-for-go-fuzzing","title":"Conclusion for Go Fuzzing","text":"<p>We have used a simple example to describe how to develop a fuzzing function in Go and how to leverage the Go command-line tool to execute fuzz testing.</p> <p>Next, we will examine a real case, CVE-2022-43677, and demonstrate the process of developing a fuzzing function to identify edge cases.</p>"},{"location":"blog/20230809/main/#cve-2022-43677","title":"CVE-2022-43677","text":"<p>Accroding to the descriptoin:</p> <p>In free5GC 3.2.1, a malformed NGAP message can crash the AMF and NGAP decoders via an index-out-of-range panic in aper.GetBitString.</p> <p>In response to this vulnerability, we have developed a fuzzing function to test the NGAP decoder. The function utilizes two approaches: modifying the NGAP message's content under a valid template or adjusting its format by changing the Information Elements (IEs) with variable lengths.</p> <pre><code>// Put the code under the free5gc/test\nfunc FuzzNgapDecode(f *testing.F) {\n    f.Fuzz(func(t *testing.T,\n        modifyWhat uint8,\n        changeIe0, changeIe1, changeIe2, changeIe3, changeIe4 bool,\n        valueIe0A uint32,\n        valueIe2ACellId uint64, valueIe2ATac uint32,\n        valueIe3A uint64,\n        valueIe4A uint64,\n        valueIePlmn uint32,\n    ) {\n        var idx, n int\n        var sendMsg []byte\n        var registrationRequest []byte\n        var bs []byte\n        var err error\n        var ngapPdu ngapType.NGAPPDU\n        var mobileIdentity5GS nasType.MobileIdentity5GS\n        var ue *test.RanUeContext\n\n        // New UE\n        ue = test.NewRanUeContext(\"imsi-2089300007487\", 1, security.AlgCiphering128NEA0, security.AlgIntegrity128NIA2,\n            models.AccessType__3_GPP_ACCESS)\n        ue.AmfUeNgapId = 1\n        ue.AuthenticationSubs = test.GetAuthSubscription(TestGenAuthData.MilenageTestSet19.K,\n            TestGenAuthData.MilenageTestSet19.OPC,\n            TestGenAuthData.MilenageTestSet19.OP)\n\n        mobileIdentity5GS = nasType.MobileIdentity5GS{\n            Len:    12, // suci\n            Buffer: []uint8{0x01, 0x02, 0xf8, 0x39, 0xf0, 0xff, 0x00, 0x00, 0x00, 0x00, 0x47, 0x78},\n        }\n\n        if modifyWhat%2 == DoModifyContent {\n            if changeIe0 {\n                // RAN UE NGAP ID\n                ue.RanUeNgapId = int64(valueIe0A)\n            }\n\n            registrationRequest = nasTestpacket.GetRegistrationRequest(\n                nasMessage.RegistrationType5GSInitialRegistration, mobileIdentity5GS, nil, ue.GetUESecurityCapability(), nil, nil, nil)\n            ngapPdu = ngapTestpacket.BuildInitialUEMessage(ue.RanUeNgapId, registrationRequest, \"\")\n\n            if changeIe2 {\n                // User Location Information\n                for _, ie := range ngapPdu.InitiatingMessage.Value.InitialUEMessage.ProtocolIEs.List {\n                    if ie.Id.Value == ngapType.ProtocolIEIDUserLocationInformation {\n                        bs = make([]byte, 4)\n                        valueIePlmn &amp;= uint32(PlmnMask)\n                        binary.LittleEndian.PutUint32(bs, valueIePlmn)\n\n                        NgRan := ie.Value.UserLocationInformation.UserLocationInformationNR\n                        NgRan.NRCGI.PLMNIdentity.Value = bs[:PlmnByteLen]\n                        NgRan.TAI.PLMNIdentity.Value = bs[:PlmnByteLen]\n\n                        bs = make([]byte, 8)\n                        valueIe2ACellId &amp;= uint64(CellIdMask)\n                        binary.LittleEndian.PutUint64(bs, valueIe2ACellId)\n                        NgRan.NRCGI.NRCellIdentity.Value.Bytes = bs[:CellIdByteLen]\n\n                        bs = make([]byte, 4)\n                        valueIe2ATac &amp;= uint32(TacMask)\n                        binary.LittleEndian.PutUint32(bs, valueIe2ATac)\n                        NgRan.TAI.TAC.Value = bs[:TacByteLen]\n                    }\n                }\n            }\n            if changeIe3 {\n                // RRC Establishment Cause\n                for _, ie := range ngapPdu.InitiatingMessage.Value.InitialUEMessage.ProtocolIEs.List {\n                    if ie.Id.Value == ngapType.ProtocolIEIDRRCEstablishmentCause {\n                        ie.Value.RRCEstablishmentCause.Value = aper.Enumerated(valueIe3A)\n                    }\n                }\n            }\n            if changeIe4 {\n                // UE Context Request\n                for _, ie := range ngapPdu.InitiatingMessage.Value.InitialUEMessage.ProtocolIEs.List {\n                    if ie.Id.Value == ngapType.ProtocolIEIDUEContextRequest {\n                        ie.Value.UEContextRequest.Value = aper.Enumerated(valueIe4A)\n                    }\n                }\n            }\n            sendMsg, err = ngap.Encoder(ngapPdu)\n        } else if modifyWhat%2 == DoModifyFormat {\n            registrationRequest = nasTestpacket.GetRegistrationRequest(\n                nasMessage.RegistrationType5GSInitialRegistration, mobileIdentity5GS, nil, ue.GetUESecurityCapability(), nil, nil, nil)\n\n            if changeIe1 {\n                registrationRequest[3] += 1\n                registrationRequest = append(registrationRequest, registrationRequest[len(registrationRequest)-1])\n            } else {\n                registrationRequest[3] -= 1\n                registrationRequest = registrationRequest[:len(registrationRequest)-1]\n            }\n\n            ngapPdu = ngapTestpacket.BuildInitialUEMessage(ue.RanUeNgapId, registrationRequest, \"\")\n            sendMsg, err = ngap.Encoder(ngapPdu)\n            require.Nil(t, err, \"Error: %v\", err)\n            require.Equal(t, int(sendMsg[3]), len(sendMsg[4:]), \"%v\", sendMsg)\n\n            idx = bytes.Index(sendMsg, []byte(\"\\x00\\x70\\x40\"))\n            assert.NotEqual(t, idx, -1, \"Can not find UE context Request\")\n            if idx != -1 {\n                if valueIe4A%8 == 0 || valueIe4A%8 == 1 {\n                    n = 2\n                } else {\n                    n = int(valueIe4A % 8)\n                }\n                sendMsg[idx+3] = uint8(n)\n                sendMsg = sendMsg[:idx+4]\n                bs = make([]byte, 8)\n                binary.LittleEndian.PutUint64(bs, valueIe4A)\n\n                for i := 0; i &lt; n; i++ {\n                    sendMsg = append(sendMsg, bs[i])\n                }\n\n                sendMsg[3] += uint8(n - 1) // total length\n            }\n        }\n        require.Equal(t, int(sendMsg[3]), len(sendMsg[4:]), \"%v\", sendMsg)\n\n        _, err = ngap.Decoder(sendMsg)\n    })\n}\n</code></pre> <p>We can use the following command to execute the fuzz testing.</p> <pre><code>go test -fuzz=^FuzzNgapDecode$ -run=^FuzzNgapDecode$\n</code></pre> <p>The test resulted in a crash, which confirms the presence of the vulnerability as described in CVE-2022-43677.</p> <p></p> <p>The bug was found in the package aper at version v1.0.4. Fortunately, the latest version of the package has already fixed this issue. To verify the fix, we can update the aper package to the latest commit using the following commands:</p> <pre><code># Update package aper to the latest commit\ngo get github.com/free5gc/aper@main\n</code></pre> <p>After updating the aper package, we can test it again with the fuzzing function:</p> <p><pre><code>go test -fuzz=^FuzzNgapDecode$ -run=^FuzzNgapDecode$\n</code></pre> </p> <pre><code># Alternatively, re-testing the failing case\ngo test -run=FuzzNgapDecode/87af855bbc381c8d510af5ce897fcdd7f9154574e61c0413223f7e31769c2767\n</code></pre> <p></p>"},{"location":"blog/20230809/main/#conclusion","title":"Conclusion","text":"<p>Fuzz testing is a powerful technique for improving the security and reliability of software systems. By subjecting programs to a wide range of inputs, fuzzing can uncover vulnerabilities and defects that might not be found through traditional testing methods. It automates the testing process, making it efficient and scalable for large codebases.</p> <p>In the context of Go programming, Go fuzzing is well-supported and integrates seamlessly with the standard testing framework. Developers can create fuzzing functions to target specific functions and uncover potential issues using random or mutated inputs.</p> <p>To demonstrate the effectiveness of fuzz testing, we presented a real case, CVE-2022-43677, which affected free5GC version 3.2.1. By developing a fuzzing function for the NGAP decoder, we were able to identify a vulnerability that caused a crash.</p> <p>In conclusion, fuzz testing is a critical practice in software development, enabling developers to proactively discover and resolve bugs and vulnerabilities. It empowers them to deliver more secure and robust software systems, providing users with a higher level of confidence in the applications they use. By incorporating fuzz testing as part of the software development lifecycle, developers can significantly enhance the quality and security of their software products.</p>"},{"location":"blog/20230809/main/#reference","title":"Reference","text":"<ul> <li>Go Fuzzing</li> <li>CVE-2022-43677</li> </ul>"},{"location":"blog/20230809/main/#about","title":"About","text":"<p>I'm Yu-Sheng Liu, a master's student at National Yang Ming Chiao Tung University. My research topic focuses on improving the performance of the 5G core network, such as reducing the latency of message propagation in SBI. If you have any questions, please don't hesitate to contact me!</p> <ul> <li>LinkedIn</li> </ul>"},{"location":"blog/20230816/main/","title":"Introduce Kubernetes and Deploy free5GC on Kubernetes with helm","text":"<p>Note</p> <p>Author: Elisa Lee Date: 2023/8/16</p>"},{"location":"blog/20230816/main/#abstract","title":"Abstract","text":"<p>In the initial section of the article, I will provide an introduction to Kubernetes. Moving on to the subsequent part, I will delve into the utilization of Kubernetes for facilitating the deployment of free5GC. Lastly, in the final segment of the article, I will elaborate on the effective utilization of Kubernetes for monitoring services.</p>"},{"location":"blog/20230816/main/#introduce-kubernetes","title":"Introduce Kubernetes","text":"<p>Do you know why Kubernetes is called k8s?</p> <p>It's due to a shorthand notation that uses the first letter \"k,\" followed by the number \"8,\" and ending with the last letter \"s\" to represent the full name. Kubernetes,stands as an open-source container orchestration platform that bestows organizations with the capacity to adeptly govern, deploy, and expand containerized applications. Initially conceived by Google and presently overseen by the Cloud Native Computing Foundation (CNCF), Kubernetes has ascended to become a pivotal technological underpinning within the realm of contemporary cloud-native computing.</p> <p>For those who find themselves unacquainted with the intricacies of Kubernetes, let us embark on an exploration of its architectural framework.</p> <p> I understand that the image presented above might appear intricate at first glance. However, there's no need for concern. Allow me to guide you through each component step by step.</p>"},{"location":"blog/20230816/main/#pods","title":"Pods","text":"<p>A \"Pod\" stands as the most diminutive executable entity within the Kubernetes ecosystem. It possesses the capability to encompass either an individual container or a collective assembly of containers. The subsequent enumeration outlines several salient distinctions that set it apart from the act of directly launching a standalone container.</p> <p>Notably, a Pod possesses its dedicated network interface, affording all enclosed containers the ability to intercommunicate seamlessly by interfacing with the \"localhost.\" Furthermore, connectivity to other Pods is conveniently established through direct usage of their respective IP addresses within the Kubernetes environment.</p> <p>The Pod's inherent duplicability and capacity for effortless restarts, even from the point of its most recent execution, distinguish it. Additionally, the versatility of including a functioning container within its initial state further characterizes its nature.</p> <p>Collectively, these attributes contribute to the refinement and streamlined nature of networking within the Kubernetes ecosystem. Such qualities not only facilitate smoother scalability but also offer enhanced capabilities for restarting services with utmost ease.</p>"},{"location":"blog/20230816/main/#nodes","title":"Nodes","text":"<p>Consider a \"node\" as a tangible computing entity akin to a physical machine. Analogous to our personal machines, these nodes possess the capacity to concurrently execute multiple tasks, akin to the pods referenced earlier. The orchestration of nodes is overseen by a pivotal component known as the Kubernetes control plane, which, in an automated fashion, allocates pods across the available nodes. Within each node, a minimum of two services operate in tandem.</p> <ol> <li> <p>Kubelet: This crucial service undertakes the responsibility of facilitating seamless communication between the Kubernetes control plane and the individual node. It serves as the intermediary that relays instructions and status updates, ensuring synchronization and cooperation.</p> </li> <li> <p>Container Runtime: Operating in tandem with Kubelet, the container runtime undertakes pivotal functions. These encompass retrieving container images from registries, the unpacking of containers, and the actual execution of applications. A prime example of such a container runtime is Docker, renowned for its role in enabling containerization.</p> </li> </ol> <p>In essence, this intricate interplay of nodes, services, and orchestration elements underscores the dynamism and efficiency inherent to the Kubernetes ecosystem. Through these interlocking mechanisms, the platform optimizes resource utilization, ensures effective communication, and enables the seamless execution of applications across a distributed infrastructure.</p>"},{"location":"blog/20230816/main/#master-nodes","title":"Master Nodes","text":"<p>We've now explored all the scalable components and the task runner. Undoubtedly, to orchestrate and oversee everything, a central command hub is necessary \u2013 this is referred to as the master node. Although direct intervention within these nodes isn't typically required to ensure the seamless operation of the entire system, it's still beneficial for you to grasp a basic understanding of its functionality.</p>"},{"location":"blog/20230816/main/#api-server","title":"API server","text":"<p>It determines which interface among all nodes can be externally accessed. Any subsequent commands you execute will be channeled through this service to the designated node or pod. Furthermore, essential cluster information can also be obtained from this service.</p>"},{"location":"blog/20230816/main/#scheduler","title":"Scheduler","text":"<p>Similar to an airport's control tower, its function is akin to orchestrating the deployment of pods on specific nodes based on the rules you've established and the data obtained from the API server. The effectiveness of these rules is pivotal, as they often determine the system's overall efficiency.</p>"},{"location":"blog/20230816/main/#controller-manager","title":"Controller Manager","text":"<p>When the need arises to enact concrete modifications on a pod, such as terminating or pausing its operation, a fundamental prerequisite is pinpointing the pod's process location and establishing the means to interact with it. This is precisely the role fulfilled by the controller manager. Additionally, this manager oversees vital components, including accounts, services, and more.</p>"},{"location":"blog/20230816/main/#etcd","title":"Etcd","text":"<p>For a simplified understanding, we can view this as essentially a comprehensive backup of the entire cluster.</p>"},{"location":"blog/20230816/main/#service","title":"Service","text":"<p>In Kubernetes, a \"service\" is an abstraction that enables communication between different sets of pods, usually to provide a stable network endpoint for accessing a specific group of pods. Pods in Kubernetes are ephemeral and can be created, terminated, or scaled dynamically, which makes their IP addresses and lifecycles unpredictable. Services provide a way to decouple the frontend of an application from the backend pods, making it easier for other components or users to access the application without having to know the exact locations or IP addresses of the pods.</p> <p>A service can be defined in Kubernetes using a YAML or JSON configuration file, and it is associated with a set of pods based on a label selector. The service acts as a load balancer, distributing incoming network traffic among the pods that match the specified selector. This distribution ensures that even if pods are scaled up or down, the service remains available and reachable.</p> <p>There are different types of services in Kubernetes:</p> <ol> <li> <p>ClusterIP: This is the default service type, and it exposes the service on a cluster-internal IP address. It is accessible only within the cluster.</p> </li> <li> <p>NodePort: This type exposes the service on each node's IP address at a static port. It allows external access to the service using the node's IP and the specified static port.</p> </li> <li> <p>LoadBalancer: This type automatically provisions a cloud provider load balancer to expose the service externally. It works in environments that support external load balancers.</p> </li> <li> <p>ExternalName: This type provides an alias for an external service by returning a CNAME record with the configured DNS name.</p> </li> </ol> <p>Services are a fundamental concept in Kubernetes and play a crucial role in enabling communication and load balancing between pods and external clients. They provide a stable and abstracted network endpoint that allows applications to scale and be more resilient without disrupting access from users or other components.</p> <p>In the upcoming section, I will delve into the process of deploying free5GC on Kubernetes.</p>"},{"location":"blog/20230816/main/#deploying-5g-core-network-with-free5gc","title":"Deploying 5G core network with free5GC","text":"<p>Now I'm going to introduce how to implement free5GC on Kubernetes with helm</p>"},{"location":"blog/20230816/main/#install-require-packages","title":"Install require packages","text":"<pre><code>sudo apt update -y\nsudo apt upgrade -y\n</code></pre>"},{"location":"blog/20230816/main/#install-apt-transport-https","title":"Install apt-transport-https","text":"<p>\"apt-transport-https\" is a crucial package that equips your system with the essential tools and libraries required to seamlessly integrate the HTTPS protocol. This integration ensures secure and encrypted communication when connecting to package repositories while utilizing the Advanced Package Tool (APT) for effective package management. <pre><code>sudo apt install -y curl wget apt-transport-https\n</code></pre></p>"},{"location":"blog/20230816/main/#install-gtp5g","title":"Install gtp5g","text":"<p>\"gtp5g\" refers to a customized Linux kernel module specifically designed to handle packets by PFCP (Packet Forwarding Control Protocol) Information Elements (IEs) such as PDR (Packet Detection Rule) and FAR (Forwarding Action Rule). For comprehensive insights, you can delve into the 3GPP specifications TS 29.281 and TS 29.244. To employ the UPF (User Plane Function) component effectively, it's imperative to operate on either the 5.0.0-23-generic or 5.4.x version of the Linux kernel. This ensures optimal compatibility and seamless integration with the necessary functionalities. <pre><code>sudo apt install gcc\nsudo apt install make\ngit clone -b v0.8.1 https://github.com/free5gc/gtp5g.git\ncd gtp5g\nmake\nsudo make install\n</code></pre></p>"},{"location":"blog/20230816/main/#install-docker","title":"Install docker","text":"<p>\"docker\" is a platform that enables developers to build, package, and distribute applications as containers. Containers are lightweight, portable, and self-sufficient units that encapsulate everything an application needs to run, including the code, runtime, system tools, system libraries, and settings. Docker provides a consistent environment across different development and deployment stages, from local development to testing and production. <pre><code>for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do sudo apt-get remove $pkg; done\nsudo apt-get update\nsudo apt-get install ca-certificates curl gnupg\nsudo install -m 0755 -d /etc/apt/keyrings\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\nsudo chmod a+r /etc/apt/keyrings/docker.gpg\necho \\\n  \"deb [arch=\"$(dpkg --print-architecture)\" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\n  \"$(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\")\" stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n  sudo apt-get update\n  sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre></p>"},{"location":"blog/20230816/main/#install-minikube","title":"Install minikube","text":"<p>\"minikube\" is an open-source tool that enables developers to set up and run a single-node Kubernetes cluster locally on their own computer. It's particularly useful for learning, development, and testing purposes. Minikube provides an easy way to experience Kubernetes without needing access to a full-scale cluster, making it a great tool for getting familiar with Kubernetes concepts and features. <pre><code>wget https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64\nsudo cp minikube-linux-amd64 /usr/local/bin/minikube\nsudo chmod +x /usr/local/bin/minikube\n</code></pre></p>"},{"location":"blog/20230816/main/#install-kubectl","title":"Install kubectl","text":"<p>\"kubectl\" is the command-line tool used to interact with and manage Kubernetes clusters. It is an essential component for working with Kubernetes, allowing users to perform various tasks and operations on Kubernetes clusters directly from the terminal. <pre><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl\nchmod +x kubectl\nsudo mv kubectl /usr/local/bin/\n</code></pre></p>"},{"location":"blog/20230816/main/#install-helm","title":"Install helm","text":"<p>\"helm\" is a package manager for Kubernetes that simplifies the deployment and management of applications and services on a Kubernetes cluster. It allows you to define, install, and upgrade complex applications using pre-configured templates called \"charts.\" These charts encapsulate all the necessary resources, configurations, and dependencies required to run an application. <pre><code>curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3\nchmod 700 get_helm.sh\n./get_helm.sh\nhelm list -A\n</code></pre> </p>"},{"location":"blog/20230816/main/#install-multus-cni","title":"Install multus-cni","text":"<p>\"multus-cni\" is a project that provides a Kubernetes network plugin, specifically a \"Container Network Interface\" (CNI) plugin, which enables the attachment of multiple network interfaces to pods in a Kubernetes cluster. <pre><code>git clone https://github.com/k8snetworkplumbingwg/multus-cni.git\n</code></pre></p>"},{"location":"blog/20230816/main/#deploy-free5gc","title":"Deploy free5GC","text":""},{"location":"blog/20230816/main/#useful-kubectl-command","title":"Useful kubectl command","text":"<p>Now, I will proceed to introduce a selection of kubectl command that can be employed during the deployment of free5GC.</p> <p>\"kubectl get pods\" retrieves a list of running pods in the current namespace along with their names, statuses, and other relevant information. <pre><code>kubectl get pods\n</code></pre> \"kubectl describe pod\" is used to get detailed information about a specific pod, including its status, events, labels, and more.</p> <p><pre><code>kubectl describe pod [pod-name]\n</code></pre> \"kubectl logs\" fetches the logs of a specific pod, helping you troubleshoot issues and monitor application output.</p> <p><pre><code>kubectl logs [pod-name]\n</code></pre> \"kubectl exec -it\" allows you to execute a command inside a running pod. The <code>-it</code> flag enables interactive terminal access. <pre><code>kubectl exec -it [pod-name] -- [command]\n</code></pre> \"kubectl apply -f \" deploys resources defined in a YAML file, such as pods, services, or deployments, to your cluster. <pre><code>kubectl apply -f [yaml-file]\n</code></pre> \"kubectl delete\" deletes a specific resource by specifying its type and name, freeing up resources and cleaning the cluster. <pre><code>kubectl delete [resource-type] [resource-name]\n</code></pre> \"kubectl expose deployment\" creates a new service, typically of type LoadBalancer, to expose a deployment's pods to external network traffic. <pre><code>kubectl expose deployment [deployment-name] --type=LoadBalancer --port=[port]\n</code></pre></p> <p>\"kubectl get services\" lists all services running in the current namespace along with their details, including ClusterIP, external IP (if applicable), and ports. <pre><code>kubectl get services\n</code></pre> \"kubectl get nodes\" retrieves information about the worker nodes in the cluster, displaying their statuses, roles, and other essential data. <pre><code>kubectl get nodes\n</code></pre> \"kubectl describe node\" provides detailed information about a specific node, including its capacity, allocated resources, and conditions. <pre><code>kubectl describe node [node-name]\n</code></pre> \"kubectl get namespaces\" displays all available namespaces in the cluster, which are used to isolate resources and manage multi-tenancy. <pre><code>kubectl get namespaces\n</code></pre> \"kubectl create namespace\" creates a new namespace, allowing you to logically separate and organize resources. <pre><code>kubectl create namespace [namespace-name]\n</code></pre> \"kubectl port-forward\" enables you to create a network tunnel between your local machine and a specific pod running within a Kubernetes cluster. This allows you to access services or applications running inside the pod as if they were running on your local machine. The command forwards traffic from a specified local port to a port on the selected pod. <pre><code>kubectl port-forward [pod-name] [local-port]:[remote-port]\n</code></pre></p>"},{"location":"blog/20230816/main/#start-minikube","title":"Start minikube","text":"<p>Use flannel as cni plugin to start minikue. Flannel is a popular \"Container Network Interface\" (CNI) plugin used for networking in Kubernetes and other container orchestration platforms. It provides a simple and lightweight network fabric designed to facilitate communication between containers and pods in a distributed environment, such as a Kubernetes cluster. <pre><code>sudo usermod -aG docker $USER &amp;&amp; newgrp docker\nminikube start --driver=docker --cpus=4 --memory=8g --disk-size=20g --cni=flannel\n## verify minikube installation\nminikube status\n</code></pre> </p>"},{"location":"blog/20230816/main/#enable-multus-cni-plugin","title":"Enable Multus-CNI Plugin","text":"<pre><code>cd multus-cni\ncat ./deployments/multus-daemonset.yml | kubectl apply -f -\n</code></pre>"},{"location":"blog/20230816/main/#install-free5gc-and-ueransim","title":"Install free5GC and UERANSIM","text":"<p>If you have only one interface on each Kubernetes node and its name is <code>toto</code>. Then you have to set these parameters to <code>toto</code>: <code>global.n2network.masterIf</code> <code>global.n3network.masterIf</code> <code>global.n4network.masterIf</code> <code>global.n6network.masterIf</code> <code>global.n9network.masterIf</code></p> <p><pre><code>kubectl create ns free5gc\ngit clone https://github.com/Orange-OpenSource/towards5gs-helm.git\ncd towards5gs-helm/charts/\nhelm -n free5gc install free5gc-v1 ./free5gc/\nhelm -n free5gc install ueransim-v1 ./ueransim/\nwatch kubectl get pods -n free5gc\n</code></pre> </p>"},{"location":"blog/20230816/main/#start-webconsole","title":"Start WebConsole","text":"<p>free5GC offers a user-friendly web tool called WebConsole, designed to facilitate the creation and management of User Equipment (UE) registrations. This tool serves as a valuable resource for multiple 5G network functions (NFs), streamlining the process of handling UE registrations and associated tasks. <pre><code>kubectl port-forward --namespace free5gc svc/webui-service 5000:5000\n</code></pre> Execute the following command in your local machine's terminal, and subsequently, you will be able to access the WebConsole via localhost:5000. You can login with username <code>admin</code> and password <code>free5gc</code>. <pre><code>ssh -L localhost:5000:localhost:5000 ubuntu@[VM ip]\n</code></pre> </p>"},{"location":"blog/20230816/main/#service-monitoring","title":"Service Monitoring","text":""},{"location":"blog/20230816/main/#install-prometheusgrafana-services","title":"install Prometheus/Grafana services","text":"<p>For monitoring Kubernetes, I utilized Prometheus and Grafana. The installation of Prometheus and Grafana services is facilitated through the Helm chart provided by the prometheus-community. <pre><code>helm repo add prometheus-community https://prometheus-community.github.io/helm-charts\nhelm repo update\nkubectl create namespace prometheus\nhelm install prometheus prometheus-community/kube-prometheus-stack -n prometheus\nwatch kubectl get pods -n prometheus\n</code></pre> </p> <p><pre><code>kubectl port-forward -n prometheus svc/prometheus-grafana 8080:80\n</code></pre> Execute the following command in your local machine's terminal, and subsequently, you will be able to access the WebConsole via localhost:8080. <pre><code>ssh -L localhost:8080:localhost:8080 ubuntu@[VM ip]\n</code></pre>  A variety of dashboards are available, offering different perspectives for those who are interested. Below is a snapshot of one such dashboard option.</p> <p></p>"},{"location":"blog/20230816/main/#reference","title":"Reference","text":"<p>https://free5gc.org/</p> <p>https://medium.com/rahasak/deploying-5g-core-network-with-free5gc-kubernets-and-helm-charts-29741cea3922</p> <p>https://github.com/Orange-OpenSource/towards5gs-helm</p> <p>https://github.com/k8snetworkplumbingwg/multus-cni</p>"},{"location":"blog/20230816/main/#about","title":"About","text":"<p>Hello, I am Elisa Lee. My ongoing research revolves around VoNR (Voice over New Radio). I encourage any inquiries or identification of errors within the article, as they are welcomed for correction. Your feedback is invaluable, so please don't hesitate to reach out via email to share your insights.</p>"},{"location":"blog/20230823/20230823/","title":"Web security: CSRF vulnerability in webconsole","text":"<p>Note</p> <p>Author: Brian Chen (\u9673\u715c\u76db) Date: 2023/8/23</p>"},{"location":"blog/20230823/20230823/#abstract","title":"Abstract","text":"<p>This article is intended for individuals who possess an interest in free5gc/webconsole and hold concerns regarding security matters. It aims to provide a concise introduction to the webconsole, followed by an exposition of a significant security concern along with our corresponding solution. Within webconsole v1.2.0, aligning with the most recent iteration of free5gc v3.3.0, certain vulnerabilities have been identified that could potentially lead to the exposure of subscriber data. It is my responsibility to address and rectify these vulnerabilities, enhancing the webconsole's resilience against cyber attacks.</p>"},{"location":"blog/20230823/20230823/#webconsole-overview","title":"Webconsole Overview","text":"<p>The Webconsole serves as a web-based tool designed to manage User Equipment (UE) subscription data. It plays a crucial role in aiding the free5GC Core Network manager by facilitating the configuration of UEs and providing the ability to monitor the status of activated UEs.</p>"},{"location":"blog/20230823/20230823/#environment","title":"Environment","text":"<ul> <li>Frontend<ul> <li>React v17.0.2</li> <li>node.js v20.2.0</li> <li>yarn v1.22.19</li> </ul> </li> <li>Backend<ul> <li>Golang v1.17</li> <li>Gin v1.9.0</li> <li>MongoDB v3.6.8</li> </ul> </li> </ul>"},{"location":"blog/20230823/20230823/#install-run-webconsole","title":"Install &amp; Run webconsole","text":"<p>Prior to building webconsole, install nodejs and yarn package first:</p> <pre><code>sudo apt remove cmdtest\nsudo apt remove yarn\ncurl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -\necho \"deb https://dl.yarnpkg.com/debian/ stable main\" | sudo tee /etc/apt/sources.list.d/yarn.list\nsudo apt-get update\nsudo apt-get install -y nodejs yarn\n</code></pre> <p>To run free5GC webconsole server. The following steps are to be considered.</p> <pre><code>git clone https://github.com/free5gc/webconsole.git\ncd frontend\nyarn install\nyarn build\nrm -rf ../public\ncp -R build ../public\ncd ..\ngo run server.go\n</code></pre> <p>Default account and password is <code>admin/free5gc</code></p> <p></p>"},{"location":"blog/20230823/20230823/#pages","title":"Pages","text":""},{"location":"blog/20230823/20230823/#subscribers","title":"SUBSCRIBERS","text":"<p>Creation/deletion/editing the subscriber's data:</p> <p></p> <p>A Subscriber data contains these informations:</p> <ul> <li>PLMN ID</li> <li>SUPI (UE ID)</li> <li>AKA parameters</li> <li>S-NSSAI Configurations<ul> <li>Sst/Sd</li> <li>DNN<ul> <li>Name</li> <li>AMBR</li> <li>Flow Rules<ul> <li>IP Filter</li> <li>Precedence</li> <li>5QI</li> <li>GBR</li> <li>MBR</li> </ul> </li> </ul> </li> </ul> </li> </ul> <p></p>"},{"location":"blog/20230823/20230823/#tenant-and-user","title":"TENANT AND USER","text":"<p>The Webconsole also allows for the creation, deletion, and editing of tenants. A tenant functions as an access control group, delineating specific permissions and boundaries. In this setup, if you do not possess admin privileges, you are unable to access subscriber data generated by other tenants, ensuring data privacy and security.</p> <p></p> <p>Furthermore, the capability to incorporate users within a tenant is available. To illustrate, by selecting the brian1 tenant and clicking on the New User option, it becomes possible to introduce a new user. As an example, a user with the email address aaabbb@gmail.com can be added through this process.</p> <p></p> <p>The data within MongoDB can be accessed and reviewed using the MongoDBCompass tool.</p> <p></p>"},{"location":"blog/20230823/20230823/#csrf-cross-site-request-forgery-vulnerability","title":"CSRF (Cross-Site Request Forgery) Vulnerability","text":"<p>The vulnerability was discovered by INCIBE, and they promptly notified the free5GC team via email. </p> <p>The corresponding issue related to this vulnerability is also documented in the free5gc repository. Despite the typical deployment of the webconsole within LAN or Docker environments, it's essential to exercise caution regarding users who operate this service on a public IP or within an insecure network environment.</p> <p>In a nutshell, an attacker can gain unauthorized access to the database by merely setting the token to the term 'admin'. <pre><code>$ curl '&lt;webconsole's IP&gt;:5000/api/subscriber' -H 'User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:103.0) Gecko/20100101 Firefox/103.0' -H 'Accept: application/json' -H 'Accept-Language: en-US,en;q=0.5' -H 'Accept-Encoding: gzip, deflate' -H 'Referer: http://&lt;webconsole's IP&gt;:5000/' -H 'Connection: keep-alive' -H 'X-Requested-With: XMLHttpRequest' -H 'Token: admin' -H 'Pragma: no-cache' -H 'Cache-Control: no-cache'\n</code></pre></p> <p>Subsequently, they can directly retrieve subscriber information from the server's MongoDB. <pre><code>[{\"plmnID\":\"20893\",\"ueId\":\"imsi-208930000000003\"}]\n</code></pre></p> <p>Undoubtedly, this vulnerability is of significant concern since the intended safeguard, allowing access solely to admin, has been compromised, thereby enabling easy access for anyone.</p>"},{"location":"blog/20230823/20230823/#trace-code","title":"Trace Code","text":""},{"location":"blog/20230823/20230823/#frontend","title":"Frontend","text":"<p>In <code>webconsole/frontend/src/util/AuthHelper.js</code></p> <ul> <li>In scenarios where the default username and password (admin/free5gc) are employed, the <code>ApiHelper.login()</code> function remains untouched. This practice might expedite agile development, but it comes at the cost of compromising security.</li> </ul> <p></p>"},{"location":"blog/20230823/20230823/#backend","title":"Backend","text":"<p>In <code>webconsole/frontend/WebUI/api_webui.go</code> - In situations where a webconsole client configures the <code>tokenStr</code> as 'admin', the backend process will omit the execution of <code>ParseJWT()</code>.</p> <p></p>"},{"location":"blog/20230823/20230823/#json-web-token-jwt","title":"JSON Web Token (JWT)","text":"<p>The Webconsole relies on JSON Web Token (JWT) as its authentication mechanism, a specification outlined in RFC 7519.</p> <p>JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties.  The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted.</p> <p>When a client employs a web browser to initiate a login via the HTTP(s) protocol, the Web server is expected to furnish the client with a JWT token in response. Subsequently, the client employs this JWT token to interact with resources by sending requests through the RESTful API (such as GET, POST, PUT, etc.).</p> <p>A JSON Web Token (JWT) consists of three distinct parts. In the context of the webconsole backend, the following fields are relevant:</p> <ul> <li>Header: This section contains information about the type of token and the signing algorithm used. It often includes the \"alg\" (algorithm) and \"typ\" (type) fields.</li> <li>Payload: The payload holds the actual claims or data that are being conveyed by the token. For the webconsole backend, specific fields within this section could include:<ul> <li>Claim (JSON object)<ul> <li><code>sub</code>: identifies the principal that is the subject of the JWT.</li> <li><code>iat</code>: identifies the time at which the JWT was issued.</li> <li><code>exp</code>: identifies the expiration time onor after which the JWT MUST NOT be accepted for processing.</li> <li><code>email</code></li> <li><code>tenantId</code></li> <li>...(you can design the attribute yourself)</li> </ul> </li> </ul> </li> <li>Signature: This component is created by combining the encoded header and payload with a secret key (or a public/private key pair) to ensure the token's integrity and authenticity. The signature allows the recipient to verify that the token hasn't been tampered with.</li> </ul> <p>The JWT Claims Set represents a JSON object whose members are the claims conveyed by the JWT.  The Claim Names within a JWT Claims Set MUST be unique; JWT parsers MUST either reject JWTs with duplicate Claim Names or use a JSON parser that returns only the lexically last duplicate member name</p> <p>The image depicted below illustrates the process of using jwt.io to both encode and decode JWT tokens. These tokens are segmented into distinct sections denoted by the red, purple and blue divisions, separated by periods dots.</p> <p></p> <p>Given that the Payload can be decoded using the algorithm specified in the Header, it's essential to refrain from including sensitive details like passwords or credit card numbers within it. Instead, the Payload typically holds claims and application-specific metadata.</p> <p>To maintain the security of the process, the server retains a confidential key used to validate the signature. In situations where a client endeavors to access a resource using a JWT token that possesses an incorrect Verify Signature, an error response will be generated. This stringent signature verification mechanism ensures that the authenticity and integrity of both the token and its enclosed data are upheld.</p>"},{"location":"blog/20230823/20230823/#trace-code-cont","title":"Trace Code (Cont.)","text":"<p>In <code>webconsole/frontend/WebUI/api_webui.go</code>, we can find the implementation of JWT.</p> <ul> <li><code>JWT()</code> is for encoding: <pre><code>func JWT(email, userId, tenantId string) string {\n    token := jwt.New(jwt.SigningMethodHS256)\n\n    claims := token.Claims.(jwt.MapClaims)\n    claims[\"sub\"] = userId\n    claims[\"iat\"] = time.Now()\n    claims[\"exp\"] = time.Now().Add(time.Hour * 24).Unix()\n    claims[\"email\"] = email\n    claims[\"tenantId\"] = tenantId\n\n    if jwtKey == \"\" {\n        return \"\"\n    }\n\n    tokenString, err := token.SignedString([]byte(jwtKey))\n    if err != nil {\n        logger.ProcLog.Errorf(\"JWT err: %+v\", err)\n        return \"\"\n    }\n\n    return tokenString\n}\n</code></pre></li> <li><code>ParseJWT()</code> is for decoding: <pre><code>func ParseJWT(tokenStr string) (jwt.MapClaims, error) {\n    token, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) {\n        return []byte(jwtKey), nil\n    })\n    if err != nil {\n        return nil, errors.Wrap(err, \"ParseJWT error\")\n    }\n\n    claims, _ := token.Claims.(jwt.MapClaims)\n\n    return claims, nil\n}\n</code></pre></li> <li>The function <code>CheckAuth()</code> serves the purpose of determining whether a user possesses the authorization to access a particular resource.</li> </ul> <pre><code>func CheckAuth(c *gin.Context) bool {\n    tokenStr := c.GetHeader(\"Token\")\n    if tokenStr == \"admin\" {\n        return true\n    } else {\n        return false\n    }\n}\n</code></pre> <p>Warning</p> <ul> <li> <p>The secret key utilized for signature verification is obtained through <code>os.Getenv(\"SIGNINGKEY\")</code>. However, there's a possibility that <code>SIGNINGKEY</code> might not be exported as an environment variable, leading to a potential return of an empty value. Under such circumstances, an implication arises: an admin in Webconsole A could potentially gain access to subscriber data within Webconsole B.</p> </li> <li> <p>Within the <code>CheckAuth()</code> function, if the client sets the JWT token to 'admin', the function will evaluate to true, effectively allowing the check to be passed.</p> </li> </ul>"},{"location":"blog/20230823/20230823/#implementation","title":"Implementation","text":""},{"location":"blog/20230823/20230823/#check-authentication","title":"Check Authentication","text":"<p>Initially, I have revised the design of the <code>CheckAuth()</code> function to ensure the mandatory execution of <code>ParseJWT()</code>. <pre><code>func CheckAuth(c *gin.Context) bool {\n    tokenStr := c.GetHeader(\"Token\")\n    claims, err := ParseJWT(tokenStr)\n\n    if err == nil &amp;&amp; claims[\"email\"] == \"admin\" {\n        return true\n    } else {\n        return false\n    }\n}\n</code></pre> Furthermore, I've implemented a second change where, considering that the webconsole v1.2.0 doesn't inherently establish a tenant named 'admin' or a user named 'admin', I propose a more effective approach. During the initialization of the webconsole backend, it is recommended to generate an 'admin' tenant and user. This means that executing <code>go run server.go</code> within the <code>webconsole/</code> directory should consistently generate an admin user, thereby fulfilling the initial login requirement.</p> <p></p> <p>Certainly, in the <code>backend/WebUI/api_webui.go</code> file, I propose the addition of a function named <code>SetAdmin()</code>. To streamline the process and maintain consistency with the rest of the free5GC project, it is recommended to leverage the <code>mongoapi</code> module established within the <code>free5gc/util</code> repository. Given the project's heavy reliance on MongoDB, employing <code>mongoapi</code> over frequent calls to <code>mongo-driver</code> is essential to ensure efficiency and coherence.</p> <pre><code>func SetAdmin() {\n    err := mongoapi.RestfulAPIDeleteOne(\"tenantData\", bson.M{\"tenantName\": \"admin\"})\n    if err != nil {\n        logger.InitLog.Errorf(\"RestfulAPIDeleteOne err: %+v\", err)\n    }\n    err = mongoapi.RestfulAPIDeleteOne(\"userData\", bson.M{\"email\": \"admin\"})\n    if err != nil {\n        logger.InitLog.Errorf(\"RestfulAPIDeleteOne err: %+v\", err)\n    }\n\n    // Create Admin tenant\n    logger.InitLog.Infoln(\"Create tenant: admin\")\n\n    adminTenantData := bson.M{\n        \"tenantId\":   uuid.Must(uuid.NewRandom()).String(),\n        \"tenantName\": \"admin\",\n    }\n\n    _, err = mongoapi.RestfulAPIPutOne(\"tenantData\", bson.M{\"tenantName\": \"admin\"}, adminTenantData)\n    if err != nil {\n        logger.InitLog.Errorf(\"RestfulAPIPutOne err: %+v\", err)\n    }\n\n    AmdinTenant, err := mongoapi.RestfulAPIGetOne(\"tenantData\", bson.M{\"tenantName\": \"admin\"})\n    if err != nil {\n        logger.InitLog.Errorf(\"RestfulAPIGetOne err: %+v\", err)\n    }\n\n    // Create Admin user\n    logger.InitLog.Infoln(\"Create user: admin\")\n\n    hash, err := bcrypt.GenerateFromPassword([]byte(\"free5gc\"), 12)\n    if err != nil {\n        logger.InitLog.Errorf(\"GenerateFromPassword err: %+v\", err)\n    }\n\n    adminUserData := bson.M{\n        \"userId\":            uuid.Must(uuid.NewRandom()).String(),\n        \"tenantId\":          AmdinTenant[\"tenantId\"],\n        \"email\":             \"admin\",\n        \"encryptedPassword\": string(hash),\n    }\n\n    _, err = mongoapi.RestfulAPIPutOne(\"userData\", bson.M{\"email\": \"admin\"}, adminUserData)\n    if err != nil {\n        logger.InitLog.Errorf(\"RestfulAPIPutOne err: %+v\", err)\n    }\n}\n</code></pre>"},{"location":"blog/20230823/20230823/#jwt-verify-signature","title":"JWT Verify Signature","text":"<p>Certainly, within the <code>backend/WebUI/api_webui.go</code> file, I recommend introducing a string variable named <code>jwtKey</code> to serve as the private key for JWT Verify Signature. Although the length of jwtKey is specified as 256 bytes, it's worth noting that the distinction between 256 bytes and 256 bits is inconsequential in this context. The jwt module will adeptly transform the key to a 256-bit form. For further insights, you can refer to issue 28.</p> <pre><code>var jwtKey = \"\" // for generating JWT\n\n/* ... */\n\nfunc InitJwtKey() error {\n    randomBytes := make([]byte, 256)\n    _, err := rand.Read(randomBytes)\n    if err != nil {\n        return errors.Wrap(err, \"Init JWT key error\")\n    } else {\n        jwtKey = string(randomBytes)\n    }\n    return nil\n}\n</code></pre>"},{"location":"blog/20230823/20230823/#backend-initialization","title":"Backend Initialization","text":"<p>In <code>backend/webui_service/webui_init.go</code>:</p> <pre><code>func (a *WebuiApp) Start(tlsKeyLogPath string) {\n    /* ... */\n    WebUI.SetAdmin()\n    if err := WebUI.InitJwtKey(); err != nil {\n        logger.InitLog.Errorln(err)\n        return\n    }\n    /* ... */\n}\n</code></pre>"},{"location":"blog/20230823/20230823/#frontend-login","title":"Frontend Login","text":"<p>Certainly, in the <code>frontend/src/util/AuthHelper.js</code> file, it is advised to remove the section of code that could be considered a \"cheating snippet.\" To ensure a robust authentication process, all users should be required to successfully pass through the <code>ApiHelper.login</code> function and receive a response code of 200. This approach ensures a consistent and legitimate authentication mechanism.</p> <pre><code>static async login(username, password) {\n    let response = await ApiHelper.login({username: username, password: password});\n\n    if (response !== undefined &amp;&amp; response.status === 200) {\n      var user = null\n      if (username == \"admin\") {\n        user = new User(username, \"System Administrator\", response.data.access_token);\n      } else {\n        user = new User(username, \"User\", response.data.access_token);\n      }\n      LocalStorageHelper.setUserInfo(user);\n      store.dispatch(authActions.setUser(user));\n      return true;\n    } else {\n      return false;\n    }\n  }\n</code></pre>"},{"location":"blog/20230823/20230823/#conclusion","title":"Conclusion","text":"<p>In this endeavor, we've successfully addressed the CSRF vulnerability issue, as highlighted in issue #387 and acknowledged by INCIBE. Furthermore, I've introduced the concept of JWT tokens in this article, detailing their implementation and the corresponding adjustments made within the webconsole. You can locate the detailed implementation in the merged PR #44 of the webconsole repository. I'd like to extend my gratitude to the contributors kishiguro and LaumiH for their significant role in refactoring the webconsole. As a result of their efforts, the webconsole UI has been notably enhanced. Our upcoming focus involves the integration of the charging function, which we are actively pursuing.</p>"},{"location":"blog/20230823/20230823/#reference","title":"Reference","text":"<p>free5gc/webconsole merged PR #44 free5gc issue #387 free5gc issue #28 JSON Token RFC 7519 MongoDBCompass</p>"},{"location":"blog/20230823/20230823/#about","title":"About","text":"<p>Hello everyone,</p> <p>I'm Brian Chen (\u9673\u715c\u76db), and I've been immersed in the realm of 5G Core Network technologies. Over the course of seven months, I've had the privilege of serving as an intern at Saviah. In this role, my responsibilities encompass a spectrum of tasks including maintenance, development, and rigorous testing of the free5GC project.</p> <p>Should any inquiries, questions, or bug reports regarding free5GC arise, I encourage you to reach out by creating an issue in the free5gc repository or by participating in discussions on the forum. I'm here to assist and collaborate with the community as we navigate the intricacies of this project.</p> <p>Warm regards, Brian Chen (\u9673\u715c\u76db)</p> <ul> <li>Github</li> <li>LinkedIn</li> </ul>"},{"location":"blog/20230830/20230830/","title":"Article Sharing: eBPF: A New Approach to Cloud-Native Observability, Networking and Security for Current (5G) and Future Mobile Networks (6G and Beyond)","text":"<p>Note</p> <p>Author: Lin Poyi Date: 2023/8/30</p> <p>Original Paper: eBPF: A New Approach to Cloud-Native Observability, Networking and Security for Current (5G) and Future Mobile Networks (6G and Beyond)</p>"},{"location":"blog/20230830/20230830/#overview","title":"Overview","text":"<p>This article shows why extended Berkeley Packet Filter (eBPF) is a powerful tool to use on cloud-native platforms. Using specific eBPF programs to improve network observability and runtime security. Also, present a platform named Sauron to demonstrate how eBPF allows us to write custom code and dynamically load eBPF programs into the kernel. These programs can be used to derive performance counters and gauges for transport networks, 5G applications, and non-access stratum protocols.</p>"},{"location":"blog/20230830/20230830/#layout-of-ebpf","title":"Layout of eBPF","text":"<ul> <li>eBPF programs: run in the kernel to react to events.</li> <li>User space programs: load eBPF programs to the kernel and interact with them.</li> <li>eBPF Maps: allow data storage and information sharing between eBPF/User space programs.<ul> <li>There are different types of eBPF Maps, for example: Hash, Array, etc. A special type of eBPF Maps is called per-CPU map, since it is only accessed by one CPU and the eBPF process cannot be preempted, there's no lock needed. As a result, the performance is better.</li> </ul> </li> </ul> <p>Development phase:</p> <ol> <li>A program is compiled into an object Executable and Linkable Format (ELF) file. Using compiler suites like clang/LLVM to compile it into eBPF bytecode.</li> <li>The ELF file is loaded into the kernel using a monolithic approach enabled by bpf system calls.</li> <li>Maps are created in the kernel space. The eBPF programs can utilize eBPF maps to share data and preserve the state.</li> </ol> <p>Runtime phase:</p> <ol> <li>The eBPF program is loaded into the kernel to be verified by eBPF verifier and to be compiled by JIT Compiler into native instructions.</li> <li>The eBPF program is attached to selected events (injected in the desired kernel hooks). The eBPF program is executed once the event has occurred.</li> </ol> <p>Higher-level networking constructs can be created by combining the hooks below:</p> <ul> <li>Express Data Path (XDP): XDP BPF hook can be attached to the networking driver. The eBPF program is triggered when a packet arrives in the driver.</li> <li>Traffic Control ingress/egress: hooking eBPF programs to the traffic control ingress/egress. The eBPF program is triggered after the initial packet processing.</li> <li>Socket operations</li> </ul>"},{"location":"blog/20230830/20230830/#ebpfs-for-kubernetes","title":"eBPF's for Kubernetes","text":""},{"location":"blog/20230830/20230830/#container-networking","title":"Container Networking","text":"<p>In K8s, the kernel typically runs a networking stack for each pod. The data path is convoluted, as shown in a). eBPF can simplify the networking stack in the kernel, and connect pods as endpoints.</p> <p></p> <p>This is an example of load balancing between four replicated pods on two worker nodes. Using eBPF service (svc) Map to replace the iptables rules. This allows operators to transport data directly from inbound sockets to outbound sockets, which enables super-fast service load balancing with eBPF.</p>"},{"location":"blog/20230830/20230830/#service-mesh","title":"Service Mesh","text":"<p>A Service Mesh is a dedicated infrastructure layer that can be added to applications or Cloud-Native Network Function (CNF) micro-services. Provides connectivity between applications at the service level, and offers features such as observability, security, and traffic management.</p> <p></p> <p>The traditional approach (left) was to use a Service Mesh Library. It requires the Service Mesh Library to be written in the application's language framework.</p> <p>Then Service Mesh was achieved by implementing a cloud-native Sidecar Model (middle). With the Service Mesh Sidecar run as a proxy outside of the application, there's no limit to the language being used. And there's no modification needed to be done in the application code.</p> <p>Service Mesh which utilizes eBPF (right) has fewer resources used since duplicate copies of state configuration information within each pod are no longer needed. Also, there's no pod configuration to be modified. In addition, eBPF is aware of all activities carried out on that node, which can provide extra security.</p>"},{"location":"blog/20230830/20230830/#sauron-concept-and-architecture","title":"Sauron concept and architecture","text":"<p>The proposed eBPF platform, named Sauron, includes a Node Agent, a Controller to handle the Node Agents (NAs) deployed in the clusters, and three eBPF modules for observability, security, and networking use cases. There's no installation of any specific K8s plug-in needed.</p>"},{"location":"blog/20230830/20230830/#sauron-ebpf-module-for-transport","title":"Sauron eBPF module for transport","text":""},{"location":"blog/20230830/20230830/#ebpf-solutions-for-latency-calculation","title":"eBPF solutions for latency calculation","text":"<p>By leveraging the XDP hook, the programs can inspect or modify the content of the packets, but they can also decide whether to redirect or drop them. Moreover, through eBPF helpers, they can perform more advanced actions such as timestamping.</p> <p></p> <p>The eBPF program utilizes an XDP feature that allows it to redirect the synthetic packet through the same interface at which it was received. The program also adds a timestamp of each action (send or receive) to the packet payload. The packet will bounce between the receiving device and the original sender for a fixed number of times. After the final iteration, the original sender passes the packet to the Sauron Agent through the socket interface. The Sauron Agent then uses the collected timestamps to calculate both One-way and Two-way latency. Once the calculation is done, the data can be exported to a remote collector for processing and visualization.</p>"},{"location":"blog/20230830/20230830/#sauron-module-for-network-observability","title":"Sauron module for network observability","text":"<p>The Sauron Agent configures the necessary eBPF programs and collects the messages using a Ring buffer or throughout eBPF Maps. It also detects containers and pods of the 5GC network by querying the API server. The Agent can be configured to collect information from all parts of the network (radio access and core domains) with minimal overhead.</p>"},{"location":"blog/20230830/20230830/#sauron-ebpf-module-for-security","title":"Sauron eBPF module for security","text":"<p>eBPF Traffic Control Programs are used to implement network security. The primary job is to detect policy violations and enforce configured rules on unwanted traffic. Unwanted traffic could be:</p> <ol> <li>Traffic directed to or coming from entities that are not allowed to communicate with the object pod.</li> <li>Malicious traffic directed to or coming from sources that are allowed to communicate with the object pod but not authorized to perform certain tasks.</li> <li>Malicious traffic that insists on a disallowed communication path.</li> </ol> <p>eBPF tracepoints programs are attached to static markers defined by kernel developers in the kernel code. Tracepoints can be used to track events related to multiple subsystems, including sched, netlink, and system call (only syscall is shown in the graph). Static markers implementing the hook points guarantee the Application Binary Interface for tracepoints to be more stable than the one available for kprobes.</p> <p>Even though kprobes are not as effective or stable as tracepoints, they allow the implementation of an additional layer of defense. By tapping deeper into the system calls implementation, it is possible to solve the well-known Time-Of-Check Time-Of-Use vulnerability of tracepoints.</p> <p>eBPF Linux Security Module (LSM) programs also add an additional layer of security to the kernel. They can detect malicious behaviors and deny the access and permission directly in the kernel. By doing this, they provide faster response than tracepoint and kprobe programs.</p> <p>The agent in user space provides all rules for detecting malicious behavior to eBPF programs via eBPF maps. The eBPF programs in kernel space sent three kinds of data to the Agent: samples of normal events, suspicious events, and malicious events. Suspicious events will be classified in the agent. Then all collected data will be sent to a cluster-wide events collector, which can build an AI/ML model using the collected events to enforce rules in each agent or provide a plugin-based interface to a third-party system.</p>"},{"location":"blog/20230830/20230830/#ebpf-for-performance-monitoring-of-5g-protocols","title":"eBPF for performance monitoring of 5G protocols","text":""},{"location":"blog/20230830/20230830/#ngap-and-nas-performance-monitoring","title":"NGAP and NAS performance monitoring","text":"<p>NAS messages are encapsulated into NGAP messages and NGAP relies on the SCTP of the 5G transport network layer. To extract information from NGAP messages, we need to parse SCTP packets containing multiple data chunks that can be fragmented. Since XDP and TC hooks are at the packet level, they're not suitable for handling NGAP messages. To have direct access to messages, using tracepoint hooks is the way to go.</p> <p>Examples of NGAP and NAS metrics:</p> <ul> <li>NGAP Initial Context Setup Counters</li> <li>NGAP Setup Success Ratio</li> <li>NGAP Setup Time (ms)</li> <li>NGAP Procedure Duration (ms)</li> <li>NGAP Failed Procedures Cause Code</li> <li>PDU Session Establishment Attempts</li> </ul>"},{"location":"blog/20230830/20230830/#packet-capturing-and-forwarding","title":"Packet capturing and forwarding","text":"<ol> <li>A libpcap probe is installed on the interface.</li> <li>Packets pass through the BPF filter installed on the interface.</li> <li>Matching packets flow to the agent.</li> <li>The agent encodes incoming packets in PCAPNG format.</li> <li>Send them to the processing probe.</li> </ol>"},{"location":"blog/20230830/20230830/#ebpf-for-estimating-energy-consumption","title":"eBPF for estimating energy consumption","text":""},{"location":"blog/20230830/20230830/#conclusion","title":"Conclusion","text":"<p>Using eBPF is hard. The way of implementation also changes based on what version of kernel is used. There's no easy packaging solution. Developers need to be familiar with not only the eBPF library but also the kernel they're working with.</p> <p>Although the development of eBPF might be challenging, it can be used to provide great observability, security, and networking in a cloud-native environment. Allow developers to dynamically program the kernel in a safe, performant, and scalable way. By leveraging the benefit of low overhead monitoring and close-to-source data processing, eBPF will be handy for real-time monitoring 5GC, or even boost the performance of K8s deployments.</p>"},{"location":"blog/20230830/20230830/#about","title":"About","text":"<p>Poyi Lin</p> <ul> <li>Graduate student majoring in 5GC Research</li> </ul>"},{"location":"blog/20230830/20230830/#reference","title":"Reference","text":"<ul> <li>eBPF: A New Approach to Cloud-Native Observability, Networking and Security for Current (5G) and Future Mobile Networks (6G and Beyond)</li> </ul>"},{"location":"blog/20230906/0905-2023blog/","title":"The role of VNFD and NSD in 5G Network Slicing","text":"<p>Note</p> <p>Author: Leon Sawada(\u6fa4\u7530\u535a\u4e45) Date: 2023/09/05</p>"},{"location":"blog/20230906/0905-2023blog/#overview","title":"Overview","text":"<p>Before you read this blog article, I highly recommend you read this blog article first:  How to deploy a free5GC network slice on OpenStack. This blog article was written by my friend Daniel Hsieh, and in his article, he went through the entire process of how to deploy a free5GC network slice on OpenStack. He also introduced some architectures we need to know when we are deploying the free5GC network slice. However, there are still some details remaining, so in this blog article, I will explore more information and what role these components play in the overall experiment. Daniel used 8 steps to explain how to [deploy a free5GC Network Slice].In this article, I am going to focus on VNFD and NSD, which appear in steps No.5 and No.6, these two most important concepts while we are creating the network slice. By this article, you will understand more about the 5G network slicing.</p>"},{"location":"blog/20230906/0905-2023blog/#vnfd","title":"VNFD","text":"<p>VNFD, You may have seen this word a few times in Daniel\u2019s blog posts already, but what exactly is VNFD? Before I tell you the answer directly, there is something I want you to know first.</p> <p>We know that network slicing is a technology that allows network operators to divide physical network infrastructure into multiple customized virtual network slices, and each of the slices can meet specific requirements for specific use cases.  One of the most important functions of 5G network slicing is the virtual network function (VNF). VNF is a virtualized network service running on an open computing platform. In this free5GC network slicing experiment, the VNF in our experiment is our NF in free5GC, such as UPF, NSSF, UDM... etc. When you load all your VNFs into OpenStack, it should be like this:</p> <p></p> <p>So what is VNFD? What is the connection between it and VNF? VNFD's full name is Virtual Network Function Descriptor. A VNFD is a deployment template that describes a VNF in terms of deployment and operational behavior requirements. It also contains connectivity, interface, and virtualized resource requirements. The VNFD conforms to the GS NFV-SOL 001 specifications and standards specified by ETSI. The Virtual Network Function Descriptor (VNFD) file describes the instantiation parameters and operational behaviors of the VNFs. It contains KPIs and other key requirements that can be used in the process of onboarding and managing the lifecycle of a VNF. Each VNFD template has the following fields:</p> <p></p> <p>In the deployment of free5GC network slicing experiment, if you onboard all your VNFs successfully, then your VNFD should also be like this:</p> <p></p> <p>As you can see, every VNFD is matched with its represented VNF and its IP address, VNFD acts as a blueprint or template for VNF. Also be aware that The VNFD is a static description file, not a dynamic configuration file. The metadata description in the VNFD is not changed during the whole VNF lifecycle. Some VNF parameters described in the VNFD can be declared to be configurable during the VNF design phase, and further be configured by the VNFM during or after VNF instantiation.</p>"},{"location":"blog/20230906/0905-2023blog/#vnfd-architecture-and-details","title":"VNFD Architecture And Details","text":"<p>The UML representation of the VNFD high-level structure is shown in the figure below.</p> <p></p> <p>The ETSI released a specification that defines the requirements for the structure and format of a VNFD. As you can see, this graph illustrates the high\u2010level structure of a VNFD. The VNFD is composed of one or many virtual deployment units (VDUs) that describe the deployment resources and operation behavior of a VNF component (VNFC). Virtual Deployment Unit(VDU) is a basic part of VNF. It is the VM that hosts the network function. They are virtual machines that host the VNF or parts of it. Each part of the VNF is a VNFC and can be deployed on one or more VDUs. Each VDU is characterized, among other elements, by the software image loaded on it and the resources needed to deploy it. That is the flavor of Nova in OpenStack, which can set Disk, Memory, CPU, etc. An NS(Network Service) might contain different VNF. A VNF might also contain different VDU. Each level puts constraints on the subsequent levels, information in a lower level does not appear in a higher level. This is a complex and flexible architecture, very beautiful, very powerful.</p> <p>The following graph shows the composition of the virtual deployment unit in a VNFD:</p> <p></p> <p>This graph illustrates a VDU deployment view. A VDU describes mainly the virtual compute (VC), virtual storage (VS), and virtual memory (VM) resources that are necessary for deploying a VNFC, and it could be linked via connection points (CPD) to other VDUs or to external VDUs that belong to other VNFs via external CPD. Virtual links in the VNFD indicate how the VDUs are connected and via which CPD. This means that different VDUs can be connected to each other through the CPD. However, in free5GC network slicing, things might be different. For 5G's NS (network slice), since there are already many VNFs in 5G, under the 5G network slice architecture, an NS contains many VNFs, but a VNF always contains one and only VDU. We use AMF as an example, (AMF is an NF in free5GC) AMF is an important and complete function and we didn't break it into more pieces. Therefore, there are not many examples in our 5G of a VNF having many VDUs. Each VNF contains one VDU only, and the via connection points (CPD) function will no longer be used in 5G network slicing, although it is a powerful and convenient function.</p>"},{"location":"blog/20230906/0905-2023blog/#nsd","title":"NSD","text":"<p>NSD is a template file, whose parameters follow the ETSI MANO specification, used by the NFV Orchestrator (NFVO) for deploying network services (as a combination of multiple VNFs). Which consists of information used by the NFV Orchestrator (NFVO) for the life cycle management of an NS. Just like VNFD, NSD is also a static configuration file.</p> <p>An NS is a composition of Network Functions (NF) arranged as a set of functions with unspecified connectivity between them or according to one or more forwarding graphs. As the following figure shows, the description of an NS as used by the NFV Management and Orchestration (MANO) functions to deploy an NS instance includes or references the descriptors of its constituent objects:</p> <p></p> <p>As the specification mentioned in ETSI GS NFV-IFA 014 V3.3.1, an NSD references at least one VNFD or one nested NSD, just like this graph has shown. Here is an example code if today we want to instantiate VNF1 and VNF2 in the experiment.</p> <pre><code>tosca_definitions_version: tosca_simple_profile_for_nfv_1_0_0\nimports:\n  - VNFD1\n  - VNFD2\ntopology_template:\n  node_templates:\n    VNF1:\n      type: tosca.nodes.nfv.VNF1\n      requirements:\n        - virtualLink1: VL1\n        - virtualLink2: VL2\n    VNF2:\n      type: tosca.nodes.nfv.VNF2\n    VL1:\n      type: tosca.nodes.nfv.VL\n      properties:\n      network_name: net0\n      vendor: tacker\n    VL2:\n      type: tosca.nodes.nfv.VL\n      properties:\n          network_name: net_mgmt\n          vendor: tacker\n</code></pre> <p>In the above NSD template, VL1 and VL2 are substituting the virtual links of VNF1. If we want to apply the NFs we have in free5GC, just import these NFs into the VNF to which they belong.</p> <p>To onboard the above NSD:</p> <pre><code>tacker nsd-create \u2013nsd-file &lt;nsd file&gt; &lt;nsd name&gt;\n</code></pre> <p>This is also how we can use NSD to import all the VNFs we want to create network slices. It is very easy and convenient to create free5GC network slice that we want, the step was mentioned in Dainel's blog article.</p>"},{"location":"blog/20230906/0905-2023blog/#deployment-flavor","title":"Deployment flavor","text":"<p>Please go back to the VNFD high-level structure, On the right side we can see the DnfDf, which stands for VNF deployment flavor. Deployment flavor is a very important concept in NSD and VNFD, therefore it needs to be explained separately. Since VNFD and NSD are not dynamic configuration files but static configuration files. Even static configuration file has their own advantages, however, they are irreversible and lack of flexibility. To overcome this problem, we have a concept called deployment flavor. While we are using these static configuration files, we can have different deployment flavors, therefore when we are deploying these static configuration files, we can have different ways to deploy them. For example, when we deploy them, we use the 10 MB memory, and we use 100 MB memory to deploy another one. In this example, while we are deploying our deployment parameters are different, then we can define it into deployment flavor. Deployment flavor helps NSD and VNFD to increase their flexibility as a static configuration file. Make sure it's not 100% unchangeable. We can deploy different types of Deployment_Flavor that case needs, like Deployment_Flavor#2, Deployment_Flavor#3, and Deployment_Flavor#4. Therefore, we can deploy different NS and VNF for different specific needs. Add some deployment flexibility as much as possible under the limitation that they are static configuration files.</p> <p></p> <p>That's it, I hope this blog article can help you learn more about 5G network slicing, even if you go back and read this previous blog post How \u200b\u200bto deploy free5GC network slicing on OpenStack now, I think you will have a clearer idea of \u200b\u200bhow the whole experiment works. Learning the theory behind the scenes will always help you further your studies.</p>"},{"location":"blog/20230906/0905-2023blog/#reference","title":"Reference","text":"<p>https://docs.openstack.org/tacker/latest/contributor/vnfd_template_description.html</p> <p>https://docs.openstack.org/tacker/ocata/devref/nsd_usage_guide.html</p> <p>Atoui, Wassim &amp; Assy, Nour &amp; Gaaloul, Walid &amp; Grida Ben Yahia, Imen. (2020). Configurable Deployment Descriptor Model in NFV. Journal of Network and Systems Management. 28. 10.1007/s10922-020-09531-2.</p> <p>Automated Network Service Scaling in NFV: Concepts, Mechanisms and Scaling Workflow</p> <p>ETSI GS NFV-IFA 011 V2.4.1</p> <p>ETSI GS NFV-IFA 014 V3.3.1</p>"},{"location":"blog/20230906/0905-2023blog/#about","title":"About","text":"<p>Greetings everyone, my name is Leon Sawada, I am a 2nd-year master's student in NYCU Wireless Internet Research and Engineering (WIRE) Laboratory. My research field is network slicing, and I will be very grateful if this blog article helps you understand more about these components in network slicing. Best wishes.</p>"},{"location":"blog/20230913/20230913/","title":"CHarging Function(CHF) Overview","text":"<p>Note</p> <p>Author: Benson Hsu Date: 2023/9/13</p> <p>The <code>charging function</code> is a crucial component of the 5G core network responsible for tasks such as <code>traffic calculation and quota management</code>. For network providers and administrators, it is one of the most critical network elements. This article will explain the fundamental concepts and mechanisms of charging, as well as highlight the differences between 4G and 5G charging. Finally, we will include information about the CHF implementation developed by the free5GC team. </p>"},{"location":"blog/20230913/20230913/#charging-mechanisms","title":"Charging Mechanisms","text":"<p>The charging system can be divided into three main types: offline charging, online charging, and converged charging:</p> <ul> <li> <p>Offline Charging:</p> <ul> <li>After network resource usage, charging information is transmitted from the network to the Billing Domain (BD).</li> <li>The Billing Domain is responsible for performing cost calculations and data statistics.</li> </ul> </li> <li> <p>Online Charging:</p> <ul> <li>Before network resource usage, the network sends an authentication request to the Online Charging System (OCS).</li> <li>The OCS queries the subscriber's account information to determine whether the usage of these resources is allowed.</li> <li>After receiving authentication from the OCS, resource usage is monitored, and related account information is stored in the OCS.</li> </ul> </li> <li> <p>Converged Charging:</p> <ul> <li>Converged charging is a mechanism that combines both online and offline charging.</li> <li>For example, the CHF (Converged Charging Function) architecture in the 5G core system is an example of converged charging.</li> <li>In other service systems, if the charging system includes both offline and online charging functionalities, it can also be referred to as converged charging.</li> </ul> </li> </ul> <p>Typical triggers for charging related to network resource usage include:</p> <ul> <li>A voice call of a certain duration.</li> <li>The transport of a certain volume of data.</li> <li>The submission of a multimedia message (MM) of a certain size.</li> </ul> <p>Resource usage requests can be triggered by the UE  or by the core network. Furthermore, for the same chargeable event, both offline and online charging can occur simultaneously and independently.</p>"},{"location":"blog/20230913/20230913/#high-level-common-architecture","title":"High Level Common Architecture","text":"<p>The diagram below is from 3GPP TS32.240-V15.5.0, which illustrates the architectural differences among the three charging systems and indicates through which reference points data is transmitted for each Network Element (NE). </p>"},{"location":"blog/20230913/20230913/#offline-charging-function","title":"Offline Charging Function","text":"<p>The Offline Charging Function primarily consists of three components: CTF (Charging Trigger Function), CDF (Charging Data Function), and CGF (Charging Gateway Function). Here's an overview of the roles of each function and how data flows between them:</p> <ol> <li>CTF (Charging Trigger Function):</li> <li>Role: CTF is responsible for generating charging events by observing network resource usage.</li> <li>Data Flow: It collects information about trigger conditions, information elements to be collected, and which service events, signaling, or user traffic to monitor.</li> <li> <p>Data Transfer: CTF forwards generated charging events to CDF.</p> </li> <li> <p>CDF (Charging Data Function):</p> </li> <li>Role: CDF receives charging events from CTF and processes them.</li> <li>Data Flow: It processes and stores charging data, potentially performing reformatting to comply with specific formats.</li> <li> <p>Data Transfer: CDF sends the processed Charging Data Records (CDRs) to CGF.</p> </li> <li> <p>CGF (Charging Gateway Function):</p> </li> <li>Role: CGF is responsible for persistent CDR storage, preparing CDR files, and transferring them to the Billing Domain (BD).</li> <li>Data Flow: It provides storage for CDRs and manages the routing of CDR files.</li> <li>Data Transfer: CGF transfers CDR files to the Billing Domain via the Bx reference point.</li> </ol> <p>These functions work together to collect, process, and store charging data in the offline charging system.</p>"},{"location":"blog/20230913/20230913/#online-charging-functionsocf","title":"Online Charging Functions(OCF)","text":"<p> The Online Charging Function primarily consists of four components: CTF (Charging Trigger Function), OCF (Online Charging Function), ABMF (Account Balance Management Function), and RF (Rating Function). Here's an overview of the roles of each function and how data flows between them:</p> <p>1. CTF (Charging Trigger Function):    * Role: CTF observes network resource usage to generate charging events.    * Data Flow: It collects information about trigger conditions, information elements to be collected, and the monitoring of service events, signaling, or user traffic.    * Data Transfer: CTF forwards generated charging events to the OCF.</p> <p>2. OCF (Online Charging Function):    * Role: OCF is responsible for real-time charging and authorization of resource usage.    * Data Flow: It evaluates charging events, determines the value of requested resource usage, and authorizes it.    * Data Transfer: OCF sends authorization information to the network element, which then executes the resource usage.</p> <p>3. ABMF (Account Balance Management Function):    * Role: ABMF manages subscriber account balances and credit control.    * Data Flow: It keeps track of subscriber account balances and interacts with OCF for authorization and debiting.    * Data Transfer: ABMF communicates with OCF to manage subscriber balances during resource usage.</p> <p>4. RF (Rating Function):    * Role: RF determines the value or amount of actual network resource usage for OCF (according to OCF from charging event)    * Data Flow: The OCF provides the RF with essential data extracted from the charging event. Then RF returns the rating results, which can be in the form of monetary or non-monetary units.    * Data Transfer: OCF send charging event to RF, and RF return rating results in specific unit</p> <p>These functions collaborate to enable real-time online charging, authorization, and account management for subscribers in the online charging system.</p>"},{"location":"blog/20230913/20230913/#converged-charging-functions","title":"Converged Charging Functions","text":"<p> The Converged Charging Functions consist of various components, each with specific roles and data flow within the system. Here's an overview of the roles of each function and how data flows between them:</p> <p>1. CTF (Charging Trigger Function):    * Role: CTF is mostly integrated into network functions like PCF, SMSF, and SMF. These network functions monitor charging information and transform it into charging events, which are then forwarded to the CHF for further processing.    * Data Flow: It collects information on trigger conditions, information elements to be captured, and monitors service events, signaling, or user traffic.    * Data Transfer: The CTF forwards the generated charging events to the CHF via an SBI (Service-Based Interface) located within the core network's control plane.</p> <p>2. CHF (CHarging Function):    * Role: CHF is responsible for facilitating communication among all functions within the Converged Charging System(CCS). Its role includes receiving charging events and generating CDRs (Charging Data Records). Importantly, it can simultaneously handle both online and offline charging functions.    * Data Flow: It evaluates charging events, determines the value of requested resource usage, authorizes it, and manages subscriber account balances.    * Data Transfer: CHF and its associated functions engage in data exchanges involving various types of information. These data exchanges include charging events, user count balances, CDRs (Charging Data Records), and rating information.</p> <p>The remaining functions mentioned earlier in the descriptions of offline and online charging serve the same purposes and functions, so we won't go into further detail here.</p>"},{"location":"blog/20230913/20230913/#the-differences-between-4g-and-5g-charging","title":"The Differences between 4G and 5G Charging","text":"<p>In the 4G era, various concepts and functions for online and offline charging were already established. When defining the 5G standards, it was recognized that there was a need to support various charging methods. Therefore, a new function called CHF (Charging Function) was introduced, and other functions such as ABMF, CGF, and RF from different systems were integrated into the Converged Charging System. This addition expanded the capabilities of 5G Core (5GC) charging.</p> <p></p> <p>The differences between 4G and 5G charging can be summarized as follows:</p> <p>1. Network Architecture:    * 4G: In 4G networks, charging functions are typically less integrated and may involve multiple separate components.    * 5G: 5G introduces a more integrated and converged charging system where various charging functions are unified within the Converged Charging System (CHF), allowing for more flexibility and efficiency.</p> <p>2. Charging Flexibility:    * 4G: 4G networks may have limitations in terms of charging flexibility, especially when it comes to handling different charging scenarios and services.    * 5G: 5G charging is designed to be more versatile and adaptable, capable of handling various charging models, both online and offline, for a wide range of services and use cases.</p> <p>3. Service Support:    * 4G: 4G charging systems are primarily designed for traditional mobile services like voice and data.    * 5G: 5G charging systems are built to support a broader range of services, including enhanced mobile broadband (eMBB), massive machine-type communications (mMTC), and ultra-reliable low-latency communications (URLLC), making them more suitable for diverse 5G applications.</p> <p>4. Convergence:    * 4G: Converged charging in 4G networks is often limited, and different charging models may not be as seamlessly integrated.    * 5G: 5G emphasizes the convergence of charging functions, allowing for greater consistency and interoperability across various charging scenarios and services.</p> <p>5. Charging Efficiency:    * 4G: Charging efficiency in 4G networks may vary depending on the specific implementation and the level of integration between charging components.    * 5G: 5G charging systems aim to improve efficiency by streamlining charging processes and reducing redundancy, thanks to the unified CHF.</p> <p>Overall, the key difference between 4G and 5G charging lies in the level of integration, flexibility, and support for a broader range of services and use cases in 5G networks. The introduction of the CHF in 5G brings greater convergence and efficiency to charging operations.</p>"},{"location":"blog/20230913/20230913/#chf-implementation","title":"CHF Implementation","text":"<p>Hello everyone, we are the free5gc development team. We have recently added CHF (Charging Function) to enhance the functionality of 5G Core (5GC). We invite anyone interested in CHF to check out how we have implemented the charging function. Below is the relevant link, and thank you for your interest.</p> <p></p> <ul> <li>Ref: https://github.com/free5gc/chf</li> </ul>"},{"location":"blog/20230913/20230913/#reference","title":"Reference","text":"<ul> <li>3GPP TS32.240 v15 spec(offline)</li> <li>3GPP TS32.240 v15 spec(online)</li> <li>https://devopedia.org/5g-service-based-architecture</li> <li>https://free5gc.org/</li> </ul>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/","title":"Introduction of gtp5g and some kernel concepts","text":"<p>Note</p> <p>Author: Jimmy Date: 2023/9/20</p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#overview","title":"Overview","text":"<p>GTP (General Packet Radio System Tunneling Protocol) is a group of IP-based communication protocols used to transport General Packet Radio Services (GPRS) within LTE, 5G NR, and other networks. GTP can be broken down into several components: GTP-C, GTP-U, and GTP prime. GTP-C and GTP-U are responsible for the control plane and user plane, respectively, while GTP prime is utilized for transmitting charging data through the Ga interface as defined in the 3GPP GPRS Core Network.</p> <p>In the context of free5GC, the UPF network function combines the GTP-C control part to correctly instruct the routing path for any packet passing through the core network. GTP-U, on the other hand, is managed by gtp5g, which transports packets using kernel modules generated by gtp5g. This article will introduce how gtp5g assists free5GC in handling packets and some kernel-related concepts.</p> <p>Let's start the journey!</p> <p>Additional information:</p> <ul> <li>Linux kernel version is 5.4.0-159-generic in article. According to other versions, some of content would be different, but the main concept is the same.</li> <li>Gtp5g version is v0.8.2</li> <li>UPF version is v1.2.0</li> </ul>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#netlink-generic-netlink-and-rtnetlink","title":"Netlink, Generic Netlink and Rtnetlink","text":""},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#netlink","title":"Netlink","text":"<p>Before we continue, I need to introduce Netlink first. What is Netlink? Netlink is an IPC (Inter Process Communication) protocol which can connect kernel space and user space processes by socket.  Traditionally, it used three methods: Ioctl, sysfs, or procfs, to facilitate communication between the kernel and user space. However, it can only be initiated from user space, not from kernel space. Netlink can support not only initiated from kernel and user space but also:</p> <ul> <li>Bidirectional transmission, asynchronous communication.</li> <li>Standard socket API used in user space.</li> <li>Specialized API used in kernel space.</li> <li>Support for multicast.</li> <li>Support for 32 protocol types.</li> </ul> <p>There are servel usages define in include/uapi/linux/netlink.h <pre><code>#define NETLINK_ROUTE       0   /* Routing/device hook              */\n#define NETLINK_UNUSED      1   /* Unused number                */\n#define NETLINK_USERSOCK    2   /* Reserved for user mode socket protocols  */\n#define NETLINK_FIREWALL    3   /* Unused number, formerly ip_queue     */\n#define NETLINK_SOCK_DIAG   4   /* socket monitoring                */\n#define NETLINK_NFLOG       5   /* netfilter/iptables ULOG */\n#define NETLINK_XFRM        6   /* ipsec */\n#define NETLINK_SELINUX     7   /* SELinux event notifications */\n#define NETLINK_ISCSI       8   /* Open-iSCSI */\n#define NETLINK_AUDIT       9   /* auditing */\n#define NETLINK_FIB_LOOKUP  10\n#define NETLINK_CONNECTOR   11\n#define NETLINK_NETFILTER   12  /* netfilter subsystem */\n#define NETLINK_IP6_FW      13\n#define NETLINK_DNRTMSG     14  /* DECnet routing messages */\n#define NETLINK_KOBJECT_UEVENT  15  /* Kernel messages to userspace */\n#define NETLINK_GENERIC     16\n/* leave room for NETLINK_DM (DM Events) */\n#define NETLINK_SCSITRANSPORT   18  /* SCSI Transports */\n#define NETLINK_ECRYPTFS    19\n#define NETLINK_RDMA        20\n#define NETLINK_CRYPTO      21  /* Crypto layer */\n#define NETLINK_SMC     22  /* SMC monitoring */\n\n#define NETLINK_INET_DIAG   NETLINK_SOCK_DIAG\n\n#define MAX_LINKS 32\n</code></pre></p> <p>These are Linux system pre-defined Netlink protocols. Therefore, if users want to define their own Netlink protocol, they would need to modify the Linux kernel files to meet their requirements. However, the kernel must be protected from modification. Additionally, the maximum protocol number allowed is 32, can't exceed it.</p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#generic-netlink","title":"Generic Netlink","text":"<p>Due to the shortage of protocol numbers and the need to prevent kernel modification, kernel developers extended Netlink and introduced Generic Netlink. Generic Netlink supports 1023 protocols, addressing the protocol number limitation, and it allocates protocol IDs automatically.</p> <p>The following figure is Generic Netlink structure:</p> <pre><code>graph TD\nA1[Application_1] --- B[Kernel_Socket_API]\nA2[Application_2] --- B[Kernel_Socket_API]\n\nB[Kernel_Socket_API] --- C[Netlink_Subsystem]\nB[Kernel_Socket_API] --- C[Netlink_Subsystem]\n\nC[Netlink_Subsystem] --- D[Generic_Netlink_Bus]\n\nD[Generic_Netlink_Bus] --- E1[Controller]\nD[Generic_Netlink_Bus] --- E2[Kernel_User_1]\nD[Generic_Netlink_Bus] --- E3[Kernel_User_2]\n\n</code></pre> <ul> <li>The Generic Netlink users application_1 and application_2 could communicate both user space and kernel space endpoint through Kernel_socket_API.</li> <li>The Netlink subsystem which serves as the underlying transport layer for all of the Generic Netlink communications.</li> <li>The Generic Netlink bus which is implemented inside the kernel, but which is available to userspace through the socket API and inside the kernel via the normal Netlink and Generic Netlink APIs.</li> <li>The Generic Netlink users who communicate with each other over the Generic Netlink bus; users can exist both in kernel and user space.</li> <li>The Generic Netlink controller which is part of the kernel and is responsible for dynamically allocating Generic Netlink communication channels and other management tasks. The Generic Netlink controller is implemented as a standard Generic Netlink kernel user, however, it listens on a special, pre-allocated Generic Netlink channel.</li> <li>The kernel socket API. Generic Netlink sockets are created with the PF_NETLINK domain and the NETLINK_GENERIC protocol values.</li> </ul>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#rtnetlink","title":"RtNetlink","text":"<p>The last one is rtnetlink, it also known as Netlink protocol type NETLINK_ROUTE, user space program could read and alter kernel's routing table or create new network device.</p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#free5gc-upf","title":"free5GC UPF","text":"<p>Since gtp5g is part of UPF logically, article also covers part of UPF.</p> <p>The Driver provides functions to communicate with gtp5g (the functions are one-to-one match to gtp5g_genl_ops[] in genl.c). So, when UPF receives a PFCP message, it parses the content and then uses various functions of the Driver to instruct gtp5g to take regarding rules. <pre><code>// internel/forwarder/driver.go\ntype Driver interface {\n    Close()\n\n    CreatePDR(uint64, *ie.IE) error\n    UpdatePDR(uint64, *ie.IE) error\n    RemovePDR(uint64, *ie.IE) error\n\n    CreateFAR(uint64, *ie.IE) error\n    UpdateFAR(uint64, *ie.IE) error\n    RemoveFAR(uint64, *ie.IE) error\n\n    CreateQER(uint64, *ie.IE) error\n    UpdateQER(uint64, *ie.IE) error\n    RemoveQER(uint64, *ie.IE) error\n\n    CreateURR(uint64, *ie.IE) error\n    UpdateURR(uint64, *ie.IE) ([]report.USAReport, error)\n    RemoveURR(uint64, *ie.IE) ([]report.USAReport, error)\n    QueryURR(uint64, uint32) ([]report.USAReport, error)\n\n    CreateBAR(uint64, *ie.IE) error\n    UpdateBAR(uint64, *ie.IE) error\n    RemoveBAR(uint64, *ie.IE) error\n\n    HandleReport(report.Handler)\n}\n</code></pre></p> <p>UPF use rtnl to create device (interface) named <code>upfgtp</code>. User can observe it while executing run.sh. <pre><code>func OpenGtp5gLink(mux *nl.Mux, addr string, mtu uint32, log *logrus.Entry) (*Gtp5gLink, error) {\n    g := &amp;Gtp5gLink{\n        log: log,\n    }\n\n    g.mux = mux\n\n    rtconn, err := nl.Open(syscall.NETLINK_ROUTE)\n    if err != nil {\n        return nil, errors.Wrap(err, \"open\")\n    }\n    g.rtconn = rtconn\n    g.client = nl.NewClient(rtconn, mux)\n\n    laddr, err := net.ResolveUDPAddr(\"udp4\", addr)\n    if err != nil {\n        g.Close()\n        return nil, errors.Wrap(err, \"resolve addr\")\n    }\n    conn, err := net.ListenUDP(\"udp4\", laddr)\n    if err != nil {\n        g.Close()\n        return nil, errors.Wrap(err, \"listen\")\n    }\n    g.conn = conn\n\n    // TODO: Duplicate fd\n    f, err := conn.File()\n    if err != nil {\n        g.Close()\n        return nil, errors.Wrap(err, \"file\")\n    }\n    g.f = f\n\n    linkinfo := &amp;nl.Attr{\n        Type: syscall.IFLA_LINKINFO,\n        Value: nl.AttrList{\n            {\n                Type:  rtnllink.IFLA_INFO_KIND,\n                Value: nl.AttrString(\"gtp5g\"),\n            },\n            {\n                Type: rtnllink.IFLA_INFO_DATA,\n                Value: nl.AttrList{\n                    {\n                        Type:  gtp5gnl.IFLA_FD1,\n                        Value: nl.AttrU32(f.Fd()),\n                    },\n                    {\n                        Type:  gtp5gnl.IFLA_HASHSIZE,\n                        Value: nl.AttrU32(131072),\n                    },\n                },\n            },\n        },\n    }\n    attrs := []*nl.Attr{linkinfo}\n\n    if mtu != 0 {\n        attrs = append(attrs, &amp;nl.Attr{\n            Type:  syscall.IFLA_MTU,\n            Value: nl.AttrU32(mtu),\n        })\n    }\n\n    err = rtnllink.Create(g.client, \"upfgtp\", attrs...)\n    if err != nil {\n        g.Close()\n        return nil, errors.Wrap(err, \"create\")\n    }\n    err = rtnllink.Up(g.client, \"upfgtp\")\n    if err != nil {\n        g.Close()\n        return nil, errors.Wrap(err, \"up\")\n    }\n    link, err := gtp5gnl.GetLink(\"upfgtp\")\n    if err != nil {\n        g.Close()\n        return nil, errors.Wrap(err, \"get link\")\n    }\n    g.link = link\n    return g, nil\n}\n</code></pre></p> <p>Connect UPF Driver functions and <code>gtp5g_genl_ops</code>. <pre><code>// internl/forwarder/buffnetlink/server.go\nfunc OpenServer(wg *sync.WaitGroup, client *nl.Client, mux *nl.Mux) (*Server, error) {\n    s := &amp;Server{\n        client: client,\n        mux:    mux,\n    }\n\n    f, err := genl.GetFamily(s.client, \"gtp5g\")\n    if err != nil {\n        return nil, errors.Wrap(err, \"get family\")\n    }\n\n    s.conn, err = nl.Open(syscall.NETLINK_GENERIC, int(f.Groups[gtp5gnl.GENL_MCGRP].ID))\n    if err != nil {\n        return nil, errors.Wrap(err, \"open netlink\")\n    }\n\n    err = s.mux.PushHandler(s.conn, s)\n    if err != nil {\n        return nil, errors.Wrap(err, \"push handler\")\n    }\n\n    logger.BuffLog.Infof(\"buff netlink server started\")\n\n    // wg.Add(1)\n    return s, nil\n}\n</code></pre></p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#gtp5g","title":"GTP5G","text":"<ul> <li>Gtp5g utilizes a Linux kernel module to manage packet traffic. A Linux kernel module can be thought of as a small piece of code that is inserted into the Linux kernel, allowing users to customize the program according to the current hardware device</li> <li>In gtp5g, the primary function is gtp5g_init in gtp5g.c; it exposes most of the components and techniques provided by gtp5g. This article will choose the following concepts to investigate further:</li> <li>Network device -&gt; <code>net_device_ops</code></li> <li>Rtnetlink -&gt; <code>gtp5g_link_ops</code></li> <li>Generic Netlink -&gt; <code>gtp5g_genl_family</code></li> <li>Additionally, the article will present two functions in detail:</li> <li><code>rtnl_link_register()</code></li> <li><code>genl_register_family()</code></li> </ul> <pre><code>// src/gtp5g.c\nstatic int __init gtp5g_init(void)\n{\n    int err;\n\n    GTP5G_LOG(NULL, \"Gtp5g Module initialization Ver: %s\\n\", DRV_VERSION);\n\n    init_proc_gtp5g_dev_list();\n\n    // set hash initial value\n    get_random_bytes(&amp;gtp5g_h_initval, sizeof(gtp5g_h_initval));\n\n    err = rtnl_link_register(&amp;gtp5g_link_ops);\n    if (err &lt; 0) {\n        GTP5G_ERR(NULL, \"Failed to register rtnl\\n\");\n        goto error_out;\n    }\n\n    err = genl_register_family(&amp;gtp5g_genl_family);\n    if (err &lt; 0) {\n        GTP5G_ERR(NULL, \"Failed to register generic\\n\");\n        goto unreg_rtnl_link;\n    }\n\n    err = register_pernet_subsys(&amp;gtp5g_net_ops);\n    if (err &lt; 0) {\n        GTP5G_ERR(NULL, \"Failed to register namespace\\n\");\n        goto unreg_genl_family;\n    }\n\n    err = create_proc();\n    if (err &lt; 0) {\n        goto unreg_pernet;\n    }\n    GTP5G_LOG(NULL, \"5G GTP module loaded\\n\");\n\n    return 0;\n    ...\n}\n</code></pre>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#net_device_ops","title":"<code>net_device_ops</code>","text":"<p>It is defined in dev.h and referenced in dev.c. The structure net_device_ops encompasses all operations related to network device, and free5GC inherits some of these operations to implement self-made netdev ops. <pre><code>// include/dev.h\nextern const struct net_device_ops gtp5g_netdev_ops;\n</code></pre></p> <p><pre><code>// src/gtpu/dev.c\nconst struct net_device_ops gtp5g_netdev_ops = {\n    .ndo_init           = gtp5g_dev_init,\n    .ndo_uninit         = gtp5g_dev_uninit,\n    .ndo_start_xmit     = gtp5g_dev_xmit,\n#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 11, 0)\n    .ndo_get_stats64    = dev_get_tstats64,\n#else\n    .ndo_get_stats64    = ip_tunnel_get_stats64,\n#endif\n};\n</code></pre> According to /include/linux/netdevice.h, you can find the definition of hooks of net_device_ops:</p> <ul> <li><code>.ndo_init</code>: This function is called once when a network device is registered. The network device can use this for any late stage initialization or semantic validation. It can fail with an error code which will be propagated back to register_netdev.</li> <li><code>.ndo_uninit</code>: This function is called when device is unregistered or when registration fails. It is not called if init fails.</li> <li><code>.ndo_start_xmit</code>: Called when a packet needs to be transmitted. Returns NETDEV_TX_OK. Can return NETDEV_TX_BUSY, but you should stop the queue before that can happen; it's for obsolete devices and weird corner cases, but the stack really does a non-trivial amount of useless work if you return NETDEV_TX_BUSY. Required; cannot be NULL. <pre><code>struct net_device_ops {\n  int           (*ndo_init)(struct net_device *dev);\n  void          (*ndo_uninit)(struct net_device *dev);\n  netdev_tx_t       (*ndo_start_xmit)(struct sk_buff *skb,\n                      struct net_device *dev);\n...\n}\n</code></pre> Gtp5g self-made structure: <pre><code>// include/dev.h\nstruct gtp5g_dev {\n    struct list_head list;\n    struct sock *sk1u; // UDP socket from user space\n    struct net_device *dev;\n    unsigned int role;\n    unsigned int hash_size;\n    struct hlist_head *pdr_id_hash;\n    struct hlist_head *far_id_hash;\n    struct hlist_head *qer_id_hash;\n    struct hlist_head *bar_id_hash;\n    struct hlist_head *urr_id_hash;\n\n    struct hlist_head *i_teid_hash; // Used for GTP-U packet detect\n    struct hlist_head *addr_hash;   // Used for IPv4 packet detect\n\n    /* IEs list related to PDR */\n    struct hlist_head *related_far_hash; // PDR list waiting the FAR to handle\n    struct hlist_head *related_qer_hash; // PDR list waiting the QER to handle\n    struct hlist_head *related_bar_hash;\n    struct hlist_head *related_urr_hash;\n\n    /* Used by proc interface */\n    struct list_head proc_list;\n};\n</code></pre></li> </ul> <p>It would find the private data address in network device by netdev_priv() and allocate the device statistics space for each CPU by netdev_alloc_pcpu_stats(): <pre><code>// src/gtpu/dev.c\nstatic int gtp5g_dev_init(struct net_device *dev)\n{\n    struct gtp5g_dev *gtp = netdev_priv(dev);\n\n    gtp-&gt;dev = dev;\n\n    dev-&gt;tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n    if (!dev-&gt;tstats) {\n        return -ENOMEM;\n    }\n\n    return 0;\n}\n</code></pre></p> <p>From /include/linux/netdevice.h, the return value would be times of 32: <pre><code>static inline void *netdev_priv(const struct net_device *dev)\n{\n    return (char *)dev + ALIGN(sizeof(struct net_device), NETDEV_ALIGN);\n}\n</code></pre></p> <p>Close the udp socket (sk1u) is used to receive uplink (N3) packet: <pre><code>// src/gtpu/dev.c\nstatic void gtp5g_dev_uninit(struct net_device *dev)\n{\n    struct gtp5g_dev *gtp = netdev_priv(dev);\n\n    gtp5g_encap_disable(gtp-&gt;sk1u);\n    free_percpu(dev-&gt;tstats);\n}\n</code></pre></p> <p>Utilized for the reception of downlink (N6) packets by a network device: <pre><code>// src/gtpu/dev.c\nstatic netdev_tx_t gtp5g_dev_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n    unsigned int proto = ntohs(skb-&gt;protocol);\n    struct gtp5g_pktinfo pktinfo;\n    int ret = 0;\n\n    /* Ensure there is sufficient headroom */\n    if (skb_cow_head(skb, dev-&gt;needed_headroom)) {\n        goto tx_err;\n    }\n\n    skb_reset_inner_headers(skb);\n\n    /* PDR lookups in gtp5g_build_skb_*() need rcu read-side lock.\n     * */\n    rcu_read_lock();\n    switch (proto) {\n    case ETH_P_IP:\n        ret = gtp5g_handle_skb_ipv4(skb, dev, &amp;pktinfo);\n        break;\n    default:\n        ret = -EOPNOTSUPP;\n    }\n    rcu_read_unlock();\n\n    if (ret &lt; 0)\n        goto tx_err;\n\n    if (ret == FAR_ACTION_FORW)\n        gtp5g_xmit_skb_ipv4(skb, &amp;pktinfo);\n\n    return NETDEV_TX_OK;\n    ...\n}\n</code></pre></p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#gtp5g_link_ops","title":"<code>gtp5g_link_ops</code>","text":"<p>Ignore headder file here, structure defines Rtnetlink operations.</p> <pre><code>// src/gtpu/link.c\nstruct rtnl_link_ops gtp5g_link_ops __read_mostly = {\n    .kind         = \"gtp5g\",\n    .maxtype      = IFLA_GTP5G_MAX,\n    .policy       = gtp5g_policy,\n    .priv_size    = sizeof(struct gtp5g_dev),\n    .setup        = gtp5g_link_setup,\n    .validate     = gtp5g_validate,\n    .newlink      = gtp5g_newlink,\n    .dellink      = gtp5g_dellink,\n    .get_size     = gtp5g_get_size,\n    .fill_info    = gtp5g_fill_info,\n};\n</code></pre> <p>Definition is in /include/net/rtnetlink.h: - <code>.kind</code>: Identifier - <code>.maxtype</code>: Highest device specific netlink attribute number - <code>.policy</code>: Netlink policy for device specific attribute validation - <code>.priv_size</code>: sizeof net_device private space - <code>.setup</code>: net_device setup function - <code>.validate</code>: Optional validation function for netlink/changelink parameters - <code>.newlink</code>: Function for configuring and registering a new device - <code>.dellink</code>: Function to remove a device - <code>.get_size</code>: Function to calculate required room for dumping device specific netlink attributes - <code>.fill_info</code>: Function to dump device specific netlink attributes</p> <pre><code>struct rtnl_link_ops {\n    struct list_head    list;\n\n    const char      *kind;\n\n    size_t          priv_size;\n    void            (*setup)(struct net_device *dev);\n\n    unsigned int        maxtype;\n    const struct nla_policy *policy;\n    int         (*validate)(struct nlattr *tb[],\n                        struct nlattr *data[],\n                        struct netlink_ext_ack *extack);\n\n    int         (*newlink)(struct net *src_net,\n                       struct net_device *dev,\n                       struct nlattr *tb[],\n                       struct nlattr *data[],\n                       struct netlink_ext_ack *extack);\n    int         (*changelink)(struct net_device *dev,\n                          struct nlattr *tb[],\n                          struct nlattr *data[],\n                          struct netlink_ext_ack *extack);\n    void            (*dellink)(struct net_device *dev,\n                       struct list_head *head);\n\n    size_t          (*get_size)(const struct net_device *dev);\n    int         (*fill_info)(struct sk_buff *skb,\n                         const struct net_device *dev);\n\n    size_t          (*get_xstats_size)(const struct net_device *dev);\n    int         (*fill_xstats)(struct sk_buff *skb,\n                           const struct net_device *dev);\n    unsigned int        (*get_num_tx_queues)(void);\n    unsigned int        (*get_num_rx_queues)(void);\n\n    unsigned int        slave_maxtype;\n    const struct nla_policy *slave_policy;\n    int         (*slave_changelink)(struct net_device *dev,\n                            struct net_device *slave_dev,\n                            struct nlattr *tb[],\n                            struct nlattr *data[],\n                            struct netlink_ext_ack *extack);\n    size_t          (*get_slave_size)(const struct net_device *dev,\n                          const struct net_device *slave_dev);\n    int         (*fill_slave_info)(struct sk_buff *skb,\n                           const struct net_device *dev,\n                           const struct net_device *slave_dev);\n    struct net      *(*get_link_net)(const struct net_device *dev);\n    size_t          (*get_linkxstats_size)(const struct net_device *dev,\n                               int attr);\n    int         (*fill_linkxstats)(struct sk_buff *skb,\n                           const struct net_device *dev,\n                           int *prividx, int attr);\n};\n</code></pre> <p>Once rtnl link setting up, gtp5g would assign net_device_ops to device. <pre><code>static void gtp5g_link_setup(struct net_device *dev)\n{\n    dev-&gt;netdev_ops = &amp;gtp5g_netdev_ops;   &lt;---- network device assignment\n    dev-&gt;needs_free_netdev = true;\n\n    dev-&gt;hard_header_len = 0;\n    dev-&gt;addr_len = 0;\n    dev-&gt;mtu = ETH_DATA_LEN -\n        (sizeof(struct iphdr) +\n         sizeof(struct udphdr) +\n         sizeof(struct gtpv1_hdr));\n\n    /* Zero header length. */\n    dev-&gt;type = ARPHRD_NONE;\n    dev-&gt;flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\n    dev-&gt;priv_flags |= IFF_NO_QUEUE;\n    dev-&gt;features |= NETIF_F_LLTX;\n    netif_keep_dst(dev);\n\n    /* TODO: Modify the headroom size based on\n     * what are the extension header going to support\n     * */\n    dev-&gt;needed_headroom = LL_MAX_HEADER +\n        sizeof(struct iphdr) +\n        sizeof(struct udphdr) +\n        sizeof(struct gtpv1_hdr);\n}\n</code></pre></p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#rtnl_link_register","title":"<code>rtnl_link_register()</code>","text":"<ul> <li>Definition is in /net/core/rtnetlink.c</li> <li>This function should be used by drivers that create devices during module initialization. It must be called before registering the devices</li> <li>Using the kind property of rtnl_link_ops to search for the existence of ops in link_ops. If ops do not exist, then inserted it at the end of link_ops</li> <li>Once register sucess, UPF can create new network device (interface) using Rtnetlink socket <pre><code>int __rtnl_link_register(struct rtnl_link_ops *ops)\n{\n    if (rtnl_link_ops_get(ops-&gt;kind))\n        return -EEXIST;\n\n    /* The check for setup is here because if ops\n     * does not have that filled up, it is not possible\n     * to use the ops for creating device. So do not\n     * fill up dellink as well. That disables rtnl_dellink.\n     */\n    if (ops-&gt;setup &amp;&amp; !ops-&gt;dellink)\n        ops-&gt;dellink = unregister_netdevice_queue;\n\n    list_add_tail(&amp;ops-&gt;list, &amp;link_ops);\n    return 0;\n}\nEXPORT_SYMBOL_GPL(__rtnl_link_register);\n</code></pre></li> </ul>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#gtp5g_genl_family","title":"gtp5g_genl_family","text":"<p>Gtp5g defines the genl (Generic Netlink) interface to facilitate communication between user and kernel space after register 'family'. As mentioned earlier, there is a Generic Netlink Controller responsible for bus allocation and dynamically assigns tunnel based on genl family id (name).</p> <p><pre><code>// src/genl/genl.c\nstruct genl_family gtp5g_genl_family __ro_after_init = {\n    .name       = \"gtp5g\",\n    .version    = 0,\n    .hdrsize    = 0,\n    .maxattr    = GTP5G_ATTR_MAX,\n    .netnsok    = true,\n    .module     = THIS_MODULE,\n    .ops        = gtp5g_genl_ops,\n    .n_ops      = ARRAY_SIZE(gtp5g_genl_ops),\n    .mcgrps     = gtp5g_genl_mcgrps,\n    .n_mcgrps   = ARRAY_SIZE(gtp5g_genl_mcgrps),\n};\n</code></pre> Definition is in /include/net/genetlink.h: - <code>.name</code>: name of family (exclusive) - <code>.version</code>: protocol version (usually is 1) - <code>.hdrsize</code>: length of user specific header in bytes - <code>.maxattr</code>: maximum number of attributes supported - <code>.netnsok</code>: set to true if the family can handle network namespaces and should be presented in all of them - <code>.ops</code>: the operations supported by this family - <code>.n_ops</code>: number of operations supported by this family - <code>.mcgrps</code>: multicast groups used by this family - <code>.n_mcgrps</code>: number of multicast groups</p> <pre><code>struct genl_family {\n    int         id;     /* private */\n    unsigned int        hdrsize;\n    char            name[GENL_NAMSIZ];\n    unsigned int        version;\n    unsigned int        maxattr;\n    bool            netnsok;\n    bool            parallel_ops;\n    const struct nla_policy *policy;\n    int         (*pre_doit)(const struct genl_ops *ops,\n                        struct sk_buff *skb,\n                        struct genl_info *info);\n    void            (*post_doit)(const struct genl_ops *ops,\n                         struct sk_buff *skb,\n                         struct genl_info *info);\n    struct nlattr **    attrbuf;    /* private */\n    const struct genl_ops * ops;\n    const struct genl_multicast_group *mcgrps;\n    unsigned int        n_ops;\n    unsigned int        n_mcgrps;\n    unsigned int        mcgrp_offset;   /* private */\n    struct module       *module;\n};\n</code></pre> <p>Gtp5g defines <code>gtp5g_genl_ops</code>, all operations are one-to-one match to Driver functions in UPF part: <pre><code>// src/genl/genl.c\nstatic const struct genl_ops gtp5g_genl_ops[] = {\n    {\n        .cmd = GTP5G_CMD_ADD_PDR,\n        // .validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n        .doit = gtp5g_genl_add_pdr,\n        // .policy = gtp5g_genl_pdr_policy,\n        .flags = GENL_ADMIN_PERM,\n    },\n    {\n        .cmd = GTP5G_CMD_DEL_PDR,\n        // .validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n        .doit = gtp5g_genl_del_pdr,\n        // .policy = gtp5g_genl_pdr_policy,\n        .flags = GENL_ADMIN_PERM,\n    },\n    {\n        .cmd = GTP5G_CMD_GET_PDR,\n        // .validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n        .doit = gtp5g_genl_get_pdr,\n        .dumpit = gtp5g_genl_dump_pdr,\n        // .policy = gtp5g_genl_pdr_policy,\n        .flags = GENL_ADMIN_PERM,\n    },\n    ...\n}\n</code></pre></p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#genl_register_family","title":"<code>genl_register_family()</code>","text":"<ul> <li>Definition is in /net/netlink/genetlink.c</li> <li>Registers the specified family after validating it first. Only one family may be registered with the same family name or identifier. The family's ops, multicast groups and module pointer must already be assigned. Return 0 on success or a negative error code</li> <li>Three functions within this method hold greater significance (all of them in /net/netlink/genetlink.c):</li> <li><code>genl_validate_ops()</code></li> <li><code>genl_family_find_byname()</code></li> <li><code>genl_validate_assign_mc_groups()</code></li> </ul> <pre><code>int genl_register_family(struct genl_family *family)\n{\n    int err, i;\n    int start = GENL_START_ALLOC, end = GENL_MAX_ID;\n\n    err = genl_validate_ops(family);\n    if (err)\n        return err;\n\n    genl_lock_all();\n\n    if (genl_family_find_byname(family-&gt;name)) {\n        err = -EEXIST;\n        goto errout_locked;\n    }\n\n    if (family == &amp;genl_ctrl) {\n        start = end = GENL_ID_CTRL;\n    } else if (strcmp(family-&gt;name, \"pmcraid\") == 0) {\n        start = end = GENL_ID_PMCRAID;\n    } else if (strcmp(family-&gt;name, \"VFS_DQUOT\") == 0) {\n        start = end = GENL_ID_VFS_DQUOT;\n    }\n\n    if (family-&gt;maxattr &amp;&amp; !family-&gt;parallel_ops) {\n        family-&gt;attrbuf = kmalloc_array(family-&gt;maxattr + 1,\n                        sizeof(struct nlattr *),\n                        GFP_KERNEL);\n        if (family-&gt;attrbuf == NULL) {\n            err = -ENOMEM;\n            goto errout_locked;\n        }\n    } else\n        family-&gt;attrbuf = NULL;\n\n    family-&gt;id = idr_alloc_cyclic(&amp;genl_fam_idr, family,\n                      start, end + 1, GFP_KERNEL);\n    if (family-&gt;id &lt; 0) {\n        err = family-&gt;id;\n        goto errout_free;\n    }\n\n    err = genl_validate_assign_mc_groups(family);\n    if (err)\n        goto errout_remove;\n\n    genl_unlock_all();\n\n    /* send all events */\n    genl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\n    for (i = 0; i &lt; family-&gt;n_mcgrps; i++)\n        genl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\n                &amp;family-&gt;mcgrps[i], family-&gt;mcgrp_offset + i);\n\n    return 0;\n\nerrout_remove:\n    idr_remove(&amp;genl_fam_idr, family-&gt;id);\nerrout_free:\n    kfree(family-&gt;attrbuf);\nerrout_locked:\n    genl_unlock_all();\n    return err;\n}\nEXPORT_SYMBOL(genl_register_family);\n</code></pre>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#genl_validate_ops","title":"<code>genl_validate_ops()</code>","text":"<p>This function will verify if there is defined function for the operations and will also compare whether any operation is reused by a command. Using gtp5g as an example, command can be considered as action such as add, del, modify PDR rules. <pre><code>static int genl_validate_ops(const struct genl_family *family)\n{\n    const struct genl_ops *ops = family-&gt;ops;\n    unsigned int n_ops = family-&gt;n_ops;\n    int i, j;\n\n    if (WARN_ON(n_ops &amp;&amp; !ops))\n        return -EINVAL;\n\n    if (!n_ops)\n        return 0;\n\n    for (i = 0; i &lt; n_ops; i++) {\n        if (ops[i].dumpit == NULL &amp;&amp; ops[i].doit == NULL)\n            return -EINVAL;\n        for (j = i + 1; j &lt; n_ops; j++)\n            if (ops[i].cmd == ops[j].cmd)\n                return -EINVAL;\n    }\n\n    return 0;\n}\n</code></pre></p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#genl_family_find_byname","title":"<code>genl_family_find_byname()</code>","text":"<p>Function would check every entry in genl_fam_idr whether exists the same family name.</p> <pre><code>static const struct genl_family *genl_family_find_byname(char *name)\n{\n    const struct genl_family *family;\n    unsigned int id;\n\n    idr_for_each_entry(&amp;genl_fam_idr, family, id)\n        if (strcmp(family-&gt;name, name) == 0)\n            return family;\n\n    return NULL;\n}\n</code></pre> <p>Here is the macro of <code>idr_for_each_entry()</code>: <pre><code>#define idr_for_each_entry(idr, entry, id)          \\\n    for (id = 0; ((entry) = idr_get_next(idr, &amp;(id))) != NULL; id += 1U)\n</code></pre></p>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#genl_validate_assign_mc_groups","title":"<code>genl_validate_assign_mc_groups()</code>","text":"<p>This changes the number of multicast groups that are available when ntensok is ture:</p> <pre><code>static int genl_validate_assign_mc_groups(struct genl_family *family)\n{\n    int first_id;\n    int n_groups = family-&gt;n_mcgrps;\n    int err = 0, i;\n    bool groups_allocated = false;\n\n    if (!n_groups)\n        return 0;\n\n    for (i = 0; i &lt; n_groups; i++) {\n        const struct genl_multicast_group *grp = &amp;family-&gt;mcgrps[i];\n\n        if (WARN_ON(grp-&gt;name[0] == '\\0'))\n            return -EINVAL;\n        if (WARN_ON(memchr(grp-&gt;name, '\\0', GENL_NAMSIZ) == NULL))\n            return -EINVAL;\n    }\n\n    /* special-case our own group and hacks */\n    if (family == &amp;genl_ctrl) {\n        first_id = GENL_ID_CTRL;\n        BUG_ON(n_groups != 1);\n    } else if (strcmp(family-&gt;name, \"NET_DM\") == 0) {\n        first_id = 1;\n        BUG_ON(n_groups != 1);\n    } else if (family-&gt;id == GENL_ID_VFS_DQUOT) {\n        first_id = GENL_ID_VFS_DQUOT;\n        BUG_ON(n_groups != 1);\n    } else if (family-&gt;id == GENL_ID_PMCRAID) {\n        first_id = GENL_ID_PMCRAID;\n        BUG_ON(n_groups != 1);\n    } else {\n        groups_allocated = true;\n        err = genl_allocate_reserve_groups(n_groups, &amp;first_id);\n        if (err)\n            return err;\n    }\n\n    family-&gt;mcgrp_offset = first_id;\n\n    /* if still initializing, can't and don't need to to realloc bitmaps */\n    if (!init_net.genl_sock)\n        return 0;\n\n    if (family-&gt;netnsok) {\n        struct net *net;\n\n        netlink_table_grab();\n        rcu_read_lock();\n        for_each_net_rcu(net) {\n            err = __netlink_change_ngroups(net-&gt;genl_sock,\n                    mc_groups_longs * BITS_PER_LONG);\n            if (err) {\n                /*\n                 * No need to roll back, can only fail if\n                 * memory allocation fails and then the\n                 * number of _possible_ groups has been\n                 * increased on some sockets which is ok.\n                 */\n                break;\n            }\n        }\n        rcu_read_unlock();\n        netlink_table_ungrab();\n    } else {\n        err = netlink_change_ngroups(init_net.genl_sock,\n                         mc_groups_longs * BITS_PER_LONG);\n    }\n\n    if (groups_allocated &amp;&amp; err) {\n        for (i = 0; i &lt; family-&gt;n_mcgrps; i++)\n            clear_bit(family-&gt;mcgrp_offset + i, mc_groups);\n    }\n\n    return err;\n}\n</code></pre>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#about","title":"About","text":"<ul> <li>Jimmy Chang<ul> <li>Graduate student majoring in 5GC Research</li> <li>As I am a beginner in the Linux kernel, please feel free to send me an email if you find any errors.</li> <li>mail</li> <li>Linkin</li> </ul> </li> </ul>"},{"location":"blog/20230920/Introduction_of_gtp5g_and_some_kernel_concepts/#reference","title":"Reference","text":"<ul> <li>https://bootlin.com</li> <li>https://www.linuxjournal.com/article/8498</li> <li>https://wiki.linuxfoundation.org/networking/generic_netlink_howto</li> <li>https://www.kernel.org/doc/html/latest/driver-api/driver-model/overview.html</li> <li>https://www.cnblogs.com/ssyfj/p/16230540.html</li> <li>https://www.twblogs.net/a/5b81e5852b71772165aedd7a</li> <li>https://www.cnblogs.com/ssyfj/p/16230540.html</li> <li>IT blog by Ian Chen</li> <li>IT blog by 0xff07</li> </ul>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/","title":"Support of Time Sensitive Communication and Time Synchronization in 5G system - Introduction (Rel-17)","text":"<p>Note</p> <p>Author: Ya-shih Tseng Date: 2023/9/27</p> <p>Before you read the article, I suggest you to read  Time-Sensitive Networking over 5G system - Introduction (Rel-16).</p>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#overview","title":"Overview","text":"<p>This article will introduce TSN enhancements in 3GPP Release 17. We will start by discussing the new roles introduced in 5GS and their applicable scenarios. The architecture has been modified to accommodate a wider range of applications, and additional network functions have been added to offer a broader range of services.</p> <p></p> <p>Architcture to enable time sensitive communication and time synchronization</p>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#5gs-can-be-as-boundary-clock-and-transparent-clock","title":"5GS can be as Boundary Clock and Transparent Clock","text":"<p>Time Synchronization: describes how 5GS can operate as a PTP Relay (IEEE 802.1AS), as a Boundary Clock or as Transparent Clock (IEEE 1588) for PDU Session type Ethernet and IP.</p> <p>According to 3GPP TS 23.501 Release 17, 5GS's role in TSN goes beyond just acting as a bridge. It now extends to UDP/IP applications. In addition to its original support for Ethernet through IEEE 802.1AS Time-Aware System, it has been updated to include four types of PTP instances described in IEEE 1588.</p>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#what-is-bc-and-tc","title":"What is BC and TC?","text":"<p>Difference types of PTP instances (clocks).</p> <ul> <li>For the BC, you can have a GM as a time source, and it can also act as a time source itself, allowing other slave clocks to synchronize their time with it.</li> <li>For the TC, it doesn't need to synchronize its time with other clocks. Its role is to receive time from one end, potentially adjust it, and then forward it to the next clock</li> </ul> <p>For more detail about PTP instance / Clock types, please check IEEE 1588v2 PTP Support.</p> <p>To support above applications, DS-TT and NW-TT have expanded their functionalities.</p>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#capability-of-ds-tt-and-nw-tt","title":"Capability of DS-TT and NW-TT","text":"<p>With release 17 now supporting for the scenarios when Master clock is behind the UE (uplink time sync, UE \u2013 UE time sync), behind the network (downlink time sync) and support for multiple (g)PTP domains.</p> <p>Note</p> <p>In release 16, the roles of 5GS, DS-TT, and NW-TT are fixed. The Data Network side follows the TSN master, while the UE side follows the slave. When a packet enters, the entry time is first recorded in NW-TT, and the exit time is recorded in DS-TT. The difference between these two times determines the packet's resident time.</p> <p>In general case, when receiving PTP event messages from upstream PTP instances, the ingress TT (NW-TT or DS-TT) records an ingress timestamp (TSi) for each PTP event, such as Sync messages. Then, NW-TT determines whether to forward messages to DS-TT or discard it.</p> <p>Subsequently, the egress TT creates an egress timestamp (TSe) for PTP events (i.e., Sync messages) in the external PTP network and modifies the payload of the PTP message to add/update the resident time.</p> <ul> <li>As for 5GS operates as BC, NW-TT and DS-TT should support generate Sync, Follow_Up and Announce message. If DS-TT doesn't support it, NW-TT will take over.</li> </ul>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#ptp-transparent","title":"PTP transparent","text":"<p>TTs can support the following PTP transport modes described in IEEE 1588:</p> <ul> <li>over UDP/IPv4</li> <li>over UDP/IPv6</li> <li>over IEEE 802.3 (Ethernet)</li> </ul>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#delay-measurements","title":"Delay measurements","text":"<p>Different PTP instances have different measurements of path delay due to hardware limitations.</p> <p>TTs should support the following delay measurements as described in IEEE 1588:</p> <ul> <li>Delay request-response mechanism</li> <li>Peer-to-peer delay mechanism</li> <li>which we talked about it in previous article.</li> </ul> <p>Let's see what's the diference between them. </p> <p>Difference measurements of path delay</p> <ul> <li>For E2E (End-to-End) slaves send delay requests to the Master, passing through other devices in the network. Each TC (Transparent Clock) modifies the request to update the time it has spent locally. Finally, it reaches the Master, so the E2E measured delay represents the total time taken along the entire path.</li> <li>For P2P (Point-to-Point) devices, they send requests to nearby neighbors to measure the delay time between each other.</li> </ul> <p>By now, We introduce few supports for PTP instances. Then, How should these functionalities be managed?</p>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#time-sensitive-communication-and-time-synchronization-function","title":"Time Sensitive Communication and Time Synchronization Function","text":"<p>In release 16, TSN AF is used for exchanging messages to manage TSN bridges in conjunction with centralized network configuration (CNC). This means that TSN AF is responsible for managing the ports of DS-TT and NW-TT. Additionally, in release 17, TSCTSF is a new component introduced between PCF and NEF. To support AF requests related to time-sensitive communication.</p> <p>TSCTSF can check the PTP functionalities supported by DS-TT and NW-TT by retrieving the following port management information or user plane node management information:</p> <ul> <li>Supported PTP instance types;</li> <li>Supported transport types;</li> <li>Supported PTP delay mechanisms;</li> <li>Grandmaster capability;</li> <li>Supported PTP profiles;</li> <li>Number of supported PTP instances.</li> </ul> <p>AF can obtain the required services directly or indirectly through TSCTSF</p> <ul> <li>e.g. AF can provide traffic pattern parameters to NEF. NEF will forward the received traffic pattern parameters to TSCTSF.</li> <li>e.g. AF trusted by the operator can directly provide such traffic pattern parameters to TSCTSF.</li> </ul> <p>TSCTSF may support AF to</p> <ul> <li>Activate and deactivate the time syncgronization services</li> <li>Control the time synchronization service for target UE.</li> <li>Configure the TTs to operate on AF-selected method</li> <li>Managing the DS-TT and NW-TT via exchange of PMIC and UMIC</li> <li>Provide specific QoS traffic pattern</li> <li>Creating the TSC Assistance Container based on individual traffic pattern parameters from the NEF/AF and providing it to the PCF.</li> </ul>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#abbreviation","title":"Abbreviation","text":"TSN Time-Sensitive network TT TSN Translator NW-TT Network-Side TSN Translator DS-TT Device-Side TSN Translator PTP Precision Time Protocol BC Boundary Clock E2E-TC End-to-End Transparent Clock P2P-TC Peer-to-Peer Transparent Clock GM Grand Master AF Application Function TSCTSF Time Sensitive Communication and Time Synchronization Function PMIC Port Management Information Container UMIC User Plane Node Management Information Container"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#conclusion","title":"Conclusion","text":"<p>Release 17 expanded and improved the integration with IEEE TSN. This included enabling uplink synchronization through the 5G System (5GS), enhancing End-to-End Quality of Service (QoS) across multiple clock domains, and facilitating direct communication between UE within the 5GS network.</p>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#reference","title":"Reference","text":"<ul> <li>IEEE Std 802.1AS-2020: \u201cIEEE Standard for Local and metropolitan area networks--Timing and Synchronization for Time-Sensitive Applications\u201d.</li> <li>IEEE Std 1588: \u201cIEEE Standard for a Precision Clock Synchronization Protocol for Networked Measurement and Control Systems\u201d, Edition 2019.</li> <li>3GPP TS 23.501 v16.6.0: \"System Architecture for the 5G System\"</li> <li>3GPP TS 23.501 v17.8.0: \"System Architecture for the 5G System\"</li> <li>3GPP TS 23.502 v17.4.0: \"Procedures for the 5G System\"</li> <li>Time-Sensitive Networking (TSN) Task Group | - IEEE 802.1</li> </ul>"},{"location":"blog/20230927/Support_of_Time_Sensitive_Communication_and_Time_Synchronization_in_5G_system_-_Introduction_%28Rel-17%29/#about","title":"About","text":"<p>Hi, This is Ya-shih Tseng. I am currently researching the implementation of 5G TSN as part of my master's studies. Feel free to discuss with me.</p> <ul> <li>Here is my linkedin profile</li> </ul>"},{"location":"blog/20231004/20231004/","title":"Introduction of MPTCP","text":"<p>Note</p> <p>Author: \u5f35\u54f2\u777f (Jerry) Date: 2023/10/04</p> <p>MPTCP (multipath TCP) is a set of extensions to regular TCP that allows a connection to use many paths to transport data simultaneously. The simultaneous use of these multiple paths for a TCP/IP session would improve resource usage within the network, and if one path is blocked, it can use another path to transport data, improving resilience to network failure. A common use of mptcp is: Most mobile phones today have the ability to connect to wifi or mobile networks (4G/5G), but regular TCP can't use two network resources simultaneously, and if the network we were originally using (for example, wifi) is disconnected, it cannot automatically switch to using the mobile network. Therefore, the connection at the application layer will also be disconnected. In this article, I will introduce MPTCP, including how to establish an MPTCP connection, how to start a new subflow, the ack mechanism, and the congestion control algorithm it uses.</p>"},{"location":"blog/20231004/20231004/#initiating-an-mptcp-connection","title":"Initiating an MPTCP Connection","text":"<p>MPTCP implements multi-path transmission by creating multiple subflows; each subflow is similar to a general TCP connection. Use the 3-way handshaking to establish the connection. But instead of a separate connection, the subflow is bound into an existing MPTCP session. MPTCP uses SYN, SYN/ACK, and ACK packets to establish connections. But these sockets also carry the MP_CAPABLE option (in the optional field of the tcp header), which is used to verify whether the remote host supports MPTCP and exchange some information to authenticate the establishment of additional subflows.</p> <p></p> <p>RFC8684 3.1</p> <p>The above figure shows the structure of MP_CAPABLE. First, the initiator sends only 4 octets. If the listener also supports MPTCP v1, it will respond SYN/ACK, and the listener's key will be included in MP_CAPABLE. Then the initiator replies ACK, which contains the sender's key and the receiver's key. These keys are used to authenticate the addition of future subflows to this connection; all future subflows will identify the connection using a 32-bit \"token\". This token is a cryptographic hash of this key. The use of flags in the fourth octets are as follow:</p> <ul> <li>A: Indicate \"Checksum required\".</li> <li>B: It is an extensibility flag, must be set to 0.</li> <li>C: Indicate that the sender of this option will not accept additional MPTCP subflows to the source address and port.</li> <li>D through H: The flags D through H, are used for crypto algorithm negotiation. In MPTCP v1, only the rightmost bit, labeled H, is assigned. Bit H indicates the use of HMAC-SHA256.</li> </ul>"},{"location":"blog/20231004/20231004/#starting-a-new-subflow","title":"Starting a New Subflow","text":"<p>Once an MPTCP connection has begun with the MP_CAPABLE exchange, further subflows can be added to the connection. A new subflow is started as a normal TCP SYN/ACK exchange. But these packets contain the Join Connection option.</p> <p></p> <p>RFC8684 3.2</p> <p>This is the first Join Connection (MP_join) Option for the initial SYN. The token is a cryptographic hash of the receiver's key. The MP_join also contains an \"Address ID\", which is used to identify the source address of this packet. This mechanism allows addresses to be removed even if they are changed by NAT. The last bit of the third byte (flag B) indicates that the sender (1) wishes this subflow to be used as a backup path (B=1) in the event of failure of other paths or (2) wants the subflow to be used as part of the connection immediately. MP_JOIN also contains a random number to prevent replay attacks. If MP_JOIN contains a valid token, the recipient will respond with a SYN/ACK also containing an MP_JOIN option containing a random number and a truncated (leftmost 64-bit) HMAC. Transport HMAC is to have previously exchanged random data (in the first two SYN packets) that is used as the \"message\".</p> <p></p> <p>RFC8684 3.2</p> <p>If the HMAC in SYN/ACK is valid, then the initiator will send its authentication in the third packet (ACK). This data needs to be sent reliably since it is the only time this HMAC is sent. Therefore, receipt of this packet triggers a regular TCP ACK in response, and the packet will be retransmitted if this ACK is not received.</p> <p></p> <p>RFC8684 3.2</p> <p></p> <p>RFC8684 3.2</p> <p>This is total handshake procedure.</p>"},{"location":"blog/20231004/20231004/#mptcp-operation-and-data-transfer","title":"MPTCP Operation and Data Transfer","text":"<p>MPTCP takes one input data stream and splits it into subflows. It then uses a 64-bit data sequence number to number all the data and let the data be reassembled at the receiver. Each subflow has its own 32-bit sequence number space, utilizing the regular TCP sequence number header, and an MPTCP option (Data Sequence Signal optional) maps the subflow sequence space to the data sequence space. MPTCP uses the Data Sequence Signal optional to carry the Data Sequence Mapping, which consists of the subflow sequence number, data sequence number, and length for which this mapping is valid. The Data Sequence Number is the starting sequence number for the subflow, and the Subflow Sequence Number is the sequence number only relevant to the subflow. The Data Ack in the Data Sequence Signal optional is used to ACK for the connection, indicating how much data has been successfully received.</p> <p></p> <p>RFC8684 3.3</p>"},{"location":"blog/20231004/20231004/#coupled-congestion-control-algorithm","title":"Coupled Congestion Control Algorithm","text":"<p>There are two goals that MPTCP congestion control needs to meet: 1.   A multipath flow should perform at least as well as a single-path flow would on the best of the paths available to it. 2.   A multipath flow should take no more capacity on any path or collection of paths than if it were a single-path TCP flow using the best of those paths.</p> <p>The second goal is to prevent MPTCP traffic from occupying too many resources and harming other TCP flows on the bottleneck link. So if we combine the first goal and the second goal, it means that the total capacity that MPTCP occupies should equal the capacity that the best path can transport. (In the situation where there is some competitive TCP flow, if there is no other competitive flow, then MPTCP will occupy all the capacity it can use.)</p> <p>The algorithm rule: * Each ACK on subflow r, increase the window  by . * Each loss on subflow r, decrease the window  by .</p> <p> </p> <p>  is the current window size on path r,  is equilibrium window size on path r, and similarly for the total window size.</p> <p>And how  derived? Here I write down some of my thoughts after reading the paper. There may be errors. If you find any, please tell me directly. First, we assume that , so if the transmission speed of subflow r is slower than tcp, then the increments of the window size r is . Because the increase and decrease of the window in the equilibrium state are equal to each other, so we have the fallowing equation.</p> <p> </p> <p>  is the loss rate of subflow r.Then we assume loss rate is small.</p> <p> </p> <p>Now assume that there is tcp on this subflow, then we have:</p> <p> </p> <p>p is the loss rate. Here, assume p is equal to .(But actually, they would not be equal if there was no other competitive flow.  is smaller, so we measure a better tcp performence.) Substitute  with p, then we have:</p> <p> </p> <p>And we want the total capacity MPTCP occupies to equal the capacity that the best path can transport using TCP. So we have the equation:</p> <p> </p> <p>Window size divide by RTT is the traffic send on path per second.</p> <p> </p> <p> </p> <p>Finally, we can derive .</p> <p> </p> <p>Because tcp performance on path r is measured by loss rate , if there is no competitive flow, mptcp can use more resources, and the increments of the window finally bounded by . So if we only run mptcp on many paths, it's like we have many TCP connecion, the total traffic is sum of every subflow's max transmission capability.</p>"},{"location":"blog/20231004/20231004/#how-to-use-mptcp","title":"How to use MPTCP","text":"<p>As for how to use mptcp under Linux system, you can refer to this article. It describes how to use mptcpize to change the original tcp connection to mptcp.</p>"},{"location":"blog/20231004/20231004/#about","title":"About","text":"<p>Hello! My name is \u5f35\u54f2\u777f, and my current research topic is ATSSS (Access Traffic Steering, Switching and Splitting).  If you find any mistakes in my articles, please contact me.</p> <ul> <li>Linkedln</li> </ul>"},{"location":"blog/20231004/20231004/#reference","title":"Reference","text":"<ul> <li>RFC 8684</li> <li>RFC 6356</li> <li>Coupled Congestion Control Algorithm</li> <li>MPTCP congestion control</li> <li>How to use MPTCP</li> </ul>"},{"location":"blog/20231018/20231018/","title":"LTE Authentication Introduction: EPS-AKA'","text":"<p>Note</p> <p>Author: Wilson Date: 2023/10/18</p>"},{"location":"blog/20231018/20231018/#abstract","title":"Abstract","text":"<p>In this article, I will delve into the topic of EPS-AKA', a subject closely related to 4G network security. The article is structured as follows:</p> <ol> <li>An introduction to EPS-AKA'.</li> <li>An explanation of the concept of authentication.</li> <li>An exploration of key hierarchy generation in the 4G network, emphasizing its relevance to the EPS-AKA' procedure.</li> <li>A detailed examination of the EPS-AKA' procedure.</li> <li>A comparison between 4G AKA and 5G AKA, highlighting both their similarities and differences.</li> </ol>"},{"location":"blog/20231018/20231018/#introduction","title":"Introduction","text":"<p>Every day, people use apps like Line to send messages, watch videos on YouTube, and send emails via Gmail. To do any these activities, a connection to the Internet must be established. However, once a connection is made, the data packets transmitted are at risk of being intercepted. To ensure the confidentiality of the data and to verify its integrity, the LTE Security Procedure is initiated whenever a mobile phone goes online or sends a message.</p> <p>The LTE Security Procedure is categorized into three stages :</p> <ul> <li>EPS-AKA'</li> <li>NAS Security</li> <li>AS Security</li> </ul> <p>EPS-AKA' stands for \"Evolved Packet System-Authentication and Key Agreement\". As suggested by its full name, AKA primarily involves two key actions:</p> <ul> <li>Authentication</li> <li>Key Agreement</li> </ul> <p>The focus of this article will be on EPS-AKA', which is further divided into two main steps:</p> <ol> <li>In the first step, the network generate an authentication vector. Some of the information within this vector is used for authentication.</li> <li>The second step involves mutual authentication between the user and the network.</li> </ol>"},{"location":"blog/20231018/20231018/#understanding-the-definition-of-authentication","title":"Understanding the Definition of Authentication","text":"<p>Most people have come across the term \"authentication\", and its definition varies depending on context and interpretation. For the purposes of this article, and based on my own understanding, I'll use an everyday analogy to explain the concept of authentication.</p> <p>Imagine during summer of winter vacation, your family decides to travel abroad. Before you board the plane, you must clear customs. The customs officier determines if you can proceed by examining your passport. This procedure resembles the process of authentication. As illustrated in Figure 1, a traveler presents their passport to a customs officer who then compares the passport details with information on their computer. If the passport's contents match the computer's records, you are granted passage. At the heart of authentication is this act of verification.</p> <p>In the context of the EPS-AKA' procedure, authentication occurs twice:</p> <ol> <li>Initially, the HSS provides the  to the UE. The UE then compares the received  whith its . If the  mathes the , it indicates sucessful authentication. This step verifies the authenticity of the HSS and, by extension, the network.</li> <li>In the second instance, the UE forwards the RES to the MME. The MME then compares the provided RES with the XRES. If the RES aligns with the XRES, authentication is successful. This stage confirms the authenticity of the UE.</li> </ol> <p> Figure 1. The Definition of Authentication</p>"},{"location":"blog/20231018/20231018/#key-hierarchy-generation-in-4g","title":"Key Hierarchy Generation in 4G","text":"<p>The Figure 2 is the key hierarchy generation in 4G. When an UE is generated, the <code>IMSI</code> and <code>K</code> value are stored in the USIM card, and the <code>IMSI</code> and <code>K</code> value are regarded as the permanent value. When an UE subscribes to the operator's network, the HSS will get the permanent value of the UE's <code>IMSI</code> and <code>K</code>.</p> <p>The USIM and HSS use the <code>K</code> as the base to generate the <code>CK</code> and <code>IK</code> in the EPS-AKA' stage of the LTE Security Procedure. The HSS uses the <code>CK</code> and <code>IK</code> as the base to generate the  and transmits the  to the MME. The USIM transmits the <code>CK</code> and <code>IK</code> to the UE, and UE uses the <code>CK</code> and <code>IK</code> as the base to generate the .</p> <p>The UE and MME use the  as the base and generate separately three keys in the NAS Security stage of the LTE Security Procedure. Three keys are the , , and . The  and  are used in the NAS Security stage, and the  is transmitted to the eNodeB.</p> <p>The UE and eNodeB use the  as the base and generate separately three keys in the AS Security stage of the LTE Security Procedure. Three keys are the , , and .</p> <p> Figure 2. Key Hierarchy Generation in 4G</p>"},{"location":"blog/20231018/20231018/#eps-aka-procedure","title":"EPS-AKA' Procedure","text":"<p> Figure 3. EPS-AKA' Procedure</p>"},{"location":"blog/20231018/20231018/#the-ue-sends-the-attach-request-to-the-mme","title":"The UE sends the <code>Attach Request</code> to the MME","text":"<p>The Figure 3 shows the entire EPS-AKA' procedure. The UE sends the <code>Attach Request</code> to the MME. The <code>Attach Request</code> contains the <code>IMSI</code>, <code>UE Network Capability</code>, and . The <code>IMSI</code> is like the ID number of this UE. The <code>UE Network Capability</code> is what encryption and integrity protection algorithms the UE supports. The UE sends <code>UE Network Capability</code> to tell MME. The content of <code>UE Network Capability</code> is like EEA0=on, EEA1=on, EEA2=off, ..., EIA1=on, EIA2=on, ... The on and off symbols are represented by one bit. The  represents the number corresponding to the . The  is represented by 3 bits. The value of  is 7, which means that the UE does not have the  yet.</p>"},{"location":"blog/20231018/20231018/#the-mme-sends-the-authentication-information-request-to-the-hss","title":"The MME sends the <code>Authentication Information Request</code> to the HSS","text":"<p>The MME sends the <code>Authentication Information Request</code> to the HSS after receiving the <code>Attach Request</code>. The <code>Authentication Information Request</code> contains the <code>IMSI</code>, <code>SN ID</code>, <code>n</code>, and <code>Network Type</code>. The full English name of <code>SN ID</code> is Serving Network ID, which refers to the network that the user wants to connect to. The value of <code>SN ID</code> is usually composed of the MCC and MNC (PLMN ID). The <code>n</code> represents how many verifcation vectors are sent to the HSS. The <code>Network Type</code> is what kind of wireless network the user wants to connect to the Internet from my understanding.</p>"},{"location":"blog/20231018/20231018/#the-hss-sends-the-authentication-information-answer-to-the-mme","title":"The HSS sends the <code>Authentication Information Answer</code> to the MME","text":"<p>The HSS automatically generates the <code>RAND</code> and <code>SQN</code> after receiving the <code>Authentication Information Request</code>. The HSS inputs the <code>K</code>, <code>SQN</code>, and <code>RAND</code> into the Cryptographic Function. The Cryptographic Function uses the EPS AKA algorithm and outputs the <code>XRES</code>, , <code>CK</code>, and <code>IK</code>. The HSS inputs the <code>CK</code>, <code>IK</code>, <code>SQN</code>, and <code>SN ID</code> into the KDF (Key Derivation Function). The KDF outputs . Then, the <code>RAND</code> that is generated by the HSS itself, the  and <code>XRES</code> that are generated by the Cryptographic Function, and the  that is generated by KDF are combined into the AV. The <code>Authentication Information Answer</code> includes AV and is sent to the MME.</p>"},{"location":"blog/20231018/20231018/#the-mme-sends-the-authentication-request-to-the-ue","title":"The MME sends the <code>Authentication Request</code> to the UE","text":"<p>The MME selects an AV among multiple AVs and sends the <code>Authentication Request</code> to the UE after receiving the <code>Authentication Information Answer</code>. The <code>Authentication Request</code> contains the <code>RAND</code>, , and .</p>"},{"location":"blog/20231018/20231018/#the-ue-sends-the-authentication-response-to-the-mme","title":"The UE sends the <code>Authentication Response</code> to the MME","text":"<p>The UE receives the <code>Authentication Request</code>. Why do you see the <code>SQN</code> is generated by the HSS in the Figure 3? The  carries the <code>SQN</code>. The UE can find the <code>SQN</code> in the . The USIM inputs the <code>K</code>, <code>SQN</code>, and <code>RAND</code> into the Cryptographic Function. The Cryptographic Function uses the EPS AKA algorithm and outputs the <code>RES</code>, , <code>CK</code>, and <code>IK</code>. When the UE gets , it compares the  with the . If the authentication is successful, the UE will generate the <code>RES</code>. The <code>Authentication Response</code> contains the <code>RES</code> and is returned to the MME.</p>"},{"location":"blog/20231018/20231018/#the-mme-receives-the-authentication-response","title":"The MME receives the <code>Authentication Response</code>","text":"<p>The MME compares the <code>XRES</code> with <code>RES</code> after receiving the <code>Authentication Response</code>. If the content of the <code>XRES</code> and <code>RES</code> are the same, it means that the authentication is successful. The authentication stage has come to an end.</p> <p>Finally, the UE inputs the <code>CK</code>, <code>IK</code>, <code>SQN</code>, and <code>SN ID</code> into the KDF. The KDF outputs . The UE and MME have the same . The  doesn't be transmitted between the UE and MME. The  is transmitted in the form of the  to prevent the  from being stolen by a third party.</p>"},{"location":"blog/20231018/20231018/#4g-vs-5g-aka-a-comparison","title":"4G vs. 5G AKA: A Comparison","text":"<p>Similarities:</p> <ol> <li>Both 4G and 5G UEs utilize the same Universal Subscriber Identity Module (USIM).</li> <li>Both systems rely on shared symmetric keys for authentication.</li> </ol> <p>Differences:</p> <ol> <li> <p>Authentication Mechanism:</p> <ul> <li>4G: EPS-AKA'</li> <li>5G: 5G-AKA and EAP-AKA'</li> </ul> </li> <li> <p>Serving Network:</p> <ul> <li>4G: MME</li> <li>5G: SEAF</li> </ul> </li> <li> <p>Home Network:</p> <ul> <li>4G: HSS</li> <li>5G: AUSF, UDM, ARPF, and SIDF</li> </ul> </li> <li> <p>Network Function for Authentication Vector Generation:</p> <ul> <li>4G: HSS</li> <li>5G: UDM and ARPF</li> </ul> </li> <li> <p>Network Function to Verify UE Identity:</p> <ul> <li>4G: MME</li> <li>5G<ul> <li>5G-AKA: SEAF and AUSF</li> <li>EAP-AKA': AUSF</li> </ul> </li> </ul> </li> <li> <p>Key Hierarchy Generation:</p> <ul> <li>4G: K -&gt; CK + IK -&gt;  </li> <li>5G<ul> <li>5G-AKA: K -&gt; CK + IK -&gt;  -&gt;  </li> <li>EAP-AKA': K -&gt; CK + IK -&gt; CK' + IK' -&gt;  -&gt;  </li> </ul> </li> </ul> </li> </ol>"},{"location":"blog/20231018/20231018/#reference","title":"Reference","text":"<ul> <li>LTE Security I: Concept and Authentication</li> <li>LTE Security II: NAS and AS Security</li> <li>https://kknews.cc/zh-tw/code/65y6x9l.html</li> <li>https://nccnews.com.tw/202010/ch4.html</li> </ul>"},{"location":"blog/20231018/20231018/#about","title":"About","text":"<p>Hi, my name is Wilson. I am a master\u2019s student. My main area of research is network slicing. In the future, I will introduce more information about 5G. Hope you enjoy it.</p>"},{"location":"blog/20231108/20231108/","title":"Introduction of IP Multimedia Subsystem Part 1","text":"<p>Note</p> <p>Author: Elisa Lee Date: 2023/11/08</p> <p>The IMS is a framework for delivering multimedia and voice services over IP networks. It plays a crucial role in enabling communication services like voice, video, and messaging to be delivered in a converged, efficient, and scalable manner.</p>"},{"location":"blog/20231108/20231108/#definition-and-overview-of-ims","title":"Definition and Overview of IMS","text":""},{"location":"blog/20231108/20231108/#introduction-to-ims","title":"Introduction to IMS","text":"<p>A standardized, open architectural framework that allows multimedia services to be delivered over IP networks. It is defined by the 3GPP (3rd Generation Partnership Project) and widely used in mobile networks.</p>"},{"location":"blog/20231108/20231108/#purpose-and-significance-of-ims","title":"Purpose and Significance of IMS","text":""},{"location":"blog/20231108/20231108/#purpose-of-ims","title":"Purpose of IMS","text":""},{"location":"blog/20231108/20231108/#multimedia-services","title":"Multimedia Services","text":"<p>IMS is designed to support a wide range of multimedia services such as voice, video, messaging, and data services over IP networks.</p>"},{"location":"blog/20231108/20231108/#interoperability","title":"Interoperability","text":"<p>It provides a standardized architecture that allows different network elements and applications from various vendors to work together seamlessly. This promotes interoperability, which is vital in a diverse telecommunications ecosystem.</p>"},{"location":"blog/20231108/20231108/#service-convergence","title":"Service Convergence","text":"<p>IMS allows the convergence of various services like voice, video, and data onto a single IP network. This makes it possible for users to access multiple services through a unified interface.</p>"},{"location":"blog/20231108/20231108/#quality-of-service-qos","title":"Quality of Service (QoS)","text":"<p>IMS enables network operators to prioritize and manage different types of traffic, ensuring that services like voice and video receive the necessary bandwidth and low latency for a high-quality user experience.</p>"},{"location":"blog/20231108/20231108/#session-management","title":"Session Management","text":"<p>It manages sessions for different types of services, ensuring that sessions are established, maintained, and terminated appropriately.</p>"},{"location":"blog/20231108/20231108/#mobility-management","title":"Mobility Management","text":"<p>IMS allows for seamless mobility across different access networks (e.g., Wi-Fi, LTE, 5G), ensuring continuity of services as users move between different coverage areas.</p>"},{"location":"blog/20231108/20231108/#security","title":"Security","text":"<p>IMS incorporates security features and protocols to protect the confidentiality, integrity, and authenticity of communication sessions.</p>"},{"location":"blog/20231108/20231108/#billing-and-charging","title":"Billing and Charging","text":"<p>It supports real-time charging and billing capabilities, allowing operators to accurately charge users for the services they consume.</p>"},{"location":"blog/20231108/20231108/#significance-of-ims","title":"Significance of IMS","text":""},{"location":"blog/20231108/20231108/#transition-to-all-ip-networks","title":"Transition to All-IP Networks","text":"<p>IMS is a key enabler in the shift from traditional circuit-switched networks to all-IP networks. This transition is essential for supporting advanced multimedia services.</p>"},{"location":"blog/20231108/20231108/#facilitates-4g-and-5g-technologies","title":"Facilitates 4G and 5G Technologies","text":"<p>IMS is a critical component for the deployment and operation of 4G LTE and 5G networks, providing the infrastructure for delivering high-speed data services and advanced multimedia applications.</p>"},{"location":"blog/20231108/20231108/#enhances-user-experience","title":"Enhances User Experience","text":"<p>By enabling the delivery of high-quality multimedia services, IMS significantly enhances the user experience, particularly for applications like video calling, streaming, and real-time gaming.</p>"},{"location":"blog/20231108/20231108/#enables-next-generation-services","title":"Enables Next-Generation Services","text":"<p>IMS is foundational for emerging technologies like IoT (Internet of Things) and Industry 4.0, enabling a wide range of applications and services across various industries.</p>"},{"location":"blog/20231108/20231108/#promotes-innovation","title":"Promotes Innovation","text":"<p>IMS's standardized architecture encourages innovation by allowing developers to create new services and applications that can run on IMS-enabled networks.</p>"},{"location":"blog/20231108/20231108/#global-standardization","title":"Global Standardization","text":"<p>IMS is based on international standards defined by organizations like 3GPP and ETSI (European Telecommunications Standards Institute), ensuring global compatibility and uniformity in telecommunications networks.</p>"},{"location":"blog/20231108/20231108/#key-components-of-ims","title":"Key Components of IMS","text":""},{"location":"blog/20231108/20231108/#sip-session-initiation-protocol","title":"SIP (Session Initiation Protocol)","text":"<p>SIP is a signaling protocol used for initiating, maintaining, modifying, and terminating real-time sessions that involve video, voice, messaging, and other communications applications and services over the internet. It operates at the application layer of the OSI model and is widely used for VoIP (Voice over Internet Protocol) and other multimedia communication applications.</p>"},{"location":"blog/20231108/20231108/#role-of-sip-in-ims","title":"Role of SIP in IMS","text":"<p>In the context of IMS, SIP serves as the primary signaling protocol.</p>"},{"location":"blog/20231108/20231108/#session-establishment","title":"Session Establishment","text":"<p>SIP is used to initiate communication sessions between devices or applications. When a user wants to make a call, send a message, or establish a multimedia session, SIP is responsible for setting up the connection.</p>"},{"location":"blog/20231108/20231108/#user-location-and-registration","title":"User Location and Registration","text":"<p>SIP allows devices to register their location on the network. This information is crucial for routing calls and messages to the correct destination.</p>"},{"location":"blog/20231108/20231108/#call-control","title":"Call Control","text":"<p>SIP handles the signaling for call control functions such as call setup, call hold, call transfer, and call release. It defines how these operations should be communicated between endpoints.</p>"},{"location":"blog/20231108/20231108/#service-invocation","title":"Service Invocation","text":"<p>It enables the invocation of various services within IMS, like call forwarding, call waiting, and supplementary services.</p>"},{"location":"blog/20231108/20231108/#session-modification-and-termination","title":"Session Modification and Termination","text":"<p>SIP is also responsible for modifying existing sessions (e.g., adding participants to a call) and terminating sessions when the user ends the communication.</p>"},{"location":"blog/20231108/20231108/#media-negotiation","title":"Media Negotiation","text":"<p>While SIP is responsible for signaling, it doesn't handle the actual media (audio, video, etc.) transfer. It works in conjunction with protocols like RTP (Real-time Transport Protocol) for media transmission.</p>"},{"location":"blog/20231108/20231108/#signaling-for-establishing-modifying-and-terminating-sessions","title":"Signaling for establishing, modifying, and terminating sessions","text":""},{"location":"blog/20231108/20231108/#session-establishment_1","title":"Session Establishment:","text":"<ul> <li> <p>Caller's Request: The caller's device sends a SIP INVITE message to the SIP server, indicating the intention to establish a session with the callee.</p> </li> <li> <p>SIP Server Processing: The SIP server processes the INVITE message. It checks the user's location and forwards the request to the recipient's SIP server.</p> </li> <li> <p>Recipient's Response: The recipient's SIP server delivers the INVITE message to the callee's device. If the recipient is available and agrees to the session, their device sends a SIP 200 OK response back.</p> </li> <li> <p>Session Establishment: Once the caller's device receives the 200 OK response, it acknowledges the establishment of the session. The media streams (audio, video, etc.) can then begin.</p> </li> </ul>"},{"location":"blog/20231108/20231108/#session-modification","title":"Session Modification","text":"<p>If a user wants to modify an ongoing session, such as adding another participant to a call, the SIP signaling is used to send an UPDATE request. This request is processed by the SIP servers and communicated to the affected parties.</p>"},{"location":"blog/20231108/20231108/#session-termination","title":"Session Termination","text":"<p>When a user decides to end a session, their device sends a SIP BYE message. This message is processed by the SIP servers, and the appropriate responses are sent to indicate the termination of the session. It's important to note that SIP is a text-based protocol, and it uses URLs similar to those used on the web to identify users and services. This makes it versatile and easy to integrate into existing internet infrastructure.</p>"},{"location":"blog/20231108/20231108/#sdp-session-description-protocol","title":"SDP (Session Description Protocol)","text":"<p>The SDP is a protocol used in multimedia communications to negotiate and describe sessions between participants. It provides a concise and human-readable way to convey information about the characteristics of a multimedia session.</p>"},{"location":"blog/20231108/20231108/#role-of-sdp-in-session-negotiation-and-description","title":"Role of SDP in session negotiation and description","text":""},{"location":"blog/20231108/20231108/#session-negotiation","title":"Session Negotiation","text":"<ul> <li> <p>Media Types: This includes information about the type of media (e.g., audio, video, application data) that will be exchanged during the session.</p> </li> <li> <p>Codecs and Formats: SDP specifies which codecs (compression/decompression algorithms) and formats will be used for media encoding and decoding.</p> </li> <li> <p>Transport Protocols: It describes the transport protocol and ports that will be used for sending and receiving media packets.</p> </li> <li> <p>Network Addresses: SDP provides information about the IP addresses and ports where media should be sent.</p> </li> <li> <p>Timing and Synchronization: SDP can include information about timing aspects like session start and end times, as well as synchronization of different media streams.</p> </li> </ul>"},{"location":"blog/20231108/20231108/#session-description","title":"Session Description","text":"<p>SDP accomplishes session description by providing a structured text-based format that includes information about the session parameters mentioned above. This description is typically conveyed in the form of an SDP message.</p>"},{"location":"blog/20231108/20231108/#negotiating-capabilities","title":"Negotiating Capabilities","text":"<ul> <li> <p>Establishing Media Streams: SDP is crucial for establishing media streams. It specifies how media should be encoded, transported, and synchronized between participants. This ensures that audio, video, and other data are transmitted and received correctly.</p> </li> <li> <p>Interoperability: SDP is a standardized format, allowing devices and applications from different vendors to communicate effectively. This promotes interoperability, which is crucial in diverse multimedia environments.</p> </li> <li> <p>Dynamic Adaptation: SDP can be updated dynamically during a session. For example, if network conditions change, SDP can be used to renegotiate parameters like codecs or bitrates to ensure the best possible quality.</p> </li> </ul>"},{"location":"blog/20231108/20231108/#hss-home-subscriber-server","title":"HSS (Home Subscriber Server)","text":"<p>The HSS is a crucial component within the IMS architecture. It serves as a central database that stores and manages subscriber-related information for users in a telecommunications network.</p>"},{"location":"blog/20231108/20231108/#definition-and-function-of-hss-in-ims","title":"Definition and function of HSS in IMS","text":""},{"location":"blog/20231108/20231108/#definition","title":"Definition","text":"<p>The HSS is a core network element in the IMS architecture. It is a centralized database that contains essential information about subscribers, including their identities, services, and authentication credentials. The HSS plays a pivotal role in facilitating various services and functions within IMS.</p>"},{"location":"blog/20231108/20231108/#function-of-hss-in-ims","title":"Function of HSS in IMS","text":"<ul> <li> <p>Subscriber Profile Management: The HSS stores detailed information about each subscriber, including their IMS public user identity, contact information, allocated services, and preferences. This data is used for session setup, authorization, and routing decisions.</p> </li> <li> <p>Authentication and Authorization: HSS is responsible for authenticating users when they attempt to access IMS services. It verifies the subscriber's credentials (such as username and password) before granting access. Additionally, it provides information about the services and capabilities available to each subscriber.</p> </li> <li> <p>Subscriber Location: It keeps track of the location of subscribers within the network. This information is crucial for routing calls and messages to the appropriate serving network element.</p> </li> <li> <p>Security Functions: The HSS plays a role in the security architecture of IMS. It stores security-related keys and information necessary for secure communication between the subscriber's device and the IMS network.</p> </li> <li> <p>Policy and Charging Control (PCC): HSS may also be involved in policy control and charging decisions. It provides information about the subscriber's subscription and policy rules that dictate how services are delivered and charged.</p> </li> </ul>"},{"location":"blog/20231108/20231108/#managing-subscriber-data-and-authentication","title":"Managing subscriber data and authentication","text":""},{"location":"blog/20231108/20231108/#managing-subscriber-data","title":"Managing Subscriber Data","text":"<ul> <li> <p>Subscriber Registration: When a subscriber logs into the network, the HSS is involved in the registration process. It verifies the subscriber's identity and allocates necessary resources and services.</p> </li> <li> <p>Profile Updates: The HSS is responsible for updating subscriber profiles. This includes adding or removing services, updating contact information, or changing authentication credentials.</p> </li> <li> <p>Roaming Support: In the case of roaming, the HSS plays a key role in managing the subscriber's information, ensuring that services can be delivered seamlessly across different networks.</p> </li> </ul>"},{"location":"blog/20231108/20231108/#authentication","title":"Authentication","text":"<ul> <li> <p>Challenge-Response Mechanism: When a subscriber attempts to access IMS services, the HSS challenges the subscriber's device for authentication credentials.</p> </li> <li> <p>Verifying Credentials: The HSS verifies the subscriber's credentials using authentication algorithms and keys. This ensures that only authorized users can access the network.</p> </li> <li> <p>Generating Security Tokens: After successful authentication, the HSS generates security tokens that are used to secure the communication sessions between the subscriber's device and the network.</p> </li> <li> <p>Subscriber Privacy and Security: The authentication process ensures that subscriber information and communication sessions are protected from unauthorized access and interception.</p> </li> </ul>"},{"location":"blog/20231108/20231108/#cscf-call-session-control-function","title":"CSCF (Call Session Control Function)","text":"<p>The CSCF is a crucial element in the IMS architecture, responsible for handling call/session control and routing within the network. There are three types of CSCFs, each serving specific roles in the IMS framework.</p>"},{"location":"blog/20231108/20231108/#proxy-cscf-p-cscf","title":"Proxy CSCF (P-CSCF)","text":"<p>The P-CSCF is a vital component within the IMS architecture. It serves as the initial point of contact for UE (User Equipment) when establishing communication sessions. The P-CSCF behaves as a proxy, managing incoming requests by either processing them internally or forwarding them to appropriate destinations. It does not modify the Request URI in the SIP INVITE message. In certain scenarios, the P-CSCF may also act as a User Agent, independently generating SIP transactions. Additionally, the P-CSCF's address is discovered by UEs following PDP context activation, allowing for seamless initiation of sessions.</p>"},{"location":"blog/20231108/20231108/#key-functions","title":"Key Functions","text":"<ul> <li> <p>Forwarding SIP register requests from the UE to the appropriate I-CSCF based on the UE's home domain.</p> </li> <li> <p>Relaying SIP messages received from the UE to the designated SIP server (e.g., S-CSCF) obtained during the registration process.</p> </li> <li> <p>Forwarding SIP requests or responses to the UE.</p> </li> <li> <p>Detecting and handling emergency session establishment requests according to specified error handling procedures.</p> </li> <li> <p>Generating Call Detail Records for transaction records.</p> </li> <li> <p>Establishing and maintaining Security Associations with each UE.</p> </li> <li> <p>Performing SIP message compression and decompression.</p> </li> <li> <p>Authorizing bearer resources and managing QoS</p> </li> </ul>"},{"location":"blog/20231108/20231108/#interrogating-cscf-i-cscf","title":"Interrogating CSCF (I-CSCF)","text":"<p>The I-CSCF functions as the initial entry point within an operator's network for all incoming connections directed to a user of that network operator or to a roaming user currently situated within the operator's service area. An operator's network may incorporate multiple I-CSCFs to manage these incoming connections effectively.</p>"},{"location":"blog/20231108/20231108/#key-functions_1","title":"Key Functions","text":"<ul> <li>Assigning a Serving-CSCF (S-CSCF) to a user during the SIP registration process.</li> <li>Routing SIP requests received from other networks to the appropriate S-CSCF.</li> <li>Retrieving the S-CSCF address from the HSS.</li> <li>Forwarding SIP requests or responses to the determined S-CSCF.</li> <li>Generating Call Detail Records to maintain transaction records.</li> </ul>"},{"location":"blog/20231108/20231108/#serving-cscf-s-cscf","title":"Serving CSCF (S-CSCF)","text":"<p>The S-CSCF is a pivotal component in the IMS architecture. Its primary role involves providing session control services for the UE. The S-CSCF maintains a session state essential for supporting various services as required by the network operator. It's worth noting that different S-CSCFs within an operator's network may have varying functionalities tailored to specific requirements.</p>"},{"location":"blog/20231108/20231108/#key-functions_2","title":"Key Functions","text":"<ul> <li>May act as a Registrar, accepting registration requests and making its information available through the location server (e.g., HSS).</li> <li>Controls sessions for registered endpoints, including rejecting IMS communication to/from barred public user identities.</li> <li>May behave as a Proxy Server, handling requests internally or forwarding them.</li> <li>May behave as a User Agent, capable of terminating and independently generating SIP transactions.</li> <li>Provides endpoints with service event-related information, such as notification of tones/announcements and location of additional media resources, along with billing notifications.</li> <li>Obtains the Address of the I-CSCF for the network operator serving the destination user and forwards SIP requests/responses accordingly.</li> <li>Routes SIP requests/responses based on the type of procedure.</li> </ul>"},{"location":"blog/20231108/20231108/#cscfs-role-in-callsession-control-and-routing","title":"CSCFs Role in Call/Session Control and Routing","text":""},{"location":"blog/20231108/20231108/#session-setup-and-control","title":"Session Setup and Control","text":"<ul> <li> <p>P-CSCF: Acts as the first point of contact for UE and handles initial session signaling. It forwards requests to the appropriate destination, facilitating session establishment.</p> </li> <li> <p>I-CSCF: Serves as the entry point within the operator's network for connections directed to a user. It assigns a S-CSCF during SIP registration and routes requests/responses accordingly.</p> </li> <li> <p>S-CSCF: Manages session control services for the UE. It maintains a session state as required by the network operator and controls sessions for registered endpoints.</p> </li> </ul>"},{"location":"blog/20231108/20231108/#authentication-and-authorization","title":"Authentication and Authorization","text":"<ul> <li> <p>P-CSCF: May perform Registrar functions, accepting registration requests from the UE and making information available through the location server (e.g., HSS).</p> </li> <li> <p>S-CSCF: Manages authentication and authorization for the UE, ensuring secure access to network services.</p> </li> </ul>"},{"location":"blog/20231108/20231108/#routing-and-interrogation","title":"Routing and Interrogation","text":"<ul> <li>I-CSCF: Routes SIP requests received from other networks towards the appropriate S-CSCF. It retrieves the S-CSCF address from the HSS and forwards requests/responses accordingly.</li> </ul>"},{"location":"blog/20231108/20231108/#service-enforcement","title":"Service Enforcement","text":"<ul> <li>S-CSCF: Enforces services by providing endpoints with service event-related information, such as notification of tones/announcements, location of additional media resources, and billing notifications.</li> </ul>"},{"location":"blog/20231108/20231108/#interworking-with-other-networks","title":"Interworking with Other Networks","text":"<ul> <li>S-CSCF: Depending on operator policy, may forward SIP requests or responses to SIP servers located within an ISP domain outside of the IMS Core Network. It can also forward requests for call routing to the PSTN or CS Domain.</li> </ul>"},{"location":"blog/20231108/20231108/#architecture-and-interfaces-of-ims","title":"Architecture and Interfaces of IMS","text":""},{"location":"blog/20231108/20231108/#architecture-of-ims","title":"Architecture of IMS","text":""},{"location":"blog/20231108/20231108/#mgcfmedia-gateway-control-function","title":"MGCF(Media Gateway Control Function)","text":"<p>The MGCF is a crucial component within the IMS architecture. Its primary role is to facilitate the interconnection between the IMS network and circuit-switched networks, such as the Public Switched Telephone Network (PSTN) or the Circuit-Switched domain.</p>"},{"location":"blog/20231108/20231108/#asapplication-server","title":"AS(Application Server)","text":"<p>An AS in the context of the IMS is a critical component responsible for providing various value-added services to users within the IMS network. The AS hosts and executes applications that deliver a wide range of services, enriching the user experience with multimedia capabilities.</p>"},{"location":"blog/20231108/20231108/#tas-telephony-application-server","title":"TAS (Telephony Application Server)","text":"<p>The TAS is a critical component within the IMS architecture. It plays a key role in delivering advanced telephony services and features in a multimedia-rich environment. The TAS is responsible for the provisioning, execution, and control of telephony-related applications and services within the IMS network.</p>"},{"location":"blog/20231108/20231108/#p-cscf","title":"P-CSCF","text":"<p>As described above.</p>"},{"location":"blog/20231108/20231108/#i-cscf","title":"I-CSCF","text":"<p>As described above.</p>"},{"location":"blog/20231108/20231108/#s-cscf","title":"S-CSCF","text":"<p>As described above.</p>"},{"location":"blog/20231108/20231108/#hss","title":"HSS","text":"<p>As described above.</p>"},{"location":"blog/20231108/20231108/#interfaces-of-ims","title":"Interfaces of IMS","text":""},{"location":"blog/20231108/20231108/#gm-interface","title":"Gm Interface","text":"<ul> <li>Description: The Gm Interface plays a pivotal role in all user-based communications. It serves as the link between the UE and the P-CSCF, facilitating various functions such as registration, de-registration, handling incoming and outgoing calls, managing SIP signaling, and enabling any form of communication between the user and the IMS network. To ensure security, the Gm and Mw Interfaces are physically isolated. This interface is responsible for authentication, encryption, and comprehensive session control. Gm utilizes SIP and SDP protocols.</li> <li>Function: Facilitates connectivity between the UE and the IMS network for tasks including registration, authentication, encryption, and session control.</li> </ul>"},{"location":"blog/20231108/20231108/#mw-interface","title":"Mw Interface","text":"<ul> <li>Description: The Mw Interface facilitates communication between CSCF nodes within the IMS core network. Usually, the Session Border Controller (SBC) hosts the P-CSCF, establishing a connection to the I/S-CSCF through the Mw Protocol. Mw employs SIP and SDP Protocols to enable this connectivity.</li> <li>Function: Facilitates message exchange between CSCFs (e.g., from P-CSCF to S-CSCF)</li> </ul>"},{"location":"blog/20231108/20231108/#isc-interface","title":"ISC Interface","text":"<ul> <li>Description: The ISC interface establishes connectivity between the S-CSCF and TAS (Telephony Application Server). This interface engages with the MMTel supplementary services deployed on the TAS, utilizing the IMS Service Control Interface to request services. Additionally, it accommodates TAS-initiated requests to the IMS.</li> <li>Function: The S-CSCF interacts with the MMTel supplementary services integrated into the TAS.</li> </ul>"},{"location":"blog/20231108/20231108/#sh-interface","title":"Sh Interface","text":"<ul> <li>Description: The Sh Interface is employed between the TAS and HSS to facilitate the exchange of User Profile information, encompassing service-related details, user location information, and charging function data. It enables the transmission of service and subscriber-related information from the HSS to the TAS. This operation is akin to a Location Update between the HSS and TAS. Sh operates using the Diameter protocol.</li> <li>Function: The TAS retrieves user profiles from the HSS and activates services for the user.</li> </ul>"},{"location":"blog/20231108/20231108/#cx-interfaces","title":"Cx Interfaces","text":"<ul> <li>Description:The Cx Interface is utilized between the I/S-CSCF and HSS to download subscriber data from the HSS to the S-CSCF. It enables IMS registration and the transfer of subscriber data to the S-CSCF. Cx operates on the Diameter protocol.</li> <li>Function: The I/S-CSCF communicates with the HSS to retrieve user profiles, assisting in user registration and authentication.</li> </ul>"},{"location":"blog/20231108/20231108/#rx-interface","title":"Rx Interface","text":"<ul> <li>Description: The Rx interface serves as a bridge between the IMS Network and the Packet Core. It operates between the P-CSCF and the PCRF, enabling the request of an appropriate policy for session establishment, including both incoming and outgoing voice calls. The Rx Interface plays a crucial role in controlling the setup of various call types, thereby authorizing and managing resource usage in the access networks. It operates on the Diameter protocol.</li> <li>Function: Establishing a suitable policy for incoming or outgoing calls on the network through PCRF.</li> </ul>"},{"location":"blog/20231108/20231108/#mg-interface","title":"Mg Interface","text":"<ul> <li>Description: The Mg Interface facilitates the transmission of SIP messages between an S/I-CSCF and an MGCF for signaling purposes. It is utilized for the exchange of signaling between the CSCF and Media Gateway for calls coming and going towards circuit core networks.</li> <li>Function: Facilitates interworking with the circuit-switched network for the CSCF.</li> </ul>"},{"location":"blog/20231108/20231108/#reference","title":"Reference","text":"<p>3GPP TS 29 163: \"Interworking between the IP Multimedia (IM) Core Network (CN) subsystem and Circuit Switched (CS) networks\"</p> <p>3GPP TS 22.228: \"Service requirements for the Internet Protocol (IP) multimedia core network subsystem (IMS) - Stage 1\"</p> <p>3GPP TS 23.218: \"IP Multimedia (IM) session handling; IM call model; Stage 2\"</p> <p>3GPP TS 23.228: \"IP Multimedia Subsystem (IMS) - Stage 2\"</p> <p>3GPP TS 24.229: \"IP multimedia call control protocol based on Session Initiation Protocol (SIP) and Session Description Protocol (SDP) - Stage 3\"</p> <p>3GPP TS 29.228: \"IP Multimedia (IM) Subsystem Cx and Dx Interfaces; Signalling flows and message contents\"</p>"},{"location":"blog/20231108/20231108/#about","title":"About","text":"<p>Hello, I am Elisa Lee. My ongoing research revolves around VoNR (Voice over New Radio). I encourage any inquiries or identification of errors within the article, as they are welcomed for correction. Your feedback is invaluable, so please don't hesitate to reach out via email to share your insights.</p>"},{"location":"blog/20231115/free5GC_OAuth2_Procedure/","title":"Introduction to free5GC OAuth2 Procedure","text":"<p>Note</p> <p>Author: Andy Chen (CTFang, Tsung-Fang Chen) Date: 2023/11/15 Update: 2024/02/21</p> <p></p> <p>Description</p> <p>[0-0]. NF_Registration: See TS 29.510 Section5.2.2.2 NFRegister for more details.</p> <p>[0-1]. When an NF registers with NRF using NFProfile, NRF adds <code>CustomInfo.oauth2=true</code> to NFProfile and replies to NF upon successful registration. (See TS29.510 for more detailed information about CustomInfo.)</p> <p>[1]. The <code>GetTokenCtx()</code> function generates a context and inserts the access token into the request header.</p> <p>[2]. If the token has expired, the NF would use <code>SendAccTokenReq()</code> to obtain a new token from NRF.</p> <p>[3]. NRF would verify the request NFType and the requested service for authorization, and issue the token if authorized.</p>"},{"location":"blog/20231115/free5GC_OAuth2_Procedure/#note","title":"Note","text":"<p>The OAuth2 functions had been relased in free5GC v3.4.0.</p>"},{"location":"blog/20231115/free5GC_OAuth2_Procedure/#pull-requests","title":"Pull Requests","text":"<ul> <li>free5gc/NRF PR#27</li> <li>free5gc/free5gcPR#525</li> <li>There would be related Pull Request for each NF.</li> </ul>"},{"location":"blog/20231115/free5GC_OAuth2_Procedure/#future-work","title":"Future Work","text":"<ul> <li> <p><code>allowedNfTypes</code>: TS 29.510 Section6.1.6.2.2 Definition of type NFProfile</p> <p>When NRF verifies the scope during the AccessTokenRequest, it checks the target NF's NFProfile allowedNfTypes to determine whether the NF consumer is in the allowedNfType or not.</p> </li> <li> <p>TLS Mutual Authentication: TS 33.501 Section13.3.1 Authentication &amp; Authorization between NF and NRF</p> <p>Authentication and authorization between NF and NRF are completed if PLMN uses protection at the transport layer with mutual authentication.</p> </li> </ul>"},{"location":"blog/20231115/free5GC_OAuth2_Procedure/#about","title":"About","text":"<p>Hello, I am Andy Chen. I have just started making contributions to the free5GC core network. This post is my first blog, so if there are any inquiries or identification of errors within, we welcome discussion and correction. Your feedback is invaluable, so please don't hesitate to reach out via email to share your insights.</p>"},{"location":"blog/20231115/free5GC_OAuth2_Procedure/#connect-with-me","title":"Connect with Me","text":"<ul> <li> <p>Linkedin: https://www.linkedin.com/in/tsung-fang-chen-437a71191/</p> </li> <li> <p>Github: https://github.com/andy89923</p> </li> </ul>"},{"location":"blog/20231115/free5GC_OAuth2_Procedure/#appendix","title":"Appendix","text":"<p>Additionally, I have provided the graph with a dark background.</p> <p></p>"},{"location":"blog/20231122/20231122/","title":"Nephio: a Cloud Native Network Automation Linux Foundation Project","text":"<p>Note</p> <p>Author: Brian Chen (\u9673\u715c\u76db) Date: 2023/11/08</p> <p>As a free5GC maintainer, I'm excited to see a Linux Foundation project that utilizes our open-source software. Let's explore what Nephio can do. I will briefly introduce what is Nephio and then demonstrate how to install the free5gc-operator.</p>"},{"location":"blog/20231122/20231122/#nephios-goal","title":"Nephio's Goal","text":"<p>Nephio delivers carrier-grade, simple, open, Kubernetes-based cloud native intent automation and common automation templates that materially simplify the deployment and management of multi-vendor cloud infrastructure and network functions across large-scale edge deployments. It brings zero-touch provisioning of cloud infrastructure and network functions, which can offer increased network availability and resiliency while reducing maintenance downtime.</p>"},{"location":"blog/20231122/20231122/#what-problem-does-nephio-solve","title":"What Problem Does Nephio Solve?","text":"<p>Distributed cloud technologies facilitate edge access through on-demand, API-driven mechanisms. Regrettably, prevailing imperative, fragile, and fire-and-forget orchestration techniques face challenges in fully exploiting the dynamic capabilities inherent in these innovative infrastructure platforms. To achieve success in this domain, Nephio employs novel methodologies capable of navigating the intricacies associated with provisioning and overseeing a distributed, multi-vendor, multi-site deployment of interconnected network functions within on-demand distributed cloud environments.</p> <p>The objective of the solution is to handle the initial provisioning of network functions and the underlying cloud infrastructure. Additionally, it incorporates Kubernetes-enabled reconciliation to ensure network resilience amid failures, scaling occurrences, and alterations within the distributed cloud.</p>"},{"location":"blog/20231122/20231122/#benefits-of-kubernetes-based-cloud-native-automation","title":"Benefits of Kubernetes Based Cloud Native Automation","text":"<p>It enables multi-vendor support, faster onboarding, easier lifecycle management, embedded control-loop, active reconciliation, and service assurance, reducing costs through efficiency and agility. A common cloud-based automation framework, based on well-proven Kubernetes technology, minimizes the need for custom automation solutions for each application. Multi-vendor integration is enabled, improving customer experience.</p>"},{"location":"blog/20231122/20231122/#kubernetes-as-a-uniform-automation-control-plane","title":"Kubernetes as a Uniform Automation Control Plane","text":"<p>We can broadly think of three layers in the stack:</p> <ol> <li> <p>cloud infrastructure Nephio releases Custom Resource Definitions (CRDs) and operators built on Kubernetes for automation in both public and private cloud infrastructures, aligning with industry standards like the O-RAN O2 interface. These CRDs and operators have the capability to leverage established projects within the Kubernetes ecosystem as interchangeable southbound interfaces (such as Google Config Connector, AWS Controllers for Kubernetes, and Azure Service Operator). This establishes an open integration point, ensuring a more consistent approach to automation across various service providers.</p> </li> <li> <p>workload (network function) resources It covers configuring the provisioning of network function containers and the associated requirements for nodes and network fabric. This encompasses native Kubernetes primitives and industry extensions like multi-network Pods, SR-IOV, and similar technologies. Currently, efficient utilization of these features demands intricate Infrastructure-as-Code templates tailored to specific network functions. Nephio aims to simplify this process by adopting a Configuration-as-Data approach, utilizing Kubernetes CRDs and well-structured schemas to enable robust, standards-based automation for network function configuration.</p> </li> <li> <p>workload (network function) configuration. Nephio starts by offering tools and libraries to support vendors in merging their current Yang and other industry models with Nephio, complying with standards (e.g., 01, 3GPP interface specs). To completely grasp the advantages of cloud-native automation, these models must transition to Kubernetes CRDs since these configurations are closely linked to those elucidated in (2). Nephio furnishes identical tooling across each stratum, facilitating the automation of interconnected configurations amidst these layers.</p> </li> </ol> <p></p> <p>Configuration Layers</p>"},{"location":"blog/20231122/20231122/#nephio-release-1","title":"Nephio Release 1","text":"<p>Project Nephio announced the availability of Release 1 (R1) on August, 2023.</p> <p>Nephio R1 brings revolutionary advancements in deployment, life cycle management and scaling of telecom cloud infrastructure and network functions by using Kubernetes cloud native technologies and intent-based automation.</p> <p>For more details, see Learning Nephio R1.</p> <p>Release 1 highlights:</p> <ul> <li>A framework to orchestrate cloud native network functions (CNF), infrastructure, and cross-domain lifecycle management</li> <li>Core Nephio principles and Kubernetes integration with custom resource definitions (CRDs).</li> <li>Enhanced user experience and sandbox environment.</li> </ul>"},{"location":"blog/20231122/20231122/#prove-of-concept-free5gc-operator","title":"Prove-of-Concept: free5gc-operator","text":"<p>You can refer to the PowerPoint presentations and YouTube videos they have posted to fully grasp the entire concept and architecture. Here, I attach some architectural diagrams of free5gc-operator below, but for more detailed information, I recommend watching the videos.</p> <p></p> <p>Nephio project utilizes KPT, a toolkit develop by Google, which help you manage, manipulate, customize, and apply Kubernetes Resource configuration data files. KPT supports management of Configuration as Data, which is an approach to management of configuration which</p> <ul> <li>makes configuration data the source of truth, stored separately from the live state</li> <li>uses a uniform, serializable data model to represent configuration</li> <li>separates code that acts on the configuration from the data and from packages / bundles of the data</li> <li>abstracts configuration file structure and storage from operations that act upon the configuration data; clients manipulating configuration data don't need to directly interact with storage (git, container images)</li> </ul> <p></p> <p></p>"},{"location":"blog/20231122/20231122/#what-does-nephio-free5gc-operator-do","title":"What does Nephio free5gc-operator do?","text":"<ol> <li>Reconciles {AMF,SMF,UPF}Deployment CustomResources (CRs)</li> <li>For all three NFs, they each have a Deployment and a ConfigMap Kubernetes object, and for AMF and SMF, they also have a Service resource<ul> <li>Determines resource needs based on capacity input</li> <li>Builds these K8s objects with XXXDeployment CRs fields as input</li> </ul> </li> <li>Manages dependencies<ul> <li>Ensures that the corresponding NADs exist in namespace</li> <li>Creates ConfigMap before applying Deployment</li> </ul> </li> <li>Associates objects with CR</li> <li>Updates status for XXXDeployment</li> <li>Ensures ConfigMap updates will lead to Deployment update</li> </ol>"},{"location":"blog/20231122/20231122/#environment-setup","title":"Environment Setup","text":"<p>Before cloning and launching a free5gc-operator, you need to setup an environment which matches the official demonstration. The official recommendation includes two installation methods:</p> <ul> <li>through the Google Compute Engine (GCE) to set up the environment with an account of Google Cloud Platform,</li> <li>directly preparing a Pre-Provisioned VM to set up the environment required for free5gc-operator.</li> </ul> <p>Warning</p> <p>Due to the mandatory hardware resource requirements set by the official guidelines, which include an 8-core CPU, 16 GB of memory, 200 GB disk, the resources needed are quite &gt;substantial. If you operate on the Google Cloud Native platform, you may incur significant charges on your credit card. Therefore, I recommend installing the environment on a virtual &gt;machine (VM) on your local machine for follow-on exercises.</p>"},{"location":"blog/20231122/20231122/#installation-on-pre-provisioned-vm","title":"Installation on Pre-Provisioned VM","text":"<p>After completing the Ubuntu 20.04 focal installation, you need to get a sudo passwordless permissions. Edit <code>/etc/sudoers</code>: <pre><code>$ sudo vim /etc/sudoers\n</code></pre></p> <p>Add 2 lines:</p> <pre><code>&lt;linux username&gt;   ALL=(ALL:ALL) NOPASSWD:ALL\nsudo    ALL=(ALL:ALL) NOPASSWD:ALL\n</code></pre>"},{"location":"blog/20231122/20231122/#kick-off-an-installation-on-vm","title":"Kick Off an Installation on VM:","text":"<p><pre><code>wget -O - https://raw.githubusercontent.com/nephio-project/test-infra/v1.0.1/e2e/provision/init.sh |  \\\nsudo NEPHIO_DEBUG=false   \\\n     NEPHIO_BRANCH=v1.0.1 \\\n     NEPHIO_USER=&lt;linux username&gt;   \\\n     bash\n</code></pre> The next step is to wait for Ansible to automatically set up the environment. The entire process may take approximately 10 minutes, so please be patient. Once it is completed, ssh in and port forward the port to the UI (7007) and to Gitea's HTTP interface, if desired (3000):</p> <p><pre><code>ssh &lt;user&gt;@&lt;vm-address&gt; \\\n                -L 7007:localhost:7007 \\\n                -L 3000:172.18.0.200:3000 \\\n                kubectl port-forward --namespace=nephio-webui svc/nephio-webui 7007\n</code></pre> You can now navigate to:</p> <ul> <li> <p>http://localhost:7007/config-as-data to browse the Nephio Web UI </p> </li> <li> <p>http://localhost:3000/nephio to browse the Gitea UI </p> </li> </ul>"},{"location":"blog/20231122/20231122/#free5gc-amfsmfupf-deployments-prerequisite-automatically-done-in-environment-setup","title":"free5GC AMF/SMF/UPF Deployment's Prerequisite (automatically done in environment setup)","text":"<ol> <li>Install multus</li> <li>Install CNI binary (macvlan) on all hosts that can possibly run free5gc AMF, SMF, or UPF</li> <li>Install gtp5g on nodes that could run UPF</li> <li>Install sctp on nodes that could run AMF</li> <li>Connectivity:     a. IP address allocation and reachability</li> <li>Network Attachment Definitions (NADs) for all the secondary interfaces</li> <li>3GPP related configs (PLMN, S-NSSAI info)</li> <li>free5gc SMF config requires connected UPF information</li> <li>Client (such as UERANSIM) set up with corresponding IP addresses and 3GPP info</li> </ol>"},{"location":"blog/20231122/20231122/#quick-start-exercises","title":"Quick Start Exercises","text":"<p>You can follow the tutorial steps in this page. I won't show all detail in this article. I only list the action of all steps:</p> <ul> <li>Step 1: Create the Regional cluster</li> <li>Step 2: Check the Regional cluster installation</li> <li>Step 3: Deploy two Edge clusters</li> <li>Step 4: Deploy Free5GC Control Plane Functions</li> <li>Step 5: Deploy Free5GC Operator in the Workload clusters</li> <li>Step 6: Check Free5GC Operator Deployment</li> <li>Step 7: Deploy the AMF, SMF and UPF NFs</li> <li>Step 8: Deploy UERANSIM</li> <li>Step 9: Change the Capacities of the UPF and SMF NFs</li> </ul>"},{"location":"blog/20231122/20231122/#reference","title":"Reference","text":"<ul> <li>https://nephio.org/</li> <li>https://nephio.org/about/</li> <li>https://github.com/nephio-project/docs/blob/main/install-guide/README.md#demonstration-environment-installation</li> <li>https://github.com/nephio-project/docs/blob/main/user-guide/exercises.md</li> <li>https://pkg.go.dev/github.com/GoogleContainerTools/kpt#section-readme</li> </ul>"},{"location":"blog/20231122/20231122/#about","title":"About","text":"<p>Hello everyone, I'm Brian Chen (\u9673\u715c\u76db). Currently, I am pursuing a master's degree and have been interning at Saviah for 10 months. My current role involves maintaining free5GC and reviewing issues and PR. Additionally, I am researching Kubernetes with the aim of improving the efficiency of deployment experiences for free5GC. There is still a lot of knowledge for me to acquire, so please feel free to contact me if you have any questions or would like to discuss anything.</p> <ul> <li>My GitHub</li> <li>LinkedIn</li> </ul>"},{"location":"blog/20231129/20231129/","title":"Basic concept of RCU: Read, Copy, Update","text":"<p>Note</p> <p>Author: Lin Poyi Date: 2023/11/29</p>"},{"location":"blog/20231129/20231129/#what-is-rcu","title":"What is RCU","text":"<p>RCU is a lock-free synchronization mechanism in Linux kernel, and we use it in gtp5g. RCU is a way of making changes to data structures that are mostly read by many threads but rarely updated by a few threads. RCU stands for \u201cRead, Copy, Update\u201d, which means that the updater thread first makes a copy of the data item, modifies the copy, and then replaces the original with the copy. It works very well and has great scalability under read-heavy use cases. Compared with Reader-Writer lock (RWlock) and other lock-based approaches, RCU is a lot faster but does not provide strong consistency over data.</p> <p>In RCU, there's nothing blocking readers from entering the critical section. The reader can access the protected data at all times. Also, the updater can modify the data whenever it wants (assume only 1 updater) no matter if there are still readers using the data.</p>"},{"location":"blog/20231129/20231129/#drawbacks-of-reader-writer-lock-rwlock","title":"Drawbacks of Reader-Writer lock (RWlock)","text":"<ol> <li>It is expensive and complex to implement, especially for fine-grained locking of individual data items.</li> <li>It can cause contention and scalability issues, especially when the number of readers is large or the lock is held for a long time.</li> <li>It can introduce deadlocks and livelocks, especially when the locking order is not well-defined or the lock is nested or reentrant.</li> </ol>"},{"location":"blog/20231129/20231129/#benefits-of-rcu","title":"benefits of RCU","text":"<ol> <li>It is faster and more scalable for read-intensive workloads because the readers do not need to wait for the updaters or contend for shared resources.</li> <li>It is simpler and more reliable for avoiding deadlocks because the readers do not need to acquire any locks or follow any ordering rules.</li> <li>It is more flexible and adaptable for different scenarios because there are many variants of RCU that can handle different types of updates and readers.</li> </ol>"},{"location":"blog/20231129/20231129/#how-to-use-rcu","title":"How to use RCU","text":"<p>While using RCU, there are some rules to be followed: 1. You need to mark the sections of code where you access the RCU-protected data structures as \u201cRCU read-side critical sections\u201d, using the appropriate RCU primitives, such as rcu_read_lock() and rcu_read_unlock(). 2. You need to mark the sections of code where you modify the RCU-protected data structures as \u201cRCU update-side critical sections\u201d, using the appropriate RCU primitives, such as call_rcu() and synchronize_rcu(). 3. You need to ensure that the RCU read-side critical sections are short and do not block, switch to user mode, or enter the idle loop unless you use a special variant of RCU that allows blocking, such as SRCU or preemptible RCU. 4. You need to ensure that the RCU update-side critical sections wait for a \u201cgrace period\u201d to elapse before freeing or reusing the old versions of the data items and that the grace period is long enough that all the readers have finished accessing the old versions.</p> <p>Note</p> <p>Grace period is the time between the data being changed by the updater and the time when all readers are using the new data. During the grace period, some readers may be using the old data, some may be using the new data.</p>"},{"location":"blog/20231129/20231129/#main-rcu-apis","title":"main RCU APIs","text":"<ol> <li>rcu_read_lock(): Inform others the reader is entering the critical section, does not actually block anyone from entering the critical section.</li> <li>rcu_read_unlock(): Inform others the reader has exit critical section.</li> <li>rcu_assign_pointer(): Using this API instead of directly assign pointer with \"=\" can avoid pointer been assigned before the update_data() been done due to CPU's out-of-order execution.</li> <li>syncronize_rcu(): Wait for readers who are already in the critical section and haven't left yet. Used after updating the data and before the old data has been released.</li> <li>call_rcu(): this function is the asyncronized version of syncronize_rcu(), it will return right after it scedules a handler (clean up the old data) to be performed after all previous readers left C.S.(critical section) We use this instead of the syncronized version in gtp5g.</li> </ol>"},{"location":"blog/20231129/20231129/#pseudo-code-for-reader-and-updater","title":"pseudo code for reader and updater","text":"<p><pre><code>void Reader(){\n    rcu_read_lock();    //enter C.S. (critical section)\n    item *data = Item_A;\n    access_data(data);\n    rcu_read_unlock();  //leave C.S.\n    return;\n}\n</code></pre> <pre><code>void Updater(){\n    item *old_data = Item_A;  //save the old location\n    item *new_data = new(item);    //make a new item\n    update_data(new_data);   //modify the data in new item\n    rcu_assign_pointer(Item_A, new_data);   //now the global pointer points to the new item\n    syncronize_rcu();   //wait for all readers using old_data to leave C.S.\n    kfree(old_data);  //now we can safely release the old_data\n    return;\n}\n</code></pre> </p>"},{"location":"blog/20231129/20231129/#another-version-of-updater-with-call_rcu","title":"another version of Updater with call_rcu()","text":"<p><pre><code>void item_free(item *data){\n    kfree(data);\n    return;\n}\nvoid Updater(){\n    item *old_data = Item_A;  //save the old location\n    item *new_data = new(item);    //make a new item\n    update_data(new_data);   //modify the data in new item\n    rcu_assign_pointer(Item_A, new_data);   //now the global pointer points to the new item\n    call_rcu(old_data, item_free);   //schedule item_free(old_data) to be performed after all previous readers left C.S. and return immediately\n    return;\n}\n</code></pre> </p> <p>When the updater tries to update the data, the data doesn't get replaced instantly. The pointer will point to new data, but the old data still exists in the memory. This method prevents readers who are still accessing the old data from accessing the released memory and also allows updates before all readers leave the critical section.</p>"},{"location":"blog/20231129/20231129/#comparison-between-rcu-and-rwlock","title":"Comparison between RCU and RWlock","text":"<p>scalability of RWlock and RCU </p> <p>The graph above shows that RCU not only has better scalability with CPUs but also has better overall performance, which is not surprising when we look at the CPU utilization difference between RWlock and RCU in the graph shown below. But keep in mind that RCU does not guarantee that all readers running simultaneously have the same version of data, but RWlock does. Also if there's more than one updater, you might need some locks to prevent multiple updates been performed at the same time.</p> <p>What it might look like in the CPUs while running these two methods </p>"},{"location":"blog/20231129/20231129/#reference","title":"Reference","text":"<p>https://www.kernel.org/doc/html/next/RCU/whatisRCU.html</p> <p>https://hackmd.io/@cccccs100203/So-What-Has-RCU-Done-Lately</p> <p>Linux kernel design: RCU synchronization mechanism</p> <p>So What Has RCU Done Lately?</p>"},{"location":"blog/20231206/20231206/","title":"Introduction of IP Multimedia Subsystem Part 2","text":"<p>Note</p> <p>Author: TzuChieh Huang Date: 2023/12/06</p> <p>In the rapidly evolving landscape of telecommunications, the IP Multimedia Subsystem (IMS) stands as a linchpin for delivering advanced multimedia and voice services over IP networks. As explored in the preceding introduction (IMS Part 1), IMS serves as a standardized and open architectural framework defined by the 3rd Generation Partnership Project (3GPP). Its role in facilitating seamless communication services, including voice, video, messaging, and data, highlights its pivotal position in modern network infrastructures. Building upon the foundational knowledge established in IMS Part 1, this section will delve into the IMS registration.</p>"},{"location":"blog/20231206/20231206/#interaction-and-flow-of-registration","title":"Interaction and flow of Registration","text":""},{"location":"blog/20231206/20231206/#procedures-related-to-proxy-cscf-discovery","title":"Procedures related to Proxy-CSCF discovery","text":"<p>P-CSCF(Proxy-Call Session Control Function) is the initial point of contact for UE when establishing communication sessions. Therefore, P-CSCF discovery is a crucial step in IMS architecture. It involves the process of determining the network address of P-CSCF that the UE(User Equipment) should contact during the initiation of the communication session.</p> <p>The Proxy-CSCF discovery shall be performed using the following mechanisms:</p> <ul> <li>During the establishment of connectivity to the IP-Connectivity Access Network, provided that the IP-Connectivity Access Network supports such procedures.</li> <li>Alternatively, the P-CSCF discovery may take place after the IP connectivity has been established. To enable P-CSCF discovery after the establishment of IP connectivity, the IP-Connectivity Access Network shall provide the following P-CSCF discovery option to the UE:<ul> <li>Utilizing DHCP to furnish the UE with the domain name and/or IP address of a Proxy-CSCF, along with the address of a Domain Name Server (DNS) capable of resolving the Proxy-CSCF name</li> <li>The UE may be configured (e.g., during initial provisioning or via a 3GPP IMS Management Object (MO), or in the ISIM) to be aware of the fully qualified domain name (FQDN) of the P-CSCF or its IP address. If the domain name is known, DNS resolution is employed to obtain the IP address.</li> </ul> </li> </ul>"},{"location":"blog/20231206/20231206/#dhcpdns-procedure-for-p-cscf-discovery","title":"DHCP/DNS procedure for P-CSCF discovery","text":"<p>When DNS is employed to retrieve the IP address of the P-CSCF, the name-address resolution mechanism is permitted to take the load information of the P-CSCFs. This load information, obtained through network management procedures, is factored in when determining the address of the P-CSCF for the UE.</p> <p></p> <ol> <li> <p>Initiate the establishment of an IP-Connectivity Access Network bearer, utilizing the procedures available in the IP-Connectivity Access Network, if it is not already in place.</p> </li> <li> <p>The UE initiates a request to a DHCP server, seeking the domain name and/or IP address of the P-CSCF, along with the IP addresses of DNS servers. This may involve multiple DHCP Query/Response message exchanges to obtain the necessary information.</p> </li> <li> <p>The UE conducts a DNS query to retrieve a list of IP addresses for the P-CSCF(s), from which one is selected. If the response lacks IP addresses, an additional DNS query becomes necessary to resolve a FQDN to an IP address.</p> <ul> <li>If the UE is aware of multiple P-CSCF addresses, the selection process is determined based on the home operator's configured policy for P-CSCF selection. The policy dictates the criteria or rules according to which one P-CSCF address is chosen over others in such scenarios.</li> <li>Depending on the policy set by the home operator, the UE chooses the Home Proxy-CSCF by using a preconfigured Home P-CSCF FQDN. This selection can be made without P-CSCF discovery procedure.</li> </ul> </li> </ol>"},{"location":"blog/20231206/20231206/#assigning-a-serving-cscf-for-a-user","title":"Assigning a Serving-CSCF for a user","text":"<p>When an UE attaches itself and becomes available for access to IMS services through explicit registration within the IMS, a S-CSCF (Serving-Call Session Control Function)shall be assigned to serve the UE. The S-CSCF plays a central role in call control and service execution for the registered UE within the IMS network.</p> <p>The assignment of a S-CSCF is carried out within the I-CSCF (Interrogating-Call Session Control Function). The selection of the S-CSCF requires the following information:</p> <ol> <li> <p>Required capabilities for user services:</p> <ul> <li>Provided by the HSS (Home Subscriber Server), this information outlines the necessary capabilities for the user's services.</li> </ul> </li> <li> <p>Operator preference on a per-user basis:</p> <ul> <li>Also provided by the HSS, this information reflects the operator's preferences specific to each user.</li> </ul> </li> <li> <p>Capabilities of individual S-CSCFs in the home network:</p> <ul> <li>This internal information within the operator's network, pertaining to the capabilities of individual S-CSCFs, may influence the S-CSCF selection.</li> </ul> </li> <li> <p>Topological (i.e. P-CSCF) information of where the user is located</p> <ul> <li>This internal information within the operator's network, concerning the topological details of the user's location, may be utilized in the S-CSCF selection process. The P-CSCF name is received in the registration request.</li> </ul> </li> <li> <p>Topological information of where the S-CSCF is located</p> <ul> <li>Another internal aspect within the operator's network, this information regarding the topological details of the S-CSCF's location may play a role in S-CSCF selection.</li> </ul> </li> <li> <p>Availability of S-CSCFs</p> <ul> <li>Internal to the operator's network, information about the availability of S-CSCFs may be considered in the S-CSCF selection process.</li> </ul> </li> </ol>"},{"location":"blog/20231206/20231206/#registration-flow","title":"Registration Flow:","text":"<ol> <li> <p>UE to P-CSCF:</p> <ul> <li>After establishing IP connectivity, the UE, such as a mobile device, initiates IM registration by sending a SIP (Session Initiation Protocol) REGISTER request to the P-CSCF. This flow includes essential details such as the Public User Identity, Private User Identity, home network domain name, UE IP address, Instance Identifier, and GRUU (Globally Routable User Agent URI) Support Indication.</li> <li>Upon receiving the Register information flow, the P-CSCF examines the \"home domain name\" to identify the entry point to the home network, which is the I-CSCF.</li> </ul> </li> <li> <p>P-CSCF to I-CSCF:</p> <ul> <li>The P-CSCF forwards the Register information flow to the I-CSCF, including details such as the P-CSCF address/name, Public User Identity, Private User Identity, P-CSCF network identifier, and UE IP address.</li> </ul> </li> <li> <p>I-CSCF to HSS:</p> <ul> <li>The I-CSCF initiates the Cx-Query/Cx-Select-Pull information flow, sending relevant information to the HSS to perform user authentication and retrieve the user's location information. This flow includes the Public User Identity, Private User Identity, and P-CSCF network identifier.<ul> <li>The HSS verifies if the user is already registered and assesses whether the user is permitted to register in the specified P-CSCF network based on user subscription and operator limitations/restrictions.</li> </ul> </li> <li>Upon receiving Cx-Query Resp/Cx-Select-Pull Resp from the HSS, which includes the S-CSCF name or capabilities, the I-CSCF constructs a name from the capabilities, if necessary. The registration attempt is rejected if the HSS checking is unsuccessful.</li> </ul> </li> <li> <p>I-CSCF to S-CSCF:</p> <ul> <li> <p>The I-CSCF, using the S-CSCF name, determines the address of the S-CSCF through a name-address resolution mechanism. The load information of the S-CSCFs is considered in the resolution process. The I-CSCF also identifies the name of a suitable home network contact point, potentially based on information received from the HSS. The I-CSCF then sends the register information flow (P-CSCF address/name, Public User Identity, Private User Identity, P-CSCF network identifier, UE IP address) to the selected S-CSCF.</p> </li> <li> <p>The S-CSCF rejects the registration if the number of registered contact addresses for a Public User Identity exceeds the configured limit. The S-CSCF stores the P-CSCF address/name supplied by the visited network, representing the address/name that the home network uses to forward subsequent terminating session signaling to the UE. The S-CSCF stores the P-CSCF Network ID information.</p> </li> </ul> </li> <li> <p>S-CSCF to HSS:</p> <ul> <li>The S-CSCF communicates with the HSS to retrieve user profiles and perform tasks like registration and authentication.<ul> <li>The S-CSCF sends Cx-Put/Cx-Pull (Public User Identity, Private User Identity, S-CSCF name) to the HSS.</li> <li>The HSS stores the S-CSCF name for the user and returns the information flow Cx-Put Resp/Cx-Pull Resp (user information) to the S-CSCF. The user information includes one or more names/addresses that can be used to access the platforms used for service control while the user is registered. Security information may also be sent for use within the S-CSCF.</li> </ul> </li> </ul> </li> <li> <p>S-CSCF to AS (Application Server):</p> <ul> <li>The S-CSCF may interact with Application Servers for additional services.</li> </ul> </li> <li> <p>S-CSCF to TAS (Telephony Application Server):</p> <ul> <li>The S-CSCF interfaces with the TAS for services related to MMTel (MultiMedia Telephony) supplementary services.</li> </ul> </li> <li> <p>S-CSCF to MGCF (Media Gateway Control Function):</p> <ul> <li>The S-CSCF may communicate with the MGCF for signaling purposes.</li> </ul> </li> </ol>"},{"location":"blog/20231206/20231206/#conclusion","title":"Conclusion","text":"<p>IMS registration is a fundamental process in the IMS that establishes connectivity for UE to access advanced multimedia and voice services over IP networks. The IMS operates as a standardized and open architectural framework defined by the 3GPP. Through standardized protocols, IMS ensures secure and seamless communication services, making it a crucial framework in modern telecommunications.</p>"},{"location":"blog/20231206/20231206/#reference","title":"Reference","text":"<p>3GPP TS 22.228: \"Service requirements for the Internet Protocol (IP) multimedia core network subsystem (IMS) - Stage 1\"</p> <p>3GPP TS 23.218: \"IP Multimedia (IM) session handling; IM call model; Stage 2\"</p> <p>3GPP TS 23.228: \"IP Multimedia Subsystem (IMS) - Stage 2\"</p> <p>3GPP TS 29.228: \"IP Multimedia (IM) Subsystem Cx and Dx Interfaces; Signalling flows and message contents\"</p>"},{"location":"blog/20231206/20231206/#about","title":"About","text":"<p>Hello, I am TzuChieh Huang. My ongoing research focuses on VoNR (Voice over New Radio). Feel free to reach out and share any inquiries or point out errors in the article. I welcome corrections and value your feedback. Please don't hesitate to contact me via email to contribute your insights.</p>"},{"location":"blog/20231213/20231213/","title":"Article Sharing: Evaluating Dedicated Slices of Different Configurations in 5G Core","text":"<p>Note</p> <p>Author:Leon Sawada(\u6fa4\u7530\u535a\u4e45) Date: 2023/12/13</p>"},{"location":"blog/20231213/20231213/#overview","title":"Overview","text":"<p>Network slicing is a new concept born after the emergence of 5G. Network slicing and edge computing (Multi-access Edge) are both key technologies in 5G networks. Network slicing uses virtualization technology to cut the network into multiple virtual end-to-end networks, and the equipment, access, transmission, and core network between each virtual network are all independent. Dynamic demand, resource adjustment, and improved network flexibility can also reduce the construction cost of hardware resources and network construction time, and achieve hardware resource sharing. Since one of the characteristics of network slicing is its flexibility, this article verifies this very well. In this article, the author uses free5GC, ETSI NFV MANO framework, and other tools, and designs three different slices to show how different configurations of dedicated slices will affect the performance of the 5G core. Finally, discussed which slice should be used in different situations to provide the best service to users.</p>"},{"location":"blog/20231213/20231213/#nfv-mano","title":"NFV MANO","text":"<p>The management and scheduling of the core network mainly uses NFV MANO (Management and Orchestration) technology, which is an architecture proposed by the European Telecom Standards Institute (ETSI) and later adopted by 3GPP to manage 5G core network virtualization. Network function (Virtual Network Function, VNF) specification, NFV MANO allows the core network to adopt a fully virtualized VNF design and better schedule various network slicing functions. MANO of the 5G core network has the ability to manage and schedule VNFs belonging to different slices for different slice services. As shown in the figure, NFV MANO can manage and schedule VNFs of the 5G core network such as AMF, NSSF, NRF, AUSF, and PCF, SMF, UDM, UPF, etc. This will also be paired with the core network in free5GC that we will only use. As you can see: NFV Orchestrator (NFVO), VNF Management (VNFM), and Virtualized Infrastructure Managers (VIM) are three major components in the MANO architecture framework.</p> <p>*NFV Orchestrator: Responsible for supporting new network services (NS) suites and virtual network functions (VNF). Nuclear submarine life cycle management. Global resource management. Review and approve requests for Network Functions Virtualization Infrastructure (NFVI) resources.</p> <p>*VNF Manager: Controls the life cycle management of VNF instances. Performs the function of coordinating and coordinating configuration and event reporting between the NFV infrastructure (NFVI) and network element/network management systems.</p> <p>*Virtualization Infrastructure Manager (VIM): Monitors and manages NFVI compute, storage, and network resources.</p> <p> Figure 1. NFV MANO architecture</p> <p>According to the definition of 3GPP, network slices are composed of multiple network slice sub-networks such as core network, access network, and transport network. NFV MANO plays an important role in mapping each network slice network to network services.</p>"},{"location":"blog/20231213/20231213/#free5gc","title":"free5GC","text":"<p>free5GC is an open-source project for fifth-generation (5G) mobile networks. The ultimate goal of this project is to implement the 5G Core Network (5GC) defined in 3GPP Release 15 (R15) and later.</p> <p>As shown in the figure, NYCU free5GC provides all the functions of a 5G network and is divided into the control plane and the user plane. The control plan includes NSSF, NRF, UDM, PCF, NEF, AUSF, AMF, SMF, UDR, and AF. In the user plane, there is only one network function called UPF. The separation of the user plane and the control plane allows each aircraft to be deployed and evolved independently. NYCU free5GC has also modulated its functional design to make the deployment of network functions in an NFV environment more flexible and efficient.</p> <p> Figure 2. free5GC architecture</p> <p>In addition to free5GC, use MANO open source including OpenStack and Tacker. OpenStack is an open-source cloud operating system that virtualizes resources such as storage, computing, and networking. Most of these virtualized resources are deployed in the cloud as Infrastructure-as-a-service (IaaS). OpenStack provides a web-based interface dashboard. This dashboard allows us to efficiently configure, manage and monitor our virtualization resources. Tacker is an OpenStack project that provides NFVO and VNFM functionality to configure, deploy, manage, and schedule NS and VNFs on NFV infrastructure platforms such as OpenStack. The Tacker API can be used not only by NFV Orchestrator but also by OSS/BSS to deploy VNFs.</p>"},{"location":"blog/20231213/20231213/#three-different-types-of-slice","title":"Three different types of slice","text":""},{"location":"blog/20231213/20231213/#free5gc-stage-3-with-upf-dedicated-slices","title":"free5GC Stage 3 with UPF Dedicated Slices","text":"<p>The image below shows the architecture of free5GC Stage 3, each dedicated slice consisting of only UPF. It uses three dedicated slices to handle three different types of test traffic. Each dedicated slice is connected to a specific data network (DN) server. These UPFs in different dedicated slices share the same SMF in the common slice.</p> <p> Figure 3. free5GC with different configurations of dedicated slices</p> <p>Three traffic generators are provided to simulate the packets that will be sent to the 5GC by the 5G UEs and RAN. Each traffic generator will transmit two types of packets: UDP and ICMP (Internet Control Message Protocol). Each traffic generator Each traffic generator sends UDP packets at different rates: high, medium, and low. All traffic generators send both UDP packets and ICMP packets. This can estimate the throughput of UDP traffic and calculate the response time of ICMP packets. Each network cutter routes packets to a different data network (DN) server. (DN) servers so that can verify successful transmission through the selected UPF.</p> <p>Firstly, the UE will be connected to the RAN within the traffic generator. Secondly, the traffic generator transmits the NGAP Initial UE message to the AMF. This message carries the registration request and the UE information (including UE address IP, SST (Slice/Service Type), and SD (Slice Differentiator)). Thirdly, AMF requests UE authentication from AUSF. If the UE is a valid user, the AUSF accepts the request and transmits the response to the AMF. After that, the AMF transmits the UE information to the NSSF, which then provides a list of available SMFs to the AMF based on the information received. Next, AMF will select a suitable SMF for UE and create a smContext for SMF to establish a new session. Finally, the SMF will select a suitable UPF and establish a PDU (Protocol Data Unit) session between the UE and the selected UPF.</p> <p> Figure 4. Registration workflow of free5GC Stage 3</p> <p>After the registration is complete, the UE can start transmitting packets to its DN server. The transmission workflow is shown in the following figure. First, the UE sends UDP packets and ICMP packets to the UPF through its PDU session. Second, the UPF will forward these packets to a specific DN. Third, the DN will calculate the throughput of the UDP packets received from the UPF. Fourth, when the DN receives an ICMP packet, it will send the ICMP response back to the UPF. Finally, the UPF will forward this ICMP response to the UE; this will allow the UE to calculate the ICMP response time.</p> <p> Figure 5. Transmission workflow</p>"},{"location":"blog/20231213/20231213/#free5gc-stage-3-with-smfupf-dedicated-slices","title":"free5GC Stage 3 with SMF/UPF Dedicated Slices","text":"<p>The architecture of this slice is similar to the previous one, as shown in part b of the figure. Each dedicated slice is composed of SMF and UPF It also uses three dedicated slices to handle different data rate requirements, each connected to a specific DN server. All VNFs use the same resources as the previous VNF. Unlike the previous one, we move the SMF from the common slice to the dedicated slice. Each UPF connects to an SMF in the same dedicated slice and both need to share resources. The traffic generators and DN servers are the same as those used in the previous architecture. The registration workflow is also similar to Fig. 4; the only difference is that in the last step, the SMFs do not need to select the UPFs because the UPFs have already been assigned to each SMF. The SMFs only need to set up PDU sessions between the UEs and the UPFs. After the registration is completed, the transmission workflow is also the same as the previous architecture, as shown in the above figure.</p> <p> Figure 3.free5GC with different configurations of dedicated slices</p>"},{"location":"blog/20231213/20231213/#free5gc-stage-2-with-upf-dedicated-slice","title":"free5GC Stage 2 with UPF Dedicated Slice","text":"<p>The architecture of this slice, with each dedicated shard consisting only of UPFs, is the same as that shown in Figure 3 part(a). The only difference is that the VNF version in this architecture is free5GC Stage 2. VNFs in Stage 2 are less optimized than in Stage 3 The traffic generator and DN server are also the same as in free5GC Stage 3. However, the registration workflow is very different from Stage 3. This is because, in free5GC Stage 2, the NSSF is not utilized to select a dedicated and exclusive slice to serve the requesting UE. It is assumed that the UE will deliver the traffic directly to the allocated slice as shown in Fig. 6. First, the UE will connect to the RAN within the traffic generator. Second, the traffic generator will send a registration request and assign the UPF. Third, the AMF requests the UE authentication from the AUSF. If the UE is a valid user, the AUSF accepts the request and transmits the response to the AMF. Next, the AMF transmits the UE message to the SMF. Finally, the SMF locates the UPF specified by the UE and establishes a PDU session between the UE and the UPF. The transmission workflow in Stage 2 is the same as that in Stage 3, as shown in Fig. 5.</p> <p> Figure 6. Registration workflow of free5GC Stage 2</p>"},{"location":"blog/20231213/20231213/#experiment","title":"Experiment","text":"<p>There are two sumptions: 1st, all the dedicated slices are allocated with the same amount of resources, i.e., to use the same number of vCPU and the same amount of memory and storage. 2nd, all three systems under evaluation are allocated the same amount of resources. We use two identical rack servers, one for OpenStack and one for Tacker. Follow the ETSI MANO framework to build this slicing environment.</p> <p>For the first assumption, the specification of VNFs is divided into two parts:  common slice and dedicated slice. For the common slice, the specifications of all VNFs in the common slice are the same for different systems. As shown in Table 2. For the dedicated slices, we show the VNFs with different specifications in Table 3. Three traffic generators and three DN servers are configured with 2 vCPUs, 1 GB RAM, and 10 GB disks, and mirrored with Ubuntu 18.04.</p> <p> Table 1. Specification of implementation environment</p> <p> Table 2. Specification of VNF in a common slice for the first assumption</p> <p> Table 3. Specification of VNF in the dedicated slice for the first assumption</p> <p>For the second assumption, the specification of VNFs is also divided into two parts: common slices and dedicated slices. For common slices, the resource specifications of VNFs other than SMFs are the same as in Table 2. On the other hand, the resource specifications of SMFs in different configurations are shown in Table 4. Correspondingly, the resource specifications of UPFs in different configurations are shown in Table 5.</p> <p> Table 4. Specification of SMF for second assumption</p> <p> Table 5. Specification of UPF for second assumption</p>"},{"location":"blog/20231213/20231213/#result-and-conclusion","title":"Result and conclusion","text":"<p>Figures 7 and 8 show the average throughput results for three different systems at three UDP packet data rates: low (80 Mbps), medium (200 Mbps), and high (400 Mbps).</p> <p> Figure 7. Average throughput under the first assumption</p> <p> Figure 8. Average throughput under the second assumption</p> <p>Based on the graph, we can see that under the first assumption, free5GC Stage 3 with UPF-specific cuts provides higher throughput than free5GC Stage 3 with SMF/UPF-specific cuts because the former has more vCPU resources than the latter. Compared with free5GC Stage 2, the free5GC Stage 3 system is more optimized.</p> <p>Figures 9 and 10 show the average response time of the three different systems under the two assumptions. As the design of our proposed system is more complicated than that of the comparator system, the average response time becomes more modest. Under the second assumption, both systems have similar response times. However, under the first assumption, the response time of free5GC Stage 3 with UPF-specific slice is shorter because UPF has more vCPU resources.</p> <p> Figure 9. Average response time under the first assumption</p> <p> Figure 10. Average response time under the second assumption</p> <p>Figures 11 and 12 show the average CPU utilization of the two free5GC Stage 3 systems at the three data rates. Under the second assumption, there is no difference in CPU usage between the two free5GC Stage 3 systems. However, under the first assumption, the CPU usage rate is almost the same even if the number of vCPUs used in the UPF is different. However, in both assumptions, if we send more packets from the traffic generator, the CPU usage rate will be higher. This is because CPU usage depends only on the number of packets transmitted. On the other hand, the CPU usage of free5GC Stage 3 with the UPF dedicated cutter is slightly higher than that of free5GC Stage 3 with the SMF/UPF dedicated cutter, because the use of more vCPU resources results in more competitive conditions among CPUs.</p> <p> Figure 11. Average response time under the second assumption</p> <p> Figure 12. Average CPU utilization under the first assumption</p> <p>Figures 13 and Figures 14 show the average registration time in our proposed system. In free5GC Stage 3 with SMF/UPF dedicated slices, SMF does not require the choice of UPF, and thus the registration time is lower under both assumptions. Even though we provide more powerful SMF and UPF dedicated slices in free5GC Stage 3 under the second assumption, the registration process still takes longer. This is because SMF takes extra time to select UPF.</p> <p> Figure 13. Average registration time under the first assumption</p> <p> Figure 14. Average registration time under the second assumption</p> <p>Based on these results lead to the following conclusions: Under the first assumption, moving the SMF from the common slice to the dedicated slice will shorten the registration time, but it will deteriorate the performance of the UPF because fewer resources are allocated to the UPF than before. However, under the second assumption, only the registration time is affected; the performance of the UPF is not affected. This is because the functions in the control plane are no longer involved in the operation when the transfer starts. Therefore, if a large number of connections are required in a short period, moving the SMF from the common slice to the dedicated slice will be a better choice because the registration time of the system is shorter; it can handle a large number of registrations more efficiently. In addition, if users want to get better throughput and shorter response time under the first assumption, it is recommended to keep the SMF in the common slice so that more resources can be allocated to the UPF for better performance. Therefore we know we need to use different network slices based on different scenarios, which is the best proof of the convenience of network slicing.</p> <p>Network slicing is a crucial concept in 5G networks, allowing virtual network functions to form interconnected network services, with dedicated slices being evaluated to determine the best-performing configuration based on various factors. Fuchun Joseph Lin and Yu-Herng Chai described evaluating dedicated slices of different configurations in the 5G core. The text discusses the creation of a common slice and three dedicated slices in a network architecture. The performance of these systems is evaluated based on throughput, response time, CPU utilization, and registration time. The deployment of dedicated slices is experimented with using open-source projects. Moving the SMF from the common slice to the dedicated slice is recommended for handling a large number of connections efficiently. Different resource allocations to dedicated slices are also considered. The performance of the three systems is compared based on registration time, response time, throughput, resource cost, and CPU utilization. The testbed is built using the ETSI NFV MANO framework, free5GC, OpenStack, and Tacker. The goal is to evaluate the performance of different configurations of 5G core dedicated slices. The response time of free5GC Stage 3 with UPF dedicated slice is shorter under the first assumption, while a more powerful SMF in free5GC Stage 3 still takes longer during registration under the second assumption.</p>"},{"location":"blog/20231213/20231213/#about","title":"About","text":"<p>Leon Sawada</p> <p>NYCU CS Graduate student, today I introduce an article written by my professor Fuchun Joseph Lin. I hope this article could help you understand more about the attributes of different network slices.</p>"},{"location":"blog/20231213/20231213/#reference","title":"Reference","text":"<p>What Is NFV MANO -SDxCentral Studios</p> <p>free5GC Offical website</p> <p>Li, X., et al. (2017) Network Slicing for 5G: Challenges and Opportunities. IEEE Internet Computing, 21, 20-27</p> <p>V. K. Choyi, A. Abdel-Hamid, Y. Shah, S. Ferdi, and A. Brusilovsky, \"Network slice selection, assignment and routing within 5G Networks,\" 2016 IEEE Conference on Standards for Communications and Networking (CSCN), Berlin, Germany, 2016, pp. 1-7, doi: 10.1109/CSCN.2016.7784887.</p> <p>Liao, C.W., Lin, F.J. and Sato, Y. (2020) Evaluating NFV-enabled Network Slicing for 5G Core. 2020 21st Asia-Pacific Network Operations and Management Symposium (APNOMS), Daegu, Korea (South), 22-25 September 2020, 401-404.</p> <p>Chai, Y.-H. and Lin, F.J. (2021) Evaluating Dedicated Slices of Different Configurations in 5G Core. Journal of Computer and Communications, 9, 55-72</p>"},{"location":"blog/20240103/20240103/","title":"UE-initiated PLR Measurement Procedure in PMFP Procedure","text":"<p>Note</p> <p>Author: Samuel Lin Date: 2024/01/03</p>"},{"location":"blog/20240103/20240103/#introduction","title":"Introduction","text":"<p>Performance measurement function protocol (PMFP) procedures are performed between a performance measurement function (PMF) in a UE and a PMF in the UPF.</p> <p>The PMF can measure Round-Trip Time (RTT) and Packet Loss Rate (PLR) by exchanging information through PMFP messages to perform these calculations.</p> <p>In this document, we solely introduce the UE-initiated Packet Loss Rate (PLR) Measurement Procedure.</p> <p></p>"},{"location":"blog/20240103/20240103/#description","title":"Description","text":"<p>Counting start:</p> <ul> <li>[1-4] UE initiates measurement by sending a <code>PMFP PLR Count Request message</code> to the UPF. UE and UPF commence respective packet counting processes.</li> </ul> <p>Reporting and Potential Restart:</p> <ul> <li>[5, 6-2] UE sends a <code>PMFP PLR Report Request message</code> to request UPF's counted packets and may optionally request counting restart.</li> <li>[7-2, 8] UPF responds with a <code>PMFP PLR Report Response message</code> containing counted packets and potentially restarts counting if requested and accepted.</li> </ul> <p>PLR Calculation and Procedure Termination:</p> <ul> <li>[6-1, 7-1] Procedure terminates if restart is not requested or not accepted.</li> <li>[9] UE calculates the UL PLR (Uplink PLR) based on local and reported packet counts.</li> <li>[10-14] Counting can be restarted multiple times upon mutual agreement between UE and UPF, enabling continuous measurement.</li> </ul>"},{"location":"blog/20240103/20240103/#key-considerations","title":"Key Considerations","text":"<p>Message Transport: All PMFP messages are transported over the same QoS flow on the same access.</p> <p>PLR Calculation: UE derives the UL PLR using its own transmitted packet count and the UPF's reported received packet count.</p> <p>Compliance: The procedure adheres to 3GPP specifications for packet loss management.</p>"},{"location":"blog/20240103/20240103/#additional-notes","title":"Additional Notes","text":"<p>QoS Flow Selection: The specific QoS flow for message transmission is contingent upon the measurement type (default or non-default QoS rule).</p> <p>Continuous Measurement: The restart capability facilitates ongoing packet loss monitoring.</p>"},{"location":"blog/20240103/20240103/#conclusion","title":"Conclusion","text":"<p>This UE-initiated PLR measurement procedure provides a standardized and coordinated approach to assess UL packet loss within 5G networks. Its adherence to 3GPP specifications ensures interoperability and consistency across network implementations.</p> <p>Note</p> <p>The network-initiated PLR measurement procedure is to enable UPF to measure the PLR of DL traffic access to the UE through the MA PDU session. The process is the same as the UE-initiated PLR measurement, except that the objects are reversed.</p>"},{"location":"blog/20240103/20240103/#reference","title":"Reference","text":"<ul> <li>3GPP TS 24.193: 5G System; Access Traffic Steering, Switching and Splitting (ATSSS); Stage 3</li> <li>3GPP TS 23.501: System architecture for the 5G System (5GS)</li> </ul>"},{"location":"blog/20240103/20240103/#about","title":"About","text":"<p>Hello, I am Samuel Lin. I have just started making contributions to the free5GC core network. This post is my first blog, so if there are any inquiries or identification of errors within, we welcome discussion and correction. Your feedback is invaluable, so please don't hesitate to reach out via email to share your insights.</p>"},{"location":"blog/20240103/20240103/#connect-with-me","title":"Connect with Me","text":"<ul> <li>Linkedin: https://www.linkedin.com/in/pin-fan-lin-464201290/</li> <li>Github: https://github.com/pf-lin</li> </ul>"},{"location":"blog/20240103/20240103/#appendix","title":"Appendix","text":"<p>Additionally, I have provided the graph with the network-initiated PLR measurement procedure.</p> <p></p>"},{"location":"blog/20240110/20240110/","title":"PacketRusher: A new UE/gNB simulator and CP/UP load tester","text":"<p>Note</p> <p>Author: Michael Chien (newb1er) Date: 2024/1/10</p>"},{"location":"blog/20240110/20240110/#introduction","title":"Introduction","text":"<p>PacketRusher is an innovative open-source project developed by Hewlett Packard, drawing inspiration from my5G-RANTester and leveraging multiple libraries created by free5GC. Its primary objective is to establish automated and high-performance UE/RAN testing suites.</p> <p>In this blog, we will guide you through the setup process and some experiment results.</p>"},{"location":"blog/20240110/20240110/#quick-start","title":"Quick Start","text":""},{"location":"blog/20240110/20240110/#overview","title":"Overview","text":"<p>We are going to create two VMs here. We run free5GC core on one machine and run PacketRusher on the other.</p> <p>Here is the VM spec,</p> <ul> <li>Platform: VirtualBox</li> <li>OS: Ubuntu 20.04</li> <li>CPUs: 2</li> <li>RAM: 2048</li> </ul> <p>and the host spec,</p> <ul> <li>OS: Ubuntu 22.04</li> <li>CPU: Intel Core i5-12400</li> <li>RAM: 32GB</li> </ul>"},{"location":"blog/20240110/20240110/#free5gc-setup","title":"free5GC setup","text":"<p>You can follow the tutorials to install free5GC. Here, we will create a VM and run CP and UP on the same VM.</p>"},{"location":"blog/20240110/20240110/#packetrusher-setup","title":"PacketRusher Setup","text":"<p>They provides a very thorough installation guide on their wiki. Please follow the official instructions in case of any updates.</p> <p>We will lead you through installation that helps you get hand-on experice more quickly. First, create a new VM that runs Ubuntu 20.04. Then, follow the instruction below to install all the dependencies.</p> <pre><code>sudo apt install build-essential linux-headers-generic make git wget tar linux-modules-extra-$(uname -r)\n\nsudo rm -rf /usr/local/go\n# PacketRusher requires Go 1.20 or newer version, \n# we choose 1.21.3 as it's the latest patch version at the moment.\n# Kindly refer to the official Golang changelog should you \n# seek additional information on new features or bug fixes.\nwget https://go.dev/dl/go1.21.3.linux-amd64.tar.gz -O - | sudo tar -C /usr/local -zxvf -\necho \"export PATH=$PATH:/usr/local/go/bin\" &gt;&gt; $HOME/.profile\nsource $HOME/.profile\n</code></pre> <p>After that, we can now clone the repo and build the PacketRusher.</p> <pre><code>git clone https://github.com/HewlettPackard/PacketRusher\ncd PacketRusher\nPACKETRUSHER=$PWD\n\n# Install gtp5g kernel module\ncd $PACKETRUSHER/lib/gtp5g &amp;&amp; make clean &amp;&amp; make &amp;&amp; sudo make install\n\n# build PacketRusher binary\ncd $PACKETRUSHER &amp;&amp; go mod download &amp;&amp; go build cmd/packetrusher.go\n</code></pre>"},{"location":"blog/20240110/20240110/#packetrusher-gnbue-config","title":"PacketRusher gNB/UE config","text":"<p>All the configuration about gNodeB and UE is located in <code>$PACKETRUSHER/config/config.yml</code> file.</p> <p>Here is the example,</p> <pre><code>gnodeb:\n  controlif:\n    ip: \"192.168.56.11\"\n    port: 9487\n  dataif:\n    ip: \"192.168.56.11\"\n    port: 2152\n  plmnlist:\n    mcc: \"208\"\n    mnc: \"93\"\n    tac: \"000001\"\n    gnbid: \"000008\"\n  slicesupportlist:\n    sst: \"01\"\n    sd: \"010203\" # optional, can be removed if not used\n\nue:\n  msin: \"0000000003\"\n  key: \"8baf473f2f8fd09487cccbd7097c6862\"\n  opc: \"8e27b6af0e692e750f32667a3b14605d\"\n  amf: \"8000\"\n  sqn: \"000000000023\"\n  dnn: \"internet\"\n  routingindicator: \"0000\"\n  hplmn:\n    mcc: \"208\"\n    mnc: \"93\"\n  snssai:\n    sst: 01\n    sd: \"010203\" # optional, can be removed if not used\n  integrity:\n    nia0: false\n    nia1: false\n    nia2: true\n    nia3: false\n  ciphering:\n    nea0: true\n    nea1: false\n    nea2: true\n    nea3: false\namfif:\n  ip: \"192.168.56.10\"\n  port: 38412\nlogs:\n    level: 4\n</code></pre> <p>Feel free to customize the configuration to suit your preferences. Make sure it corresponds to your 5GC config.</p>"},{"location":"blog/20240110/20240110/#register-a-set-of-gnb-and-ue","title":"Register a set of gNB and UE","text":"<p>Now, we are ready to rock! Go ahead and runs this command,</p> <pre><code># Make sure to run PacketRusher as root\n# because it will create a gtp5g tunnel.\nsudo ./packetrusher ue\n</code></pre> <p>Now a new GTP tunnel is created and a new PDU session has established. Open another shell and ping google DNS.</p> <pre><code># You can find VRF name on the output of `./packetrusher ue`\nsudo ip vrf exec &lt;vrf_name&gt; ping 8.8.8.8\n</code></pre>"},{"location":"blog/20240110/20240110/#experiment","title":"Experiment","text":""},{"location":"blog/20240110/20240110/#multi-ue-registration-load-test","title":"Multi-UE Registration Load Test","text":""},{"location":"blog/20240110/20240110/#bandwidth-test","title":"Bandwidth Test","text":"<p>We use iperf3 to perform this test.</p> <p>iperf3 server runs on the VM-5GC.</p> <p>iperf3 client send traffic through the GTP tunnel we just created on VM-RAN/UE.</p> <p>The GTP-U tunnel traffic is forwarded by VirtualBox host-only NICs.</p> <pre><code># `iperf3 -c 192.168.56.10`\n\n[ ID]   Interval        Transfer     Bitrate         Retr\n[  6]   0.00-10.00 sec  2.17 GBytes  1.86 Gbits/sec  679             sender\n[  6]   0.00-10.00 sec  2.17 GBytes  1.86 Gbits/sec                  receive\n</code></pre>"},{"location":"blog/20240110/20240110/#about","title":"About","text":"<p>Hey there, I'm Michael! I hopped on board with the free5GC team last summer, diving into the exciting world of 5G. This is my first shot of sharing my experiences, and I'm stoked about it. Any advise or discussion are welcome!</p> <p> </p>"},{"location":"blog/20240119/20240119/","title":"Registration procedures","text":"<p>Note</p> <p>Author: Tim Lin (tim1207) Author: Donald Shih (donald1218) Date: 2024/1/19</p>"},{"location":"blog/20240119/20240119/#introduction","title":"Introduction","text":"<p>The purpose of registration procedures is to allow UEs to register for specific service access rights in 5G. They can be divided into four main type:</p> <p>1. Initial Registration is a mandatory procedure that UEs must execute when they are first powered on. After completing this procedure, the core network will allocate the corresponding resources to the UE. If the UE is in the Idle state (CM-Idle) for a long period of time, causing the core network to lose the UE Context, the UE must also initiate this procedure. 2. Mobility Registration is a procedure that UEs must initiate when they move to a new Tracking Area (TA) that is not included in the UE's TAI List. This procedure is used to update the TA information. 3. Periodic Registration is similar to the Periodic TAU in 4G. 4. Emergency Registration is a procedure that UEs can use to register for emergency services, even if they do not have a valid 5G subscription.</p>"},{"location":"blog/20240119/20240119/#registration-procedure-with-new-amf","title":"Registration Procedure with New AMF","text":""},{"location":"blog/20240119/20240119/#description","title":"Description","text":"<ul> <li> <p>[1] The UE initiates a Registration Request to the (R)AN, which includes an (R)AN message.  </p> <ul> <li>AN message has:  <ul> <li>Registration Type </li> <li>SUCI or 5G-GUTI or PEI</li> <li>Last visited TAI (if available)</li> <li>Security parameters</li> <li>Requested NSSAI</li> <li>Mapping of Requested NSSAI</li> <li>PDU Session status</li> <li>List of PDU Sessions To Be Activated</li> </ul> </li> </ul> </li> <li> <p>[2] The base station selects the AMF that will service the UE based on the GUAMI information.If the UE does not provide a GUAMI, the core network uses the Requested NSSAI to find an AMF that supports those needs.</p> </li> <li> <p>[3] Ran will send N2 Message to New AMF:</p> <ul> <li>N2 Message with :<ul> <li>N2 parameters</li> <li>Registration Request</li> <li>UE Policy Container <p>If the Registration type is Periodic Registration Update, then steps 4 to 20 may be omitted.</p> </li> </ul> </li> </ul> </li> <li> <p>[4] [Conditional] In step 4, the following actions are taken depending on the deployment status of UDSF:  </p> <ul> <li> <p>UDSF is deployed: The new AMF does not need to get data from the old AMF. Instead, the new AMF can call the Nudsf_UnstructuredDataManagement_Query service to directly retrieve the UE's SUPI and UE context from the UDSF.</p> </li> <li> <p>UDSF is not deployed: The new AMF will invoke the Namf_Communication_UEContextTransfer message provided by the old AMF, to request the UE's SUPI and UE context.</p> </li> </ul> </li> <li> <p>[5] [Conditional] </p> <ul> <li> <p>UDSF is deployed: The UDSF responds to the new AMF for the Nudsf_Unstructured_Data_Management_Query invocation with the related contexts.</p> </li> <li> <p>UDSF is not deployed: Old AMF responds to the new AMF for the Namf_Communication_UEContextTransfer invocation by including the UE's SUPI and UE Context.</p> <ul> <li>UE Context with :<ul> <li>information about established PDU Session(s)</li> <li>information about active NGAP UE-TNLA bindings to N3IWF</li> <li>information about AM Policy Association</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>[6] [Conditional] If the SUCI is not provided by the UE, and it is not retrieved from the old AMF, then the new AMF will send an Identity Request message to the UE to obtain the SUCI.</p> </li> <li> <p>[7] [Conditional] The UE uses the HPLMN-provided public key and SUPI to derive the SUCI. The UE then includes the SUCI in the Identity Response message to the new AMF.</p> </li> </ul> <p></p>"},{"location":"blog/20240119/20240119/#description_1","title":"Description","text":"<ul> <li> <p>[8] UEs can initiate UE authentication by calling AUSF. In this example, the AMF will use the SUPI or SUCI to select the AUSF.</p> </li> <li> <p>[9] Authentication and Security Due to the complexity of this section of the process, it will be described in detail in another section.</p> </li> <li> <p>[10] [Conditional] If the conversion of AMF is completed, New AMF will call Namf_Communication_RegistrationCompleteNotify to notify Old AMF registration is completed.</p> <p>If the S-NSSAIs used in the old Registration Area cannot be served in the target Registration Area, the new AMF determines which PDU Session cannot be supported in the new Registration Area.The new AMF invokes the Namf_Communication_RegistrationCompleteNotify service operation to notify the old AMF.Then the new AMF modifies the PDU Session Status.  </p> <p>If new AMF received in the UE context transfer in step 2 the information about the AM Policy Association, It will inform the old AMF that the AM Policy Association in the UE context is no longer in use.</p> </li> <li> <p>[11] [Conditional] If the PEI is not provided by the UE nor obtained from Old AMF, New AMF will obtain the PEI by sending an Identity Request message to the UE to initiate the Identity Request procedure.</p> </li> <li> <p>[12] [Optional] The new AMF initiates ME identity check by invoking the N5g-eir_EquipmentIdentityCheck_Get service operation</p> </li> </ul> <p></p>"},{"location":"blog/20240119/20240119/#description_2","title":"Description","text":"<ul> <li> <p>[13] If Step 14 is to be executed, New AMF will select the UDM based on the SUPI and the UDM will select a UDR Instance.</p> </li> <li> <p>[14a] If the AMF changes, or the SUPI provided by the UE is invalid, or the UE registers to the same AMF but this AMF is already registered for non-3GPP access, the new AMF is registered with the UDM using Nudm_UECM_Registration, and subscribes to be notified when the UDM deregisters this AMF, the UDM stores the AMF identity assciated to the Access Type, and the UDM can store the information in the UDR via Nudr_DM_Update.</p> </li> <li> <p>[14b] The AMF retrieves the SMF Selection Subscription data and Access and Mobility Subscription data and UE context using Nudm_SDM_Get, and the UDM retrieves that information from the UDR via Nudr_DM_Query.</p> </li> <li> <p>[14c] After receiving a successful response, AMF calls Nudm_SDM_Subscribe to subscribe to the notification when the requested data has been modified, and UDM can subscribe to the UDR via Nudr_DM_Subscribe.</p> </li> <li> <p>[14d] [Conditional] After the UDM stores the Access type information, it causes the UDM to initiate a Nudm_UECM_DeregistrationNotification to the Old AMF so that the Old AMF deletes the corresponding UE context.      </p> <ul> <li> <p>If the UDM indicates the deletion reason is Initial Registration, the old AMF will send a Nsmf_PDUSession_ReleaseSMContext message to all the SMFs associated with the UE to notify them that the UE has deregistered from the old AMF. The SMFs will then release the PDU sessions after receiving this notification.</p> </li> <li> <p>If the Old AMF has an N2 connection against that UE, the Old AMF will perform an (R)AN Release indicating that the UE has locally released the RRC Connection for the NG-RAN.</p> </li> </ul> </li> <li> <p>[14e] The Old AMF unsubscribes with the UDM for subscription data using Nudm_SDM_unsubscribe.</p> </li> </ul> <p></p>"},{"location":"blog/20240119/20240119/#description_3","title":"Description","text":"<ul> <li> <p>[15] The New AMF can be contacted to the (V-)PCF using the PCF ID in the UE context received in Step 5.</p> </li> <li> <p>[16] [Optional] If the New AMF contacts (V-)PCF using the PCF ID in the UE context received in Step 5. the New AMF shall put the PCF ID(s) in the call to Npcf_AMPolicyControl Create operation.</p> </li> <li> <p>[17] [Conditional]</p> <ul> <li>Nsmf_PDUSession_UpdateSMContext The AMF invokes the Nsmf_PDUSession_UpdateSMContext in the following scenario(s):<ul> <li>If the registration request in Step 1 contains List Of PDU Sessions To Be Activated, the AMF sends an Nsmf_PDUSession_UpdateSMContext request to the SMFs associated with the PDU Session(s) to activate the User Plane connections of these PDU Session(s). </li> </ul> </li> <li>Nsmf_PDUSession_ReleaseSMContext The AMF invokes the Nsmf_PDUSession_ReleaseSMContext service operation towards the SMF in the following scenario:<ul> <li>If any PDU Session status indicates that it has been released on the UE side, the AMF will use this to notify the SMF to release the resources associated with that PDU Session.</li> </ul> </li> </ul> </li> <li> <p>[18-19] If the AMF has changed and the Old AMF indicates a pre-existing NGAP UE association to the N3IWF, the New AMF creates an NGAP UE association to the N3IWF to which the UE is already connected and automatically releases the previous NGAP UE associations of the Old AMF and the N3IWF , and N3IWF will response to AMF.</p> </li> <li> <p>[20] [Optional] If the Old AMF previously initiated a Policy Association for the PCF and the Old AMF did not transfer the PCF ID(s) to the New AMF, the Old AMF performs an AMF-initiated Policy Association Termination to remove the association with the PCF.</p> </li> <li> <p>[21] The AMF sends a Registration Accept message to the UE indicating that the registration request has been accepted. If the AMF assigns a new 5G-GUTI, it will include the 5G-GUTI.</p> </li> <li> <p>[22] [Conditional] After receiving any of [Configured NSSAI for the Serving PLMN], [Mapping Of Configured NSSAI] and Network Slicing Subscription Change Indication in Step 21, the UE sends a Registration Complete message (to confirm whether the new 5G-GUTI is allocated) to the AMF. sends a Registration Complete message (to confirm whether the new 5G-GUTI has been allocated).</p> <ul> <li>If the List Of PDU Sessions To Be Activated is not included in the Registration Request, the AMF releases the signalling connection with the UE.</li> <li>If Follow-on request is included in the Registration Request, AMF shall not release the signalling connection after completing the registration process.</li> <li>If AMF knows that there is a pending signalling in AMF or between UE and 5GC, AMF shall not release the signalling connection immediately after completing the registration process.</li> </ul> </li> <li> <p>[23] [Conditional] The AMF also uses Nudm_SDM_Info to confirm to the UDM that the UE has received and acted upon the Network Slicing Subscription Change Indication (see Step 21 and step 22).</p> <ul> <li>If the Access and Mobility Subscription data provided by the UDM to the AMF in Step 14b includes Steering of Roaming information with an indication that the UDM is requesting to receive an acknowledgement of that information from the UE, the AMF uses Nudm_SDM_Info to provide a UE acknowledgement to the UDM. AMF uses Nudm_SDM_Info to provide a UE acknowledgement to the UDM.</li> </ul> </li> <li> <p>[24] [Conditional] This step occurs after Step 14a will send Homogeneous Support of IMS Voice over PS Sessions to the UDM using Nudm_UECM_Update.  </p> <ul> <li>If the AMF has evaluated the support of IMS Voice over PS Sessions, see TS 23.501.</li> <li>If the AMF determines that it needs to update the Homogeneous Support of IMS Voice over PS Sessions, see TS 23.501.</li> </ul> </li> </ul>"},{"location":"blog/20240119/20240119/#reference","title":"Reference","text":"<ul> <li>3GPP TS 23.502: Registration Management procedures</li> </ul>"},{"location":"blog/20240119/20240119/#about","title":"About","text":"<p>Thank you for reading.We are members of the free5GC team who joined last year. This post is our first blog.If you find any errors in the article or have any questions about the content, don't hesitate to reach out via email to share your insights.</p>"},{"location":"blog/20240119/20240119/#connect-with-me","title":"Connect with Me","text":"<ul> <li>Linkedin: Donald</li> <li>Github: https://github.com/donald1218</li> <li>Linkedin: Tim</li> <li>Github: https://github.com/tim1207</li> </ul>"},{"location":"blog/20240221/20240221/","title":"Effective Network Management for Cloud-Native 5G Networks with eBPF","text":"<p>Note</p> <p>Author: LEE KUN LIN Date: 2024/02/21</p>"},{"location":"blog/20240221/20240221/#introduction","title":"Introduction","text":"<p>With the rapid development of 5G technology in recent years, the demand for high-performance networks has increased. Therefore, a new technology has emerged that decomposes traditional telecommunications network services into a group or multiple independent, reusable, and elastic microservices (lightweight network functions), called CNF (Cloud native Network Function). Currently, telecommunications operators have begun to accelerate the adoption of cloud-native technologies. In addition to valuing their self-healing capabilities, they also hope that microservice architectures can accelerate and promote the development of new network services, while also providing a high level of granularity. However, the increasing complexity of microservices begets a challenge to traditional network performance monitoring solutions. First, the rapid development of microservices makes the utilization and maintenance of tracing frameworks increasingly burdensome. Second, microservices increase the complexity of network maintenance and create more blind spots on the network level. Therefore, it is becoming increasingly important to build new low-cost tracing frameworks and increase the observability of cloud-native 5G networks. This blog article will share the framework for effective network management proposed by Abderaouf KHICHANE, a PhD candidate at Orange Labs and Universit\u00e9 Paris-Saclay, and his team.</p>"},{"location":"blog/20240221/20240221/#description","title":"Description","text":"<p>Dr. Abderaouf's Team Proposed 5GC-Observer as a Non-Intrusive Observability Framework for Cloud-Native 5G Network Services. The framework utilizes eBPF technology to observe the 5G core network and generate rich telemetry data, which can be used for real 5G end-users\u2019 QoS degradation detection. - [1, 2, 3] Dr. Abderaouf made use of a Kubernetes cluster composed of 3 nodes. As shown in the figure above, there is 1 master node as the control plane [1], and 2 worker nodes as the data plane [2, 3]. - In addition, they setup a VM having access to the Kubernetes cluster is dedicated to the simulation of UEs to ensure the E2E 5G workflow. Here is a brief explanation of the different parts of the figure above (We would not explain the components in detail. Please refer to the team's paper for more information.): Controller: It is used to discover the 5G microservices and their networks by periodically interacting with the Kubernetes API. it can also retrieve for each Kubernetes Pod belonging to the 5G network service, such as its name, the high level Kubernetes resources managing it, its network interfaces, and their IP addresses, etc. And it is communicated to the 5GC-Observer\u2019s Agent using a Kubernetes Custom Resource (CR). Agent: As shown in the figure above, the agents use the eBPF technology to monitor network traffic between 5G microservices. The agents are deployed on Kubernetes worker nodes and runs in privileged mode. And because of the utilization of eBPF, their solution is agnostic to the observed 5G core network and allows to retrieve rich telemetry data without having to know or access the source code of 5G CNFs. Log Server\uff1a They utilize \u201dGrafana Loki\u201d as a log aggregation system, allowing to collect, store and expose logs with HTTP API. Anomaly Detector\uff1a It is responsible for detecting anomalies in critical metrics stored in the Metric Server, including service level metrics (reported by the Agent) and system level metrics (reported by the Infra Exporter). They Proposed \u201cZscore\u201c as critical metrics for quantifying the distance between a point and the average of the dataset in function of the standard deviation. The formula of is as follow: </p> \u2200t, \u01b5score(m,t)=m(t)-avg(m,W)sd(m,W) <p>Where the \u201csd(m, W)\u201d is the standard deviation of metric m over a sliding time window W. Anomaly alerts would be triggered once the value of \u201cZscore\u201c is higher than a threshold \u03c7. They set W and \u03c7 to 10 minutes and 2 respectively. Their goals for the new framework are as follow: 1.Collect enough and rich telemetry data. 2.Use the acquired metrics to accurately detect anomalies.</p>"},{"location":"blog/20240221/20240221/#conclusion","title":"Conclusion","text":"<ul> <li>Dr. Abderaouf's team proposed the \"5GC-Observer\" framework and successfully used the eBPF technology to observe telemetry data generated by the 5G core network.</li> <li>In fact, the team used a chaos engineering tool that consists in simulating network delay. They also proposed a statistically-based anomaly detection solution that can efficiently detect network performance degradation, while their proposed \"5GC-Observer\" framework can effectively detect performance degradation phenomena.</li> <li>This article focuses on introducing the \"5GC-Observer\" framework, so the process of simulating network delay and detection would not be described in detail. In the future, traditional telecommunications network services will move towards being decomposed into lightweight microservices. The observation of cloud-native 5G networks will become increasingly important. Therefore, this article introduces the achievements of Dr. Abderaouf's team and uses this article to briefly discuss eBPF observation technology. We will discuss eBPF technology in more detail in the future.</li> </ul>"},{"location":"blog/20240221/20240221/#reference","title":"Reference","text":"<ul> <li>*A Khichane, I. Fajjari, N. Aitsaadi, and M. Gueroui, \u201c5GC-Observer: a Non-intrusive Observability Framework for Cloud Native 5G System\u201d in NOMS 2023-2023 IEEE/IFIP Network Operations and Management Symposium, 2023.</li> <li>*Junxian Shen, Han Zhang, Yang Xiang, et al., \u201cNetwork-Centric Distributed Tracing with DeepFlow:Troubleshooting Your Microservices in Zero Code\u201d in Proceedings of the ACM SIGCOMM 2023 Conference</li> </ul>"},{"location":"blog/20240221/20240221/#about","title":"About","text":"<p>Hi There! Thank you for reading. I am LEE KUN LIN. I joined the free5GC team last summer and have been learning and growing with the team members and all of you who love the free5GC platform. This is my first article, sharing a framework from a team in France who are passionate about developing new 5G core network technologies. I hope you would derive some benefits from the content. There may be some shortcomings or errors in my article. If you have any questions, please feel free to contact me and share your thoughts.</p>"},{"location":"blog/20240221/20240221/#connect-with-me","title":"Connect with Me","text":"<ul> <li>Linkedin: www.linkedin.com/in/kunlin-lee-53b129282/</li> <li>Github: https://github.com/KunLee76</li> </ul>"},{"location":"blog/20240327/20240327/","title":"Introduction of IP Multimedia Subsystem Part 3","text":"<p>Note</p> <p>Author: TzuChieh Huang Date: 2024/03/27</p> <p>Continuing our exploration of the IP Multimedia Subsystem (IMS), Part 1 and Part 2 have provided a comprehensive understanding of the architecture, key components, and registration processes within the IMS framework. In Part 3, we delve into the intricate procedures of IMS call handling and look toward the future developments and innovations expected within this dynamic telecommunications landscape.</p>"},{"location":"blog/20240327/20240327/#media-flow-call-procedure","title":"Media Flow / Call Procedure","text":"<p>After successful registration, the following steps will be processed when a user initiates a communication session (e.g., make a call).</p> <p></p>"},{"location":"blog/20240327/20240327/#sip-invite-and-100-trying","title":"SIP INVITE and 100 Trying","text":"<p>A SIP INVITE message aims to initiate a session between two endpoints. When a user wants to make a call, their SIP client sends an INVITE request to the SIP server, specifying the desired recipient and various parameters such as the media types (audio, video, etc.) and codecs for encoding the media.</p> <p>The 100 Trying response in the context of the SIP is an informational response indicating that the request has been received and the server is working on a response. It serves as an interim response while the server processes the INVITE request or performs other tasks related to call setup.</p> <ul> <li> <p>Caller to Orig P-CSCF</p> <ul> <li>The caller sends the SIP INVITE request, including an initial SDP, to the P-CSCF, which is determined via the CSCF discovery mechanism. </li> <li>The initial SDP may encompass one or more media streams for a multi-media session.</li> </ul> </li> <li> <p>Orig P-CSCF to Orig S-CSCF</p> <ul> <li>The originating P-CSCF knows the next hop CSCF since the UE has been registered.</li> <li>The originating P-CSCF determines whether the INVITE message needs priority treatment based on the user profile saved during registration, the priority specified by the user, and/or the MPS code/identifier contained in the INVITE message.</li> <li>If the session needs priority handling, the originating P-CSCF inserts or replaces the priority indication and forwards the INVITE to the originating S-CSCF. </li> </ul> </li> <li> <p>Orig S-CSCF to Term I-CSCF</p> <ul> <li>The originating S-CSCF validates the service profile and, if a Globally Routable User Agent URI (GRUU) is received as the contact, ensures that the Public User Identity associated with the served user in the request matches the Public User Identity linked to the GRUU, both belonging to the same service profile. </li> <li> <p>Then the originating S-CSCF triggers any origination service logic necessary for this user</p> <ul> <li>e.g., Authorization of the requested SDP based on the user's subscription for multi-media services. </li> </ul> </li> <li> <p>The originating S-CSCF analyzes the destination address, identifies the network operator the subscriber is affiliated with and forwards the SIP INVITE request. </p> </li> <li>When the INVITE message contains a priority indication, the originating S-CSCF forwards the INVITE along with the Service User's priority level if available.</li> <li>If the destination is local, the request is directed to a local I-CSCF for further processing.</li> </ul> </li> <li> <p>Term I-CSCF to Term S-CSCF</p> <ul> <li>The terminated I-CSCF forwards the INVITE request to the terminated S-CSCF.</li> <li>The S-CSCF validates the service profile and triggers any termination service logic required for this user. <ul> <li>e.g., Authorization of the requested SDP based on the user's subscription for multi-media services.</li> </ul> </li> </ul> </li> <li> <p>Term S-CSCF to Term P-CSCF</p> <ul> <li>The terminated S-CSCF knows the next hop CSCF for this UE and forwards the INVITE to the terminated P-CSCF in the visited network.</li> </ul> </li> <li> <p>Term P-CSCF to Callee</p> <ul> <li>If the terminated P-CSCF identifies that the termination is for a Multimedia Priority Service (MPS) session, it extracts the session information. It initiates dynamic policy enforcement by transmitting the derived session details to the Policy and Charging Rules Function (PCRF) or Policy Control Function (PCF). </li> <li>The terminated P-CSCF recalls (from the registration procedure) the UE address and forwards the INVITE to the UE.</li> </ul> </li> </ul>"},{"location":"blog/20240327/20240327/#180-ringing","title":"180 ringing","text":"<ul> <li>If the UE needs user input before finalizing the session setup, it may alert the user and await their response. In such cases, it notifies the originating party with a provisional response, specifically indicating \"Ringing.\" </li> <li>This message is transmitted to the P-CSCF and forwarded along the signaling path to the originating endpoint.</li> </ul>"},{"location":"blog/20240327/20240327/#200-ok","title":"200 OK","text":"<ul> <li>The 200 OK response indicates that the callee has accepted the call invitation and has successfully established the session. It contains essential information such as session parameters, codecs, and media descriptions for both parties to begin communication.</li> <li>This message is transmitted to the P-CSCF and forwarded along the signaling path to the originating endpoint.</li> </ul>"},{"location":"blog/20240327/20240327/#ack","title":"ACK","text":"<ul> <li>After receiving the 200 OK response from the callee, the caller sends an ACK message to confirm the successful reception of the acceptance. The ACK message acknowledges the receipt of the 200 OK response and finalizes the call setup process. </li> <li>It ensures that both ends of the call are synchronized and ready to proceed with the communication session.</li> <li>This message is transmitted to the P-CSCF and forwarded along the signaling path to the terminated endpoint.</li> </ul>"},{"location":"blog/20240327/20240327/#rtp-streams","title":"RTP Streams","text":"<ul> <li>RTP streams are designed to deliver media in real-time with minimal delay, which is essential for IMS voice and video communication. They use UDP to transport media data, providing a continuous stream of packets representing the media content. The RTP protocol also supports mechanisms for synchronizing audio and video streams, handling packet loss, and ensuring media quality during the call.</li> <li>Once the SIP handshake is complete, RTP streams are established between the caller and the callee. </li> <li>These streams carry the actual media (voice, video, etc.) over the network.</li> </ul>"},{"location":"blog/20240327/20240327/#ims-in-convergence-and-next-generation-networks","title":"IMS in Convergence and Next-Generation Networks","text":""},{"location":"blog/20240327/20240327/#integration-with-4g5g-networks","title":"Integration with 4G/5G Networks","text":""},{"location":"blog/20240327/20240327/#1-role-of-ims-in-lte-and-5g-architectures","title":"1. Role of IMS in LTE and 5G Architectures","text":"<p>In LTE and 5G networks, IMS is pivotal in enabling multimedia services over IP networks. It serves as the framework for delivering services like voice and video calls, multimedia messaging, and other IP-based communication services. </p> <p>In both LTE and 5G architectures, IMS is responsible for:</p> <ul> <li> <p>Session Control: IMS handles the setup, modification, and termination of multimedia sessions, ensuring seamless communication.</p> </li> <li> <p>Service Functionality: It hosts Application Servers (AS) that provide various services like Voice over LTE (VoLTE), Video over LTE (ViLTE), Video over New Radio (VoNR), instant messaging, presence, and more.</p> </li> <li> <p>Interoperability: IMS ensures that different types of devices (smartphones, tablets, IoT devices, etc.) can communicate effectively, regardless of the access network (Wi-Fi, cellular, etc.).</p> </li> </ul>"},{"location":"blog/20240327/20240327/#2-enhancements-for-low-latency-and-high-throughput","title":"2. Enhancements for Low Latency and High Throughput","text":"<p>In the context of 5G integration, IMS undergoes several enhancements to leverage the capabilities of the new network:</p> <ul> <li> <p>Low Latency: IMS is optimized to work with the ultra-low latency capabilities of 5G networks. This is particularly crucial for applications like real-time gaming, augmented reality (AR), virtual reality (VR), and other time-sensitive services.</p> </li> <li> <p>High Throughput: 5G networks provide significantly higher data rates than previous generations. IMS is enhanced to maximize this increased throughput, ensuring high-quality multimedia experiences.</p> </li> </ul>"},{"location":"blog/20240327/20240327/#cross-device-and-cross-network-communication","title":"Cross-device and Cross-Network Communication","text":""},{"location":"blog/20240327/20240327/#1-enabling-seamless-communication-across-various-devices-and-networks","title":"1. Enabling Seamless Communication Across Various Devices and Networks","text":"<p>IMS enables users to communicate seamlessly across various devices, regardless of their form factor or operating system. This includes smartphones, tablets, laptops, IoT devices, and more. The key components facilitating this include:</p> <ul> <li> <p>P-CSCF and S-CSCF: These elements ensure that SIP-based signaling messages can be appropriately routed to and from different devices.</p> </li> <li> <p>Application Servers (AS): AS plays a critical role in providing services that can adapt to various device capabilities, ensuring a consistent user experience.</p> </li> <li> <p>IMS Profile Management:  IMS profiles associated with a user are stored in the HSS and can be retrieved dynamically, allowing services to adapt to the device's capabilities.</p> </li> </ul>"},{"location":"blog/20240327/20240327/#2-support-for-volte-vilte-vonr-and-other-multimedia-services","title":"2. Support for VoLTE, ViLTE, VoNR, and Other Multimedia Services","text":"<p>IMS is instrumental in delivering various multimedia services over LTE and 5G networks:</p> <ul> <li> <p>VoLTE (Voice over LTE):  IMS enables high-quality voice calls over LTE networks. It ensures that voice calls are treated as data sessions, allowing simultaneous voice and data usage.</p> </li> <li> <p>ViLTE (Video over LTE):  This service extends VoLTE's capabilities to include high-definition video calling.</p> </li> <li> <p>VoNR (Voice over New Radio):  With the introduction of 5G, IMS facilitates voice calls over the new radio interface, taking advantage of 5G's enhanced capabilities.</p> </li> <li> <p>Multimedia Messaging:  IMS supports multimedia messaging services, allowing users to exchange images, videos, and other media in real time.</p> </li> </ul> <p>These services are made possible by interacting with various IMS components, including P-CSCF, I-CSCF, S-CSCF, and Application Servers, working together to establish and manage multimedia sessions.</p>"},{"location":"blog/20240327/20240327/#conclusion","title":"Conclusion","text":"<p>The IMS call flow is a sophisticated signaling and media transfer orchestration that enables seamless multimedia communication across various devices and networks. The entire process involves several network components, including P-CSCF, S-CSCF, and I-CSCF, which collaborate to support quality of service, security, and reliability. Meanwhile, the convergence of IMS with Next-Generation Networks marks a significant evolution in telecommunications, allowing for the integration of traditional telephony with modern IP-based services. This convergence promises enhanced efficiency, more decadent service offerings, and a robust platform for innovation, paving the way for a future where communication is more versatile, integrated, and ubiquitous. Together, they represent the ongoing commitment to advancing connectivity and creating a more cohesive and flexible communication ecosystem for users worldwide.</p>"},{"location":"blog/20240327/20240327/#reference","title":"Reference","text":"<p>3GPP TS 22.228: \"Service requirements for the Internet Protocol (IP) multimedia core network subsystem (IMS) - Stage 1\"</p> <p>3GPP TS 23.218: \"IP Multimedia (IM) session handling; IM call model; Stage 2\"</p> <p>3GPP TS 23.228: \"IP Multimedia Subsystem (IMS) - Stage 2\"</p> <p>3GPP TS 29.228: \"IP Multimedia (IM) Subsystem Cx and Dx Interfaces; Signalling flows and message contents\"</p>"},{"location":"blog/20240327/20240327/#about","title":"About","text":"<p>Hello, I am TzuChieh Huang. My ongoing research focuses on VoNR (Voice over New Radio). Feel free to reach out and share any inquiries or point out errors in the article. I welcome corrections and value your feedback. Please do not hesitate to contact me via email to contribute your insights.</p>"},{"location":"blog/20240521/20240521/","title":"Introduction to ONOS","text":"<p>Note</p> <p>Author: HanHung Chen Date: 2024/05/21</p> <p>The way we manage networks is undergoing a revolution. Traditional, hardware-centric approaches are giving way to a software-defined future.</p>"},{"location":"blog/20240521/20240521/#traditional-network-vs-software-defined-networkingsdn","title":"Traditional Network vs. Software Defined Networking(SDN)","text":""},{"location":"blog/20240521/20240521/#traditional-network","title":"Traditional Network","text":"<ul> <li>Traditional networks typically have an integrated control and data plane and use distributed control.</li> <li>The control plane is responsible for routing and forwarding traffic.</li> <li>The data plane is responsible for transmitting traffic. </li> <li>The advantage</li> <li>Well-established and widely used: Traditional networks have been around for a long time. This means there's a vast pool of knowledge and expertise available for managing and troubleshooting them. Organizations likely already have the necessary tools and personnel in place.</li> <li>Predictable performance: Traditional networks are designed with dedicated hardware and software for specific purposes. This allows for consistent and predictable performance because the behavior of the network is well-understood.</li> <li>The disadvantage</li> <li>Less flexible: Traditional networks have a rigid, hierarchical architecture that is difficult to modify or adapt to changing business needs.</li> <li>Limited automation: Because traditional network is highly depending on hardware, it requires manual intervaention.</li> <li>Limited scalability: Traditional networks have limited scalability due to the dependence on physical hardware devices.</li> </ul>"},{"location":"blog/20240521/20240521/#sdn","title":"SDN","text":"<ul> <li>Software-defined networking (SDN) is a new network architecture that separates the control plane from the data plane. </li> <li>SDN Architecture typically consist of the following components:</li> <li>Controller: The controller is responsible for controlling the routing and forwarding of traffic across the entire network.</li> <li>Switches: Switches are responsible for transmitting traffic.</li> <li>Southbound API: The southbound API is the interface that the controller uses to control switches.</li> <li>Northbound API: The northbound API is the interface that applications use to interact with the controller.</li> <li>The advantage</li> <li>Centralized provisioning: SDN virtualizes both the data and control planes allowing the user much easier to provision physical and virtual elements. This is useful as traditional infrastructure can be challenging to monitor especially if there are many disparate systems that need to be managed individually.</li> <li>Good scalability: A good side effect of centralized provisioning is that SDN gives the user more scalability. By having the ability to provision resources at will you can change your network infrastructure at a moment\u2019s notice.</li> <li>The disadvantage</li> <li>High latency: SDN has high latency, due to both software implementation inefficiencies and interactions between switch hardware properties and the control operation workload.</li> </ul>"},{"location":"blog/20240521/20240521/#open-network-operating-system-onos","title":"Open Network Operating System (ONOS)","text":""},{"location":"blog/20240521/20240521/#what-is-onos","title":"What is ONOS ?","text":"<ul> <li> <p>Open Network Operating System (ONOS) is an open source network operating system (OS) from the Open Networking Lab (ON.Lab), which released the ONOS source code, written in Java, to the open source community in December 2014. The goal of the project is to create a software-defined networking (SDN) operating system for communications service providers that is designed for scalability, high performance and high availability.</p> </li> <li> <p>ONOS platform includes:</p> </li> <li>A platform and a set of applications that act as an extensible, modular, distributed SDN controller.</li> <li>Manages entire network (rather than a single device)</li> <li>Simplified management, configuration and deployment of software, hardware and services.</li> <li>A scale-out architecture to provide resiliency and scalability</li> <li>Required to meet the rigors of production carrier environments.</li> </ul>"},{"location":"blog/20240521/20240521/#onos-feature","title":"ONOS feature","text":"<ul> <li>Performance at Scale</li> <li>ONOS has been architected and built to provide the highest performance possible for scaled network operations. ONOS scales as needed by adding new instances when more control plane capacity is needed. capacity is needed.</li> <li>Modular Software</li> <li>Software is easier to read, test, and maintain. Most importantly, it allows more easily to customize the software.</li> <li>Northbound Abstractions</li> <li>ONOS provides northbound abstractions that simplify the creation, deployment, and operation of configuration, management and control applications.</li> <li>Southbound Abstractions</li> <li>ONOS abstracts device characteristics so that the core operating system does not have to be aware of the particular protocol being used to control or configure a device.</li> </ul>"},{"location":"blog/20240521/20240521/#onos-distributed-architecture","title":"ONOS Distributed Architecture","text":""},{"location":"blog/20240521/20240521/#distributed-core","title":"Distributed Core","text":"<ul> <li>This part is protocol-Agnostic</li> <li>Interact with Network-facing modules via a southbound (provider) API</li> <li>Interact with Applications via the northbound (consumer) API</li> </ul>"},{"location":"blog/20240521/20240521/#applicationsapps","title":"Applications(Apps)","text":"<ul> <li>Applications take and react base on the information provided by the core.</li> </ul>"},{"location":"blog/20240521/20240521/#providers-protocols","title":"Providers &amp; Protocols","text":"<ul> <li>These two parts are protocol-aware network-facing modules.</li> <li>Acquire network state information through protocol-specific means.</li> <li>Interact with the core via a southbound (provider) API.</li> </ul>"},{"location":"blog/20240521/20240521/#subsystems-of-the-core","title":"Subsystems of the Core","text":"<ul> <li>The ONOS core comprises several subsystems, each responsible for a particular aspect of network state (e.g. topology, host tracking, packet intercept, flow programming). Each subsystem maintains its \u00a0service abstraction, where its implementation is responsible for propagating the state throughout the cluster.</li> <li>Example subsystems</li> <li>Device Subsystem: Manages inventory of infrastructure devices. (Device and Port)</li> <li>Link Subsystem: Manages inventory of infrastructure links.</li> <li>Host Subsystem: Manages inventory of end-station hosts and their locations.</li> <li>Topology Subsystem: Manages time-ordered snapshots of network graph views.</li> <li>PathService: Computes/finds paths between infrastructure devices or between end-station hosts (using the most recent topology graph snapshot).</li> <li>FlowRule Subsystem: Manages inventory of match/action flow rules installed on  infrastructure devices and provides flow metrics.</li> <li>Packet Subsystem: Allows applications to listen for   data packets received from network devices and to emit data packets out onto the  network via one or more network devices.</li> <li>Driver Subsystem: Isolate device-specific code from rest of the system</li> </ul>"},{"location":"blog/20240521/20240521/#subsystem-structure","title":"Subsystem Structure","text":""},{"location":"blog/20240521/20240521/#manager","title":"Manager","text":"<ul> <li>The Manager is located in the core</li> <li>Gathers data from Providers</li> <li>Delivers information to applications and other services.</li> <li>NB Service Interface: allows applications or other core components to access specific network state information.</li> <li>NB AdminService Interface: used for receiving administrative commands and implementing them in the network state or system.</li> <li>SB ProviderRegistry Interface: enables Providers to register with the Manager, allowing interaction between Providers and the Manager.</li> <li>SB ProviderService Interface: available to registered Providers, allowing them to exchange information with the Manager.</li> </ul>"},{"location":"blog/20240521/20240521/#providers","title":"Providers","text":"<ul> <li>Providers are protocol-aware and register with the core to be recognized.</li> <li>ProviderRegistry Interface: Providers register their presence with the core.</li> <li>Provider Interface: Providers receive control commands from the core.</li> <li>using protocol-specific methods: Providers interact with network elements.</li> <li>ProviderService Interface: Providers deliver service-specific sensory data to the core.</li> </ul>"},{"location":"blog/20240521/20240521/#application","title":"Application","text":"<ul> <li>Users of the Manager's service interface</li> <li>Can obtain information in both synchronous and asynchronous manners</li> <li>Synchronous: by making queries to the service</li> <li>Asynchronous: by acting as an event listener<ul> <li>By implementing an EventListener interface to handle events</li> <li>Register events through the ListenerService interface</li> <li>The ListenerService interface is integrated into each Service interface</li> </ul> </li> </ul>"},{"location":"blog/20240521/20240521/#conclusion","title":"Conclusion","text":"<p>Combining SDN with ONOS and free5GC enables a powerful platform for experimenting with next-generation network technologies, offering enhanced flexibility and control over network management and 5G services.</p>"},{"location":"blog/20240521/20240521/#reference","title":"Reference","text":"<ul> <li>ONOS - Wikipedia</li> <li>ONOS Official Website</li> <li>ONOS Wiki</li> <li>Difference between Software Defined Network and Traditional Network </li> </ul>"},{"location":"blog/20240521/20240521/#about-me","title":"About me","text":"<p>Hi, I am Han-Hung Chen, a beginner to 5G and free5gc. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20240521/20240521/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: https://github.com/HanHongChen</li> </ul>"},{"location":"blog/20240626/20240626/","title":"NTN Overview","text":"<p>Note</p> <p>Author: Samuel Lin (pflin) Date: 2024/06/26</p>"},{"location":"blog/20240626/20240626/#introduction","title":"Introduction","text":"<p>Non-Terrestrial Network (NTN) is an important component of future B5G and 6G networks. It can provide extensive coverage, enhanced connectivity for terrestrial networks, and establish the necessary satellite backhaul links to connect with the core network.</p> <p>The global organization 3GPP extends existing terrestrial mobile communications to a satellite-based non-terrestrial network architecture. The aim is to integrate satellite and terrestrial networks. In the Release 16 TR 22.822 document, 3GPP proposes three main NTN application types: Service Continuity, Service Scalability, and Service Ubiquity. These applications can provide stable and flexible network services in areas difficult for terrestrial networks to cover, such as oceans, remote areas, or conflict zones. In Release 17, 3GPP plans to incorporate NTN into the 5G cellular ecosystem, significantly accelerating the commercialization of NTN.</p>"},{"location":"blog/20240626/20240626/#ntn-architecture","title":"NTN Architecture","text":""},{"location":"blog/20240626/20240626/#transparent-mode","title":"Transparent mode","text":"<p>Initially, in Release 17, NTN primarily relies on the reception and forwarding of signals from satellites to ground receiving stations in a Transparent mode. A ground receiving station can cover an area with a radius of approximately 800 kilometers.</p> <p>Note</p> <p>Feeder links: Wireless link between <code>NTN Gateway</code> and <code>satellite</code> \"Uu\" Service links: Radio link between <code>satellite</code> and <code>mobile devices (UE)</code></p>"},{"location":"blog/20240626/20240626/#service-link-types","title":"Service Link Types","text":"<p>3GPP standards support three types of satellite service links, allowing support for any type of orbit.</p> <ul> <li>Earth-fixed: The beam continuously covers the same geographic area, remaining stationary relative to the Earth's surface. A typical example is the Global Positioning System (GPS), which uses multiple geosynchronous satellites to provide precise global positioning services.</li> <li>Quasi-Earth-fixed: In this coverage mode, the beam covers a geographic area for a specific period but shifts to cover other geographic areas over time. This method provides efficient geographic coverage for a specific time but lacks continuity.</li> <li>Earth-moving: The beam coverage moves along the Earth's surface, typically achieved by Low Earth Orbit (LEO) satellites. It is suitable for applications requiring dynamic global coverage, such as LEO satellite communication systems needing real-time updates and extensive geographic coverage.</li> </ul>"},{"location":"blog/20240626/20240626/#current-research","title":"Current Research","text":""},{"location":"blog/20240626/20240626/#constellation-routing","title":"Constellation Routing","text":"<p>Constellation routing is a routing decision method for inter-satellite communication technology (Inter-Satellite Link, ISL) used in dynamically changing but periodically predictable satellite subnetworks. Its goal is to ensure high performance and reliability in message transmission while minimizing network delay and packet loss rates.</p> <p>NTN develops ISL technology to replace submarine cables and achieve cross-regional communication. Compared to ground stations, LEO satellites have lower average latency, around 20 milliseconds, but ISL subnetworks may face challenges such as network congestion and link failures, increasing latency. Since NTN systems integrate with the 5G cellular network, which is sensitive to end-to-end delay, developing efficient, reliable, and low-complexity constellation routing solutions is a priority.</p> <p>Research focuses on developing routing algorithms that achieve minimum hop count, high reliability, and efficiency in ISL subnetworks, enhancing the overall performance and reliability of satellite communication systems.</p>"},{"location":"blog/20240626/20240626/#reference","title":"Reference","text":"<ul> <li>3GPP TR 22.822: Study on using satellite access in 5G</li> <li>3GPP TS 38.821: Solutions for NR to support Non-Terrestrial Networks (NTN)</li> <li>MediaTek Inc. (2023). MediaTek 6G Technology White Paper - Satellite and Terrestrial Network Convergence</li> </ul>"},{"location":"blog/20240626/20240626/#about","title":"About","text":"<p>Hello, I\u2019m Samuel Lin. I am currently conducting research related to NTN. If there are any inaccuracies, please feel free to let me know.</p>"},{"location":"blog/20240626/20240626/#connect-with-me","title":"Connect with Me","text":""},{"location":"blog/20240628/20240628/","title":"Introduction to 5G Quality of Service (QoS)","text":"<p>Note</p> <p>Author: Ting-Yuan Chou Date: 2024/06/28</p>"},{"location":"blog/20240628/20240628/#introduction","title":"Introduction","text":"<p>5G networks revolutionize connectivity with their ability to support high-speed data, low latency, and massive device connectivity. A key element in this innovation is Quality of Service (QoS), which ensures that diverse network demands are met with precision, whether for broadband, critical communications, or IoT. Understanding QoS is crucial for leveraging 5G\u2019s full potential in catering to varied digital needs.</p>"},{"location":"blog/20240628/20240628/#5g-qos-architecture","title":"5G QoS Architecture","text":"<p> This diagram illustrates the relationship between PDU sessions and QoS flows within a 5G network, involving the User Equipment (UE), gNodeB (gNB), and User Plane Function (UPF). Each PDU session can encompass multiple QoS flows, each tailored to a specific type of service, ensuring that different data streams receive appropriate quality of service levels based on their requirements.</p>"},{"location":"blog/20240628/20240628/#key-components","title":"Key Components","text":"<ul> <li>PDU Session - This is a logical connection between the UE and the data network, which can carry one or more QoS flows.</li> <li>QoS Flow - A QoS flow is a logical channel with specific QoS characteristics that guarantee certain service levels for the data transported within it.</li> <li>Data Radio Bearer (DRB) - This is used to transport the QoS flows between the UE and gNB.</li> <li>UP Tunnel - It represents the path that QoS flows take between the gNB and the UPF.</li> </ul>"},{"location":"blog/20240628/20240628/#explained-with-the-diagram","title":"Explained with the Diagram","text":"<ul> <li>Internet PDU Session - Includes an Internet DRB and associated QoS flow marked with QFI (QoS Flow Identifier) for internet services.</li> <li>IMS Voice PDU Session - Contains multiple DRBs for SIP, RCS, Voice, and Video services, each with its own QoS flow and QFI, such as QFI SIP for SIP services, and QFI RTP/RTCP for voice.</li> </ul>"},{"location":"blog/20240628/20240628/#qos-flow-overview","title":"QoS Flow Overview","text":"<p>In 5G networks, QoS Flows are crucial for ensuring the quality of data transmission. According to 3GPP standards, QoS Flows are categorized into two types:</p>"},{"location":"blog/20240628/20240628/#types-of-qos-flow","title":"Types of QoS Flow","text":"<ul> <li>GBR QoS Flows - Require a guaranteed flow bit rate.</li> <li>Non-GBR QoS Flows - Do not require a guaranteed flow bit rate.</li> </ul>"},{"location":"blog/20240628/20240628/#qfi-qos-flow-identifier","title":"QFI (QoS Flow Identifier)","text":"<p>Each QoS Flow is identified by a unique QoS Flow ID (QFI), which is unique within the scope of a PDU session and visible in the GTP-U header of 5G user-plane packets. The lifecycle of a QoS Flow is managed by the SMF, including its establishment, modification, and deletion. SMF creates a default QoS Flow for each PDU session, associated with a default QoS Rule installed in the UE for mapping uplink packets.</p>"},{"location":"blog/20240628/20240628/#qos-flow-management","title":"QoS Flow Management","text":"<p>The management of QoS Flows is controlled by the SMF, including the creation, modification, and deletion of QoS Flows. Whenever any PDU session is established, the SMF creates a default Non-GBR QoS Flow associated with a default QoS Rule that allows all uplink packets to pass.</p>"},{"location":"blog/20240628/20240628/#components-of-qos-flow-instantiation","title":"Components of QoS Flow instantiation","text":"<ul> <li>QoS Profile - Can be distributed by SMF to the gNB or predefined on the gNB. Each QoS Profile contains a series of QoS parameters corresponding to a QFI.</li> <li>QoS Rule - Sent to the UE via NAS message by SMF, including a series of QoS parameters and Packet Filters.</li> <li>PDR(s) - Sent to the UPF via PFCP messages by SMF, containing rules and parameters related to QoS.</li> </ul>"},{"location":"blog/20240628/20240628/#default-qos-flow-vs-gbr-qos-flow","title":"Default QoS Flow vs GBR QoS Flow","text":"<p> The diagram illustrates the architecture of QoS Flows in a 5G network, highlighting the two main types: Default QoS Flow and GBR QoS Flow.</p> <ul> <li>Default QoS Flow (Non-Guaranteed Bit Rate, Non-GBR) </li> <li> <p>As shown by the green tunnel in the diagram, each PDU Session has a default QoS Flow, with a QFI of 102, classified as Non-GBR. This indicates that the flow does not guarantee a fixed data transfer rate. The default QoS Flow typically has the lowest priority, and all uplink or downlink data flows use this default QoS Flow when no higher priority service data flows (SDF) are matched.</p> </li> <li> <p>GBR QoS Flow (Guaranteed Bit Rate) </p> </li> <li>The pink tunnel in the diagram exemplifies a GBR QoS Flow, with a QFI of 101. This type of flow guarantees a fixed data transfer rate, suitable for applications requiring high quality of service assurance, such as voice and video calls. This GBR QoS Flow contains two SDFs, indicating that two business data flows meet this QoS Flow, enjoying the same QoS forwarding treatment.</li> </ul>"},{"location":"blog/20240628/20240628/#qos-profile","title":"QoS Profile","text":""},{"location":"blog/20240628/20240628/#parameters-for-every-qos-flow","title":"Parameters for Every QoS Flow","text":"<ul> <li>5G QoS Identifier (5QI) - Defines the type of QoS Flow (GBR, Non-GBR, or Delay Critical GBR).</li> <li>Allocation and Retention Priority (ARP) - Priority for resource allocation and retention.</li> </ul>"},{"location":"blog/20240628/20240628/#parameters-for-non-gbr-qos-flow","title":"Parameters for Non-GBR QoS Flow","text":"<ul> <li>Reflective QoS Attribute (RQA) - Reflective QoS attribute used for dynamic adjustment of QoS settings.</li> </ul>"},{"location":"blog/20240628/20240628/#parameters-for-gbr-qos-flow","title":"Parameters for GBR QoS Flow","text":"<ul> <li>Guaranteed Flow Bit Rate (GFBR) - Guaranteed bitrate applicable to uplink and downlink.</li> <li>Maximum Flow Bit Rate (MFBR) - Maximum bitrate applicable to uplink and downlink.</li> </ul>"},{"location":"blog/20240628/20240628/#additional-important-parameters-for-gbr-qos-flow","title":"Additional important parameters for GBR QoS Flow","text":"<ul> <li>Notification Control - Controls the notifications.</li> <li>Maximum Packet Loss Rate - Maximum allowable packet loss rate for uplink and downlink.</li> </ul>"},{"location":"blog/20240628/20240628/#5qi","title":"5QI","text":"<p>In 5G networks, the 5G QoS Identifier (5QI) defines the specific Quality of Service characteristics for a QoS Flow. Below is a detailed description of the key QoS characteristics associated with different types of 5QI.</p> QoS Characteristic Description Resource Type Specifies whether the QoS Flow is GBR, Delay Critical GBR, or Non-GBR. Priority Level Indicates the priority level of the QoS Flow, which impacts the allocation and retention of resources. Packet Delay Budget (PDB) The maximum allowable delay for packets within the QoS Flow, crucial for maintaining the latency requirements. Packet Error Rate (PER) Defines the acceptable error rate for packets within the QoS Flow, ensuring data integrity. Averaging Window Applies only to GBR and Delay-critical GBR resources, determining the time period over which the guaranteed bit rates are calculated. Maximum Data Burst Volume (MDBV) Relevant only for Delay-critical GBR resources, specifies the maximum amount of data transmitted in a burst."},{"location":"blog/20240628/20240628/#qos-rule","title":"QoS Rule","text":"<p>In 5G networks, QoS Rules are crucial configurations that guide how user-plane data flows are handled. QoS Rules determine which packets should be allocated to specific QoS flows to ensure the quality of data transmission.</p> <ul> <li>Definition of QoS Rules</li> <li> <p>A QoS Rule includes the associated QoS flow's QFI (QoS Flow Identifier), a set of packet filters, and a priority. Packet filters determine which packets should be forwarded to a specific QoS flow.</p> </li> <li> <p>Configuration of QoS Rules</p> </li> <li> <p>QoS Rules can be explicitly provided to the UE during PDU session establishment or modification through signaling. They can also be pre-configured on the UE or implicitly derived through the UE's use of reflective QoS mechanisms.</p> </li> <li> <p>Default QoS Rules</p> </li> <li> <p>Each PDU session is configured with a default QoS rule, which is associated with a QoS flow. For IP or Ethernet type PDU sessions, the default QoS rule is the only packet filter set, typically configured to allow all uplink packets.</p> </li> <li> <p>Application of Packet Filters</p> </li> <li>If the UE does not find a matching QoS rule, it will discard the uplink packet. This ensures that only data meeting specific QoS criteria are sent.</li> </ul>"},{"location":"blog/20240628/20240628/#qos-flow-mapping","title":"QoS Flow Mapping","text":"<p>QoS mapping is crucial in 5G networks, ensuring that data packets are correctly mapped to corresponding QoS flows and network resources. Here is an introduction to the process and implementation of QoS mapping:</p> <ol> <li>Process of QoS Mapping</li> <li>Role of SMF: The SMF binds SDFs to specific QoS flows based on QoS and service requirements, assigning a QFI and exporting related QoS configuration profiles for each new QoS flow.</li> <li> <p>Data Flow and QoS Flows: As shown in the diagram, UL (uplink) and DL (downlink) data packets are processed through appropriate QoS rules and mapped to corresponding QoS flows.</p> </li> <li> <p>Mapping of QoS Rules to QoS Flows</p> </li> <li>SMF to (R)AN: SMF indirectly influences resource allocation in the RAN through the coordination with the AMF, which relays necessary QoS information, including QFIs and QoS profiles, to ensure proper resource management.</li> <li> <p>SMF to UPF: SMF instructs the UPF on packet classification, bandwidth execution, and marking, including setting up DL PDR / UL PDR and providing QoS related information (such as MBR, GFBR, and MFBR).</p> </li> <li> <p>Packet Handling</p> </li> <li>Downlink Data Handling: The UPF classifies packets based on PDRs, ensuring that packets are appropriately downlinked according to their QoS needs.</li> <li> <p>Uplink Data Handling: The UE classifies and marks uplink packets according to QoS rules and uploads them through the designated QoS flows.</p> </li> <li> <p>Exception Handling</p> </li> <li>If a packet does not match a DL PDR or a QoS rule (for uplink), it will be discarded by the UPF or UE.</li> </ol>"},{"location":"blog/20240628/20240628/#how-nfs-achieve-the-qos-in-the-5g-system","title":"How NFs Achieve the QoS in the 5G System","text":""},{"location":"blog/20240628/20240628/#nfs-involved-in-qos","title":"NFs involved in QoS","text":"<ul> <li>AMF (Access and Mobility Management Function) - Located within the Control Plane, the AMF handles all control functions related to access and mobility. This includes managing UE registration and area tracking based on QoS requirements.</li> <li>SMF (Session Management Function) - A core component in the Control Plane, the SMF is responsible for session management, including the negotiation and assurance of QoS. The SMF configures user plane data flows and ensures these flows meet their required QoS.</li> <li>PCF (Policy Control Function) - The PCF provides policy rules in the Control Plane to regulate network behavior, including decisions and applications of QoS policies. It determines which QoS rules apply to specific data flows and conveys these rules to the SMF for enforcement.</li> <li>UPF (User Plane Function) - The primary component of the User Plane, the UPF handles data forwarding and processing. It enforces QoS rules received from the SMF to ensure the quality of service for different data streams. The UPF ensures that data is correctly tagged and handled within the network to meet its QoS requirements.</li> </ul>"},{"location":"blog/20240628/20240628/#interaction","title":"Interaction","text":""},{"location":"blog/20240628/20240628/#downlink-direction-upf-to-ue","title":"Downlink Direction (UPF to UE)","text":"<ul> <li>The IP flows created by application layers and received from DN are mapped to SDFs (Service Data Flow) and then to QoS flows using PDRs (Packet Detection Rules).</li> <li>The QoS flows are then carried through N3 GPRS tunnels using GTPv1-U protocol.</li> <li>The QoS flows received from N3 tunnels are then mapped by the SDAP layer in the gNB to the DRBs using the QoS profiles prepared by the SMF as well as the parameters configured by the operator.</li> </ul>"},{"location":"blog/20240628/20240628/#uplink-direction-ue-to-upf","title":"Uplink Direction (UE to UPF)","text":"<ul> <li>To map IP flows received from the application layer to QoS flows, QoS rules are prepared by SMF. </li> <li>To map the QoS flows to the DRBs, the 5G device is configured through RRC Reconfiguration or by using SDAP header in the case of Reflective QOS.</li> </ul>"},{"location":"blog/20240628/20240628/#core-network","title":"Core Network","text":"<ul> <li>When UE send PDU establishment request to AMF, SMF will get Nsmf_PDUSession_CreateSMContext from AMF, then SMF need to: </li> <li>send Npcf_SMPolicyControl_Get to PCF</li> <li>PCF respond with policy rules (PCC Rules) back to SMF via HTTP/2 protocol.</li> <li>SMF Constructs NAS-5GSM Message Based on Policy Rules:<ul> <li>The SMF constructs a NAS-5GSM message to inform the UE about the specific QoS policies that it should apply for mapping uplink (UL) packets to QoS flows and for applying QoS flow marking.</li> </ul> </li> <li>SMF Sends QoS Profiles to the AMF via N1N2MessageTransfer Request Call Flow:<ul> <li>The SMF uses the N1N2MessageTransfer to send QoS profiles to the AMF. This transfer includes not only the delivery of QoS profiles to the gNB via NGAP messages but also the transmission of NAS messages to the UE. This step aids the gNB in mapping the QoS flows to the Data Radio Bearers (DRBs) and applies QoS rule to UE.</li> </ul> </li> <li>SMF Sends PFCP Message to Instruct the UPF to Apply PDR:<ul> <li>The SMF sends a PFCP (Packet Forwarding Control Protocol) message to the UPF to guide the UPF on applying the predefined PDRs (Packet Detection Rules).</li> </ul> </li> </ul>"},{"location":"blog/20240628/20240628/#conclusion","title":"Conclusion","text":"<p>In conclusion, 5G Quality of Service (QoS) represents a cornerstone in the evolution of mobile networks, enabling a diverse array of applications to operate with the requisite service quality, ranging from high-speed data services to low-latency critical communications and massive IoT deployments. This article has explored the key functions and mechanisms through which 5G networks manage and enforce QoS, emphasizing the roles of various network functions such as the AMF, SMF, PCF, and UPF.</p> <p>We delved into the intricacies of QoS flows, illustrating how different data streams are handled within the network to ensure that each meets its specific quality requirements. The discussion on QoS flow management, including the differentiation between GBR and Non-GBR flows, highlights the adaptability and precision of 5G QoS capabilities.</p> <p>Furthermore, the process of QoS mapping and the roles of QoS rules in directing traffic within the network infrastructure were clarified. This ensures that data is not only efficiently managed but also adheres to the stringent quality standards required by modern applications.</p> <p>Overall, the effective implementation of QoS in 5G networks is fundamental to maximizing network resource utilization and enhancing user experience, establishing a robust framework for the future of telecommunications.</p>"},{"location":"blog/20240628/20240628/#reference","title":"Reference","text":"<ul> <li>TS 23.501</li> <li>TS 23.502</li> <li>TS 23.502</li> <li>TS 24.501</li> </ul>"},{"location":"blog/20240628/20240628/#about-me","title":"About me","text":"<p>Hi, I am Ting-Yuan Chou, a beginner to 5G and free5gc. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20240628/20240628/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: https://github.com/TYuan0816</li> </ul>"},{"location":"blog/20240918/20240918/","title":"How L25GC+ achieved the low-latency communication","text":"<p>Note</p> <p>Author: Chun-Ting Lin Date: 2024/09/18</p>"},{"location":"blog/20240918/20240918/#introduction","title":"Introduction","text":"<p>Cloud-native applications are undergoing a rapid transformation from monolithic architectures to modular architectures, offering enhanced flexibility, modularity, and scalability. However, the decoupling of modules introduces communication overhead, particularly when multiple modules need to collaborate to accomplish a task. A prime example of this is the 5G core network, where multiple modules work together to complete the registration process of a user device. Within this collaboration, two main modes of communication exist: synchronous and asynchronous. Traditional network communication methods can lead to significant overhead between modules, including data replication and protocol processing.</p>"},{"location":"blog/20240918/20240918/#x-io","title":"X-IO","text":"<p>X-IO is implemented using shared memory processing and unlocked producer/consumer rings between callers on the same nodes as the \"X-IO stack\". This approach is a much simpler alternative to kernel network stacking, enabling zero-copy packet transfers and providing a substantial improvement in data plane performance.</p>"},{"location":"blog/20240918/20240918/#unlocked-shared-memory-communication","title":"Unlocked Shared Memory Communication","text":"<p>Two key elements are required to support shared memory communication: - Shared memory buffer pool - Packet descriptor delivery mechanism The shared memory pool provides a shareable backend to store the payload for module access. Packet descriptor delivery delivers pointers to payloads in shared memory between different modules, rather than moving payloads.</p> <p></p>"},{"location":"blog/20240918/20240918/#shared-memory-pools","title":"Shared Memory Pools","text":"<p>X-IO utilizes the X-IO Manager to manage the initialization of shared memory pools. These pools contain a specific number of shared memory buffers. The X-IO Manager runs as the DPDK master process, which grants it the privilege to create memory pools in the Linux file system.</p>"},{"location":"blog/20240918/20240918/#unlocked-packet-descriptor-transfer","title":"Unlocked Packet Descriptor Transfer","text":"<p>To efficiently transfer packet descriptors between caller' X-IO stacks, X-IO utilizes DPDK's RTE RING as a high-speed IPC channel. To minimize latency and overhead, X-IO implements a non-locked producer/consumer ring design. Each X-IO stack has a pair of RTE RINGs for receiving and transmitting, which are shared with the XIO manager. This eliminates the need for locks and allows the X-IO Manager to facilitate descriptor transfer between different X-IO stacks.</p>"},{"location":"blog/20240918/20240918/#raw-io-primitives-in-x-io-zero-copy-interfaces","title":"Raw I/O primitives in X-IO: zero-copy interfaces","text":"<p>X-IO offers raw I/O primitives that enable zero-copy communication between caller. These primitives are implemented using DPDK's RTE RING and Mempool APIs.</p> <p> The image demonstrates zero-copy and shared memory communication in X-IO using the original I/O primitive. It involves the source module writing the payload to a memory buffer and adding the descriptor to the caller's TX ring. The X-IO manager retrieves these descriptors from the caller's TX ring, parses the routing information, and places the descriptors into the target module's RX ring. This design eliminates message duplication, reduces overhead, and improves efficiency compared to core-based networks.</p> <p>X-IO provides a high-performance interface for 5GC functions, utilizing lock-free shared memory processing. This improves the performance of the control plane, especially in achieving low latency.</p> <p>L25GC+ is a 3GPP-compliant, modified 5GC designed for low-latency control plane operations, utilizing X-IO technology. Compared to the existing core-based SBI in free5GC, X-IO provides a superior, high-performance interface between 5GC functionalities and the underlying unlocked shared memory processing.</p> <p>3GPP-compliant commercial testbed - UEs: laptops with 5G dongles (from Apal) - RU: from Alpha Networks Inc. - CU/DU: from AEWIN Technologies - UE Registration &amp; PDU Session</p> <p>Here are the improvements of L25GC+ with a commercial testbed: - Contribution to latency by the 5GC: L25GC+ demonstrates 1.5\u00d7 lower \"CN\" (Core Network) latency for a single UE and 1.3\u00d7 lower \"CN\" latency for 5 UEs during UE registration. - PDU session establishment: L25GC+ achieves 2\u00d7 lower \"CN\" latency for a single UE and 1.6\u00d7 lower \"CN\" latency for 5 UEs. </p>"},{"location":"blog/20240918/20240918/#reference","title":"Reference","text":"<ul> <li>Yu-Sheng Liu, Shixiong Qi, Po-Yi Lin, Han-Sing Tsai, K. K. Ramakrishnan, Jyh-Cheng Chen, \u201cL25GC+ is an improved, 3GPP-compliant 5GC designed for low-latency control plane operations\u201d in 2023 IEEE 12th International Conference on Cloud Networking</li> <li>Shixiong Qi, Han-Sing Tsai, Yu-Sheng Liu, K. K. Ramakrishnan, Jyh-Cheng Chen, \u201cX-IO: A High-performance Unified I/O Interface using Lock-free Shared Memory Processing\u201d in 2023 IEEE 9th International Conference on Network Softwarization</li> <li>Vivek Jain, Hao-Tse Chu, Shixiong Qi, et al., \u201cL25GC: a low latency 5G core network based on high-performance NFV platforms\u201d in Proceedings of the ACM SIGCOMM 2023 Conference</li> </ul>"},{"location":"blog/20240918/20240918/#about","title":"About","text":"<p>Hi, I am Chun-Ting Lin, a beginner to 5G and free5gc. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20240918/20240918/#connect-with-me","title":"Connect with Me","text":"<ul> <li>Linkedin: www.linkedin.com/in/tim-lin-a285bb282/</li> <li>GitHub: https://github.com/tim1207</li> </ul>"},{"location":"blog/20241108/20241108/","title":"Modeling Digital Twins in 5G Networks: A Glimpse into the Future of Intelligent Network Management","text":"<p>Note</p> <p>Author: Yu-Chun Wang Date: 2024/11/08</p> <p>In the ever-evolving landscape of 5G, digital twins are emerging as one of the most promising innovations. By creating a virtual model of physical network components, digital twins in 5G enable real-time monitoring, predictive maintenance, and proactive management. For network providers, this shift promises a powerful way to optimize resource allocation and performance, handle dynamic data traffic demands, and unlock a new level of efficiency. Here\u2019s a look at how digital twin modeling works, its applications in 5G network, and how it\u2019s transforming network management.</p>"},{"location":"blog/20241108/20241108/#what-is-a-digital-twin","title":"What is a Digital Twin?","text":"<p>A digital twin is a virtual model of a physical object, process, or system that uses real-time data to mirror its real-world counterpart. Originally developed in the manufacturing and industrial sectors, digital twins have since expanded into a wide range of fields, including healthcare, urban planning, and telecommunications. By continuously updating with data from sensors, devices, and network infrastructure, digital twins offer a detailed, dynamic representation of physical assets and systems. This environment allows for rapid analysis and supports real-time decision-making with precise, data-driven insights.</p> <p></p>"},{"location":"blog/20241108/20241108/#an-overview-for-network-digital-twin-modeling","title":"An overview for Network Digital Twin Modeling","text":"<p>As 5G technology continues to transform network capabilities, digital twin technology has emerged as a cornerstone for managing these complex, high-performance networks. The research paper \"Digital Twins for 5G Networks: A Modeling and Deployment Methodology\" by Rodrigo et al. [1] offers a detailed framework that guides the development of digital twins in 5G environments, enabling real-time monitoring, predictive analytics, and adaptive management across network elements.</p>"},{"location":"blog/20241108/20241108/#the-building-blocks-of-a-network-digital-twin-model","title":"The Building Blocks of a Network Digital Twin Model","text":"<p>Creating an effective digital twin for 5G involves integrating real-time data, predictive AI models, and secure communications to form a comprehensive, continuously updating network representation. Rodrigo et al. [1] outline a seven-phase methodology to establish a digital twin model that aligns with NFV (Network Function Virtualization) standards, ensuring interoperability and efficient performance in complex 5G ecosystems. Here is a breakdown of these phases:</p> <p></p> <ol> <li> <p>Data Acquisition: This phase begins with collecting data from physical network components, including topologies, hardware configurations, and performance metrics. Automated agents gather this information to form the foundation of the digital twin.</p> </li> <li> <p>Modeling: Using the acquired data, the network\u2019s structure and behavior are modeled. This phase simplifies the network\u2019s complexity to enable efficient and realistic simulations.</p> </li> <li> <p>Adaptation: The digital model is then adapted to fit virtualization standards, transforming data to compatible templates. This ensures it can be integrated seamlessly with Network Function Virtualization (NFV) systems.</p> </li> <li> <p>NFV Deployment: In this phase, the adapted digital model is deployed on an NFV platform, utilizing software such as OpenStack or Kubernetes to host and manage the virtual elements of the network.</p> </li> <li> <p>Provisioning: This step customizes the virtual network by aligning it with specific operational characteristics of the physical network. Tools like Ansible automate deployment, ensuring the digital twin operates similarly to its physical counterpart.</p> </li> <li> <p>Interconnection: Secure, real-time communication between the digital twin and its physical network is established, enabling the two to synchronize and share data. Messaging protocols like MQTT and Kafka are used to support continuous information flow.</p> </li> <li> <p>Feedback Loop: In the final phase, a feedback loop is created, allowing the digital and physical networks to communicate constantly. This supports real-time monitoring, predictive maintenance, and dynamic adjustments for optimal performance\u200b.</p> </li> </ol>"},{"location":"blog/20241108/20241108/#challenges-of-digital-twin-modeling-in-5g-network","title":"Challenges of Digital Twin Modeling in 5G Network","text":"<p>Creating and deploying digital twins in 5G networks is no small feat. Some of the challenges include:</p> <ul> <li> <p>High Data Processing Requirements: Digital twins require massive data streams to accurately reflect the state of network functions. This means that 5G networks need powerful processing capabilities and efficient data management strategies to support the continuous operation of digital twins.</p> </li> <li> <p>Data Privacy and Security: With vast amounts of data flowing between physical network functions and their digital counterparts, maintaining robust security protocols is crucial to prevent data breaches and unauthorized access.</p> </li> <li> <p>Computational Load: Running real-time digital twin models can require significant computational resources.</p> </li> </ul>"},{"location":"blog/20241108/20241108/#the-future-of-digital-twins-in-5g-and-beyond","title":"The Future of Digital Twins in 5G and Beyond","text":"<p>As 5G advances and the next generation of networks\u20146G\u2014emerges, digital twin technology will likely expand to support applications such as autonomous vehicles, augmented reality, and the industrial Internet of Things (IoT). With advances in AI and machine learning, digital twins will become more predictive and adaptive, enabling smarter decision-making in network management. Additionally, with the anticipated rollout of 6G, digital twins will play a pivotal role in managing an even more complex network ecosystem.</p>"},{"location":"blog/20241108/20241108/#conclusion","title":"Conclusion","text":"<p>Modeling digital twins in 5G represents a critical leap towards intelligent, proactive network management. As Rodrigo et al. [1] illustrate, these virtual models allow for unprecedented levels of control, visibility, and agility, transforming network operations. As 5G networks evolve and demand for efficient management grows, digital twin technology will be essential for network operators, ensuring they remain at the forefront of telecommunications innovation.</p>"},{"location":"blog/20241108/20241108/#reference","title":"Reference","text":"<p>[1] M. Sanz Rodrigo, D. Rivera, J. I. Moreno, M. \u00c0lvarez-Campana and D. R. L\u00f3pez, \"Digital Twins for 5G Networks: A Modeling and Deployment Methodology,\" in IEEE Access, vol. 11, pp. 38112-38126, 2023, doi: 10.1109/ACCESS.2023.3267548. [2] A. Fuller, Z. Fan, C. Day and C. Barlow, \"Digital Twin: Enabling Technologies, Challenges and Open Research,\" in IEEE Access, vol. 8, pp. 108952-108971, 2020, doi: 10.1109/ACCESS.2020.2998358.</p>"},{"location":"blog/20241108/20241108/#about","title":"About","text":"<p>Hi, I'm Yu-Chun! As a newcomer to 5G and the free5GC community, I'm diving into innovative 5G applications and tackling TNGF-related issues. My focus is on digital twin applications within the 5G space, where I\u2019m passionate about pushing network capabilities to new levels.</p>"},{"location":"blog/20241108/20241108/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: https://github.com/blackcat-118</li> </ul>"},{"location":"blog/20241113/20241113/","title":"Mapping PCC Rules into Session Rules: Policy Application in 5G Networks","text":"<p>Note</p> <p>Author: Alonza Tu Date: 2024/11/13</p>"},{"location":"blog/20241113/20241113/#roles-of-pcc-rules-and-session-rules","title":"Roles of PCC Rules and Session Rules","text":"<p>In 5G networks, managing service quality for diverse applications is critical to providing users with a consistent experience. PCC, which stands for Policy and Charging Control, rules play a central role in regulating traffic flows, enforcing quality standards, and adapting network resources according to real-time conditions.</p> <p>Session Rules serve as the operational framework for implementing PCC decisions at the user session level. They are responsible for managing session establishment, maintenance, and termination while ensuring proper resource allocation and QoS enforcement. These rules translate high-level policy decisions into concrete network behaviors, coordinating between different network functions to maintain service quality and optimize resource utilization throughout the session lifecycle.</p>"},{"location":"blog/20241113/20241113/#abstract-of-network-functions","title":"Abstract of Network Functions","text":"<ul> <li>PCF(Policy Control Function): The PCF is responsible for generating PCC rules based on the service requirements and network conditions.</li> <li>SMF(Session Management Function): The SMF is responsible for translating PCC rules received from the PCF into actionable configurations on the user plane.</li> <li>UPF(User Plane Function): The UPF enforces the PDRs based on the rules set by SMF.</li> <li>UE(User Equipment): The UE is the terminal equipment that connects to the network and communicates with the core network.</li> </ul>"},{"location":"blog/20241113/20241113/#process-of-mapping-pcc-rules-into-session-rules","title":"Process of Mapping PCC Rules into Session Rules","text":"<ul> <li> <p>PCF transmits PCC rules to SMF.</p> <ul> <li>PCF transmits SmPolicyDecision to SMF, which contains:<ul> <li>PCC rules: PCC rules specify how traffic should be handled based on various conditions, including data volume, priority, and the quality of service (QoS) requirements.</li> <li>QoS decision: The Quality of Service (QoS) decision specifies the level of service quality that should be applied to a particular network session. This includes parameters like latency, data rate, and packet loss, which collectively determine how reliably and quickly data is transmitted.</li> <li>Flow control decision: Flow control decisions determine how network traffic is regulated to prevent congestion, ensuring a smooth flow of data. It is essential to maintaining overall network stability and user experience.</li> <li>Charging decision: The charging decision outlines how usage fees are calculated for the services consumed by the user. It specifies which traffic should be charged and under what conditions, as well as the applicable rates.</li> </ul> </li> </ul> </li> <li> <p>SMF processes PCC rules.</p> <ul> <li>After receiving the SmPolicyDecision, SMF will use <code>ApplyPccRules()</code> to translate PCC rules into session rules.</li> <li>It includes three main steps:<ul> <li>Create or update the data path for each PCC rule.</li> <li>Process relative QoS, flow control, and charging rules' parameters.</li> </ul> </li> </ul> </li> <li> <p>Data path establishment.</p> <ul> <li>In the beginning of <code>CreatePccRuleDataPath()</code>, it will get routing position message from tcData(i.e., traffic control data), including DNAI(i.e., data network access identifier).</li> <li>Next, SMF will configure the UPF selection parameters which contains DNN, network slice and DNAI information and use these parameters to create the user plane data path.</li> <li>Then, check whether it is no default path and PCC priority is 255, if so, it will set this path as the default data path.</li> <li>Also, it will set if this flow is GBR(i.e., guaranteed bit rate) flow or not, as well as activate the tunnel and PDR according to the priority.</li> <li>Before returning, it will setup the PCC parameters, add charging rule(including <code>chgLevel</code> and <code>chgData</code>) and configure the QoS(including <code>QFI</code> and <code>qosData</code>) for later use.</li> </ul> </li> <li> <p>QoS configuration.</p> <ul> <li>In this step, SMF will assign a unique QFI via <code>AssignQFI()</code> to each PCC rule and use this QFI to configure the QoS flow and data path according to the QoS data.</li> <li>In <code>AddQoS()</code>, it is designed to add Quality of Service (QoS) configurations for a given session, based on the QoS parameters and a specific QoS Flow Identifier (QFI). Here\u2019s a breakdown of what this function does:<ul> <li>Default QFI check: If the QoS parameter is nil and the QFI is not 1 (which is treated as the default QFI), the function will return immediately, implying that no additional QoS setup is required for non-default QFIs when QoS is missing.</li> <li>Iterate Over Data Path Nodes: The function iterates through each data path node, starting from <code>FirstDPNode</code> and moving through each node in sequence.</li> <li>QER(QoS Enforcement Rule) Management: For each node, it fetches the UUID of the UPF (User Plane Function) node and creates a unique QoS ID based on the UUID and qfi. If a QER entry does not already exist for the given QoS ID in the session context (<code>smContext.QerUpfMap</code>), a new QER is created and configured.</li> <li>QER Setup: The QER includes the QFI value and opens both uplink and downlink gates to allow traffic in both directions.</li> <li>QER Linking: Once the QER is configured, the function links it to the PDRs (Packet Detection Rules) in the uplink and downlink tunnels of the node, if they exist. This ensures that the QER settings are applied to data packets as they traverse the UPF.</li> </ul> </li> </ul> </li> <li> <p>Flow control setup.</p> <ul> <li>In <code>ActivateTunnelAndPDR()</code>, we will use tunnel and PDR to setup the flow forward rule through these steps:<ul> <li>Activating Tunnels: It iterates through all DP Nodes(Data Path Nodes) in the given DataPath and activates both uplink and downlink tunnels for each node.</li> <li>Setting Up URR (Optional): Depending on the configuration in <code>smContext</code>, it may add a URR(Usage Reporting Rule) to monitor traffic and usage on the data path.</li> <li>Activating PDR: It then configures PDRs for each DP Node. For each node, the function:</li> <li>Sets up QERs for managing data rates.</li> <li>Configures FARs(Forwarding Action Rules) for traffic forwarding, including outer header creation where necessary.</li> <li>Configures Uplink and Downlink PDRs: For each DP Node, it establishes the uplink and downlink PDRs, defining parameters such as interface information, IP addresses, and header removal options.</li> </ul> </li> </ul> </li> <li> <p>Charging rule generation.</p> <ul> <li>Before we add the actual charging rule, we need to call <code>IdentifyChargingLevel()</code> to identify the charging level is PDU session level or flow level. Then, we will add charging rule via <code>AddChargingRules()</code>:<ul> <li>Iterating through DP Nodes: For each node in the DataPath, if the node is an anchor UPF, the function proceeds with setting up charging rules.</li> <li>Charging Info and URR ID Allocation:<ul> <li>Creates a ChargingInfo structure containing the rating group, charging level, and UPF ID.</li> <li>Allocates a unique URR ID using UrrIDGenerator. If this allocation fails, an error is logged and the function returns.</li> </ul> </li> <li>URR Setup:<ul> <li>It builds an ID key to map this URR to the UPF node.</li> <li>Checks if the URR already exists in smContext.UrrUpfMap:<ul> <li>Online Charging:<ul> <li>Creates a URR with a start trigger to detect the beginning of the Service Data Flow (SDF).</li> <li>Sets the ChargingMethod to ONLINE_CHARGING.</li> </ul> </li> <li>Offline Charging:<ul> <li>Configures URR reporting based on a volume threshold (e.g., data usage).</li> <li>Sets the ChargingMethod to OFFLINE_CHARGING.</li> </ul> </li> </ul> </li> <li>If the URR is new, it is added to smContext.UrrUpfMap.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Session rule generation.</p> <ul> <li>After finishing the above steps, SMF will generate the session rule by calling <code>ApplySessiongRules()</code>.</li> </ul> </li> </ul>"},{"location":"blog/20241113/20241113/#conclusion","title":"Conclusion","text":"<p>The mapping of PCC rules into session rules is a critical process in 5G networks, ensuring that high-level policy decisions are effectively translated into concrete network behaviors. This process involves collaboration between the PCF, SMF, UPF, and UE, coordinating between different network functions to maintain service quality and optimize resource utilization throughout the session lifecycle.</p>"},{"location":"blog/20241113/20241113/#reference","title":"Reference","text":"<ul> <li>TS 23.502</li> <li>TS 23.503</li> <li>TechSpec 23.501 5.7 QoS Model</li> <li>Introduction to 5G Quality of Service (QoS)</li> <li>\u6838\u5fc3\u7db2\u8def\u7684\u7b56\u7565\u8207\u8a08\u8cbb</li> </ul>"},{"location":"blog/20241113/20241113/#about","title":"About","text":"<p>Hello, I'm Alonza. This autumn, I\u2019m excited to be joining the free5GC project with a lot of enthusiasm. I look forward to diving into the technical aspects of the 5G core network and growing my expertise in this cutting-edge field. My goal is to learn alongside the team, contribute meaningfully, and help advance the development of 5G technology together.</p>"},{"location":"blog/20241113/20241113/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: https://github.com/Alonza0314</li> <li>Website: Alonza0314</li> </ul>"},{"location":"blog/20241127/20241127/","title":"NWDAF introduction","text":"<p>Note</p> <p>Author: Liu Hsiang Kuan Date: 2024/11/27</p>"},{"location":"blog/20241127/20241127/#roles-of-nwdaf","title":"Roles of NWDAF","text":"<ul> <li>The Network Data Analytics Function (NWDAF) is a key component of the 5G core network responsible for collecting and analyzing network data to provide insights and predictions for network optimization and management. Think of it as the \"brain\" of the 5G network that helps make intelligent decisions based on data analysis. </li> </ul>"},{"location":"blog/20241127/20241127/#analytics-mechanisms","title":"Analytics Mechanisms","text":"<ul> <li>NWDAF operates through three main functional aspects that work together to deliver network analytics:</li> <li> </li> <li> </li> <li> </li> </ul>"},{"location":"blog/20241127/20241127/#1-data-collection","title":"1. Data Collection","text":""},{"location":"blog/20241127/20241127/#mechanisms","title":"Mechanisms","text":"<p>The NWDAF begins its operation by gathering data from various sources within the 5G network. Imagine this as a network monitoring system that:</p> <ul> <li>Collects real-time performance data from network functions</li> <li>Gathers historical data for trend analysis</li> <li>Coordinates data collection to avoid redundancy</li> </ul>"},{"location":"blog/20241127/20241127/#execute-architecture","title":"Execute architecture","text":"<ul> <li> <p>Basic Collection Through Nnf Interface     The NWDAF's data collection process starts with its basic interface - Nnf, which allows NWDAF to collect data from various Network Functions (NFs) in the 5G core network. Through this interface, NWDAF can subscribe to the data it needs, such as network performance metrics, user behavior data, or service quality indicators.</p> <p></p> </li> <li> <p>Enhanced Collection with DCCF     To improve the efficiency of data collection, DCCF acts as a central coordinator between data sources and NWDAF. Think of DCCF as a smart traffic controller - when multiple NWDAFs need the same data from an NF, instead of each NWDAF making separate requests, DCCF manages these requests centrally. It collects the data once and distributes it to all interested NWDAFs, significantly reducing the network's signaling load. </p> </li> <li> <p>Management Data Through OAM     For network management information, NWDAF also connects to the Operation, Administration and Maintenance (OAM) system. This connection provides NWDAF with essential network configuration and management data, helping it understand the broader context of network operations.</p> </li> </ul>"},{"location":"blog/20241127/20241127/#2-analytics-processing","title":"2. Analytics Processing","text":""},{"location":"blog/20241127/20241127/#mechanisms_1","title":"Mechanisms","text":"<ul> <li>At the heart of NWDAF lies its analytics capabilities:</li> <li>Uses advanced algorithms to process network data</li> <li>Employs AI/ML models for predictive analytics</li> <li>Supports distributed learning across multiple NWDAF instances</li> <li>Manages and updates analytics models</li> </ul>"},{"location":"blog/20241127/20241127/#execute-architecture_1","title":"Execute Architecture","text":"<ul> <li>Analytics Processing with AnLF &amp; MTLF<ul> <li>AnLF: processes the incoming data streams and generates real-time insights about network conditions in NWDAF</li> <li>MTLF: providing trained machine learning models and help predict network behavior</li> <li> <p>Analytics Model     The interaction between AnLF and MTLF creates a dynamic analytics environment. AnLF uses the models provided by MTLF to process current data, while MTLF uses the results to refine its models. </p> <ul> <li>These two core components will discuss in next section</li> </ul> </li> </ul> </li> </ul>"},{"location":"blog/20241127/20241127/#3-analytics-exposure","title":"3. Analytics Exposure","text":""},{"location":"blog/20241127/20241127/#mechanisms_2","title":"Mechanisms","text":"<p>NWDAF shares its insights through:</p> <ul> <li>Subscription-based analytics services</li> <li>Real-time analytics delivery</li> <li>Historical data analysis</li> <li>ML model provisioning</li> </ul>"},{"location":"blog/20241127/20241127/#architecture","title":"Architecture","text":"<ul> <li> <p>Analytics Distribution through Nnwdaf     The Nnwdaf interface serves as the primary channel for sharing analytics results. Network functions can subscribe to specific types of analytics and receive regular updates or request specific information when needed. </p> </li> <li> <p>Coordinated Analytics Delivery     Similar to data collection, DCCF can help optimize analytics distribution by managing multiple subscriptions and ensuring efficient delivery of analytics results to various consumers. </p> </li> </ul>"},{"location":"blog/20241127/20241127/#details-for-analytics-processing","title":"Details for Analytics Processing","text":""},{"location":"blog/20241127/20241127/#core-components","title":"Core Components","text":"<ul> <li> <p>Analytics Logical Function (AnLF)     AnLF is the primary analytics engine in NWDAF that processes data             and generates insights.      Its responsibilities include:</p> <ul> <li>Performing inference on collected network data</li> <li>Generating statistical information about past events</li> <li>Providing predictive analytics for future network behavior</li> <li>Exposing analytics through Nnwdaf_AnalyticsSubscription/Info services</li> </ul> <p>AnLF can work with both statistical models and ML models provided by MTLF, allowing it to handle different types of analytics requirements. While AnLF processes the analytics requests, it remains unaware of whether the ML models it uses were trained through federated learning or traditional methods.</p> </li> <li> <p>Model Training Logical Function (MTLF)     MTLF specializes in training and managing ML models. In Release 18, MTLF introduced significant enhancements, particularly in federated learning capabilities. Its main functions include:</p> <ul> <li>Training ML models using collected network data</li> <li>Supporting federated learning among multiple NWDAFs</li> <li>Managing ML model updates and provisioning</li> <li>Providing trained models to AnLF and other network functions</li> </ul> <p>MTLF can operate in two modes within federated learning:</p> <pre><code>1. As an FL Server: Coordinating model training across multiple NWDAFs\n2. As an FL Client: Training models locally using its own data\n</code></pre> </li> <li> <p>The interaction between AnLF and MTLF creates a complete analytics pipeline where:</p> <ul> <li>AnLF handles the analytics processing and service exposure</li> <li>MTLF manages the underlying ML models and training</li> </ul> </li> <li> <p>This separation of concerns allows for specialized optimization of both analytics processing and model training while maintaining flexibility in deployment options.This continuous feedback loop ensures that NWDAF's analytics capabilities keep improving over time. </p> </li> </ul>"},{"location":"blog/20241127/20241127/#nwdaf-important-analytics-services","title":"NWDAF Important Analytics Services","text":"<ul> <li>Here are some key situations that need the assistance of NWDAF </li> <li> </li> <li> </li> <li> </li> </ul>"},{"location":"blog/20241127/20241127/#1-network-performance-analytics","title":"1. Network Performance Analytics","text":""},{"location":"blog/20241127/20241127/#slice-load-level-analytics-section-63","title":"Slice Load Level Analytics (Section 6.3)","text":"<ul> <li>In modern 5G networks, different services run on separate network slices. NWDAF continuously monitors each slice's resource usage and provides essential information for slice selection. </li> <li>For example, when a gaming service slice approaches high load, NWDAF can trigger resource reallocation or guide new users to less congested slices, ensuring consistent service quality.</li> </ul>"},{"location":"blog/20241127/20241127/#nf-load-analytics-section-65","title":"NF Load Analytics (Section 6.5)","text":"<ul> <li>Network Functions like AMF and SMF are critical components in 5G. NWDAF analyzes their load status to enable intelligent load balancing. </li> <li>When NWDAF detects an overloaded AMF, it can inform the system to redirect new connections to other AMFs, maintaining optimal network operation.</li> </ul>"},{"location":"blog/20241127/20241127/#2-user-experience-analytics","title":"2. User Experience Analytics","text":""},{"location":"blog/20241127/20241127/#service-experience-analytics-section-64","title":"Service Experience Analytics (Section 6.4)","text":"<ul> <li>NWDAF monitors real-time service quality by analyzing metrics like latency and throughput. </li> <li>For instance, if video streaming users in a specific area experience degraded quality, NWDAF can identify the issue and trigger necessary adjustments to maintain service standards.</li> </ul>"},{"location":"blog/20241127/20241127/#ue-behavior-analytics-section-67","title":"UE Behavior Analytics (Section 6.7)","text":"<ul> <li>By analyzing user movement patterns, NWDAF can predict future locations and behaviors. This enables proactive resource allocation </li> <li>If NWDAF predicts a large crowd gathering for an event, the network can prepare additional resources in that area beforehand.</li> </ul>"},{"location":"blog/20241127/20241127/#3-resource-optimization","title":"3. Resource Optimization","text":""},{"location":"blog/20241127/20241127/#qos-sustainability-analytics-section-69","title":"QoS Sustainability Analytics (Section 6.9)","text":"<ul> <li>NWDAF helps maintain consistent service quality by predicting potential QoS changes. If it detects that video call quality might degrade in a busy area, it can initiate preemptive measures to maintain service levels.</li> </ul>"},{"location":"blog/20241127/20241127/#user-data-congestion-analytics-section-68","title":"User Data Congestion Analytics (Section 6.8)","text":"<ul> <li>Through traffic pattern analysis, NWDAF can identify potential congestion before it impacts users. </li> <li>For example, it can detect emerging congestion patterns during peak hours and recommend traffic redistribution to prevent service degradation.</li> </ul>"},{"location":"blog/20241127/20241127/#a-complete-example-of-nwdaf-analytics","title":"A Complete Example of NWDAF Analytics","text":"<ul> <li>Let's review the NWDAF by real-world scenario, imagine a high-priority gaming service slice experiencing increasing load during peak gaming hours:</li> <li> </li> <li> </li> <li> </li> <li> </li> </ul>"},{"location":"blog/20241127/20241127/#1-data-collection-process","title":"1. Data Collection Process","text":"<p>First, NWDAF collects data from various network functions:</p> <ul> <li>Gets real-time resource utilization data from network slices</li> <li>Receives user connection information from AMF</li> <li>Obtains QoS flow statistics from SMF</li> <li>Gathers historical load patterns from OAM</li> </ul>"},{"location":"blog/20241127/20241127/#2-analytics-processing_1","title":"2. Analytics Processing","text":"<p>NWDAF then processes this data using its two core components:</p> <ul> <li> <p>AnLF (Analytics Logical Function):</p> <ul> <li>Analyses current slice load trends</li> <li>Compares with historical patterns</li> <li>Identifies potential overload risks</li> </ul> </li> <li> <p>MTLF (Model Training Logical Function):</p> <ul> <li>Uses collected data to train prediction models</li> <li>Updates models based on new patterns</li> <li>Provides refined models to AnLF for better predictions</li> </ul> </li> </ul>"},{"location":"blog/20241127/20241127/#3-analytics-results-and-actions","title":"3. Analytics Results and Actions","text":"<p>NWDAF generates actionable insights:</p> <ul> <li>Predicts slice load for the next few hours</li> <li>Identifies potential capacity issues</li> <li>Recommends preventive measures</li> </ul>"},{"location":"blog/20241127/20241127/#4-network-optimization","title":"4. Network Optimization","text":"<p>The system responds to NWDAF's analytics:</p> <ul> <li>NSSF adjusts slice selection strategy</li> <li>AMF redirects new gaming users to less loaded slices</li> <li>OAM allocates additional resources if available</li> </ul>"},{"location":"blog/20241127/20241127/#references","title":"References","text":"<ul> <li>3GPP TS 23.288</li> <li>https://blog.csdn.net/qq_31985307/article/details/139897023</li> <li>https://www.5gamericas.org/wp-content/uploads/2021/10/5G-Edge-and-Automation-PPT.pdf</li> <li>https://www.aarna.ml/post/nwdaf-rel-17-explained-architecture-features-and-use-cases</li> </ul>"},{"location":"blog/20241203/20241203/","title":"Loxilb eBPF","text":"<p>In the evolving landscape of networking, the demand for high-performance, flexible, and efficient solutions has never been greater. Traditional approaches to packet processing often struggle to keep up with the scale and complexity of modern cloud-native environments and 5G networks. Enter Loxilb, an innovative networking solution leveraging the power of eBPF (Extended Berkeley Packet Filter). eBPF, a game-changing technology in the Linux kernel, allows developers to customize packet processing directly in the kernel with unparalleled speed and flexibility, all while maintaining safety and stability.</p> <p>A practical application of LoxiLB's capabilities is demonstrated in the 5G core networks, where effectively managing signaling traffic is crucial for performance and reliability. For example, deploying a load balancer to distribute traffic across multiple Access and Mobility Management Function (AMF) instances enhances both scalability and fault tolerance. This approach is detailed in the article \"5G SCTP LoadBalancer Using LoxiLB Applying on free5GC\", which illustrates how LoxiLB can distribute SCTP traffic among multiple AMF instances within a free5GC environment.</p> <p>In this document, I will provide a comprehensive exploration of Loxilb's architecture, its efficient use of eBPF, and the dual-pipeline design that makes it a robust choice for scenarios requiring high-performance networking and advanced load balancing. Whether you're an enthusiast, developer, or systems architect, this guide will equip you with a deep understanding of how Loxilb utilizes eBPF to revolutionize packet processing and load balancing in modern networks.</p>"},{"location":"blog/20241203/20241203/#introduction","title":"Introduction","text":"<p>Loxilb is a networking solution that utilizes eBPF, leverage eBPF to modify the packet processing rules as they traverse the network stack in the Linux kernel. This can be particularly useful for network behavior without altering existing applications or the operating system itself.</p>"},{"location":"blog/20241203/20241203/#core-components","title":"Core Components","text":""},{"location":"blog/20241203/20241203/#object-files","title":"Object Files","text":"<p>loxilb generates two primary object files during build: <pre><code>/opt/loxilb/llb_ebpf_main.o  # TC layer processing (305KB)\n/opt/loxilb/llb_xdp_main.o   # XDP layer processing (95KB)\n</code></pre></p>"},{"location":"blog/20241203/20241203/#hook-points","title":"Hook Points","text":"Feature TC eBPF XDP Packet Format Socket Buffer (skb) XDP Frame Format Processing Level L2-L7 Primarily L2 <ol> <li>TC eBPF Layer</li> <li>Handles majority of L4+ processing</li> <li>Optimized for complex operations</li> <li>Supports TCP checksum offload</li> <li>Handles connection tracking</li> <li>XDP Layer</li> <li>Performs quick L2 operations</li> <li>Handles packet mirroring</li> <li>Used for operations requiring multiple packet copies</li> </ol>"},{"location":"blog/20241203/20241203/#loxilb-ebpf-maps","title":"loxilb eBPF Maps","text":"<p>eBPF (extended Berkeley Packet Filter) maps are essential data structures within the Linux kernel that facilitate efficient storage and sharing of data between eBPF programs and user-space applications.</p> <p>They function as key-value stores, enabling eBPF programs to maintain state across multiple invocations and allowing communication between the kernel and user space. * State Preservation * Kernel-User Space Communication * Data Sharing Among eBPF Programs</p> <p>LoxiLB utilizes eBPF maps to store and manage various data structures essential for packet processing. These maps are pinned to the filesystem, allowing for persistent storage and easy access. Commonly used maps include: * Interface Maps: Store information about network interfaces.</p> <ul> <li> <p>Connection Tracking Maps: Maintain state information for active connections.</p> </li> <li> <p>NAT Maps: Handle Network Address Translation entries.</p> </li> <li> <p>Policy Maps: Store security and routing policies.</p> </li> </ul>"},{"location":"blog/20241203/20241203/#loxilb-ebpf-pipeline","title":"loxilb eBPF pipeline","text":"<p>Then I will detail analysis of loxilb's end-to-end packet processing pipeline and Load Balancer based on this architecture diagram.</p>"},{"location":"blog/20241203/20241203/#what-is-ebpf-tail-call","title":"What is eBPF Tail Call?","text":"<p>An eBPF tail call is a mechanism that allows one eBPF program to call another eBPF program without returning to the original program. It's like a \"jump\" instruction that transfers control completely to another program and have benefit in: * Modular code structure * Efficient processing pipeline * Compliance with eBPF verifier limits * The Linux kernel limits the number of consecutive tail calls allowed to 32</p>"},{"location":"blog/20241203/20241203/#pipeline-selection","title":"Pipeline Selection","text":"<p>Fast Path (pipe1)and Slow Path (pipe2), these two pipelines address the need for optimizing different types of packet processing tasks based on their complexity and requirements. <pre><code>[Incoming Packet]\n      \u2193\n[Parse Packet Headers]\n      \u2193\n[Connection Lookup]\u2500\u2500\u2500\u2500\u2500Yes\u2500\u2500\u2510\n      \u2193                      \u2193\n[Is Established?]     [Process &amp; Forward (Fast Path)]\n      \u2193                      \u2502\n      No                     \u2502\n      \u2193                      \u2502\n[Tail Call to Slow Path]     \u2502\n      \u2502                      \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"blog/20241203/20241203/#tcp-and-udp-example","title":"TCP and UDP example","text":"<pre><code>### TCP Example:\nCLOSED \u2192 SYN_SENT \u2192 SYN_RECEIVED \u2192 ESTABLISHED\n   \u2502                                    \u2502\n   \u2502                                    \u25bc\n[Slow Path Processing]            [Move to Fast Path]\n\n\n### UDP Example:\nNEW \u2192 SEEN \u2192 ESTABLISHED\n \u2502              \u2502\n \u2502              \u25bc\n[Slow Path] [Move to Fast Path]\n</code></pre>"},{"location":"blog/20241203/20241203/#1-initial-packet-reception-and-parsing","title":"1. Initial Packet Reception and Parsing","text":"<p><code>kernel/llb_kern_entry.c</code> <pre><code>[Incoming Packet] \u2192 [packet parsing]\n  \u2193\n[intf map] - Interface configuration lookup\n  - Interface index\n  - VLAN information\n  - Zone information\n  - Policy parameters\n</code></pre> * When a packet arrives(parsing happens in <code>dp_parse_d0</code>), the packet parsing module extracts key metadata such as:     * Source/destination MAC addresses     * IP addresses     * Layer 4 ports (if applicable) * Metadata is stored in the <code>xfi</code> structure, which guides further processing. * Interface-specific rules and properties are checked using <code>intf_map</code>.</p>"},{"location":"blog/20241203/20241203/#2-qos-processing","title":"2. QoS Processing","text":"<p><code>kernel/llb_kern_policer.c</code> <pre><code>[QoS Stage]\n  \u2193\n[pol map] - Policy lookup\n  - Traffic policing rules\n  - Rate limiting\n  - Traffic shaping\n  \u2193\n[qos map] - QoS parameters\n  - Priority queues\n  - Bandwidth allocation\n</code></pre> * Traffic policies (e.g., rate-limiting, prioritization) are applied based on:     * Policy map <code>pol_map</code>: Defines access control and prioritization policies.     * QoS map <code>qos_map</code>: Ensures compliance with Quality of Service requirements (e.g., rate shaping). * Packets violating policies may be dropped or delayed.</p>"},{"location":"blog/20241203/20241203/#3-layer-2-forwarding","title":"3. Layer 2 Forwarding","text":"<p><code>kernel/llb_kern_l2fwd.c</code></p>"},{"location":"blog/20241203/20241203/#key-components","title":"Key Components","text":"<ul> <li><code>l2fwd</code> (Layer 2 forwarding)</li> <li><code>l2tunfwd</code> (Layer 2 tunneling forwarding)</li> </ul>"},{"location":"blog/20241203/20241203/#maps-used","title":"Maps Used:","text":"<ul> <li><code>smac_map</code>: Source MAC address</li> <li><code>dmac_map</code>: Destination MAC address</li> <li><code>rmac_map</code>: Router MAC address</li> </ul>"},{"location":"blog/20241203/20241203/#l2fwd-mac-based-forwarding","title":"<code>l2fwd</code> (MAC-based forwarding)","text":"<pre><code>[l2fwd Stage]\n  \u2193\n[smac map] - Source MAC processing\n  - MAC learning\n  - Source validation\n  \u2193\n[dmac map] - Destination MAC processing\n  - MAC lookup\n  - L2 forwarding decision\n</code></pre>"},{"location":"blog/20241203/20241203/#l2tunfwd-tunneling-at-layer-2","title":"<code>l2tunfwd</code> (tunneling at Layer 2)","text":"<pre><code>[l2tunfwd Stage]\n  - VXLAN processing\n  - NVGRE processing\n  - Other L2 tunnel protocols\n</code></pre>"},{"location":"blog/20241203/20241203/#4-layer-3-forwarding","title":"4. Layer 3 Forwarding","text":"<p><code>kernel/llb_kern_l3fwd.c</code></p>"},{"location":"blog/20241203/20241203/#key-functions","title":"Key Functions","text":"<ul> <li><code>dp_ing_l3()</code>: Entry point for L3 ingress processing.</li> <li><code>dp_l3_fwd()</code>: Main function for Layer 3 forwarding.</li> <li><code>dp_do_rtv4()</code> and <code>dp_do_rtv6()</code>: Handle IPv4 and IPv6 route lookups and apply forwarding actions.</li> <li><code>dp_do_ctops()</code>: Handles connection tracking and NAT for packets.</li> </ul>"},{"location":"blog/20241203/20241203/#maps-used_1","title":"Maps Used:","text":"<ul> <li><code>ct_map</code>: Connection tracking table for stateful flow handling.</li> <li><code>rt_v4_map</code>: IPv4 routing table.</li> <li><code>rt_v6_map</code>: IPv6 routing table.</li> <li><code>LL_DP_RTV4_STATS_MAP</code> and <code>LL_DP_RTV6_STATS_MAP</code>: Statistics for routes.</li> </ul>"},{"location":"blog/20241203/20241203/#5-load-balancer-layer-4-forwarding","title":"5. Load Balancer / Layer 4 Forwarding","text":""},{"location":"blog/20241203/20241203/#kernelllb_kern_ctc","title":"<code>kernel/llb_kern_ct.c</code>","text":"<p>Provides connection tracking infrastructure</p>"},{"location":"blog/20241203/20241203/#key-components_1","title":"Key Components","text":"<ul> <li>Connection State Tracking:</li> <li>Maintains connection states for all protocols (TCP/UDP/SCTP/ICMP)</li> <li> <p>Required for stateful operation in both load balancing and L4 forwarding</p> </li> <li> <p>NAT Support Infrastructure:</p> </li> <li>Tracks NAT translations</li> <li>Maintains original and translated addresses/ports</li> <li>Essential for load balancer backend selection</li> </ul>"},{"location":"blog/20241203/20241203/#kernelllb_kern_natlbfwdc","title":"<code>kernel/llb_kern_natlbfwd.c</code>:","text":"<p>Network Address Translation (NAT) and Load Balancer forwarding implementation</p>"},{"location":"blog/20241203/20241203/#multiple-load-balancing-algorithms","title":"Multiple load balancing algorithms:","text":"<ul> <li>Round Robin <pre><code>if (act-&gt;sel_type == NAT_LB_SEL_RR) {\n    bpf_spin_lock(&amp;act-&gt;lock);\n    i = act-&gt;sel_hint; \n\n    // Iterate through endpoints\n    while (n &lt; LLB_MAX_NXFRMS) {\n        if (nxfrm_act-&gt;inactive == 0) {\n            // Select next backend in rotation\n            act-&gt;sel_hint = (i + 1) % LLB_MAX_NXFRMS;\n            sel = i;\n            break;\n        }\n    }\n}\n</code></pre></li> <li>Hash-based <pre><code>if (act-&gt;sel_type == NAT_LB_SEL_HASH) {\n    // Hash packet for backend selection\n    sel = dp_get_pkt_hash(ctx) % act-&gt;nxfrm;\n\n    // Fallback if selected backend is inactive\n    if (act-&gt;nxfrms[sel].inactive) {\n        for (i = 0; i &lt; LLB_MAX_NXFRMS; i++) {\n            if (act-&gt;nxfrms[i].inactive == 0) {\n                sel = i;\n                break;\n            }\n        }\n    }\n}\n</code></pre></li> <li>Least Connections <pre><code>if (act-&gt;sel_type == NAT_LB_SEL_LC) {\n    struct dp_nat_epacts *epa;\n    __u32 lc = 0;\n\n    // Find backend with least active connections\n    for (i = 0; i &lt; LLB_MAX_NXFRMS; i++) {\n        if (nxfrm_act-&gt;inactive == 0) {\n            __u32 as = epa-&gt;active_sess[i];\n            if (lc &gt; as || sel &lt; 0) {\n                sel = i;\n                lc = as;\n            }\n        }\n    }\n}\n</code></pre></li> <li>Persistent RR</li> <li>N3 (GTP tunnel) based</li> </ul>"},{"location":"blog/20241203/20241203/#conclusion-about-loxilbs-effective-use-of-ebpf","title":"Conclusion about loxilb's effective use of eBPF","text":""},{"location":"blog/20241203/20241203/#smart-pipeline-design","title":"Smart Pipeline Design","text":"<ul> <li>Dual pipeline architecture (Fast/Slow) optimizes performance</li> <li>Fast path for established connections</li> <li>Slow path for new connections and complex processing</li> </ul>"},{"location":"blog/20241203/20241203/#effective-use-of-ebpf-features","title":"Effective Use of eBPF Features","text":"<ul> <li>Tail calls to overcome program size limits</li> <li>Maps for state management</li> <li>TC and XDP hooks for different processing needs</li> </ul>"},{"location":"blog/20241203/20241203/#loxilb-particularly-suitable-for","title":"loxilb particularly suitable for","text":"<ul> <li>Modern cloud-native environments</li> <li>High-performance networking</li> <li>Complex load balancing scenarios</li> <li>Situations requiring efficient packet processing</li> </ul>"},{"location":"blog/20241203/20241203/#references","title":"references","text":"<ul> <li>What is eBPF ??</li> <li>loxilb eBPF implementation details</li> <li>State synchronization of eBPF Maps using Go - A tale of two frameworks !</li> <li>\u5b66\u4e60 loxilb\uff081\uff09\uff1a\u672c\u5730\u6784\u5efa\u4e0e\u6d4b\u8bd5</li> <li>5G SCTP LoadBalancer Using LoxiLB Applying on free5GC</li> </ul>"},{"location":"blog/20241203/20241203/#about","title":"About","text":"<p>Hello, I'm William Lin. I'd like to share my excitement about being a member of the free5gc project, which is a part of the Linux Foundation. I'm always eager to discuss any aspects of core network development or related technologies.</p>"},{"location":"blog/20241203/20241203/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: williamlin0518</li> <li>Linkedin: Cheng Wei Lin</li> </ul>"},{"location":"blog/20241204/20241204/","title":"Paging in 5G Network","text":"<p>Note</p> <p>Author: Yung-Hsuan, Tsao Date: 2024/12/04</p> <p>In the 5G network, when a UE(User Equipment) is not actively involved in data transfer, it will turn into idle mode to conserve the battery. In this state, the network requires a mechanism to alert the UE when receiving an incoming call, a data packet waiting to be delivered, or a network request to re-establish connectivity with a UE. Paging is the procedure used to notify a UE in an idle or low-power state about such events.</p>"},{"location":"blog/20241204/20241204/#overview-of-paging-in-5g","title":"Overview of Paging in 5G","text":"<p>The paging process involves several key steps to ensure efficient and reliable communication between the network and the UE:</p> <p></p>"},{"location":"blog/20241204/20241204/#1-triggering-the-paging-request","title":"1. Triggering the Paging Request","text":"<p>When there is incoming data or a call request for the idle UE, the network needs to notify the UE. The trigger typically comes from the AMF(Access and Mobility Management Function), which manages mobility and session information for devices in the 5G Core Network. The AMF typically triggers paging for reasons such as:</p> <ul> <li>Downlink Data Notification: SMF(Session Management Function), primarily responsible for interacting with the decoupled data plane, informs the AMF of incoming data for the UE. </li> <li>Mobile-Terminated Call: The network receives a signaling request to connect a voice or video call to UE.</li> <li>Network Events: For example, updates or emergency notifications.</li> </ul>"},{"location":"blog/20241204/20241204/#2-generating-the-paging-message","title":"2. Generating the Paging Message","text":"<p>After receiving a paging trigger, AMF needs to determine the UE's location and reachability. It uses the UE's Registration Area(RA) or Tracking Area(TA) information stored in the AMF context to narrow down the list of gNBs or cells where the UE is likely present. The AMF uses the NG Application Protocol(NGAP) to send the paging request to these gNBs, which broadcast it over their radio interfaces.</p>"},{"location":"blog/20241204/20241204/#3-ue-response","title":"3. UE Response","text":"<p>The UE in idle mode periodically wakes up to monitor for paging messages and goes back to sleep mode if it is not intended for it, this is also known as the Discontinuous Reception(DRX) cycle. Upon recognizing its identifier in the paging message, the UE responds by initiating a Service Request procedure. This allows the UE to transition from idle mode to connected mode.</p>"},{"location":"blog/20241204/20241204/#4-re-establishing-connectivity","title":"4. Re-establishing Connectivity","text":"<p>After receiving the Service Request, the AMF: 1. Validates the Paging Context: Confirms that the UE responded to the Service Request matches the UE that the paging is triggered. 2. Retrieves UE Context: Loads the UE's mobility context and session information and also validates the request against the subscription and policy rules. 3. Manages Session Continuity: If the Service Request is for data, AMF needs to ensure the relevant PDU session is active.</p> <p>The gNB establishes a Radio Resource Control (RRC) connection with the UE, enabling the necessary radio bearers for data transfer or signaling. If the request involves downlink data, packets buffered in the User Plane Function (UPF) are delivered to the UE.</p>"},{"location":"blog/20241204/20241204/#paging-message","title":"Paging Message","text":"<p>The following is a further introduction to the paging message transmitted by the AMF via the NG-RAN(gNB) to the UE, which contains essential information to identify the UE and specify the paging cause.</p> <p>Here are some critical fields in the paging message:</p> <ul> <li>UE Paging Identity: A temporary identifier uniquely identifying the UE.</li> <li>TAI List for Paging: Specifies the areas where the paging should be broadcast.</li> <li>Paging Priority: Specifies the priority of the paging request, ensuring time-critical services(e.g. emergency calls) are handled promptly.</li> <li>Paging Origin: The source or entity in the network that initiates the paging procedure.</li> </ul>"},{"location":"blog/20241204/20241204/#error-handling-and-paging-retries","title":"Error Handling and Paging Retries","text":"<p>Error handling and retries are also critical in the paging process to ensure reliable communication with the UE(s), especially in scenarios like network congestion, UE mobility, or poor radio conditions. Following is a simple introduction to the mechanisms and strategies for handling errors and performing retries during paging in 5G networks.</p> <p>Errors in the paging process can occur under various conditions, for example:</p> <ul> <li>UE Non-Response: The UE does not respond to a paging message due to poor coverage, signal interference, or power-saving mode misalignment.</li> <li>Incorrect Paging Area: The UE is no longer present in the area where it was last registered.</li> <li>Network Congestion: The gNB experiences a high traffic load, leading to delayed or dropped paging messages.</li> </ul> <p>To address these errors, AMF employs retry mechanisms to successfully reach the UE by applying further paging according to any applicable paging strategy. These strategies include, </p> <ul> <li>a paging retransmission scheme (e.g., how frequently the paging is repeated or with what time interval)</li> <li>determining whether to send the paging message to the (R)AN nodes during certain AMF high load conditions</li> <li>apply sub-area based paging (e.g., the first page in the last known cell-id and retransmission in all registered TAs).</li> </ul> <p>If retries fail after multiple attempts, AMF may initiate additional procedures to recover the UE's context, such as requesting its current location through network-level signaling.</p> <p>Paging errors can also result from UE mobility across the registration area. In this case, the AMF coordinates with neighboring AMFs to forward the paging result if the UE is likely to have moved to a different registration area. The previous AMF forwards the paging message to the new AMF to retry paging in the updated area.</p> <p>In cases where paging errors persist after retries, the network uses fallback mechanisms to ensure continuity.</p>"},{"location":"blog/20241204/20241204/#conclusion","title":"Conclusion","text":"<p>Paging is a fundamental procedure in the 5G network, enabling seamless communication with UEs in idle or low-power states. By combining efficient paging strategies with robust error handling, the AMF ensures reliable delivery of services while minimizing resource use. This process reflects the advanced capabilities of 5G in balancing network efficiency, battery conservation, and quality of service. Paging's intelligent design ensures that the 5G network remains responsive and adaptive to the dynamic needs of modern connectivity.</p>"},{"location":"blog/20241204/20241204/#reference","title":"Reference","text":"<ul> <li>TS 23.501</li> <li>TS 23.502: Describes the overall paging and service request procedures</li> <li>TS 38.413: About NGAP messages used between AMF and gNB</li> <li>Idle Mode DRX in 5G NR</li> </ul>"},{"location":"blog/20241204/20241204/#about","title":"About","text":"<p>Hi, I'm Yung-Hsuan!  A newcomer to 5G and the free5GC community. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20241204/20241204/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: https://github.com/reki9185</li> </ul>"},{"location":"blog/20241224/","title":"Debug gtp5g kernel module using stacktrace and eBPF","text":"<p>Note</p> <p>Author: Ian Chen Date: 2024/12/24</p>"},{"location":"blog/20241224/#case-study-kernel-panic-caused-by-the-online-charging-pdu-session","title":"Case Study - kernel panic caused by the online charging PDU Session","text":"<p>free5GC is highly rely on the infrastructures provided by the Linux Kernel, especially the gtp5g kernel module.</p> <p>@andy89923 found a reproducible kernel panic issue. Follow the actions below can always produce the kernel panic:</p> <ul> <li>Create online charging PDU Session</li> <li>Ping the Data Network (should match the ip filter of the charging configuration)</li> </ul> <p>Please also note that, the case of kernel panic will only happens if the version of gtp5g greater than v0.8.x.</p>"},{"location":"blog/20241224/#figure-out-the-problem","title":"Figure out the problem","text":"<p>Although we can get the panic log by using the dmesg. However, the stack dumps are not useful enough for kernel debugging at all.</p> <p>However, we can use the decode_stacktrace.sh can find the specific line in source code by leveraging the vmlinux.</p> <p>The original panic logs: <pre><code>[  +0.004968] ------------[ cut here ]------------\n[  +0.000002] kernel BUG at mm/slub.c:307!\n[  +0.000109] invalid opcode: 0000 [#1] SMP PTI\n[  +0.000056] CPU: 3 PID: 191301 Comm: nrf Tainted: G           OE     5.4.0-131-generic #147-Ubuntu\n[  +0.000068] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014\n[  +0.000047] RIP: 0010:kfree+0x236/0x250\n[  +0.000048] Code: e7 e8 9e 71 fd ff e9 ef fe ff ff 4d 89 f1 41 b8 01 00 00 00 48 89 d9 48 89 da 4c 89 e6 4c 89 ef e8 6f fa ff ff e9 d0 fe ff ff &lt;0f&gt; 0b 48 8b 05 d1 51 77 01 e9 ff fd ff ff 66 66 2e 0f 1f 84 00 00\n[  +0.000108] RSP: 0000:ffffa104c015c7f0 EFLAGS: 00010246\n[  +0.000018] RAX: ffff93e58bc98000 RBX: ffff93e58bc98000 RCX: ffff93e58bc98000\n[  +0.000017] RDX: 0000000000039962 RSI: bdd6aff4c23d967a RDI: ffff93e58bc98000\n[  +0.000017] RBP: ffffa104c015c810 R08: ffff93e58bc98000 R09: ffffa104c015c8d8\n[  +0.000018] R10: ffff93e5d302c680 R11: 0000000000000001 R12: fffffc7d8c2f2600\n[  +0.000018] R13: ffff93e6adc06bc0 R14: ffffffff99edcf25 R15: ffff93e565a70600\n[  +0.000017] FS:  000000c000580090(0000) GS:ffff93e6afac0000(0000) knlGS:0000000000000000\n[  +0.000020] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  +0.000014] CR2: 00007fac6fecf160 CR3: 000000034857c001 CR4: 0000000000760ee0\n[  +0.000026] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  +0.000018] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  +0.000021] PKRU: 55555554\n[  +0.000007] Call Trace:\n[  +0.000014]  &lt;IRQ&gt;\n[  +0.000031]  skb_free_head+0x25/0x30\n[  +0.000018]  skb_release_data+0x11d/0x180\n[  +0.000015]  skb_release_all+0x26/0x30\n[  +0.000015]  consume_skb+0x2c/0xb0\n[  +0.000046]  gtp5g_dev_xmit+0xc3/0x170 [gtp5g]\n[  +0.000016]  ? update_load_avg+0x7c/0x670\n[  +0.000017]  dev_hard_start_xmit+0x91/0x1f0\n[  +0.000019]  __dev_queue_xmit+0x75f/0x990\n[  +0.000016]  ? nfnetlink_has_listeners+0x15/0x20 [nfnetlink]\n[  +0.000016]  dev_queue_xmit+0x10/0x20\n[  +0.000014]  neigh_direct_output+0x11/0x20\n[  +0.000019]  ip_finish_output2+0x17e/0x580\n[  +0.000016]  __ip_finish_output+0xf3/0x270\n[  +0.000017]  ip_finish_output+0x2d/0xb0\n[  +0.000018]  ip_output+0x75/0xf0\n[  +0.000010]  ? __ip_finish_output+0x270/0x270\n[  +0.000013]  ip_forward_finish+0x58/0x90\n[  +0.000012]  ip_forward+0x3b9/0x4c0\n[  +0.000010]  ? ip4_key_hashfn+0xb0/0xb0\n[  +0.000012]  ip_sublist_rcv_finish+0x3d/0x50\n[  +0.000021]  ip_sublist_rcv+0x1c5/0x270\n[  +0.000956]  ? ip_rcv_finish_core.isra.0+0x3c0/0x3c0\n[  +0.000637]  ip_list_rcv+0x10b/0x130\n[  +0.000678]  __netif_receive_skb_list_core+0x228/0x250\n[  +0.000576]  netif_receive_skb_list_internal+0x1a1/0x2b0\n[  +0.000572]  gro_normal_list.part.0+0x1e/0x40\n[  +0.000524]  napi_complete_done+0x91/0x130\n[  +0.000557]  virtnet_poll+0x30d/0x450 [virtio_net]\n[  +0.000558]  net_rx_action+0x142/0x390\n[  +0.000598]  __do_softirq+0xd1/0x2c1\n[  +0.000559]  irq_exit+0xae/0xb0\n[  +0.000500]  do_IRQ+0x5a/0xf0\n[  +0.000504]  common_interrupt+0xf/0xf\n[  +0.000488]  &lt;/IRQ&gt;\n[  +0.000467] RIP: 0033:0x423172\n[  +0.000467] Code: 23 4c 89 44 24 38 e8 8d 46 ff ff 48 85 f6 0f 84 a0 00 00 00 48 8b 94 24 88 00 00 00 49 89 f1 48 8b 74 24 48 4d 89 c8 4d 8b 09 &lt;49&gt; 29 d0 4d 85 c9 74 b0 4d 89 ca 49 29 d1 4c 39 ce 77 a5 4c 89 44\n[  +0.001066] RSP: 002b:000000c000593e90 EFLAGS: 00000202 ORIG_RAX: ffffffffffffffdb\n[  +0.000517] RAX: 000000c000387200 RBX: 0000000000018e00 RCX: 5000000000000000\n[  +0.000461] RDX: 000000c000380000 RSI: 0000000000020000 RDI: 0000000000000040\n[  +0.000590] RBP: 000000c000593f08 R08: 000000c0003873d0 R09: 0000000000d17b82\n[  +0.000601] R10: 0000000000d1ce8e R11: 0000000000018e00 R12: 0000000000000001\n[  +0.000619] R13: 13679e0f6eacd19f R14: 000000c0005821a0 R15: 0000000000000000\n[  +0.000461] Modules linked in: sctp vxlan xt_multiport xt_set ipt_rpfilter iptable_raw ip_set_hash_ip ip_set_hash_net ip_set wireguard ip6_udp_tunnel veth xfrm_user xfrm_algo nf_conntrack_netlink xt_addrtype xt_nat xt_tcpudp xt_MASQUERADE xt_mark xt_conntrack iptable_mangle ip6table_filter ip6table_mangle ip6table_nat ip6_tables iptable_nat nf_nat br_netfilter bridge stp llc nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nft_counter nft_compat nf_tables nfnetlink iptable_filter xt_comment bpfilter aufs overlay dummy dm_multipath scsi_dh_rdac scsi_dh_emc scsi_dh_alua binfmt_misc intel_rapl_msr intel_rapl_common isst_if_common nfit kvm_intel kvm rapl joydev input_leds serio_raw mac_hid qemu_fw_cfg sch_fq_codel gtp5g(OE) sunrpc ramoops udp_tunnel reed_solomon efi_pstore ip_tables x_tables autofs4 btrfs zstd_compress raid10 raid456 async_raid6_recov async_memcpy async_pq async_xor async_tx xor raid6_pq libcrc32c raid1 raid0 multipath linear hid_generic usbhid hid bochs_drm drm_vram_helper ttm\n[  +0.000189]  drm_kms_helper crct10dif_pclmul crc32_pclmul syscopyarea sysfillrect ghash_clmulni_intel sysimgblt aesni_intel crypto_simd cryptd glue_helper fb_sys_fops virtio_net psmouse net_failover drm failover virtio_scsi i2c_piix4 pata_acpi floppy\n[  +0.005947] ---[ end trace e017af78fce65824 ]---\n</code></pre></p> <p>You can follow the commands below to make the panic logs more human-friendly: <pre><code>$ sudo apt install linux-source-5.4.0\n$ cd /usr/src/linux-source-5.4.0\n$ sudo make -j$(nproc) vmlinux // if you don't have vmlinux file\n$ sudo ./scripts/decode_stacktrace.sh ./vmlinux ./ ~/gtp5g/ &lt; ~/panic.log  &gt; ~/out.log\n</code></pre> The output will looks like: <pre><code>[  +0.004968] ------------[ cut here ]------------\n[  +0.000002] kernel BUG at mm/slub.c:307!\n[  +0.000109] invalid opcode: 0000 [#1] SMP PTI\n[  +0.000056] CPU: 3 PID: 191301 Comm: nrf Tainted: G           OE     5.4.0-131-generic #147-Ubuntu\n[  +0.000068] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014\n[   +0.000047] RIP: 0010:kfree (/usr/src/linux-source-5.4.0/mm/slub.c:307 /usr/src/linux-source-5.4.0/mm/slub.c:302 /usr/src/linux-source-5.4.0/mm/slub.c:3035 /usr/src/linux-source-5.4.0/mm/slub.c:3060 /usr/src/linux-source-5.4.0/mm/slub.c:4027)\n[ +0.000048] Code: e7 e8 9e 71 fd ff e9 ef fe ff ff 4d 89 f1 41 b8 01 00 00 00 48 89 d9 48 89 da 4c 89 e6 4c 89 ef e8 6f fa ff ff e9 d0 fe ff ff &lt;0f&gt; 0b 48 8b 05 d1 51 77 01 e9 ff fd ff ff 66 66 2e 0f 1f 84 00 00\nAll code\n========\n   0:   e7 e8                   out    %eax,$0xe8\n   2:   9e                      sahf\n   3:   71 fd                   jno    0x2\n   5:   ff                      (bad)\n   6:   e9 ef fe ff ff          jmpq   0xfffffffffffffefa\n   b:   4d 89 f1                mov    %r14,%r9\n   e:   41 b8 01 00 00 00       mov    $0x1,%r8d\n  14:   48 89 d9                mov    %rbx,%rcx\n  17:   48 89 da                mov    %rbx,%rdx\n  1a:   4c 89 e6                mov    %r12,%rsi\n  1d:   4c 89 ef                mov    %r13,%rdi\n  20:   e8 6f fa ff ff          callq  0xfffffffffffffa94\n  25:   e9 d0 fe ff ff          jmpq   0xfffffffffffffefa\n  2a:*  0f 0b                   ud2         &lt;-- trapping instruction\n  2c:   48 8b 05 d1 51 77 01    mov    0x17751d1(%rip),%rax        # 0x1775204\n  33:   e9 ff fd ff ff          jmpq   0xfffffffffffffe37\n  38:   66                      data16\n  39:   66                      data16\n  3a:   2e                      cs\n  3b:   0f                      .byte 0xf\n  3c:   1f                      (bad)\n  3d:   84 00                   test   %al,(%rax)\n    ...\n\nCode starting with the faulting instruction\n===========================================\n   0:   0f 0b                   ud2\n   2:   48 8b 05 d1 51 77 01    mov    0x17751d1(%rip),%rax        # 0x17751da\n   9:   e9 ff fd ff ff          jmpq   0xfffffffffffffe0d\n   e:   66                      data16\n   f:   66                      data16\n  10:   2e                      cs\n  11:   0f                      .byte 0xf\n  12:   1f                      (bad)\n  13:   84 00                   test   %al,(%rax)\n    ...\n[  +0.000108] RSP: 0000:ffffa104c015c7f0 EFLAGS: 00010246\n[  +0.000018] RAX: ffff93e58bc98000 RBX: ffff93e58bc98000 RCX: ffff93e58bc98000\n[  +0.000017] RDX: 0000000000039962 RSI: bdd6aff4c23d967a RDI: ffff93e58bc98000\n[  +0.000017] RBP: ffffa104c015c810 R08: ffff93e58bc98000 R09: ffffa104c015c8d8\n[  +0.000018] R10: ffff93e5d302c680 R11: 0000000000000001 R12: fffffc7d8c2f2600\n[  +0.000018] R13: ffff93e6adc06bc0 R14: ffffffff99edcf25 R15: ffff93e565a70600\n[  +0.000017] FS:  000000c000580090(0000) GS:ffff93e6afac0000(0000) knlGS:0000000000000000\n[  +0.000020] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  +0.000014] CR2: 00007fac6fecf160 CR3: 000000034857c001 CR4: 0000000000760ee0\n[  +0.000026] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  +0.000018] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  +0.000021] PKRU: 55555554\n[  +0.000007] Call Trace:\n[  +0.000014]  &lt;IRQ&gt;\n[   +0.000031] skb_free_head (/usr/src/linux-source-5.4.0/net/core/skbuff.c:602)\n[   +0.000018] skb_release_data (/usr/src/linux-source-5.4.0/net/core/skbuff.c:622)\n[   +0.000015] skb_release_all (/usr/src/linux-source-5.4.0/net/core/skbuff.c:676)\n[   +0.000015] consume_skb (/usr/src/linux-source-5.4.0/net/core/skbuff.c:690 /usr/src/linux-source-5.4.0/net/core/skbuff.c:848)\n[   +0.000046] gtp5g_dev_xmit (/home/ianchen0119/gtp5g/src/gtpu/dev.c:136) gtp5g\n[   +0.000016] ? update_load_avg (/usr/src/linux-source-5.4.0/kernel/sched/fair.c:3388 /usr/src/linux-source-5.4.0/kernel/sched/fair.c:3602)\n[   +0.000017] dev_hard_start_xmit (/usr/src/linux-source-5.4.0/./include/linux/prandom.h:58 /usr/src/linux-source-5.4.0/net/core/dev.c:3216 /usr/src/linux-source-5.4.0/net/core/dev.c:3234)\n[   +0.000019] __dev_queue_xmit (/usr/src/linux-source-5.4.0/./include/net/sch_generic.h:179 /usr/src/linux-source-5.4.0/net/core/dev.c:3453 /usr/src/linux-source-5.4.0/net/core/dev.c:3765)\n[   +0.000016] ? nfnetlink_has_listeners+0x15/0x20 nfnetlink\n[   +0.000016] dev_queue_xmit (/usr/src/linux-source-5.4.0/net/core/dev.c:3834)\n[   +0.000014] neigh_direct_output (/usr/src/linux-source-5.4.0/net/core/neighbour.c:1548)\n[   +0.000019] ip_finish_output2 (/usr/src/linux-source-5.4.0/./include/net/neighbour.h:510 /usr/src/linux-source-5.4.0/net/ipv4/ip_output.c:236)\n[   +0.000016] __ip_finish_output (/usr/src/linux-source-5.4.0/net/ipv4/ip_output.c:317)\n[   +0.000017] ip_finish_output (/usr/src/linux-source-5.4.0/net/ipv4/ip_output.c:326)\n[   +0.000018] ip_output (/usr/src/linux-source-5.4.0/net/ipv4/ip_output.c:444)\n[   +0.000010] ? __ip_finish_output (/usr/src/linux-source-5.4.0/net/ipv4/ip_output.c:320)\n[   +0.000013] ip_forward_finish (/usr/src/linux-source-5.4.0/net/ipv4/ip_forward.c:84)\n[   +0.000012] ip_forward (/usr/src/linux-source-5.4.0/./include/linux/netfilter.h:300 /usr/src/linux-source-5.4.0/net/ipv4/ip_forward.c:157)\n[   +0.000010] ? ip4_key_hashfn (/usr/src/linux-source-5.4.0/net/ipv4/ip_forward.c:66)\n[   +0.000012] ip_sublist_rcv_finish (/usr/src/linux-source-5.4.0/net/ipv4/ip_input.c:539)\n[   +0.000021] ip_sublist_rcv (/usr/src/linux-source-5.4.0/net/ipv4/ip_input.c:588)\n[   +0.000956] ? ip_rcv_finish_core.isra.0 (/usr/src/linux-source-5.4.0/net/ipv4/ip_input.c:407)\n[   +0.000637] ip_list_rcv (/usr/src/linux-source-5.4.0/net/ipv4/ip_input.c:622)\n[   +0.000678] __netif_receive_skb_list_core (/usr/src/linux-source-5.4.0/net/core/dev.c:5014 /usr/src/linux-source-5.4.0/net/core/dev.c:5062)\n[   +0.000576] netif_receive_skb_list_internal (/usr/src/linux-source-5.4.0/net/core/dev.c:5116 /usr/src/linux-source-5.4.0/net/core/dev.c:5209)\n[   +0.000572] gro_normal_list.part.0 (/usr/src/linux-source-5.4.0/./include/linux/compiler.h:295 /usr/src/linux-source-5.4.0/./include/linux/list.h:28 /usr/src/linux-source-5.4.0/net/core/dev.c:5321)\n[   +0.000524] napi_complete_done (/usr/src/linux-source-5.4.0/net/core/dev.c:6063 (discriminator 1) /usr/src/linux-source-5.4.0/net/core/dev.c:6051 (discriminator 1))\n[   +0.000557] virtnet_poll+0x30d/0x450 virtio_net\n[   +0.000558] net_rx_action (/usr/src/linux-source-5.4.0/net/core/dev.c:6366 /usr/src/linux-source-5.4.0/net/core/dev.c:6436)\n[   +0.000598] __do_softirq (/usr/src/linux-source-5.4.0/./arch/x86/include/asm/jump_label.h:25 /usr/src/linux-source-5.4.0/./include/linux/jump_label.h:200 /usr/src/linux-source-5.4.0/./include/trace/events/irq.h:142 /usr/src/linux-source-5.4.0/kernel/softirq.c:293)\n[   +0.000559] irq_exit (/usr/src/linux-source-5.4.0/kernel/softirq.c:373 /usr/src/linux-source-5.4.0/kernel/softirq.c:413)\n[   +0.000500] do_IRQ (/usr/src/linux-source-5.4.0/arch/x86/kernel/irq.c:267 (discriminator 42))\n[   +0.000504] common_interrupt (/usr/src/linux-source-5.4.0/arch/x86/entry/entry_64.S:613)\n[  +0.000488]  &lt;/IRQ&gt;\n[  +0.000467] RIP: 0033:0x423172\n[ +0.000467] Code: 23 4c 89 44 24 38 e8 8d 46 ff ff 48 85 f6 0f 84 a0 00 00 00 48 8b 94 24 88 00 00 00 49 89 f1 48 8b 74 24 48 4d 89 c8 4d 8b 09 &lt;49&gt; 29 d0 4d 85 c9 74 b0 4d 89 ca 49 29 d1 4c 39 ce 77 a5 4c 89 44\nAll code\n========\n   0:   23 4c 89 44             and    0x44(%rcx,%rcx,4),%ecx\n   4:   24 38                   and    $0x38,%al\n   6:   e8 8d 46 ff ff          callq  0xffffffffffff4698\n   b:   48 85 f6                test   %rsi,%rsi\n   e:   0f 84 a0 00 00 00       je     0xb4\n  14:   48 8b 94 24 88 00 00    mov    0x88(%rsp),%rdx\n  1b:   00\n  1c:   49 89 f1                mov    %rsi,%r9\n  1f:   48 8b 74 24 48          mov    0x48(%rsp),%rsi\n  24:   4d 89 c8                mov    %r9,%r8\n  27:   4d 8b 09                mov    (%r9),%r9\n  2a:*  49 29 d0                sub    %rdx,%r8     &lt;-- trapping instruction\n  2d:   4d 85 c9                test   %r9,%r9\n  30:   74 b0                   je     0xffffffffffffffe2\n  32:   4d 89 ca                mov    %r9,%r10\n  35:   49 29 d1                sub    %rdx,%r9\n  38:   4c 39 ce                cmp    %r9,%rsi\n  3b:   77 a5                   ja     0xffffffffffffffe2\n  3d:   4c                      rex.WR\n  3e:   89                      .byte 0x89\n  3f:   44                      rex.R\n\nCode starting with the faulting instruction\n===========================================\n   0:   49 29 d0                sub    %rdx,%r8\n   3:   4d 85 c9                test   %r9,%r9\n   6:   74 b0                   je     0xffffffffffffffb8\n   8:   4d 89 ca                mov    %r9,%r10\n   b:   49 29 d1                sub    %rdx,%r9\n   e:   4c 39 ce                cmp    %r9,%rsi\n  11:   77 a5                   ja     0xffffffffffffffb8\n  13:   4c                      rex.WR\n  14:   89                      .byte 0x89\n  15:   44                      rex.R\n[  +0.001066] RSP: 002b:000000c000593e90 EFLAGS: 00000202 ORIG_RAX: ffffffffffffffdb\n[  +0.000517] RAX: 000000c000387200 RBX: 0000000000018e00 RCX: 5000000000000000\n[  +0.000461] RDX: 000000c000380000 RSI: 0000000000020000 RDI: 0000000000000040\n[  +0.000590] RBP: 000000c000593f08 R08: 000000c0003873d0 R09: 0000000000d17b82\n[  +0.000601] R10: 0000000000d1ce8e R11: 0000000000018e00 R12: 0000000000000001\n[  +0.000619] R13: 13679e0f6eacd19f R14: 000000c0005821a0 R15: 0000000000000000\n[  +0.000461] Modules linked in: sctp vxlan xt_multiport xt_set ipt_rpfilter iptable_raw ip_set_hash_ip ip_set_hash_net ip_set wireguard ip6_udp_tunnel veth xfrm_user xfrm_algo nf_conntrack_netlink xt_addrtype xt_nat xt_tcpudp xt_MASQUERADE xt_mark xt_conntrack iptable_mangle ip6table_filter ip6table_mangle ip6table_nat ip6_tables iptable_nat nf_nat br_netfilter bridge stp llc nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 nft_counter nft_compat nf_tables nfnetlink iptable_filter xt_comment bpfilter aufs overlay dummy dm_multipath scsi_dh_rdac scsi_dh_emc scsi_dh_alua binfmt_misc intel_rapl_msr intel_rapl_common isst_if_common nfit kvm_intel kvm rapl joydev input_leds serio_raw mac_hid qemu_fw_cfg sch_fq_codel gtp5g(OE) sunrpc ramoops udp_tunnel reed_solomon efi_pstore ip_tables x_tables autofs4 btrfs zstd_compress raid10 raid456 async_raid6_recov async_memcpy async_pq async_xor async_tx xor raid6_pq libcrc32c raid1 raid0 multipath linear hid_generic usbhid hid bochs_drm drm_vram_helper ttm\n[  +0.000189]  drm_kms_helper crct10dif_pclmul crc32_pclmul syscopyarea sysfillrect ghash_clmulni_intel sysimgblt aesni_intel crypto_simd cryptd glue_helper fb_sys_fops virtio_net psmouse net_failover drm failover virtio_scsi i2c_piix4 pata_acpi floppy\n[  +0.005947] ---[ end trace e017af78fce65824 ]---\n</code></pre></p> <p>The kernel panic is caused by the kfree function, I believe that the root cause is the socket buffer double-free. Moreover, <code>gtp5g_dev_xmit</code> is the dowlink entry function in GTP5G, So I can narrow down the scope of the problem.</p> <p>For the online charging session, the FAR (Forwarding Action Rule) action will be changed to PKT_DROP after the first uplink packet be sent to data network til the UPF get the quota from SMF. So the downlink packet for responding the first uplink packet will be freed twice before UPF het the new quota.</p> <p>The deatils of the charging system design can be found at CHF design document.</p> <p>The interesting thing is that the panic won't happens til the we upgrade the gtp5g to v0.9.0^. I believe that the issue started to be visible is effected by #101, because of it gives the more accurate packet counting (timing issue).</p>"},{"location":"blog/20241224/#the-potentials-of-the-ebpf-for-kernel-debugging","title":"The potentials of the eBPF for kernel debugging","text":"<p>The article: Live-patching security vulnerabilities inside the Linux kernel with eBPF Linux Security Module, posted by CloudFlare, has well explained how they leverage the eBPF to detect critical events in the kernel, even make the kernel more secured!</p> <p>It inspires me started thinking: is it possible to use eBPF to troubleshoot our own kernel module?</p>"},{"location":"blog/20241224/#optional-compile-the-kernel-with-btf-enabled","title":"[Optional] Compile the kernel with BTF enabled","text":"<p>In our testing environment, we build the kernel v6.12.4: <pre><code>$ wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.12.4.tar.xz\n$ tar xvf linux-6.12.4.tar.xz\n</code></pre> Once you have downloaded the kernel source, you can started building the kernel by following the steps described in the article: Building the Linux kernel with BTF.</p>"},{"location":"blog/20241224/#what-is-btf","title":"What is BTF?","text":"<p>The Extended Berkeley Packet Filter (eBPF) is esteemed for its portability, a primary attribute of which is due to the BPF Type Format (BTF). More details about BTF can be discovered in this comprehensive guide.</p> <p>Before the advent of Compile Once-Run Everywhere (CO-RE), developers working with eBPF had to compile an individual eBPF object for each kernel version they intended to support. This stipulation led toolkits, such as iovisor/bcc, to depend on runtime compilations to handle different kernel versions.</p> <p>However, the introduction of CO-RE facilitated a significant shift in eBPF portability, allowing a single eBPF object to be loaded into multiple differing kernels. This is achieved by the libbpf loader, a component within the eBPF's loader and verification architecture. The libbpf loader arranges the necessary infrastructure for an eBPF object, including eBPF map creation, code relocation, setting up eBPF probes, managing links, handling their attachments, among others.</p> <p>Here's the technical insight: both the eBPF object and the target kernel contain BTF information, generally embedded within their respective ELF (Executable and Linkable Format) files. The libbpf loader leverages this embedded BTF information to calculate the requisite changes such as relocations, map creations, probe attachments, and more for an eBPF object. As a result, this eBPF object can be loaded and have its programs executed across any kernel without the need for object modification, thus enhancing portability. -- aquasecurity/btfhub</p>"},{"location":"blog/20241224/#generate-btf-for-gtp5g","title":"Generate BTF for GTP5G","text":"<p>Add the btf target in the Makefile like this:</p> <pre><code>diff --git a/Makefile b/Makefile\nindex bec4880..bab04d4 100644\n--- a/Makefile\n+++ b/Makefile\n@@ -98,3 +98,6 @@ uninstall:\n        $(DEPMOD)\n        rm -f /etc/modules-load.d/gtp5g.conf\n        rmmod -f  $(MODULE_NAME)\n+\n+btf:\n+       pahole --btf_encode gtp5g.ko\n+       pahole --btf_encode gtp5g.o\n</code></pre> <p>And run the commands below:</p> <pre><code>$ make\n$ make btf\n$ readelf -S gtp5g.ko | grep BTF\n$ sudo make install\n</code></pre> <p>In this way, you will able to see the gtp5g btf by using btftool:</p> <pre><code>$ sudo bpftool btf list | grep gtp5g\n410: name [gtp5g]  size 243774B\n</code></pre> <p>use the command below to dump vmlinux and gtp5g BTF to C file: <pre><code>$ bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux/vmlinux.h\n$ bpftool btf dump file /sys/kernel/btf/gtp5g format c &gt; vmlinux/vmlinux.h\n</code></pre></p>"},{"location":"blog/20241224/#trace-the-function-calls-in-gtp5g","title":"Trace the function calls in GTP5G","text":"<p>The eBPF program type <code>BPF_PROG_TYPE_TRACING</code> are a newer alternative to kprobes and tracepoints since Linux Kernel v5.5, which provides practically zero overhead by leveraging the BPF trampoline.</p> <p>The command below can be used to list all of available functions for tracing purpose: <pre><code>$ sudo cat /sys/kernel/tracing/available_filter_functions | grep gtp5g\n// ...\ngtp5g_dbg_read [gtp5g]\nproc_qos_write [gtp5g]\ngtp5g_qos_read [gtp5g]\ngtp5g_far_read [gtp5g]\nproc_pdr_write [gtp5g]\nproc_dbg_write [gtp5g]\ngtp5g_pdr_read [gtp5g]\nproc_qer_write [gtp5g]\nproc_far_write [gtp5g]\nproc_urr_write [gtp5g]\nget_proc_gtp5g_dev_list_head [gtp5g]\ninit_proc_gtp5g_dev_list [gtp5g]\ncreate_proc [gtp5g]\nremove_proc [gtp5g]\n</code></pre></p> <p>If we want to trace the function entry of gtp5g_encap_recv, we can write a program like below:</p> <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf_tracing.h&gt;\n#include &lt;bpf_helpers.h&gt;\n\nSEC(\"fentry/gtp5g_xmit_skb_ipv4\")\nint BPF_PROG(gtp5g_uplink, struct sk_buff *skb, struct gtp5g_pktinfo *pktinfo)\n{\n    __u64 pid_tgid = bpf_get_current_pid_tgid();\n    __u32 pid = pid_tgid &amp; 0xFFFFFFFF;\n    __u32 tgid = pid_tgid &gt;&gt; 32;\n    __u32 cpu = bpf_get_smp_processor_id();\n\n    bpf_printk(\"gtp5g_xmit_skb_ipv4: PID=%u, TGID=%u, CPU=%u\", pid, tgid, cpu);\n    return 0;\n}\n\nchar _license[] SEC(\"license\") = \"GPL\";\n</code></pre> <ul> <li>Any program with the <code>fentry</code> prefix will be executed before the execution of target function (in this case is <code>gtp5g_xmit_skb_ipv4()</code>), and can be identified as the <code>BPF_PROG_TYPE_TRACING</code> type by the kernel.</li> <li>The arguments of the <code>BPF_PROG</code> follows the kernel function you want to trace. for example: <pre><code>// The definition in the gtp5g, the BPF_PROG's args should be same with the target function\nstatic int gtp5g_xmit_skb_ipv4(struct sk_buff *, struct gtp5g_pktinfo *);\n</code></pre></li> </ul>"},{"location":"blog/20241224/#load-and-attach-ebpf-program","title":"Load and attach eBPF program","text":"<p>Typically, we can load and attach the eBPF program into specific system hook by using bpftool. However, the bpftool does not support all of attachment types provided by the kernel.</p> <p>Therefore, I use the libbpfgo and libbpf to implement the agent program for loading eBPF program: <pre><code>package main\n\nimport (\n    \"os\"\n    \"time\"\n\n    bpf \"github.com/aquasecurity/libbpfgo\"\n)\n\nfunc main() {\n    bpfModule, err := bpf.NewModuleFromFile(\"main.o\")\n    if err != nil {\n        panic(err)\n    }\n    defer bpfModule.Close()\n\n    if err := bpfModule.BPFLoadObject(); err != nil {\n        panic(err)\n    }\n\n    prog, err := bpfModule.GetProgram(\"gtp5g_uplink\")\n    if err != nil {\n        panic(err)\n    }\n\n    link, err := prog.AttachGeneric()\n    if err != nil {\n        panic(err)\n    }\n    if link.FileDescriptor() == 0 {\n        os.Exit(-1)\n    }\n\n    for {\n        time.Sleep(10 * time.Second)\n    }\n}\n</code></pre></p> <p>INFO You will need to write a Makefile for building the BPF program and its agent. If you don't know how to get started, please refer to my side project: tinyLB.</p> <p>To see the output of the attached eBPF program: <pre><code>sudo cat /sys/kernel/debug/tracing/trace_pipe\n           &lt;...&gt;-236797  [009] b.s21 6141919.013036: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=236797, TGID=236797, CPU=9\n          &lt;idle&gt;-0       [009] b.s31 6141920.013210: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=9\n          &lt;idle&gt;-0       [009] b.s31 6141921.014070: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=9\n          &lt;idle&gt;-0       [009] b.s31 6141922.013615: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=9\n          &lt;idle&gt;-0       [009] b.s31 6141923.013975: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=9\n          &lt;idle&gt;-0       [009] b.s31 6141924.014871: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=9\n          &lt;idle&gt;-0       [009] b.s31 6141925.013730: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=9\n        kubelite-3377186 [009] b.s21 6141926.013908: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=3377186, TGID=3376931, CPU=9\n          &lt;idle&gt;-0       [009] b.s31 6141927.014084: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=9\n          &lt;idle&gt;-0       [009] b.s31 6141928.015013: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=9\n          &lt;idle&gt;-0       [009] b.s31 6141929.014465: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=9\n          &lt;idle&gt;-0       [009] b.s31 6141930.014600: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=9\n          &lt;idle&gt;-0       [009] b.s31 6141931.013976: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=9\n          &lt;idle&gt;-0       [009] b.s31 6141932.014142: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=9\n          &lt;idle&gt;-0       [009] b.s31 6141933.014331: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=9\n</code></pre></p>"},{"location":"blog/20241224/#conclusion","title":"Conclusion","text":"<p>This article shows how to troubleshoot the kernel panic by using the <code>decode_stacktrace.sh</code> script and how to trace the function calls in the kernel module by using eBPF. The eBPF is a powerful tool for kernel debugging. It can be used to trace the function calls in the kernel module with low overhead and even make the kernel more secure by detecting critical events.</p>"},{"location":"blog/20241224/#references","title":"References","text":"<ul> <li>https://lwn.net/Articles/592724/</li> <li>Make linux kernel function show in ftrace available_filter_function</li> <li>https://askubuntu.com/questions/1348250/skipping-btf-generation-xxx-due-to-unavailability-of-vmlinux-on-ubuntu-21-04</li> <li>https://github.com/aquasecurity/btfhub/blob/main/docs/how-to-use-pahole.md#tools-that-generate-btf-information</li> </ul>"},{"location":"blog/20241224/#about","title":"About","text":"<p>Greetings! My name is Ian. I'm currently a Technical Steering Committee member of the free5GC project. We're focusing on delevering a fully open-source 5G core network for academic and industry usage. If you're interested in our project, the pull requests and issues are always welcome!</p>"},{"location":"blog/20241230/20241230/","title":"5G Network Slicing","text":"<p>Note</p> <p>Author: Guo-Cheng Wu Date: 2024/12/30</p> <p>Network slicing is an innovative technology introduced in the 5G network, first proposed in the 3GPP Rel-15 specification. Its primary function is to support a wide range of diverse services within a single physical network. For instance, there are three major application scenarios in the 5G network: eMBB, mMTC, and URLLC. Given the varying resource requirements of these scenarios, network slicing plays a crucial role in efficiently allocating dedicated slices for each service.</p>"},{"location":"blog/20241230/20241230/#how-to-identify-a-network-slice","title":"How to Identify a Network Slice?","text":"<p>A Single Network Slice Selection Assistance Information (S-NSSAI) is used to identify a Network Slice. Each S-NSSAI consists of two parameters:</p> <ul> <li> <p>Slice/Service Type (SST): Defines the expected behavior of the Network Slice regarding features and services.</p> <ul> <li>According to the 3GPP specification, the SST values are standardized as follows:</li> </ul> Slice/Service type SST value Characteristics eMBB 1 Slice suitable for the handling of 5G enhanced Mobile Broadband. URLLC 2 Slice suitable for the handling of ultra-reliable low latency communications. MIoT 3 Slice suitable for the handling of massive IoT. V2X 4 Slice suitable for the handling of V2X services. HMTC 5 Slice suitable for the handling of High-Performance Machine-Type Communications. HDLLC 6 Slice suitable for the handling of High Data rate and Low Latency Communications. </li> <li> <p>Slice Differentiator (SD): An optional parameter that supplements the SST to distinguish between multiple Network Slices with the same Slice/Service Type.</p> </li> </ul>"},{"location":"blog/20241230/20241230/#network-slice-selection-assistance-information-nssai","title":"Network Slice Selection Assistance Information (NSSAI)","text":"<p>The NSSAI is composed of multiple S-NSSAIs and can be categorized into the following types:</p> <ul> <li>Requested NSSAI: A set of S-NSSAIs requested by the UE during connection setup, carried in the registration request sent by the UE. The Requested NSSAI can contain up to eight S-NSSAIs.</li> <li>Allowed NSSAI: A set of S-NSSAIs approved by the core network from the Requested NSSAI, which the UE can utilize in the Serving PLMN within the current Registration Area. The Allowed NSSAI can include up to eight S-NSSAIs.</li> <li>Rejected NSSAI: A set of S-NSSAIs rejected by the core network from the Requested NSSAI, often due to reasons such as the S-NSSAI being unsupported in the current registration area or unavailable due to reaching the maximum number of UEs.</li> <li> <p>Configured NSSAI: A set of S-NSSAIs provisioned in the UE by the network, applicable to one or more PLMNs, indicating which S-NSSAIs the UE is authorized to use.</p> <p>Note: If the Configured NSSAI does not contain any S-NSSAIs, a default S-NSSAI will be applied.</p> </li> </ul>"},{"location":"blog/20241230/20241230/#network-slice-selection-function-nssf","title":"Network Slice Selection Function (NSSF)","text":"<p>Before delving into the procedure of network slice selection, it is important to understand the NSSF and its functionality. The primary role of the NSSF is to assist the AMF in selecting the appropriate network slice based on the current scenario. The NSSF provides two key services:</p> <ul> <li>Nnssf_NSSelection: This service operation facilitates Network Slice selection in the Serving PLMN and the HPLMN. It enables the NSSF to provide the AMF with the Allowed NSSAI and the Configured NSSAI for the Serving PLMN. This service may be invoked during the Registration procedure, inter-PLMN mobility, PDU Session Establishment, or UE Configuration Update procedures.</li> <li>Nnssf_NSSAIAvailability: This service allows the NSSF to update the S-NSSAIs supported by the NF service consumer (e.g., AMF) on a per tracking area basis. In addition to updating and deleting operations, it also supports operations like subscribing and notifying. </li> </ul>"},{"location":"blog/20241230/20241230/#how-does-core-network-select-a-network-slice-for-ue","title":"How does Core Network Select a Network Slice for UE?","text":"<p>The process of selecting a network slice for a UE primarily involves two key network functions:</p> <ul> <li>Access and Mobility Management function (AMF): The AMF processes the registration request from the UE and forwards the Requested NSSAI to the NSSF.</li> <li>Network Slice Selection Function (NSSF): The NSSF is responsible for selecting the appropriate set of Network Slice instances to serve the UE on behalf of the AMF. Specifically, it determines the Allowed NSSAI.</li> </ul>"},{"location":"blog/20241230/20241230/#procedure","title":"Procedure","text":"<p>This section focuses specifically on the steps involved in network slice selection. For a detailed explanation of the overall 5G registration procedure, please refer to this blog: Registration procedures</p> <ol> <li>UE to RAN: The UE initiates a Registration Request to the network through the RAN. Along with UE-specific information, the request includes the Requested NSSAI, indicating the network slices the UE intends to access.</li> <li>RAN (AMF Selection): If the UE doesn't provide 5G-S-TMSI or GUAMI in the Registration Request, the RAN will select a serving AMF based on the Requested NSSAI.</li> <li>AMF to NSSF: Upon receiving the registration request, the AMF sends a request to the NSSF to execute the network slice selection process. The AMF provides detailed information such as the Requested NSSAI, the PLMN ID of the SUPI, and the TAI.</li> <li>NSSF: The NSSF performs the Nnssf_NSSelection_Get service using the information provided by the AMF. It determines which S-NSSAIs the UE is eligible to use and aggregates them into the Allowed NSSAI. In addition, the NSSF may also identify the best AMF to serve the UE or provide a list of candidate AMFs.</li> <li>NSSF to AMF: After executing the Nnssf_NSSelection_Get service, the NSSF sends the Allowed NSSAI to the AMF.</li> <li>AMF to UE: If the registration request is successful, the AMF responds to the UE with a Registration Accept message, including the Allowed NSSAI. This enables the UE to identify the network slices available for use.</li> </ol>"},{"location":"blog/20241230/20241230/#network-slice-specific-authentication-and-authorization-nssaa","title":"Network Slice-Specific Authentication and Authorization (NSSAA)","text":"<p>NSSAA is a procedure initiated by the AMF during the Registration process when certain network slices require authentication and authorization. This procedure is triggered when the AMF identifies that NSSAA is necessary for an S-NSSAI included in the current Allowed NSSAI.</p>"},{"location":"blog/20241230/20241230/#procedure_1","title":"Procedure","text":"<p>The AMF initiates a Nnssaaf_NSSAA_Authenticate request to the Network Slice-Specific and SNPN Authentication and Authorization Function (NSSAAF). The NSSAAF then forwards the request to the Authentication, Authorization, and Accounting Server (AAA Server) for authentication or authorization. Note that free5GC currently does not support this functionality. For more detailed information about the NSSAA procedure and NSSAAF service, you can refer to TS 23.502.</p>"},{"location":"blog/20241230/20241230/#conclusion","title":"Conclusion","text":"<p>Network slicing is a fundamental capability for optimizing 5G networks, allowing them to support a diverse array of services with varying resource demands. The ability to define and manage these slices is critical to meeting the diverse needs of modern network systems. It ensures efficient resource utilization, dynamic adaptability, and end-to-end isolation, delivering guaranteed performance for a wide range of use cases.</p>"},{"location":"blog/20241230/20241230/#reference","title":"reference","text":"<ul> <li>TS 23.501 </li> <li>TS 23.502</li> <li>TS 24.501</li> <li>TS 29.531</li> <li>5G Network slice management</li> <li>5G \u901a\u7528\u8a3b\u518a\u6d41\u7a0b</li> </ul>"},{"location":"blog/20241230/20241230/#about-me","title":"About me","text":"<p>Hi, I\u2019m Guo-Cheng Wu, a newcomer to 5G and free5GC, and currently conducting research on Network Slicing. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20241230/20241230/#connect-with-me","title":"Connect with Me","text":"<p>Github: https://github.com/leowu0407</p>"},{"location":"blog/20250122/20250122/","title":"5G LAN-type service Introduction","text":"<p>Note</p> <p>Author: Yuan-Ting Chen Date: 2025/01/22</p>"},{"location":"blog/20250122/20250122/#5g-lan-type-services","title":"5G LAN-type Services","text":"<p>5G LAN-type service provides services with similar functionalities to Local Area Networks (LANs) and VPN\u2019s but improved with 5G capabilities such as high performance, long distance access, mobility and security.</p> <p>For instance, Automated Guided Vehicles (AGVs) moving inside a large factory may communicate and cooperate through 5G LAN technology with low latency. This could be hard to achieve through Wi-fi due to the possibility of handover issue.</p>"},{"location":"blog/20250122/20250122/#5g-vn-group","title":"5G VN Group","text":"<p>Tip</p> <p>Definitions 5G LAN-virtual network (5G LAN-VN): a virtual network capable of supporting 5G LAN-type service. 5G VN Group: A set of UEs using private communication for 5G LAN-type service.</p>"},{"location":"blog/20250122/20250122/#5g-vn-group-management","title":"5G VN group management","text":"<p>A 5G VN group is characterized by the following:</p> <ul> <li>5G VN group identities:      used to identify the 5G VN group.<ul> <li>External Group ID</li> <li>Internal Group ID</li> </ul> </li> <li>5G VN group membership:      used to uniquely identify 5G VN group members.<ul> <li>GPSIs</li> </ul> </li> <li>5G VN group data<ul> <li>PDU session type</li> <li>DNN</li> <li>S-NSSAI</li> <li>Application descriptor</li> <li>Information related with secondary authentication / authorization (e.g. to enable IP address assignment by the DN-AAA).</li> </ul> </li> </ul> <p>The 5G VN groups and 5G VN members are managed (e.g. add/delete/modify) via a set of services exposed by NEF.</p>"},{"location":"blog/20250122/20250122/#5g-vn-group-creation","title":"5G VN group creation","text":"<ul> <li>A 5G VN group is identified by the AF using External Group ID.</li> <li>The NEF provides the External Group ID to UDM.</li> <li>The UDM maps the External Group ID to Internal Group ID.  For a newly created 5G VN Group, an Internal Group ID is determined by the UDM.</li> </ul> <p>After the 5G VN group is created, UE with corresponding DNN and S-NSSAI would get the UE policy associated with the 5G VN group in the registration procedure.</p> <p></p> <ul> <li>After Registration Accept in the General Registration Procedure, the AMF performs a UE Policy Association Establishment procedure.</li> <li>In the UE Policy Association Establishment procedure, the AMF sends a Npcf_UEPolicyControl Create Request, which contains the Internal-Group-ID-list of the UE and UE Policy Container, to PCF.</li> <li>The PCF then get the 5G VN group data and 5G VN group membership for each Internal-Group-ID received from the AMF using Nudr_DM_Query (Internal-Group-Id, Subscription Data, 5G VN Group Configuration).</li> </ul> <p></p> <ul> <li>The PCF triggers UE Configuration Update Procedure to update UE policy and sends the UE policy container including UE policy information to the UE.</li> <li>PCF invokes Namf_Communication_N1N2MessageTransfer service operation provided by the AMF. The message includes SUPI, UE Policy Container.</li> <li>the AMF transfers transparently the UE Policy container (UE policy information) received from the PCF to the UE using DL NAS TRANSPORT message.</li> </ul>"},{"location":"blog/20250122/20250122/#5g-vn-group-communication","title":"5G VN Group Communication","text":"<p>There are three types of traffic forwarding methods allowed for 5G VN communication:</p> <ul> <li>Local switch, where traffic is locally forwarded by a single UPF if this UPF is the common PSA UPF of different PDU Sessions for the same 5G VN group.</li> </ul> <p></p> <ul> <li> <p>N19-based, where the UL/DL traffic for the 5G VN group communication is forwarded between PSA UPFs of different PDU sessions via N19. N19 is based on a shared User Plane tunnel connecting PSA UPFs of a single 5G VN group.</p> <p></p> </li> <li> <p>N6-based, where the UL/DL traffic for the 5G VN communication is forwarded to/from the DN;</p> </li> </ul> <p>Traffic forwarding within the 5G VN group is realized by using a UPF internal interface (\"5G VN internal\") </p>"},{"location":"blog/20250122/20250122/#reference","title":"Reference","text":"<ul> <li>TS 22.261 \"6.26 5G LAN-type service\"</li> <li>TS 23.501 \"4.4.6 5G LAN-type Services\"</li> <li>TS 23.501 \"5.29 Support for 5G LAN-type service\"</li> <li>TS 23.502 \"4.15.6.2 NEF service operations information flow\"</li> <li>TS 23.502 \"4.2.2.2.2 General Registration\"</li> <li>TS 23.502 \"4.16.11 UE Policy Association Establishment\"</li> <li>TS 23.502 \"4.2.4.3 UE Configuration Update procedure for transparent UE Policy delivery\"</li> </ul>"},{"location":"blog/20250122/20250122/#about-me","title":"About me","text":"<p>Hi, I\u2019m Yuan-Ting Chen, a newcomer to 5G and free5GC. I'm currently conducting research on 5G LAN. Please feel free to let me know if there is any mistake in the article.</p>"},{"location":"blog/20250123/20250123/","title":"Network Devices in Linux","text":"<p>Note</p> <p>Author: Fang-Kai Ting Date: 2025/01/23</p> <p>Linux offers a diverse array of network devices, enabling the construction of intricate virtual and physical network topologies. Key examples include veth (virtual Ethernet), VLAN (Virtual LAN), VXLAN (Virtual eXtensible LAN), and IPVLAN. These devices are crucial for establishing scalable and adaptable network environments. In containerized environments such as Docker, network devices play a pivotal role in connecting containers, hosts, and routers, facilitating seamless communication across various network layers. Tools like <code>ip</code> and <code>bridge-utils</code> provide the necessary means for configuring these devices. This article will demonstrate the practical application of veth, VLAN, VXLAN, and IPVLAN by creating a sample network topology involving Docker containers and routers.</p>"},{"location":"blog/20250123/20250123/#1-veth","title":"1. Veth","text":"<p>A <code>veth</code> (virtual Ethernet) pair is a Layer 2 (Data Link Layer) virtual network device that simulates a direct Ethernet cable connection between two interfaces. Creating a veth pair results in the creation of two virtual interfaces, where traffic transmitted through one interface is seamlessly transferred to the other.</p> <p>For instance, consider two Docker containers, h1 and h2, connected by a veth pair. One end of the veth pair is placed within the h1 namespace, while the other end resides within the h2 namespace. As illustrated below, this configuration enables direct Layer 2 communication between the two hosts.</p> <p></p>"},{"location":"blog/20250123/20250123/#common-use-cases-for-veth","title":"Common Use Cases for veth","text":"<ul> <li>Container Networking (e.g., Docker or Kubernetes):<ul> <li>Scenario: In Docker, each container operates within its own isolated network namespace. To enable communication between the container and the host or other containers, a veth pair is established.</li> </ul> </li> </ul> <p>In the following example, the host image is readily accessible from Docker Hub.</p> <p>How to use docker-compose.yaml can refer to docker compose | Docker Docs</p> <pre><code>services:\n  h1:\n    image: ubuntu:22.04\n    container_name: h1\n    privileged: true\n    build:\n      context: ./config\n      dockerfile: host.Dockerfile\n    cap_add:\n      - NET_ADMIN\n      - NET_BROADCAST\n    network_mode: \"none\"\n    entrypoint: [ \"/bin/sh\", \"-c\" ]\n    command:\n      - |\n        sleep 365d\n</code></pre>"},{"location":"blog/20250123/20250123/#namespace","title":"Namespace","text":"<p>In Docker, a namespace is a fundamental concept that provides isolation for containers, ensuring they operate independently from the host system and other containers. By moving the veth into the container\u2019s namespace, the interface becomes invisible to the host and other containers. The container believes it has its own private network interface, adhering to the principle of namespace isolation.</p> <pre><code># List of container names (replace with actual container names)\nCONTAINERS=(\"h1\" \"h2\")\n# Create the /var/run/netns directory if it doesn't exist\nsudo mkdir -p /var/run/netns\n# Loop through each container and link its network namespace\nfor cname in \"${CONTAINERS[@]}\"; do\n    # Get the PID of the container\n    pid=$(docker inspect -f '{{.State.Pid}}' \"$cname\")\n    # Link the container's network namespace to /var/run/netns\n    sudo ln -sfT /proc/\"$pid\"/ns/net /var/run/netns/\"$cname\"\ndone\n</code></pre> <pre><code># create veth pair, veth always have two pair simulated physical cable\nsudo ip link add h1h2 type veth peer name h2h1\n# move veth end to docker namespace\nsudo ip link set h1h2 netns h1\nsudo ip link set h2h1 netns h2\n# bring up device inside h1, h2\nsudo ip netns exec h1 ip link set h1h2 up\nsudo ip netns exec h2 ip link set h2h1 up\nsudo ip netns exec h1 ip addr add 192.168.1.1/24 dev h1h2\nsudo ip netns exec h2 ip addr add 192.168.1.2/24 dev h2h1\n</code></pre> <p>As shown below, h1 can ping h2 and arp have been resolved.</p> <p></p>"},{"location":"blog/20250123/20250123/#2-vlanvirtual-local-area-network","title":"2. VLAN(Virtual Local Area Network)","text":""},{"location":"blog/20250123/20250123/#what-is-vlan","title":"What is VLAN?","text":"<p>A VLAN (Virtual Local Area Network) is a technology used to create separate, isolated networks within the same physical network. It allows devices to be grouped logically, even if they are not physically connected to the same network switch. VLANs are implemented at Layer 2 (Data Link Layer) and use VLAN IDs to segregate network traffic.</p> <p>In the following example, we create two virtual machines (VMs) using VirtualBox. These VMs utilize a host-only adapter as the underlay network. On top of this underlay network, we configure VLANs (Virtual LANs) to function as the overlay network.</p> <p></p>"},{"location":"blog/20250123/20250123/#what-is-underlay-network","title":"What is underlay network?","text":"<p>An underlay network is the physical or virtual infrastructure that forms the foundation for network communication. It consists of the actual hardware devices, such as routers, switches, and physical links, or virtual adapters in a virtualized environment. The underlay network is responsible for routing and delivering data packets across the network using traditional networking protocols.</p>"},{"location":"blog/20250123/20250123/#what-is-overlay-network","title":"What is overlay network?","text":"<p>An overlay network is a virtualized network built on top of an underlay network. It creates a logical network that operates independently of the physical topology. Techniques like encapsulation, tunneling (e.g., VXLAN, GRE), or VLAN tagging enable the overlay network to logically segment traffic and isolate communication between devices, even if they share the same underlay.</p>"},{"location":"blog/20250123/20250123/#step","title":"Step","text":"<ol> <li>install vlan <pre><code>sudo apt-get install vlan\n</code></pre></li> <li>Load the 8021q kernel module using the \u201cmodprobe\u201d command: <pre><code>sudo modprobe 8021q\n</code></pre></li> <li>Verify that the module is loaded by running: <pre><code>lsmod | grep 8021q\n</code></pre></li> <li>Create a VLAN subinterface for \u201cenp0s8\u201d with VLAN ID 10 <pre><code>sudo ip link add link enp0s8 name enp0s8.10 type vlan id 10\nsudo ip addr add 192.168.10.1/24 dev enp0s8.10\nsudo ip link set dev enp0s8.10 up\n</code></pre></li> <li>Repeat above in vm2</li> </ol>"},{"location":"blog/20250123/20250123/#result","title":"Result","text":"<p>We create a subinterface as overlay network</p> <p></p> <p>vm1 routing info</p> <p></p> <p>vm1 can reach vm2</p> <p></p> <p>Moreover, by tcpdump, we can see the icmp packet flow</p> <p></p>"},{"location":"blog/20250123/20250123/#3-vxlanvirtual-extensible-lan","title":"3. VXLan(Virtual Extensible LAN)","text":""},{"location":"blog/20250123/20250123/#what-is-vxlan","title":"What is VXLAN?","text":"<p>VXLAN (Virtual Extensible LAN) is a network virtualization technology designed to address the limitations of VLANs in large-scale cloud and data center networks. It encapsulates Layer 2 Ethernet frames in a Layer 3 UDP packet, enabling Layer 2 segments to extend across Layer 3 networks.</p> <p>Key features of VXLAN:</p> <ul> <li>Encapsulation: Uses UDP for encapsulation, which allows Ethernet frames to traverse IP networks.</li> <li>VXLAN Network Identifier (VNI): A 24-bit identifier used to distinguish virtual networks, supporting up to 16 million logical networks, compared to the 12-bit VLAN ID that supports only 4096.</li> <li>Distributed Gateway: VXLAN works well with distributed routing architectures, enabling better scalability and performance in modern networks.</li> </ul> <p>In following example, we create a Docker container named 'h1' within a VirtualBox virtual machine (VM) named 'vm1'. Similarly, another Docker container named 'h2' is created within a separate VirtualBox VM named 'vm2'. Both VMs utilize a host-only adapter as their underlying network. On top of this underlay network, we configure VXLAN (Virtual Extensible LAN) to establish an overlay network that enables communication between the two containers across the different VMs.</p> <p></p>"},{"location":"blog/20250123/20250123/#step_1","title":"Step","text":"<ol> <li>create h1 container with subnet 171.19.0.0/16, then assign h1 to 172.19.0.10 <pre><code>services:\n  h1:\n    image: host\n    container_name: h1\n    privileged: true\n    build:\n      context: ./config\n      dockerfile: host.Dockerfile\n    cap_add:\n      - NET_ADMIN\n      - NET_BROADCAST\n    networks:\n      vxlan-net:\n        ipv4_address: 172.19.0.10\n    entrypoint: [ \"/bin/sh\", \"-c\" ]\n    command:\n      - |\n        sleep 365d\nnetworks:\n  vxlan-net:\n    driver: bridge\n    driver_opts:\n      com.docker.network.bridge.name: br19\n    ipam:\n      config:\n        - subnet: 172.19.0.0/16\n</code></pre></li> <li>create vxlan device, 'vxlan-demo' is the name of the interface, type should be vxlan.<ol> <li>VNI(Vxlan Network identifier) ID is 100 (It is only necessary to ensure that the VNI ID inside the tunnel is the same.)</li> <li>dstport should be 4789 which a udp standard port for vxlan communication</li> <li>vxlan have multicast and unicast usage, here demonstrate unicast</li> <li><code>remote 192.168.56.108</code>  is the ip of another underlay interface. <pre><code>sudo ip link add vxlan-demo type vxlan id 100 remote 192.168.56.108 dstport 4789 dev enp0s8\n</code></pre></li> </ol> </li> <li>Set vxlan-demo device interface on br19 <pre><code>sudo ip link set vxlan-demo up\nsudo ip link set vxlan-demo master br19\n</code></pre></li> </ol>"},{"location":"blog/20250123/20250123/#result_1","title":"Result","text":"<ol> <li>h1 can ping h2 </li> <li>Through tcpdump can see VXLAN encapsulates Layer 2 Ethernet frames in a Layer 3 UDP packet <pre><code>tcpdump -i any udp port 4789\n</code></pre> </li> <li>Routing info </li> </ol>"},{"location":"blog/20250123/20250123/#4-ipvlan","title":"4. IPVLAN","text":""},{"location":"blog/20250123/20250123/#what-is-ipvlan","title":"What is IPvlan?","text":"<p>IPvlan is a Linux kernel networking feature that enables the creation of virtual network interfaces on top of a physical network interface. It allows for multiple virtual interfaces to share a single physical network interface (<code>eth0</code>, for example), with each virtual interface appearing as a separate device with its own IP address at the network layer.</p> <p>IPvlan interfaces share the same MAC address as the parent interface. This makes IPvlan particularly useful in environments where network policies or switch configurations limit the number of MAC addresses that can be assigned to a single port (e.g., in certain cloud or data center environments).</p> <p></p> <p>In below example, we create h1 container in virtualbox vm1. h2 container in vm2. both with host-only adapter as underlay network and configure IPVLAN on top of the host-only adapter network, IPVLAN is not an overlay network.</p>"},{"location":"blog/20250123/20250123/#step_2","title":"Step","text":"<ol> <li>Use docker supported ipvlan network driver.</li> </ol> <pre><code>services:\n  h1:\n    image: host\n    container_name: h1\n    privileged: true\n    build:\n      context: ./config\n      dockerfile: host.Dockerfile\n    cap_add:\n      - NET_ADMIN\n      - NET_BROADCAST\n    networks:\n      ipvlan-net:\n        ipv4_address: 172.19.0.10\n    entrypoint: [ \"/bin/sh\", \"-c\" ]\n    command:\n      - |\n        sleep 365d\nnetworks:\n  vxlan-net:\n    driver: bridge\n    driver_opts:\n      com.docker.network.bridge.name: br19\n    ipam:\n      config:\n        - subnet: 172.19.0.0/16\n  ipvlan-net:\n    driver: ipvlan\n    driver_opts:\n      parent: enp0s8\n      vlan_tag: 10\n    ipam:\n      config:\n        - subnet: 172.19.0.0/24\n</code></pre>"},{"location":"blog/20250123/20250123/#result_2","title":"Result","text":"<ol> <li>h1 can ping h2 </li> <li>Using <code>sudo ip netns exec h1 tcpdump -i any icmp</code> and <code>sudo tcpdump -i any icmp</code> can verify the following packet flow<ol> <li>(h1)eth0 \u2192 enp0s8 \u2192 (h2)enp0s8 \u2192 eth0 </li> </ol> </li> <li>h1 routing info </li> </ol>"},{"location":"blog/20250123/20250123/#comparing-vlan-vxlan-ipvlan","title":"Comparing VLAN, VXLAN, IPVLAN","text":"<p>Below show VLAN, VXLAN, IPVLAN compared table with overview, MAC address, Scalability, Network Isolation, Performance, and Use Cases.</p>"},{"location":"blog/20250123/20250123/#1-overview","title":"1. Overview","text":"Feature IPVLAN VLAN VXLAN Purpose Lightweight network virtualization at Layer 2/3. Segregates a physical network into logical networks. Extends Layer 2 networks across Layer 3 boundaries. Focus Simplifying container or VM networking. Network segmentation within a local Layer 2 domain. Large-scale network virtualization for multi-tenant clouds."},{"location":"blog/20250123/20250123/#2-addressing","title":"2. Addressing","text":"Feature IPVLAN VLAN VXLAN MAC Address Shares the same MAC address as the parent interface in L2 mode. Unique MAC address per device per VLAN. Unique MAC address per device, as in traditional L2. IP Address Each virtual interface has a unique IP address. Devices can share the same IP scheme per VLAN. Each network can share the same IP scheme (tenant isolation)."},{"location":"blog/20250123/20250123/#3-scalability","title":"3. Scalability","text":"Feature IPVLAN VLAN VXLAN Limitations Limited to one subnet per IPVLAN interface. VLAN IDs limited to 4096 (12-bit tag). Scales up to 16 million segments (24-bit tag). Use Case Scale Suitable for small-to-medium setups. Suitable for moderate-sized enterprise networks. Ideal for large-scale multi-tenant environments."},{"location":"blog/20250123/20250123/#4-network-isolation","title":"4. Network Isolation","text":"Feature IPVLAN VLAN VXLAN Isolation Provides IP-based isolation (Layer 3 mode) or MAC address-based isolation (Layer 2 mode). Segregates traffic using VLAN IDs. Provides tenant isolation using VXLAN IDs. Cross-Subnet Communication Requires routing or bridging. Requires routing between VLANs. Built-in capability to bridge between subnets."},{"location":"blog/20250123/20250123/#5-performance","title":"5. Performance","text":"Feature IPVLAN VLAN VXLAN Overhead Very lightweight, as it avoids encapsulation. Minimal overhead for VLAN tagging (4 bytes). Higher overhead due to UDP encapsulation (50 bytes). Latency Low latency. Low latency. Higher latency due to encapsulation and decapsulation."},{"location":"blog/20250123/20250123/#6-use-cases","title":"6. Use Cases","text":"Feature IPVLAN VLAN VXLAN Best Use Case Container/VM networking with minimal overhead. Network segmentation within a single data center. Multi-tenant data centers, hybrid cloud environments. Example Assigning multiple containers unique IPs on a host's subnet. Separating voice and data traffic on the same switch. Connecting virtual machines across multiple data centers."},{"location":"blog/20250123/20250123/#conclusion","title":"Conclusion","text":"<p>This article offers a introduction to veth, VLAN, VXLAN, and IPVLAN, exploring their functionalities and applications. It further illustrates the concepts through hands-on experiments, providing a practical understanding of these network technologies.</p>"},{"location":"blog/20250123/20250123/#reference","title":"Reference","text":"<p>IPvlan network driver | Docker Docs</p> <p>VXLAN &amp; Linux</p> <p>Supercharge Your Container Networking: Seamless Host Communication with VxLAN and Docker - DEV Community</p> <p>Virtual eXtensible Local Area Networking documentation \u2014 The Linux Kernel documentation</p> <p>How to create VLAN in Linux using the ip command - SysLinuxOS</p>"},{"location":"blog/20250123/20250123/#about-me","title":"About me","text":"<p>Hi, I\u2019m Fang-Kai Ting, a newcomer to 5G and free5GC, and currently conducting research on Network Slicing. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20250123/20250123/#connect-with-me","title":"Connect with Me","text":"<p>Github:\u00a0qawl987</p>"},{"location":"blog/20250219/20250219/","title":"Introducing NR-DC: Dual Connectivity for Next-Gen 5G Capabilities","text":"<p>Note</p> <p>Author: Alonza Tu Date: 2025/02/19</p>"},{"location":"blog/20250219/20250219/#what-is-nr-dc","title":"What is NR-DC?","text":"<p>NR-DC stands for New Radio Dual Connectivity. It is a 5G technology that allows a UE to be connected to two different NR cells simultaneously. In TS 37.340, NR-DC is defined as using one or two gNBs (NR cells) to serve a UE, and the gNBs are connected to the same core network. Like the following figure shows:</p> <p></p> <p>(If it is under NR-DC mode and only one gNB is used, it is acceptable that your \"Master gNB(MgNB)\" and \"Secondary gNB(SgNB)\" are the same one.)</p>"},{"location":"blog/20250219/20250219/#radio-architecture","title":"Radio Architecture","text":"<p>The radio architecture in NR-DC consists of two main aspects: network interface and radio protocol stack.</p>"},{"location":"blog/20250219/20250219/#control-plane-architecture","title":"Control Plane Architecture","text":"<ul> <li> <p>Network Interface </p> <p>From the network interface perspective, the Master gNB (MgNB) serves as the primary connection point to the 5G Core Network through the N2 interface with AMF. All control plane messages from the core network are exclusively directed to the MgNB. The Secondary gNB (SgNB) communicates with the MgNB via the Xn interface, which facilitates the exchange of control information between the two nodes.</p> </li> <li> <p>Radio Protocol Stack </p> <p>The radio protocol architecture in NR-DC implements a split control plane design:</p> <ul> <li>The MgNB maintains the overall RRC state of the UE, ensuring centralized control of the connection</li> <li>Both MgNB and SgNB maintain their own RRC protocol entities and generate independent RRC PDUs</li> <li>This architecture enables coordinated control while allowing for node-specific radio resource management</li> </ul> </li> </ul>"},{"location":"blog/20250219/20250219/#user-plane","title":"User Plane","text":"<ul> <li> <p>Network Interface </p> <p>From the network interface perspective, both MgNB and SgNB will establish direct connections to the UPF through the N3 interface. This architecture allows for flexible user plane traffic routing to meet different QoS requirements. The Xn interface between MgNB and SgNB supports user plane data forwarding when needed, especially during SgNB addition/modification/release/change procedures.</p> </li> <li> <p>Radio Protocol Stack </p> <p>The user plane protocol architecture in NR-DC implements three different designs:</p> <ul> <li>Option 1: MCG Bearer     Both the control plane message and user plane data are served by the master cell(MgNB).</li> <li>Option 2: SCG Bearer     The control plane message is served by the master cell(MgNB) but the user plane data is only served by the secondary cell(SgNB).</li> <li>Option 3: Split Bearer     The control plane message is served by the master cell(MgNB) and the user plane data is served by both the master cell(MgNB) and the secondary cell(SgNB).</li> </ul> </li> </ul>"},{"location":"blog/20250219/20250219/#nr-dcs-core-concept-pdu-session-split-at-upf","title":"NR-DC's Core Concept: PDU Session Split at UPF","text":""},{"location":"blog/20250219/20250219/#what-is-pdu-session-split","title":"What is PDU Session Split?","text":"<p>PDU Session Split allows a single PDU session to be distributed across multiple data paths, optimizing data flow for different services and improving performance. This technique is particularly useful for QoS management, where certain QoS flows can be offloaded from the MgNB to the SgNB.</p> <p>When establishing a new PDU session, the core network may provide two UL TEID addresses to the two gNBs to enable split tunneling. The MgNB takes responsibility for managing this split by coordinating with the SgNB. The MgNB can decide how to split QoS flows across multiple tunnels based on traffic requirements and network conditions. This ensures more efficient use of network resources and reduces latency for critical services.</p>"},{"location":"blog/20250219/20250219/#why-is-pdu-session-split-important","title":"Why is PDU Session Split Important?","text":"<ul> <li>Traffic Optimization: Offloading specific QoS flows to the SgNB reduces congestion at the MgNB.</li> <li>Quality of Service: Ensures that critical services receive dedicated resources.</li> <li>Network Utilization: Balances load between cells, improving overall network efficiency.</li> <li>Redundancy and Reliability: Multiple data paths improve resilience in case of a node failure.</li> </ul>"},{"location":"blog/20250219/20250219/#how-it-works-in-nr-dc","title":"How It Works in NR-DC?","text":"<p>The PDU Session Split in NR-DC operates through a well-defined sequence of procedures:</p> <ol> <li>PDU Session Establishment<ul> <li>UE initiates a PDU Session establishment request</li> <li>AMF and SMF coordinate to set up the session</li> <li>UPF allocates two sets of TEID for potential dual connectivity:<ul> <li>One for the MgNB path</li> <li>Another for the SgNB path</li> </ul> </li> </ul> </li> <li>Bearer Configuration<ul> <li>MgNB receives both TEIDs from the core network</li> <li>Based on the QoS requirements and network conditions, MgNB decides the initial bearer type:<ul> <li>MCG Bearer: Using only MgNB path</li> <li>SCG Bearer: Using only SgNB path</li> <li>Split Bearer: Using both paths</li> </ul> </li> </ul> </li> <li>Dynamic Flow Management<ul> <li>MgNB continuously monitors QoS requirements and radio conditions(these can be customized by operators)</li> <li>When conditions change, MgNB can initiate:<ul> <li>Bearer type changes (e.g., from MCG to Split Bearer)</li> <li>QoS flow redistribution between MgNB and SgNB</li> <li>Traffic ratio adjustments in Split Bearer mode</li> </ul> </li> </ul> </li> <li>Inter-gNB Coordination<ul> <li>MgNB uses Xn interface to coordinate with SgNB</li> <li>Key coordination aspects include:<ul> <li>QoS flow management</li> <li>Resource allocation</li> <li>Bearer type changes</li> <li>Load balancing</li> </ul> </li> </ul> </li> </ol> <p>This dynamic and flexible architecture allows NR-DC to optimize network performance while maintaining service quality, truly embodying the advanced capabilities of 5G technology.</p>"},{"location":"blog/20250219/20250219/#conclusion","title":"Conclusion","text":"<p>NR-DC represents a significant advancement in 5G technology, introducing an enhanced network architecture that enables flexible control and user plane separation at the RAN level. Through its PDU Session Split mechanism and dynamic bearer configurations, NR-DC provides intelligent traffic distribution and QoS-aware flow management, significantly improving network resource utilization while maintaining high service quality. As 5G networks continue to evolve, NR-DC's flexible and efficient architecture stands as a crucial enabler for next-generation mobile services, from high-bandwidth consumer applications to ultra-reliable low-latency industrial use cases.</p>"},{"location":"blog/20250219/20250219/#reference","title":"Reference","text":"<ul> <li>TS 37.340</li> <li>5G NR-NR Dual Connectivity(NR-DC) and IMS Voice service(VoNR)</li> <li>NR-NR Dual Connectivity(NR-DC)</li> </ul>"},{"location":"blog/20250219/20250219/#about-me","title":"About me","text":"<p>Hi, I'm Alonza, a core network developer currently contributing to the free5GC project. I'm passionate about exploring cutting-edge 5G technologies, with a recent focus on NR-DC and its role in shaping next-generation connectivity. If you're also interested and have ideas to share, don't hesitate\u2014reach out to me!</p>"},{"location":"blog/20250219/20250219/#connect-with-me","title":"Connect with me","text":"<ul> <li>GitHub: https://github.com/Alonza0314</li> <li>Website: Alonza0314</li> <li>LinkedIn: Alonza Tu</li> </ul>"},{"location":"blog/20250305/20250305/","title":"Exploring sched_ext: BPF-Powered CPU Schedulers in the Linux Kernel","text":"<p>The Linux kernel's scheduler is one of its most critical components, determining which tasks run on which CPUs and for how long.</p> <p>But in today's complex computing environments, the default Linux scheduler doesn't always provide optimal performance for specialized workloads. This is where sched_ext (SCX) comes in \u2013 a framework that allows implementing custom CPU schedulers in BPF (Berkeley Packet Filter) and loading them dynamically. In this technical analysis.</p> <p>I'll examine the architecture and implementation of SCX schedulers, with a particular focus on scx_rustland and scx_bpflandand, compared to traditional schedulers.</p>"},{"location":"blog/20250305/20250305/#what-is-sched_ext","title":"What is sched_ext?","text":""},{"location":"blog/20250305/20250305/#sched_ext","title":"Sched_ext","text":"<p>Linux kernel 6.12 introduced <code>sched_ext</code> (\u201cextensible scheduler\u201d) as a new scheduling class that allows pluggable CPU schedulers via eBPF</p> <p>Enables implementing and dynamically loading thread schedulers written in BPF means it unlike traditional scheduler modifications that require kernel recompilation and rebooting, <code>sched_ext</code> defines a set of hook points (operations) that an eBPF-based scheduler can implement (such as picking the next task, enqueuing/dequeuing tasks, etc.)</p> <ul> <li>BPF struct_ops: Used to define a scheduling policy through callback functions</li> <li>Dispatch queues (DSQs): Used for task queuing and execution</li> <li>Safety mechanisms: Prevent system crashes from buggy schedulers</li> </ul> <p>scx project is a collection of <code>sched_ext</code> schedulers and tools. Schedulers in scx range from simple demonstrative policies to production-oriented ones tailored for specific use cases: *  scx_simple : uses a basic FIFO or least-run-time policy *  scx_nest : places tasks on high-frequency cores *  scx_lavd : is optimized for gaming workloads *  scx_rusty : partitions CPUs by last-level cache to improve locality *  scx_bpfland : threads that block frequently (i.e. perform many voluntary context switches per second) are assumed to be interactive, and thus prioritized</p> <p>Each scheduler in SCX implements the required sched_ext hooks (via eBPF programs) and can be selected at runtime. The default Linux scheduler can always be restored if needed</p>"},{"location":"blog/20250305/20250305/#end-to-end-task-lifecycle-in-sched_ext","title":"End-to-End Task Lifecycle in sched_ext","text":"<p>Source: https://www.ebpf.top/post/bpf_sched_ext_dive_into/</p> <p>I'll provide a deep dive into the end-to-end task flow in sched_ext, specifically examining how tasks move through the scheduling cycle. This will cover:</p> <ul> <li>The reception of a task</li> <li>How it is enqueued and dequeued</li> <li>The scheduling decisions made</li> </ul>"},{"location":"blog/20250305/20250305/#task-entry-into-sched_ext","title":"Task Entry into sched_ext","text":"<ol> <li>Once a BPF scheduler is loaded, all tasks with policy <code>SCHED_EXT</code> are switched to the new <code>sched_ext</code> scheduling class</li> <li>a task is under <code>sched_ext</code> management (either by being created with <code>SCHED_EXT</code> or through a global switch), it will be integrated into the BPF scheduler's queues.</li> <li>The kernel\u2019s <code>sched_ext</code> core calls the BPF scheduler\u2019s <code>ops.init_task()</code> callback for each task joining <code>sched_ext</code>, giving the BPF code to initialize per-task state (e.g. tracking virtual runtime, etc.)</li> <li>At this point, the task is \u201creceived\u201d by <code>sched_ext</code> \u2013 it\u2019s now subject to the BPF scheduling logic rather than the default CFS rules.</li> </ol>"},{"location":"blog/20250305/20250305/#enqueuing-and-dequeuing-mechanisms-in-sched_ext","title":"Enqueuing and Dequeuing Mechanisms in sched_ext","text":"<ol> <li>Dispatch Queues (DSQs): sched_ext uses dispatch queues (DSQs) as intermediate run queues between the BPF logic and actual CPU execution By default, there is one global FIFO queue (designated <code>SCX_DSQ_GLOBAL</code>) and one local DSQ per CPU (<code>SCX_DSQ_LOCAL</code>). Tasks are dispatched into DSQs by the BPF code, and CPUs consume from DSQs to get their next runnable task</li> <li>Enqueueing a task: When a task becomes runnable, the <code>sched_ext</code> core invokes the BPF scheduler\u2019s <code>ops.select_cpu()</code> followed by <code>ops.enqueue()</code> callbacks.<ul> <li>it may call <code>scx_bpf_dispatch(p, SCX_DSQ_LOCAL, SCX_SLICE_DFL, enq_flags)</code> to place the task directly into the target CPU\u2019s local queue</li> <li>Or it might dispatch to the global queue (<code>SCX_DSQ_GLOBAL</code>) or a custom DSQ.</li> </ul> </li> </ol>"},{"location":"blog/20250305/20250305/#scheduling-logic-and-decision-making-process","title":"Scheduling Logic and Decision-Making Process","text":"<p>We know the actual decision of which task runs next on each CPU is made by the interplay of the <code>ops.dispatch()</code> and (optionally) <code>ops.consume()</code> callbacks, in conjunction with the dispatch queues. The scheduling cycle on a CPU, from a high-level perspective, is as follows:  - Selecting a target CPU on wakeup \u2013 <code>select_cpu()</code>, This function allows the scheduler to choose an optimal CPU for the task before it is enqueued. For example, a scheduler might want to put a waking task on the same CPU it ran last (for cache affinity) or find an idle CPU to improve latency.  - Enqueue decision \u2013 <code>enqueue()</code>: As described above, the BPF scheduler\u2019s <code>.enqueue()</code> either dispatches the task to a DSQ (local, global, or custom) or holds it in an internal queue  - CPU picks next task \u2013 consumption and dispatch: the scheduler core asks <code>sched_ext</code> for the next task to run. The CPU first check local DSQ for any tasks waiting. Then, that task is dequeued and chosen to run immediately. If the local DSQ is empty, the CPU can try to consume from a global shared queue.  - Dispatching tasks from BPF scheduler \u2013 <code>dispatch()</code>: If after consuming global the CPU still has no task, the core invokes the BPF scheduler\u2019s <code>ops.dispatch()</code>callback. It can call <code>scx_bpf_dispatch()</code> to dispatch tasks to either the requesting CPU\u2019s local DSQ, the global DSQ</p>"},{"location":"blog/20250305/20250305/#heres-a-summary-of-key-functions-used-in-scx-scheduling","title":"Here's a summary of key functions used in SCX scheduling:","text":"Function Purpose Called By <code>select_cpu()</code> Choose target CPU hint Kernel on task wakeup <code>enqueue()</code> Place task in queue or DSQ Kernel after CPU selection <code>dispatch()</code> Find next task to run on CPU Kernel when CPU needs work <code>scx_bpf_dsq_insert()</code> Add task to FIFO DSQ BPF scheduler <code>scx_bpf_dsq_insert_vtime()</code> Add task to priority DSQ BPF scheduler <code>scx_bpf_dsq_move_to_local()</code> Move task from DSQ to CPU BPF in <code>dispatch()</code> <code>scx_bpf_kick_cpu()</code> Wake up idle CPU BPF scheduler <code>running()</code> Track task starting on CPU Kernel when task runs"},{"location":"blog/20250305/20250305/#build-and-run-sched_ext","title":"Build and run sched_ext","text":"<p>I use blog post by Andrea Righi outlines a great workflow for testing sched_ext without modifying  existing system</p>"},{"location":"blog/20250305/20250305/#run-the-virtual-environment-and-test-a-scheduler","title":"Run the virtual environment and test a scheduler","text":"<p>First, start the virtual environment with the sched_ext kernel: <pre><code>vng -vr ../linux\n</code></pre> </p> <p>Once inside the virtual environment, you can run one of the schedulers with the helper function:</p> <pre><code>scx ./build/scheds/c/scx_simple\n</code></pre> <p></p>"},{"location":"blog/20250305/20250305/#c-based-schedulers","title":"C-Based Schedulers","text":"<p>scx_simple </p> <p><code>scx_simple</code> is a minimal scheduler that functions either as a global weighted vtime scheduler (similar to the Completely Fair Scheduler) or as a FIFO scheduler. It's designed primarily to demonstrate basic scheduling concepts </p> <p>In the code below, from <code>scx_simple.bpf.c</code>, the <code>.enqueue</code> callback handles a task that needs to be scheduled.  1. If the scheduler is in FIFO mode (fifo_sched == true), it simply inserts the task into the shared dispatch queue without any priority sorting. </p> <ol> <li> <p>If in normal (weighted vtime) mode, it retrieves the task\u2019s current virtual time (p-&gt;scx.dsq_vtime), adjusts it so that no task gains more than one slice worth of idle credit, </p> </li> <li> <p>inserts the task into the shared queue with that virtual time as the key:</p> </li> </ol> <pre><code>void BPF_STRUCT_OPS(simple_enqueue, struct task_struct *p, u64 enq_flags) {\n    stat_inc(1);  // increment global queue count\n    if (fifo_sched) {\n        // FIFO scheduling: enqueue to shared queue with default slice\n        scx_bpf_dsq_insert(p, SHARED_DSQ, SCX_SLICE_DFL, enq_flags);\n    } else {\n        u64 vtime = p-&gt;scx.dsq_vtime;\n        // Cap the vtime lag to one slice to prevent too much credit\n        if (time_before(vtime, vtime_now - SCX_SLICE_DFL))\n            vtime = vtime_now - SCX_SLICE_DFL;\n        // Enqueue with a specific virtual time for fairness\n        scx_bpf_dsq_insert_vtime(p, SHARED_DSQ, SCX_SLICE_DFL, vtime, enq_flags);\n    }\n}\n</code></pre>"},{"location":"blog/20250305/20250305/#scx_rustland","title":"scx_rustland","text":"<p><code>scx_rustland</code> is designed to prioritize interactive workloads over CPU-intensive background workloads.</p> <p>In practical terms, this likely means it keeps track of each task\u2019s recent CPU usage or blocking behavior and assigns higher priority (sooner scheduling, more CPU time) to tasks that have shorter CPU bursts.</p>"},{"location":"blog/20250305/20250305/#scx_rustland-overiew","title":"scx_rustland overiew","text":"<p><code>scx_rustland</code> uses a hybrid approach that splits functionality between kernel space and user space:</p> <pre><code>User Space: Complex scheduling logic in Rust\n    - Task prioritization\n    - CPU selection algorithms\n    - Complex data structures\n    |\n    | Ring buffer communication\n    v\nKernel Space: Minimal BPF component\n    - Task state tracking\n    - Dispatch queue management\n    - Safety mechanisms\n</code></pre> <p>BPF Dispatcher (scx_rustland_core): The BPF part of scx_rustland implements minimal logic required to interface with the kernel. Its enqueue hook, for example, does not directly decide a run queue as a normal scheduler would. Instead, it may place the task into a BPF queue map that represents \u201ctasks waiting for user-space decision.\u201d </p> <p>User-Space Scheduler (Rust): On the user side, the Rust scheduler process uses libraries (like libbpf or Aya in Rust) to interact with the eBPF program. It attaches to the maps exposed by BPF. Typically, it might use a ring buffer to receives a task to schedule, it runs its algorithm to decide where/when that task should run. </p>"},{"location":"blog/20250305/20250305/#scx_rustland-code-structure","title":"scx_rustland Code Structure","text":"<pre><code>scheds/rust/scx_rustland/\n\u251c\u2500\u2500 Cargo.toml                 # Rust package definition\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main.rs                # Main userspace implementation\n\u2502   \u251c\u2500\u2500 scheduler.rs           # Scheduler logic\n\u2502   \u251c\u2500\u2500 stats.rs               # Statistics collection\n\u2502   \u251c\u2500\u2500 topology.rs            # CPU topology handling\n\u2502   \u2514\u2500\u2500 bpf/                   # BPF skeleton code\n\u2514\u2500\u2500 src/bpf/\n    \u251c\u2500\u2500 main.bpf.c             # Minimal BPF implementation\n    \u2514\u2500\u2500 intf.h                 # Interface definitions\n</code></pre> <p><code>scx_rustland</code> has two main components:</p> <ol> <li>BPF Component (kernel space):</li> </ol> <pre><code>void BPF_STRUCT_OPS(rustland_enqueue, struct task_struct *p, u64 enq_flags)\n{\n    // Skip scheduling the scheduler itself\n    if (is_usersched_task(p))\n        return;\n\n    // Pass task information to userspace for scheduling decision\n    struct queued_task_ctx *task = bpf_ringbuf_reserve(&amp;queued, sizeof(*task), 0);\n    if (!task) {\n        // Fallback: direct dispatch if userspace communication fails\n        scx_bpf_dsq_insert_vtime(p, SHARED_DSQ, SCX_SLICE_DFL, 0, enq_flags);\n        return;\n    }\n\n    // Send task info to userspace\n    populate_task_info(task, p, enq_flags);\n    bpf_ringbuf_submit(task, 0);\n}\n</code></pre> <ol> <li>Rust Component (user space):</li> </ol> <pre><code>impl Scheduler {\n    fn dispatch_next_task(&amp;mut self) {\n        if let Some(task) = self.priority_queue.pop_min() {\n            // Complex scheduling logic in Rust\n            let target_cpu = self.find_best_cpu_for_task(&amp;task);\n            let time_slice = self.calculate_time_slice(&amp;task);\n\n            // Send decision back to kernel\n            let mut dispatched_task = DispatchedTask::new(&amp;task);\n            dispatched_task.cpu = target_cpu;\n            dispatched_task.slice_ns = time_slice;\n            self.bpf.dispatch_task(&amp;dispatched_task).unwrap();\n        }\n    }\n\n    fn find_best_cpu_for_task(&amp;self, task: &amp;QueuedTask) -&gt; i32 {\n        // Can use complex data structures and algorithms here\n        // without BPF verifier constraints\n        // ...\n    }\n}\n</code></pre>"},{"location":"blog/20250305/20250305/#advantages","title":"Advantages","text":"<ul> <li>Better abstraction capabilities</li> <li>Rich error handling</li> <li>More readable algorithms</li> <li>Unit testing support</li> <li>Modern language features</li> </ul>"},{"location":"blog/20250305/20250305/#scheduling-logic","title":"Scheduling Logic","text":"<p>The scheduling logic in <code>scx_rustland</code> is split across kernel (BPF) and user-space</p> <p><pre><code>// Main scheduler object\nstruct Scheduler&lt;'a&gt; {\n    bpf: BpfScheduler&lt;'a&gt;,                  // BPF connector\n    stats_server: StatsServer&lt;(), Metrics&gt;, // statistics\n    task_pool: TaskTree,                    // tasks ordered by deadline\n    task_map: TaskInfoMap,                  // map pids to the corresponding task information\n    min_vruntime: u64,                      // Keep track of the minimum vruntime across all tasks\n    init_page_faults: u64,                  // Initial page faults counter\n    slice_ns: u64,                          // Default time slice (in ns)\n    slice_ns_min: u64,                      // Minimum time slice (in ns)\n}\n</code></pre> In user-space, <code>scx_rustland</code> maintains its own runqueue data structure \u2013 specifically a BTreeSet of tasks ordered by weighted vruntime (essentially mimicking CFS in user-space). It also monitors each task\u2019s behavior to detect interactive tasks: if a task consistently voluntarily yields CPU (releasing the CPU before its time slice is fully used), it\u2019s considered interactive.</p>"},{"location":"blog/20250305/20250305/#scx_bpfland","title":"scx_bpfland","text":"<p><code>scx_bpfland</code> implements its scheduling logic almost entirely in BPF (Berkeley Packet Filter) code that runs in kernel space. It follows a more traditional approach where all scheduling decisions happen within the kernel:</p>"},{"location":"blog/20250305/20250305/#scx_bpfland-overiew","title":"scx_bpfland  overiew","text":"<p><pre><code>User Space: Minimal (monitoring only)\n    |\n    | (Minimal interaction)\n    v\nKernel Space: Full scheduler implementation in BPF\n    - Task selection\n    - CPU assignment\n    - Priority decisions\n    - All scheduling algorithms\n</code></pre> <pre><code>scheds/c/scx_bpfland.bpf.c        # Main BPF scheduler implementation\nscheds/c/scx_bpfland.c            # Userspace loader and monitoring\nscheds/include/scx_common.bpf.h   # Common BPF utilities\n</code></pre></p>"},{"location":"blog/20250305/20250305/#scx_bpfland-code-structure","title":"scx_bpfland Code Structure","text":"<p><pre><code>scheds/c/scx_bpfland.bpf.c        # Main BPF scheduler implementation\nscheds/c/scx_bpfland.c            # Userspace loader and monitoring\nscheds/include/scx_common.bpf.h   # Common BPF utilities\n</code></pre> <code>scx_bpfland</code> implements all scheduling callbacks directly in BPF: <pre><code>void BPF_STRUCT_OPS(bpfland_enqueue, struct task_struct *p, u64 enq_flags)\n{\n    // Implementation directly in BPF\n    struct task_ctx *task_ctx;\n    u64 vruntime = 0;\n\n    // Skip enqueuing the scheduler itself\n    if (p-&gt;pid == bpfland_pid)\n        return;\n\n    // Get or create task context\n    task_ctx = get_task_ctx(p);\n    if (!task_ctx)\n        return;\n\n    // Calculate vruntime based on scheduling policy\n    vruntime = calc_vruntime(p, task_ctx, enq_flags);\n\n    // Direct enqueue to DSQ with calculated vruntime\n    scx_bpf_dsq_insert_vtime(p, GLOBAL_DSQ, task_slice(p), vruntime, enq_flags);\n}\n</code></pre></p>"},{"location":"blog/20250305/20250305/#scheduling-logic_1","title":"Scheduling Logic","text":"<p><code>scx_bpfland</code> internal logic is very similar in spirit to scx_rustland\u2019s algorithm, but it executes entirely within the BPF program (in kernel). It effectively merges the two-tier logic into one.</p>"},{"location":"blog/20250305/20250305/#advantages-over-traditional-schedulers","title":"Advantages Over Traditional Schedulers","text":"<p>The sched_ext + eBPF approach (exemplified by SCX schedulers) brings several key advantages over traditional in-kernel schedulers: * Dynamic Policy Changes: New schedulers can be loaded and unloaded at runtime. There\u2019s no need to patch or reboot the kernel to try a different scheduling policy. This is invaluable for testing and tuning in production environments \u2013 administrators can switch between, say, a latency-focused scheduler during interactive sessions and a throughput-focused one for batch processing periods, with a simple command. * Workload-Specific Optimizations: The biggest advantage is the ability to tailor scheduling to a specific workload or environment. Instead of one-size-fits-all, users can pick or write a scheduler that, for example, never migrates certain tasks off a preferred CPU, or that implements strict priority levels, or that optimizes for particular patterns (like the \u201cblock frequently == interactive\u201d rule). SCX even allows combining policies, as shown by scx_layered which applies different scheduling rules to different groups of processes.</p>"},{"location":"blog/20250305/20250305/#future-integrating-scx_goland-with-free5gc-for-data-plane-optimization","title":"Future integrating SCX_GOLAND with free5GC for Data Plane Optimization","text":""},{"location":"blog/20250305/20250305/#scx_goland","title":"SCX_GOLAND","text":""},{"location":"blog/20250305/20250305/#architecture-overview","title":"Architecture Overview","text":"<p>The <code>scx_goland_core</code> project represents another approach to implementing a user-space scheduler for Linux using the <code>sched_ext</code> framework. This project follows the architectural patterns established by scx_rustland, adapting them to the Go ecosystem.</p>"},{"location":"blog/20250305/20250305/#go-implementation","title":"Go Implementation","text":"<p>The Go implementation consists of several key packages and types:</p> <p>Core Package:</p> <ul> <li>Sched: Main scheduler struct that holds references to BPF maps and methods for communication</li> <li>QueuedTask: Represents a task queued from the kernel</li> <li>DispatchedTask: Represents a task to be dispatched back to the kernel</li> <li>BssData: Data structure for accessing BPF's BSS section</li> </ul>"},{"location":"blog/20250305/20250305/#constraints-and-limitations","title":"Constraints and Limitations","text":"<p>Memory Management:  In <code>scx_goland_core</code>, tasks from the kernel\u2019s ring buffers are received as byte slices and then decoded (using binary.Read) into Go structs. This decoding and copying process is relatively expensive when compared to Rust\u2019s approach where you can often work in a more zero\u2011copy manner. In contrast, <code>scx_rustland</code> benefits from Rust\u2019s zero\u2011cost abstractions, minimal runtime overhead, and more direct access to low-level memory without a garbage collector.</p> <p>In go: <pre><code>func (s *Sched) DequeueTask(task *QueuedTask) {\n    select {\n    case t := &lt;-s.queue:\n        buff := bytes.NewBuffer(t)\n        err := binary.Read(buff, binary.LittleEndian, task)\n        if err != nil {\n            task.Pid = -1\n            return\n        }\n        err = s.SubNrQueued()\n        if err != nil {\n            task.Pid = -1\n            log.Printf(\"SubNrQueued err: %v\", err)\n            return\n        }\n        return\n    default:\n        task.Pid = -1\n        return\n    }\n}\n</code></pre></p> <p>In Rust: <pre><code>fn dequeue_task(&amp;mut self) -&gt; Result&lt;Option&lt;QueuedTask&gt;, i32&gt; {\n    match self.queued.consume_raw() {\n        0 =&gt; {\n            self.skel.maps.bss_data.nr_queued = 0;\n            Ok(None)\n        }\n        LIBBPF_STOP =&gt; {\n            // A valid task is received, convert data to a proper task struct.\n            let task = unsafe { EnqueuedMessage::from_bytes(&amp;BUF.0).to_queued_task() };\n            let _ = self.skel.maps.bss_data.nr_queued.saturating_sub(1);\n            Ok(Some(task))\n        }\n        res if res &lt; 0 =&gt; Err(res),\n        res =&gt; panic!(\n            \"Unexpected return value from libbpf-rs::consume_raw(): {}\",\n            res\n        ),\n    }\n}\n</code></pre></p> <p>Garbage Collection:  Go is a managed language with a garbage collector and its own scheduler for goroutines. Even though Go is very efficient, those additional layers (GC, goroutine scheduling, channel operations) add overhead compared to Rust\u2019s zero\u2011cost abstractions where most things are determined at compile time.</p>"},{"location":"blog/20250305/20250305/#scx_goland-summary","title":"SCX_GOLAND Summary","text":"<p>It shows how Go's concurrency model and ease of use can be applied to system programming tasks that were traditionally the domain of C or Rust.</p> <p>While it's not as optimized or mature as <code>scx_rustland</code>, it provides a valuable alternative for developers more comfortable with Go. It also serves as a good example of how the sched_ext framework enables experimentation with different scheduling policies and implementations without requiring deep kernel expertise.</p>"},{"location":"blog/20250305/20250305/#data-plane-and-cpu-scheduling-challenges","title":"Data Plane and CPU Scheduling Challenges","text":"<p>free5GC is an open-source implementation of the 5G Core network, written largely in Go. One of its components is the UPF (User Plane Function), which handles the data plane \u2013 i.e., packet forwarding for user traffic (GTP-U tunneling, routing packets between RAN and data network). The UPF and other network functions in Free5GC are user-space processes that can be CPU-intensive, especially under high load (many subscribers or high packet rates). Ensuring low latency and high throughput in the data plane is critical.</p>"},{"location":"blog/20250305/20250305/#future-design-of-scx_goland-scheduler","title":"Future Design of SCX_GOLAND Scheduler","text":"<p>Identifying Target Tasks: The scheduler must reliably identify the free5GC data plane threads/processes. This could be done by process name matching, by cgroup (if free5GC is in a container or specific slice, the scheduler can detect that cgroup and apply a policy), or by explicit configuration(the operator could pass PIDs or process names to <code>scx_goland</code> at startup to tell it which tasks to prioritize).</p> <p>prioritize specific goroutines: free5GC could be run in a mode where the UPF uses dedicated pinned threads for packet RX/TX loops (ensuring those OS threads only do packet work). Then <code>scx_goland</code> can target those threads precisely. But need to care that free5GC\u2019s internal scheduling of goroutines on OS threads might not be directly visible to the OS scheduler.</p>"},{"location":"blog/20250305/20250305/#conclusion","title":"Conclusion","text":"<p>The advantages of SCX (<code>sched_ext</code>) \u2013 runtime pluggability, rapid development, workload-specific optimizations, and crash resilience \u2013 make it very attractive for specialized domains. One such domain is the 5G core network. We explored <code>scx_goland</code>, a Go-based scheduler concept, illustrating how a custom scheduler could be integrated with free5GC to optimize its performance.</p>"},{"location":"blog/20250305/20250305/#reference","title":"Reference","text":"<ul> <li>Re-implementing my Linux Rust scheduler in eBPF</li> <li>\u5185\u6838\u8c03\u5ea6\u5ba2\u5236\u5316\u5229\u5668\uff1aSCHED_EXT</li> <li>BPF \u8d4b\u80fd\u8c03\u5ea6\u5668\uff1a\u4e07\u5b57\u8be6\u89e3 sched_ext \u5b9e\u73b0\u673a\u5236\u4e0e\u5de5\u4f5c\u6d41\u7a0b</li> <li>Pluggable CPU schedulers</li> <li>sched_ext: scheduler architecture and interfaces</li> <li>eBPF \u96a8\u7b46\uff08\u4e03\uff09\uff1asched_ext</li> <li>scx_goland_core</li> </ul>"},{"location":"blog/20250305/20250305/#about","title":"About","text":"<p>Hello, I'm William Lin. I'd like to share my excitement about being a member of the free5gc project, which is a part of the Linux Foundation. I'm always eager to discuss any aspects of core network development or related technologies.</p>"},{"location":"blog/20250305/20250305/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: williamlin0518</li> <li>Linkedin: Cheng Wei Lin</li> </ul>"},{"location":"blog/20250306/20250306/","title":"Install Free5GC with LoxiLB NGAP load-balancing","text":"<p>This blog discusses how LoxiLB, an open-source, eBPF-based load balancer, addresses challenges in NGAP (NG Application Protocol) Layer 7 load balancing within 5G networks with Free5GC, an open-source implementation of a 5G core network (5GC). Traditional Layer 4 load balancing can lead to issues such as AMF (Access and Mobility Management Function) overload and problematic handovers, especially when gNBs (next-generation Node Bs) serve a large number of UEs (User Equipments). LoxiLB overcomes these challenges by comprehending both NGAP and NAS (Non-Access Stratum) protocols, enabling effective distribution of UEs across stateless AMFs and facilitating seamless handovers. More information about this topic can be found here.</p> <p>This post provides a step-by-step deployment guide using open-source solutions like Free5GC, LoxiLB, and UERANSIM, all orchestrated in a cloud-native fashion with Kubernetes, to demonstrate this functionality.</p>"},{"location":"blog/20250306/20250306/#overview","title":"Overview","text":"<p>LoxiLB is deployed as a load balancer in front of multiple AMFs in a Free5GC deployment to ensure high availability and seamless failover for NGAP connections originating from a gNB (UERANSIM). By proxying NGAP traffic, LoxiLB ensures that if an AMF instance goes down, the gNB's NGAP connection remains intact and continues to function without interruption. Additionally, when a failed AMF instance recovers, LoxiLB replays cached NG Setup requests, etc to restore connectivity automatically.</p>"},{"location":"blog/20250306/20250306/#flow-diagram","title":"Flow Diagram","text":"<p>1. Normal Operation:</p> <ul> <li>UERANSIM (gNB) establishes an NGAP connection through LoxiLB.</li> <li>LoxiLB load balances NGAP traffic across multiple Free5GC AMFs.</li> <li>The NG Setup procedure is completed with the selected AMF.</li> </ul> <p>2. AMF Failure Handling:</p> <ul> <li>If an AMF fails, LoxiLB detects the failure and reroutes the gNB's NGAP session, along with its associated UEs, to a healthy AMF.</li> <li>The gNB does not experience connection loss because LoxiLB maintains the session.</li> </ul> <p>3. AMF Recovery &amp; NGAP Replay:</p> <ul> <li>When the failed AMF is restored, LoxiLB replays cached NG Setup requests and other related messages.</li> <li>The AMF resumes handling NGAP traffic without requiring the gNB to reinitiate the setup.</li> </ul> <pre><code>                          +-------------------+\n                          |   UERANSIM gNB    |\n                          | (Simulated gNB)   |\n                          +-------------------+\n                                   |\n                     NG Setup Req  |  NGAP Signaling\n                                   v\n                          +-------------------+\n                          |      LoxiLB       |\n                          | (NGAP Proxy/LB)   |\n                          +-------------------+\n                               /     |     \\\n       +----------------+    +----------------+    +----------------+\n       |   AMF 1 (UP)   |    |   AMF 2 (DOWN)  |   |   AMF 3 (UP)   |\n       |  (Processing)  |    | (Failure State) |   |  (Processing)  |\n       +----------------+    +----------------+    +----------------+\n                                        |\n                         AMF 2 Recovers |\n                                        v\n                              +----------------+\n                              |   AMF 2 (UP)   |\n                              | (Cache Replay) |\n                              +----------------+\n</code></pre> <p>This architecture significantly enhances 5G network reliability by ensuring the NGAP signaling plane remains operational even when individual AMF instances experience failures, making it ideal for production 5G deployments requiring high availability</p>"},{"location":"blog/20250306/20250306/#prerequisites","title":"Prerequisites","text":""},{"location":"blog/20250306/20250306/#install-k8s-microk8s","title":"Install K8s (MicroK8s)","text":"<p>Install MicroK8s by referring to the guide  https://free5gc.org/guide/7-free5gc-helm/ </p> <p>After installing MicroK8s, enable Multus as well, and then additionally run the following command. (It is required to to create a PV to run Free5GC properly)</p> <pre><code>microk8s enable hostpath-storage\n</code></pre>"},{"location":"blog/20250306/20250306/#install-gtp5g-kernel-module","title":"Install gtp5g kernel module","text":"<p>To run free5gc, you need the gtp5g module. The following commands install the basic packages for compiling kernel modules.</p> <pre><code>sudo apt -y install git gcc gcc-12 g++ cmake autoconf libtool pkg-config libmnl-dev libyaml-dev\n</code></pre> <p>Then, install the module by referring to the gtp5g page.</p>"},{"location":"blog/20250306/20250306/#topology","title":"Topology","text":"<p>The core networks (N2, N3, N4, N6, N9) of free5gc are configured using Multus. Therefore, each core pod of free5gc has an additional Multus network interface in addition to the default interface (eth0) provided by K8s CNI (default: calico).</p> <p>gNB uses the N2 network to access AMF. Therefore, it is reasonable for LoxiLB to also have an N2 network interface to load balance the traffic.</p> <p>In this document, free5gc is deployed as a K8s pod using Helm. At the same time, LoxiLB is also deployed to K8s in in-cluster mode. At this time, LoxiLB does not operate in host mode, but uses the pod network and is assigned the N2 Multus network interface.</p> <p>gNB sees the external IP of the load balancer service as the AMF IP and forwards the traffic. LoxiLB can load balance the traffic to AMF.</p> <p>In this document, K8s is installed as a single node in a VM environment. The Host VM has an enp0s8 interface and an IP of 192.168.122.230.</p>"},{"location":"blog/20250306/20250306/#install-free5gc-using-helm","title":"Install free5gc (using Helm)","text":"<p>Download the free5gc Helm package with the following command.</p> <pre><code>git clone https://github.com/free5gc/free5gc-helm.git\ncd free5gc-helm/charts\n</code></pre>"},{"location":"blog/20250306/20250306/#modify-free5gcvaluesyaml","title":"Modify free5gc/values.yaml","text":"<p>Modify the free5gc/values.yaml file to suit your environment.</p> <pre><code>vi free5gc/values.yaml\n</code></pre> <p>The part that needs to be modified in the values.yaml file is the masterIf of each network. The VM used as a host in the current document has an enp0s8 interface, and that interface becomes the masterIf of the Multus interface. Therefore, modify it as follows:</p> <pre><code>n2network:\n    enabled: true\n    name: n2network\n    type: ipvlan\n    **masterIf: enp1s0**\n    subnetIP: 10.100.50.248\n    cidr: 29\n    gatewayIP: 10.100.50.254\n    excludeIP: 10.100.50.254\n</code></pre> <p>Modify other networks (n3, n4, n6, n9) in the same way.</p>  \ud83d\udca1  NOTE: This document is based on a VM with one interface. The official document, [free5GC Helm Installation](https://free5gc.org/guide/7-free5gc-helm/) - free5GC, recommends using two interfaces.   <p>Next, find AMF in the global section and change service.ngap.enabled to true and service.ngap.type to LoadBalancer.</p> <pre><code>amf:\n    n2if:  # NGAP\n      ipAddress: 10.100.50.249\n    service:\n      ngap:\n        **enabled: true**\n        name: amf-n2\n        port: 38412\n        nodeport: 31412\n        protocol: SCTP\n        **type: LoadBalancer**\n</code></pre>"},{"location":"blog/20250306/20250306/#modify-amf-serviceyaml","title":"Modify amf-service.yaml","text":"<p>Next, modify the amf-service.yaml file.</p> <pre><code>vi free5gc/charts/free5gc-amf/templates/amf-service.yaml file\n</code></pre> <p>Add the following annotation to metadata: And specify \u201cloxilb.io/loxilb\u201d in spec.loadBalancerClass.</p> <pre><code>metadata:\n  name: {{ include \"free5gc-amf.fullname\" $ }}-{{ $.Values.global.amf.service.ngap.name }}\n  labels:\n    project: {{ $.Values.global.projectName }}\n    nf: {{ .name }}\n  annotations:\n    **loxilb.io/probetype: \"none\"\n    loxilb.io/lbmode: \"fullproxy\"\n    loxilb.io/epselect: \"n2\"\n    loxilb.io/multus-nets: \"n2network-free5gc-helm-free5gc-amf\"**\nspec:\n  type: {{ $.Values.global.amf.service.ngap.type }}\n  **loadBalancerClass: \"loxilb.io/loxilb\"**\n</code></pre> <p>A description of the annotation can be found on kube-loxilb\u2019s github site.</p>"},{"location":"blog/20250306/20250306/#run-helm-install-command","title":"Run helm install command","text":"<p>Deploy free5gc with the following command:</p> <pre><code>helm install -n free5gc free5gc-helm ./ \\\n--set global.n6network.masterIf=enp0s8 \\\n--set global.n6network.subnetIP=\"192.168.122.0\" \\\n--set global.n6network.gatewayIP=\"192.168.122.1\" \\\n--set free5gc-upf.upf1.n6if.ipAddress=\"192.168.122.251\" \\\n--set free5gc-upf.upf2.n6if.ipAddress=\"192.168.122.252\" \\\n--set free5gc-upf.upfb.n6if.ipAddress=\"192.168.122.253\" \\\n--set global.n2network.masterIf=enp0s8 \\\n--set global.n3network.masterIf=enp0s8 \\\n--set global.n4network.masterIf=enp0s8 \\\n--set global.n9network.masterIf=enp0s8\n</code></pre> <p>enp0s8 specified in global.n6network.masterIf is the interface name of the Host VM.</p> <p>The IP address specified in global.n6network.subnetIP &amp; global.n6network.gatewayIP is the network subnet and gateway information used by enp0s8. upf1, upf2, and upfb use the same subnet as the corresponding subnet to enable external communication. Therefore, the IPs of upf1, upf2, and upfb must be IPs that are not used by other machines.</p> <p>Since this document uses only one interface, the option is set to use enp0s8 as the master for other networks as well. (Same as specified in the values.yaml file)</p> <p>If the deployment is successful, the following pods are created.</p> <pre><code>kubectl get pods -n free5gc\nNAME                                                     READY   STATUS    RESTARTS        AGE\nfree5gc-helm-free5gc-amf-amf-8667945876-qcwlk            1/1     Running   0               5d2h\nfree5gc-helm-free5gc-ausf-ausf-64c684f546-crgjt          1/1     Running   0               5d2h\nfree5gc-helm-free5gc-chf-chf-7c7bb88fb7-xkpnj            1/1     Running   0               5d2h\nfree5gc-helm-free5gc-dbpython-dbpython-59684d749-6rppv   1/1     Running   0               5d2h\nfree5gc-helm-free5gc-nef-nef-759b6dfbdb-xrn5r            1/1     Running   0               5d2h\nfree5gc-helm-free5gc-nrf-nrf-6c8cc8b69-wwzf8             1/1     Running   0               5d2h\nfree5gc-helm-free5gc-nssf-nssf-5c9d76fc69-f4vfj          1/1     Running   0               5d2h\nfree5gc-helm-free5gc-pcf-pcf-78f7dbc67d-29xk8            1/1     Running   0               5d2h\nfree5gc-helm-free5gc-smf-smf-5dbcc8565c-2sj7w            1/1     Running   0               5d2h\nfree5gc-helm-free5gc-udm-udm-68ff9fbd47-hh2z7            1/1     Running   0               5d2h\nfree5gc-helm-free5gc-udr-udr-5bd79d98f8-8gfzh            1/1     Running   0               5d2h\nfree5gc-helm-free5gc-upf-upf1-79d75db8cd-l26ch           1/1     Running   0               5d2h\nfree5gc-helm-free5gc-upf-upf2-67dcd99f89-l2jf5           1/1     Running   0               5d2h\nfree5gc-helm-free5gc-upf-upfb-794d46bbb8-nh8fh           1/1     Running   0               5d2h\nfree5gc-helm-free5gc-webui-webui-75c45c779c-9vvc7        1/1     Running   0               5d2h\nmongodb-0                                                1/1     Running   0               5d2h\n</code></pre> <p>PVC is produced as follows:</p> <pre><code>kubectl get pvc -n free5gc\nNAME                STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS        AGE\ncert-pvc            Bound    pvc-dbc3f5ff-bdcc-4b06-bde3-462c3c96ec95   1Mi        ROX            microk8s-hostpath   5d2h\ndatadir-mongodb-0   Bound    pvc-ba897e0c-9860-4d42-8bc7-9f0ceb1ff17b   6Gi        RWO            microk8s-hostpath   6d3h\n</code></pre> <p>For service, the amf service will be stuck in pending state. This is because loxilb has not been deployed yet.</p> <pre><code>kubectl get svc -n free5gc\nNAME                                TYPE           CLUSTER-IP       EXTERNAL-IP         PORT(S)            AGE\nfree5gc-helm-free5gc-amf-amf-n2     LoadBalancer   10.152.183.91    &lt;pending&gt;           38412:31412/SCTP   5d2h\nfree5gc-helm-free5gc-amf-service    ClusterIP      10.152.183.146   &lt;none&gt;              80/TCP             5d2h\nfree5gc-helm-free5gc-ausf-service   ClusterIP      10.152.183.42    &lt;none&gt;              80/TCP             5d2h\nfree5gc-helm-free5gc-chf-service    ClusterIP      10.152.183.254   &lt;none&gt;              80/TCP             5d2h\nfree5gc-helm-free5gc-nef-service    ClusterIP      10.152.183.162   &lt;none&gt;              80/TCP             5d2h\nfree5gc-helm-free5gc-nssf-service   ClusterIP      10.152.183.181   &lt;none&gt;              80/TCP             5d2h\nfree5gc-helm-free5gc-pcf-service    ClusterIP      10.152.183.50    &lt;none&gt;              80/TCP             5d2h\nfree5gc-helm-free5gc-smf-service    ClusterIP      10.152.183.206   &lt;none&gt;              80/TCP             5d2h\nfree5gc-helm-free5gc-udm-service    ClusterIP      10.152.183.36    &lt;none&gt;              80/TCP             5d2h\nfree5gc-helm-free5gc-udr-service    ClusterIP      10.152.183.95    &lt;none&gt;              80/TCP             5d2h\ngnb-service                         ClusterIP      10.152.183.43    &lt;none&gt;              4997/UDP           5d2h\nloxilb-egress-service               LoadBalancer   10.152.183.211   llbanyextip         9999:31237/TCP     5d2h\nloxilb-lb-service                   ClusterIP      None             &lt;none&gt;              11111/TCP          5d2h\nmongodb                             ClusterIP      10.152.183.83    &lt;none&gt;              27017/TCP          5d2h\nnrf-nnrf                            ClusterIP      10.152.183.176   &lt;none&gt;              8000/TCP           5d2h\nwebui-nbiling                       ClusterIP      10.152.183.56    &lt;none&gt;              2122/TCP           5d2h\nwebui-ncgf                          ClusterIP      10.152.183.180   &lt;none&gt;              2121/TCP           5d2h\nwebui-service                       NodePort       10.152.183.226   &lt;none&gt;              5000:30500/TCP     5d2h\n</code></pre>"},{"location":"blog/20250306/20250306/#deploy-loxilb","title":"Deploy LoxiLB","text":"<p>Save the following to a file named loxilb.yaml:</p> <pre><code>apiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: loxilb-lb\n  namespace: free5gc\nspec:\n  selector:\n    matchLabels:\n      app: loxilb-app\n  template:\n    metadata:\n      name: loxilb-lb\n      labels:\n        app: loxilb-app\n      annotations:\n        k8s.v1.cni.cncf.io/networks: '[ { \"name\": \"n2network-free5gc-helm-free5gc-amf\",\n          \"interface\": \"n2\", \"ips\": [ \"10.100.50.253/29\" ], \"gateway\": [ \"10.100.50.254\"\n          ] }]'\n    spec:\n      #hostNetwork: true\n      dnsPolicy: ClusterFirstWithHostNet\n      tolerations:\n      - key: \"node-role.kubernetes.io/master\"\n        operator: Exists\n      - key: \"node-role.kubernetes.io/control-plane\"\n        operator: Exists\n      containers:\n      - name: loxilb-app\n        image: \"ghcr.io/loxilb-io/loxilb:scp2\"\n        imagePullPolicy: Always\n        command: [ \"/root/loxilb-io/loxilb/loxilb\", \"--proxyonlymode\" ]\n        ports:\n        - containerPort: 11111\n        securityContext:\n          privileged: true\n          capabilities:\n            add:\n              - SYS_ADMIN\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: loxilb-egress-service\n  namespace: free5gc\n  annotations:\n    loxilb.io/egress: \"yes\"\n    loxilb.io/probetype: \"none\"\n    loxilb.io/staticIP: \"0.0.0.0\"\nspec:\n  type: LoadBalancer\n  loadBalancerClass: loxilb.io/loxilb\n  selector:\n    app: loxilb-app\n  ports:\n  - name: loxilb-egress\n    port: 9999\n    targetPort: 9999\n    protocol: TCP\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: loxilb-lb-service\n  namespace: free5gc\nspec:\n  clusterIP: None\n  selector:\n    app: loxilb-app\n  ports:\n  - name: loxilb-app\n    port: 11111\n    targetPort: 11111\n    protocol: TCP\n</code></pre> <p>If you look at the annotations, you can see the k8s.v1.cni.cncf.io/networks entry. This is an option to assign the loxilb pod an N2 Multus network interface. The IP addresses are set to 10.100.50.253/29. If you changed the N2 network subnet, you should also change the IP addresses.</p> <p>Deploy loxilb with the following command.</p> <pre><code>kubectl apply -f loxilb.yaml\n</code></pre> <p>You will also need to deploy kube-loxilb. Save the following to a file called kube-loxilb.yaml:</p> <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: kube-loxilb\n  namespace: kube-system\n---\nkind: ClusterRole\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: kube-loxilb\nrules:\n  - apiGroups:\n      - \"\"\n    resources:\n      - nodes\n    verbs:\n      - get\n      - watch\n      - list\n      - patch\n  - apiGroups:\n      - \"\"\n    resources:\n      - pods\n    verbs:\n      - get\n      - watch\n      - list\n      - patch\n  - apiGroups:\n      - \"\"\n    resources:\n      - endpoints\n      - services\n      - namespaces\n      - services/status\n    verbs:\n      - get\n      - watch\n      - list\n      - patch\n      - update\n  - apiGroups:\n      - gateway.networking.k8s.io\n    resources:\n      - gatewayclasses\n      - gatewayclasses/status\n      - gateways\n      - gateways/status\n      - tcproutes\n      - udproutes\n    verbs: [\"get\", \"watch\", \"list\", \"patch\", \"update\"]\n  - apiGroups:\n      - discovery.k8s.io\n    resources:\n      - endpointslices\n    verbs:\n      - get\n      - watch\n      - list\n  - apiGroups:\n      - apiextensions.k8s.io\n    resources:\n      - customresourcedefinitions\n    verbs:\n      - get\n      - watch\n      - list\n  - apiGroups:\n      - authentication.k8s.io\n    resources:\n      - tokenreviews\n    verbs:\n      - create\n  - apiGroups:\n      - authorization.k8s.io\n    resources:\n      - subjectaccessreviews\n    verbs:\n      - create\n  - apiGroups:\n      - bgppeer.loxilb.io\n    resources:\n      - bgppeerservices\n    verbs:\n      - get\n      - watch\n      - list\n      - create\n      - update\n      - delete\n  - apiGroups:\n      - bgppolicydefinedsets.loxilb.io\n    resources:\n      - bgppolicydefinedsetsservices\n    verbs:\n      - get\n      - watch\n      - list\n      - create\n      - update\n      - delete\n  - apiGroups:\n      - bgppolicydefinition.loxilb.io\n    resources:\n      - bgppolicydefinitionservices\n    verbs:\n      - get\n      - watch\n      - list\n      - create\n      - update\n      - delete\n  - apiGroups:\n      - bgppolicyapply.loxilb.io\n    resources:\n      - bgppolicyapplyservices\n    verbs:\n      - get\n      - watch\n      - list\n      - create\n      - update\n      - delete\n  - apiGroups:\n      - loxiurl.loxilb.io\n    resources:\n      - loxiurls\n    verbs:\n      - get\n      - watch\n      - list\n      - create\n      - update\n      - delete\n  - apiGroups:\n      - egress.loxilb.io\n    resources:\n      - egresses\n    verbs: [\"get\", \"watch\", \"list\", \"patch\", \"update\"]\n---\nkind: ClusterRoleBinding\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: kube-loxilb\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: kube-loxilb\nsubjects:\n  - kind: ServiceAccount\n    name: kube-loxilb\n    namespace: kube-system\n---\napiVersion: apps/v1             \nkind: Deployment           \nmetadata:                           \n  name: kube-loxilb                        \n  namespace: kube-system                           \n  labels:                          \n    app: kube-loxilb-app                           \nspec:                             \n  replicas: 1                             \n  selector:                          \n    matchLabels:                      \n      app: kube-loxilb-app                            \n  template:                         \n    metadata:                          \n      labels:                       \n        app: kube-loxilb-app                    \n    spec:                       \n      dnsPolicy: ClusterFirstWithHostNet                         \n      tolerations:                      \n        # Mark the pod as a critical add-on for rescheduling.           \n        - key: CriticalAddonsOnly            \n          operator: Exists                          \n      priorityClassName: system-node-critical                      \n      serviceAccountName: kube-loxilb                       \n      terminationGracePeriodSeconds: 0                    \n      containers:                     \n      - name: kube-loxilb                     \n        image: ghcr.io/loxilb-io/kube-loxilb:latest              \n        imagePullPolicy: Always                      \n        command:                   \n        - /bin/kube-loxilb                \n        args:               \n        - --cidrPools=defaultPool=10.100.50.253/32                   \n        - --setRoles=0.0.0.0\n        - --setLBMode=1\n        resources:             \n          requests:           \n            cpu: \"100m\"\n            memory: \"50Mi\"             \n          limits:              \n            cpu: \"100m\"                \n            memory: \"50Mi\"              \n        securityContext:           \n          privileged: true             \n          capabilities:            \n            add: [\"NET_ADMIN\", \"NET_RAW\"]\n</code></pre> <p>In cidrPools of args, we specified the 10.100.50.253/32 IP address used in loxilb above.</p> <p>Deploy kube-loxilb with the following command.</p> <pre><code>kubectl apply -f kube-loxilb.yaml\n</code></pre> <p>After some time has passed since the deployment was completed, you can see that the external IP Address 10.100.50.253 has been assigned to the AMF service.</p> <pre><code>NAME                                TYPE           CLUSTER-IP       EXTERNAL-IP         PORT(S)            AGE\nfree5gc-helm-free5gc-amf-amf-n2     LoadBalancer   10.152.183.91    llb-10.100.50.253   38412:31412/SCTP   5d2h\n</code></pre>"},{"location":"blog/20250306/20250306/#test","title":"Test","text":"<p>We will deploy ueransim for testing. The free5gc helm package includes ueransim by default. Modify ueransim's values.yaml file for deployment.</p> <pre><code>vi ueransim/values.yaml\n</code></pre> <p>As with free5gc, modify the masterIf for each network to suit your host environment. In this document, we use the enp0s8 interface of the host VM.</p> <pre><code>global:\n  #Global network parametes\n  n2network:\n    enabled: true\n    name: n2network\n    type: ipvlan\n    masterIf: enp0s8\n    subnetIP: 10.100.50.248\n    cidr: 29\n    gatewayIP: 10.100.50.254\n    excludeIP: 10.100.50.254\n  n3network:\n    enabled: true\n    name: n3network\n    type: ipvlan\n    masterIf: enp0s8\n    subnetIP: 10.100.50.232\n    cidr: 29\n    gatewayIP: 10.100.50.238\n    excludeIP: 10.100.50.238\n</code></pre> <p>Then, modify the amf.n2if.ipAddress entry to the external IP of the AMF service.</p> <pre><code>amf:\n    n2if:  # NGAP\n      ipAddress: 10.100.50.253\n</code></pre> <p>Deploy ueransim with the following command:</p> <pre><code>helm install -n free5gc ueransim ./ueransim/\n</code></pre> <p>After that, you need to access the web UI and create a subscriber for UE. To access it, set up port forwarding with the following command.</p> <pre><code>kubectl port-forward svc/webui-service 5000:5000  --address 0.0.0.0\n</code></pre> <p>After that, access the web UI with the URL :5000. In this document, it is 192.168.122.230:5000. <p>When you access the web UI, a login page will appear. The default account is admin:free5gc.</p> <p>After logging in, click the Create button in the SUBSCRIBERS menu and create a UE. (The basic information is already registered.)</p> <p>After that, you can check that the UE is connected in the AMF log, and you can check that it is communicating externally with the following command.</p> <pre><code>kubectl exec -it -n free5gc deployment/ueransim-ue \\\n-- ping -I uesimtun0 8.8.8.8\n</code></pre>"},{"location":"blog/20250306/20250306/#troubleshooting-points","title":"Troubleshooting Points","text":""},{"location":"blog/20250306/20250306/#persistentvolume-issue","title":"PersistentVolume Issue","text":"<p>Sometimes, the pods of free5gc are in a pending state, so when you check the pvc, it mught also be in a pending state. In this case, you need to add the provisionor with the following command.</p> <pre><code>microk8s enable hostpath-storage\n</code></pre> <p>If you still have the same problem, refer to Create Persistent Volume in the free5GC Helm Installation - free5GC document and manually add two PersistentVolumes.</p>"},{"location":"blog/20250306/20250306/#issue-in-using-k3s","title":"Issue in using K3s","text":"<p>Free5GC uses PersistentVolume, and uses ReadOnlyMany for accessModes.</p> <p>Since K3s does not support this mode due to lightweight issues, please test using microk8s recommended in the official documentation.</p> <p>Author(s) - BackGuyn Jung (LoxiLB), William Linn (Free5GC)</p>"},{"location":"blog/20250312/20250312/","title":"SCP introduction","text":"<p>Note</p> <p>Author: Liu-Hsiang Kuan Date: 2025/03/12</p>"},{"location":"blog/20250312/20250312/#introduction-to-service-communication-proxy-scp","title":"Introduction to Service Communication Proxy (SCP)","text":"<p>The Service Communication Proxy (SCP) is a crucial component in the 5G Service-Based Architecture (SBA). It acts as an intermediary for network functions (NFs) to communicate with each other. Unlike direct NF-to-NF communication, the SCP facilitates indirect communication, offering several advantages. </p>"},{"location":"blog/20250312/20250312/#important-mechanism-of-scp-in-5g","title":"Important mechanism of SCP in 5G","text":"<ul> <li> <p>Inter-PLMN communication. The SCP can assist in inter-PLMN(Public Land Mobile Network)settings.</p> </li> <li> <p>Discovery and Routing: An SCP aids in discovering and selecting appropriate NF service producers for NF service consumers. This often involves interacting with the Network Repository Function (NRF). The NRF maintains profiles of available NF instances and their supported services. The SCP uses the NRF to discover other network entities.</p> </li> <li> <p>Routing Mechanisms: The SCP uses routing mechanisms, such as the <code>3gpp-Sbi-Routing-Binding</code> header, to direct service requests to the appropriate HTTP server with the target NF service resource context.</p> </li> <li> <p>Security: The SCP ensures that indirect communication maintains the same level of security as direct communication.</p> </li> </ul>"},{"location":"blog/20250312/20250312/#how-scp-works","title":"How SCP Works","text":"<p>Direct NF Communication (Without SCP)</p> <p></p> <ul> <li>Message Path:<ul> <li>Step 1: NF Consumer (e.g., SMF) sends discovery request directly to NRF.</li> <li>Step 2: NRF returns NF Producer (e.g., NSSF) address.</li> <li>Step 3: SMF communicates directly with NSSF for slice selection.</li> <li>Step 4: NSSF interacts with AMF and PCF through additional NRF lookups.</li> </ul> </li> <li>Challenges:<ul> <li>Repeated NRF queries cause latency and congestion.</li> <li>No traffic prioritization between slice-critical and background messages.</li> <li>Load imbalances if multiple NSSF instances exist.</li> </ul> </li> </ul> <p>SCP-Mediated Communication (With SCP):</p> <p></p> <ul> <li>Message Path:<ul> <li>Step 1: SMF sends request to SCP instead of NRF.</li> <li>Step 2: SCP handles discovery via NRF once, caching results for future requests.</li> <li>Step 3: SCP routes request to optimal NSSF instance based on load, priority, and location.</li> <li>Step 4: SCP mediates AMF/PCF interactions without additional NRF lookups.</li> </ul> </li> </ul> <p>AUSF Example (with SCP):</p> <p></p> <ul> <li>The code defines two REST API endpoints in the AUSF service:<ul> <li>POST /ue-authentications - Initiates the authentication process for a UE (User Equipment)</li> <li>PUT /ue-authentications/:authCtxId/5g-aka-confirmation - Confirms the authentication using 5G-AKA protocol</li> </ul> </li> <li>When using the SCP architecture, all these requests would flow through the Service Communication Proxy rather than going directly to the AUSF.</li> </ul>"},{"location":"blog/20250312/20250312/#what-is-the-benefit-for-scp-communication","title":"What is the benefit for SCP communication","text":"<ol> <li>Simplified Network Topology - Reduces point-to-point connections between services, creating a more maintainable architecture where services only need to know about the SCP rather than all other services.</li> <li>Enhanced Service Management - Provides centralized capabilities for load balancing, service discovery, and traffic management in one place, simplifying operations.</li> <li>Improved Resilience - Creates a more robust system by enabling automatic failover, circuit breaking, and intelligent routing around failures without complex client-side logic.</li> </ol> <p>Actual Example:</p> <ul> <li>A hospital\u2019s ultra-reliable low-latency (URLLC) network slice request competes with a background IoT firmware update. The SCP:<ul> <li>Prioritizes URLLC traffic over IoT.</li> <li>Routes URLLC requests to low-latency edge NSSF instances while directing IoT traffic to centralized NSSFs.</li> <li>Balances load across NSSF clusters during surge requests.</li> </ul> </li> </ul>"},{"location":"blog/20250312/20250312/#scp-design-details","title":"SCP Design Details","text":""},{"location":"blog/20250312/20250312/#essential-http-headers","title":"Essential HTTP Headers","text":"<p>Cruical HTTP headers for SCP operations:</p> <ul> <li>3gpp-Sbi-Routing-Binding: This header contains binding information that ensures message continuity. It helps the SCP route subsequent related requests to the same NF instance that processed the initial request, maintaining session context across multiple transactions.</li> <li>3gpp-Sbi-Target-apiRoot: Specifies the exact destination endpoint URL for the target network function. When an SCP has resolved the appropriate service provider, it includes this header to indicate the selected instance's base URL, enabling precise routing.</li> <li>3gpp-Sbi-Discovery-: A family of headers used for service discovery parameters. They carry criteria like required features, service names, or instance IDs that the SCP uses to find appropriate service providers when the consumer doesn't know the exact target.</li> </ul>"},{"location":"blog/20250312/20250312/#load-and-overload-control","title":"Load and Overload Control","text":"<ul> <li>Load Control: SCPs utilize the <code>3gpp-Sbi-Lci</code> header to convey load metrics across the network. This information allows consuming NFs to make intelligent routing decisions, potentially directing traffic to less loaded instances for better overall system performance.</li> <li>Overload Control: When overload occurs, SCPs use the <code>3gpp-Sbi-Oci</code> header to communicate overload control information, allowing NFs to reduce traffic to the overloaded peer.</li> </ul>"},{"location":"blog/20250312/20250312/#routing-information","title":"Routing Information","text":"<p>The routing mechanism is cruical to SCP. There are some keypoint have to know:</p> <ul> <li>SCP Domains: When an SCP needs to route a message but the destination is in another domain, it consults its domain routing information to determine how to forward the message to the appropriate domain first, rather than trying to reach the final destination directly.</li> </ul> <p></p> <ul> <li>Domain Routing: SCPs leverage the NRF's <code>Nnrf_NFDiscovery</code> service to build and maintain routing tables. This information maps service types and instances to appropriate routes, enabling the SCP to intelligently forward requests.</li> <li>Dynamic Updates: Through subscription mechanisms, SCPs receive real-time notifications about routing changes, service instance health, and network topology updates. This keeps routing information current without requiring constant polling.</li> </ul>"},{"location":"blog/20250312/20250312/#nrf-integration","title":"NRF Integration","text":"<p>The NRF provides essential services for SCP functionality:</p> <ul> <li><code>Nnrf_NFManagement</code>: Handles the registration and lifecycle management of network functions. SCPs use this service to register themselves and to track the availability and capabilities of other network functions.</li> <li><code>Nnrf_NFDiscovery</code>: Enables the SCP to find appropriate service instances based on various selection criteria.</li> </ul> <p>For more details about authentication about NRF, you can refer Authentication Mechanism in NRF: What Is OAuth?</p> <p>In free5gc's implementation, indirect communication mode (routing through the SCP) becomes active only after the SCP successfully registers with the NRF, ensuring the SCP is properly integrated into the network's service discovery framework before handling any service routing.</p>"},{"location":"blog/20250312/20250312/#conclusion","title":"Conclusion","text":"<p>The SCP facilitated communication between network functions by providing service discovery, routing, and security. For the scalability and flexibility of the core network, the Proper configuration and management of SCPs are essential for ensuring network efficiency and flexible. </p>"},{"location":"blog/20250312/20250312/#reference","title":"Reference","text":"<ul> <li>TS 29.500</li> <li>TS 29.510</li> <li>TS 23.502</li> <li>Everything You Need To Know About NRF and SCP in The 5G Core</li> </ul>"},{"location":"blog/20250312/20250312/#about-me","title":"About me","text":"<p>Hi, I'm Liu-hsiang, a telecommunications developer and contributor to the free5GC open-source project. My work focuses on enhancing three critical components of the 5G core: Network Data Analytics Function (NWDAF) for intelligent network optimization, Network Repository Function (NRF) for service discovery and registration, and Charging Function (CHF) for flexible monetization models. I'm particularly interested in how these components can work together to create more adaptive, efficient 5G networks. If you're working in similar areas or have thoughts on advancing these technologies, I'd love to connect and exchange ideas!</p>"},{"location":"blog/20250312/20250312/#connect-with-me","title":"Connect with me","text":"<ul> <li>GitHub</li> <li>LinkedIn</li> </ul>"},{"location":"blog/20250319/20250319/","title":"Introduction of 5G Roaming","text":"<p>Note</p> <p>Author: Yung-Hsuan, Tsao Date: 2025/03/19</p>"},{"location":"blog/20250319/20250319/#introduction","title":"Introduction","text":"<p>As 5G networks expand globally, the way users stay connected while traveling is evolving. Roaming ensures subscribers can seamlessly access calls, messaging, and mobile data across different networks or countries.</p> <p>It allows a User Equipment (UE) to access services while outside its Home Public Land Mobile Network (HPLMN) by connecting to a Visited PLMN (VPLMN).</p>"},{"location":"blog/20250319/20250319/#roaming-procedure","title":"Roaming Procedure","text":""},{"location":"blog/20250319/20250319/#1-ue-registration-in-the-visited-plmn-vplmn","title":"1. UE Registration in the Visited PLMN (VPLMN)","text":"<p>When the UE powers on in a roaming area, it scans for available PLMNs and selects the VPLMN based on roaming agreements. Then, the UE sends a registration request to the V-AMF (Access and Mobility Function in VPLMN), which checks the PLMN ID and detects that the UE is roaming.</p>"},{"location":"blog/20250319/20250319/#2-authentication-and-security-procedures","title":"2. Authentication and Security Procedures","text":"<p>Since the UE is unfamiliar with the VPLMN, authentication must happen through the HPLMN. V-AMF contacts the AUSF (Authentication Server Function) in the HPLMN through SEPP (Security Edge Protection Proxy), which ensures secure inter-PLMN signaling. The AUSF verifies the UE's credentials, and if successful, V-AMF will proceed with security procedures.</p>"},{"location":"blog/20250319/20250319/#3-smf-selection","title":"3. SMF Selection","text":"<p>Once authentication is complete, the UE needs a PDU session to access the data. The UE sends a PDU session establishment request to V-AMF, and it selects available SMFs based on the requested DNN and routing approach.</p> <p>In 5G roaming, there are two ways of routing user data: Home-Routed (HR) and Local Breakout (LBO). They determine how a UE's traffic is forwarded when it connects to a visited network (VPLMN).</p> <p>Home-Routed Roaming (HR)</p> <p>Home-Routed Roaming returns all user data traffic to HPLMN before reaching the internet or other services. This means that:</p> <ul> <li>An H-SMF is selected in step 3, and a PDU session is established with H-UPF. Both SMF and UPF (User Plane Function) remain in the HPLMN.</li> <li>The VPLMN only provides radio access and mobility management (AMF).</li> </ul> <p>In this case, data follows a longer path, which increases latency and allows the HPLMN to retain full control over security, billing, and policies.  Enterprise users who need secure connections and sensitive data applications that require strict compliance are preferred to use this kind of routing method.</p> <p></p> <p>There are two options for SMF selection in an HR scenario:</p> <p>(1) SMF Discovery via NSSF</p> <p>In an HR roaming scenario, the SMF selection involves interactions between VPLMN and HPLMN. If V-AMF does not have prior knowledge of the appropriate NRF (Network Repository Function) to use in the HPLMN, a series of steps are followed to facilitate the network function selection.</p> <p></p> <ul> <li>[1] AMF requests slicing information from VPLMN NSSF (vNSSF).</li> <li>[2]-[3] If the vNSSF does not have pre-existing slicing configuration information for the requested HPLMN S-NSSAI, it forwards the request to the HPLMN NSSF (hNSSF).</li> <li>[4] The vNSSF includes all received details from the hNSSF in its response to the AMF.</li> <li>[5] AMF initiates NF discovery via vNRF. Network Function (NF) Discovery is a fundamental procedure in the 5G core that enables a network function to find and communicate with other required NFs dynamically. </li> <li>[6] The vNRF contacts hNRF for SMF discovery.</li> <li>[7]-[8] The hNRF provides SMF information and responds to AMF.</li> </ul> <p>(2) Direct SMF Discovery</p> <p>When the NSSF is not deployed in the HPLMN, V-AMF must still determine the correct NRF in HPLMN for NF discovery.</p> <p></p> <ul> <li>[1]-[2] AMF queries vNRF and forwards the request to hNRF. If the AMF does not provide hNRF, the vNRF determines the hNRF using its own configuration. The vNRF then sends an NF Discovery request to the hNRF in HPLMN.</li> </ul> <p>Depending on the available information and based on configuration, the hNRF may either execute steps in [3A] or in [3B]. </p> <ul> <li>[3A] Directly response from hNRF.</li> <li>[3B] The hNRF queries another local NRF in HPLMN, and then the hNRF relays this information back to the AMF via the vNRF.</li> </ul> <p>Local Breakout (LBO)</p> <p>In Local Breakout (LBO), the user\u2019s data traffic is directly routed through the VPLMN instead of being sent back to the HPLMN. Then:</p> <ul> <li>Step 3 selects a V-SMF, and the PDU session is established with V-UPF. Both SMF and UPF are located in the VPLMN.</li> <li>The VPLMN handles both control and user plane traffic.</li> </ul> <p>Under this condition, data follows a shorter path, reducing latency and improving performance, which is suitable for latency-sensitive applications (e.g., gaming, video calls, streaming) or mobile operators since it can reduce operational costs.</p> <p></p> <p>In an LBO scenario, VPLMN is responsible for selecting the SMF, which means user data does not traverse back to the home network. Instead, it is locally routed via the VPLMN\u2019s User Plane Function (UPF) to external networks.</p> <p></p> <ul> <li>[1]-[2] V-AMF queries NSSF for slice selection, and NSSF responds with slice selection details.</li> <li>[3] The AMF sends a discovery request to the NRF to find an appropriate SMF within the visited network.</li> <li>[4] The NRF responds with available SMFs, and the AMF selects the most suitable one for the PDU session. </li> </ul> <p>Home-Routed vs. Local Breakout</p> <p>Following is a simple comparison of two routing approaches:</p> Feature Home-Routed Local Breakout Data Routing HPLMN UPF VPLMN UPF SMF/UPF Location HPLMN VPLMN Latency High Low Security More Secure Less Secure"},{"location":"blog/20250319/20250319/#4-pdu-session-establishment","title":"4. PDU Session Establishment","text":"<p>After selecting SMF, the PDU session establishment process starts.</p> <p>Home-Routed Roaming</p> <p></p> <ul> <li>[3]-[5] V-SMF selects a UPF in VPLMN to handle initial traffic management before forwarding the request to H-SMF.</li> <li>[6]-[7] H-SMF receives the request from V-SMF.</li> <li>[8]-[9] H-PCF applies policy rules, then H-SMF authorizes the session and proceeds with session establishment.</li> <li>[10] H-SMF selects a UPF in HPLMN for traffic routing. The H-UPF will act as the anchor point for this PDU session.</li> <li>[13] H-SMF sends the response to V-SMF.</li> <li>[14]-[17] AMF sends a message to UE, confirming the established session.</li> </ul> <p>In the user plane, the UE starts sending uplink data. The data is sent to V-UPF and tunneled to H-UPF, which routes the traffic to the data network. Downlink data follows the same path in reverse.</p> <p>Local Breakout</p> <p></p> <ul> <li>[3]-[5] The selected V-SMF creates a session context and selects a local UPF. This UPF will serve as the PDU session anchor, handling the UE's data traffic locally rather than tunneling back to HPLMN.</li> <li>[6] The SMF communicates with V-PCF policy enforcement and UDM in HPLMN to verify user subscription data.</li> <li>[12]-[14] Once authentication is complete, the SMF sends a Session Establishment Accept message to the AMF. The AMF forwards the NAS message (PDU Session Establishment Accept) to the UE via RAN.</li> </ul> <p>V-UPF establishes an N3 tunnel with the RAN to enable user-plane data transfer. The UE can now send and receive data via the UPF in VPLMN. Data is routed locally within the visited network without involving the home network.</p>"},{"location":"blog/20250319/20250319/#conclusion","title":"Conclusion","text":"<p>As 5G networks continue to expand, roaming plays a crucial role in enabling seamless connectivity for users traveling outside their home networks. In this article, two primary roaming approaches Home-Routed (HR) and Local Breakout (LBO) are introduced, offering different trade-offs in terms of latency, security, and operational costs. With the continued evolution of network slicing, edge computing, and AI-driven network optimization, 5G roaming will become even more flexible, efficient, and user-centric in the future.</p>"},{"location":"blog/20250319/20250319/#reference","title":"Reference","text":"<ul> <li>5G Roaming: Everything You Need to Know</li> <li>ts 23.501: 4.2.4 Roaming reference architectures</li> <li>ts 23.502</li> </ul>"},{"location":"blog/20250319/20250319/#about","title":"About","text":"<p>Hi, I'm Yung-Hsuan!  A newcomer to 5G and the free5GC community. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20250319/20250319/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: https://github.com/reki9185</li> </ul>"},{"location":"blog/20250416/20250416/","title":"Optimizing free5GC Through Local UE Traffic and Dedicated UPF: A Multi-Node Helm Deployment Approach","text":"<p>Note</p> <p>Author: Fang-Kai Ting Date: 2025/04/16</p> <p>This guide walks through the steps for deploying and end-to-end testing the free5GC-Helm project. It demonstrates the deployment of two nodes (Core and UPF) within a single Kubernetes cluster, along with a locally deployed UE used for ping-based connectivity testing.</p>"},{"location":"blog/20250416/20250416/#architecture","title":"Architecture","text":"<p>Using a local UE, as opposed to deploying the UE and RAN together with the UPF on the same node via Helm, offers greater stability and consistency when establishing PDU sessions.</p> <p>The architecture is as follows:</p> <ol> <li>The control plane of the 5G core and the MongoDB database are deployed on the vm1 node.</li> <li>The user plane (UPF) is deployed on the vm2 node within the same Kubernetes cluster.</li> <li> <p>The UE (User Equipment) and gNodeB simulator, UERANSIM, are deployed locally on a separate vm3 node.</p> <p></p> </li> </ol> <p>The specifications for each virtualbox VM shown below:</p> vm name CPU RAM Network Adapter 1 (enp0s3) Network Adapter 2 (enp0s8) OS vm1(free5GC control plane) ns 8 16G NAT(10.0.2.15) Host-only(192.168.56.119) Ubuntu 20.04 LTS vm2(free5GC UPF pod) ns2 8 16G NAT(10.0.2.15) Host-only(192.168.56.120) Ubuntu 20.04 LTS vm3(UE + gNB) ns3 8 16G NAT(10.0.2.15) Host-only(192.168.56.118) Ubuntu 20.04 LTS"},{"location":"blog/20250416/20250416/#cluster-nodes-setupvm1-vm2","title":"Cluster nodes setup(VM1, VM2)","text":""},{"location":"blog/20250416/20250416/#gtp5g-install","title":"gtp5g install","text":"<pre><code>git clone https://github.com/free5gc/gtp5g.git\ncd gtp5g\nbash &lt;&lt;EOF\nsudo apt -y update\nsudo apt -y install gcc g++ cmake autoconf libtool pkg-config libmnl-dev libyaml-dev\nmake clean &amp;&amp; make\nsudo make install\nEOF\n</code></pre>"},{"location":"blog/20250416/20250416/#microk8s-install-setup","title":"Microk8s install &amp; setup","text":"<p>MicroK8s is used with containerd as the container runtime. MicroK8s automatically installs containerd during its setup. For installation instructions, refer to MicroK8s - Get started</p> <p>All VMs are configured within the CIDR range 192.168.56.0/24, using the enp0s3 network adapter for internet access.</p> <pre><code>sudo snap install microk8s --classic --channel=1.32\nsudo vim ~/.bash_aliases\nalias kubectl='microk8s kubectl'\nsudo usermod -a -G microk8s $USER\nmkdir -p ~/.kube\nchmod 0700 ~/.kube\nsu - $USER\n\nbash &lt;&lt;EOF\nmicrok8s config &gt; .kube/config\nmicrok8s status --wait-ready\nmicrok8s kubectl get nodes\nmicrok8s enable dns\nmicrok8s enable hostpath-storage\nEOF\n</code></pre>"},{"location":"blog/20250416/20250416/#k8s-configuration","title":"k8s configuration","text":"<ul> <li> <p>VM ipv4 forwarding</p> <pre><code>cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-iptables  = 1\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.ipv4.ip_forward                 = 1\nEOF\n</code></pre> </li> </ul> <p>Add below in <code>/var/snap/microk8s/current/args/kubelet</code></p> <ol> <li> <p>The default internal IP for each node is 10.0.2.15, which can hinder inter-node communication. To ensure proper connectivity, update the internal IPs accordingly\u2014for example: vm1 = 192.168.56.119, vm2 = 192.168.56.120.</p> <pre><code>--node-ip=&lt;host-only ip&gt;\n</code></pre> </li> <li> <p>Ipv4 forwarding</p> <pre><code>--allowed-unsafe-sysctls \"net.ipv4.ip_forward\"\n</code></pre> </li> </ol>"},{"location":"blog/20250416/20250416/#cni-plugin-configuration","title":"CNI Plugin Configuration","text":"<p>MicroK8s clusters use the\u00a0Calico CNI\u00a0by default</p> <ul> <li>To enable IP forwarding on UPF, Calico CNI needs some necessary configurations.</li> <li>Some CNI plugin, like Flannel, kube-ovn, allow this funtionality by default</li> <li> <p>Setup Calico CNI for IP Forwarding</p> <ol> <li> <p><code>/var/snap/microk8s/current/args/cni-network/cni.yaml</code></p> <pre><code>kind: ConfigMap\ndata:\n    cni_network_config: |-\n        {\n            # ...\n            \"plugins\": [\n                {\n                    # Append IP forwarding settings\n                    \"container_settings\": {\n                        \"allow_ip_forwarding\": true\n                    },\n                }\n            ]\n        }\n</code></pre> <ul> <li>Refer to the\u00a0Calico CNI Docs<ol> <li>Apply settings</li> </ol> </li> </ul> <p><code>kubectl apply -f /var/snap/microk8s/current/args/cni-network/cni.yaml</code></p> </li> <li> <p>Restart MicroK8s</p> <p><code>sudo microk8s stop &amp;&amp; sudo microk8s start</code></p> </li> </ol> </li> </ul>"},{"location":"blog/20250416/20250416/#multus","title":"Multus","text":"<p>Multus is a CNI (Container Network Interface) plugin for Kubernetes that enables pods to have multiple network interfaces. A clear example of this is the UPF, which has the N3, N4, N6 interfaces and optionally the N9. Multus has the capability to \u201ccall\u201d other CNI plugins for this purpose.</p> <pre><code>kubectl apply -f [https://raw.githubusercontent.com/k8snetworkplumbingwg/multus-cni/master/deployments/multus-daemonset.yml](https://raw.githubusercontent.com/k8snetworkplumbingwg/multus-cni/master/deployments/multus-daemonset.yml)\n</code></pre>"},{"location":"blog/20250416/20250416/#multi-node-microk8s-setup","title":"Multi-node microk8s setup","text":"<p>After completing the above MicroK8s configuration, the two nodes can be joined into a single cluster using the following command: MicroK8s - Create a MicroK8s cluster</p> <ul> <li>vm1:  <code>microk8s add-node</code><ul> <li>output example: <code>microk8s join 192.168.56.119:25000/92b2db236428470dc4fcfc4ebbd9dc81/2c0cb5284b05</code></li> </ul> </li> <li>vm2:<ul> <li>paste output(\u2014worker is optional)</li> </ul> </li> </ul> <p>Result:</p> <p></p>"},{"location":"blog/20250416/20250416/#helm","title":"Helm","text":"<p>Helm is a package manager for Kubernetes that simplifies the deployment and management of applications. It uses Helm charts, which are pre-configured templates that define Kubernetes resources like pods, services, and deployments. Helm enables developers and operators to install, upgrade, or roll back applications with a single command, making Kubernetes workflows more efficient and reproducible. It supports versioning and configuration overrides, allowing teams to maintain consistency across environments. Helm is often compared to tools like apt or yum, but for Kubernetes, making it an essential tool for managing complex, cloud-native applications at scale.</p>"},{"location":"blog/20250416/20250416/#install","title":"Install","text":"<pre><code>bash &lt;&lt;EOF\ncurl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3\nchmod 700 get_helm.sh\n./get_helm.sh\nEOF\n</code></pre>"},{"location":"blog/20250416/20250416/#configuration","title":"Configuration","text":"<p>For a multi-cluster deployment with the UE/gNB hosted on a separate VM, the following modifications should be applied to the <code>values.yaml</code> files of each chart:</p> <ul> <li>Ref: towards5gs-helm/charts/free5gc at main \u00b7 Orange-OpenSource/towards5gs-helm</li> <li>To check where modifications were made in my Git commit<ul> <li>https://github.com/qawl987/free5gc-helm/commit/d40101d58e51a26e1c0acef3883d598528e718f1</li> </ul> </li> </ul> <p>Each NF has its own <code>values.yaml</code> file along with a shared global values.yaml; ensure that changes are applied to both configuration files.</p> <ul> <li>Ex: <code>free5gc-helm/charts/free5gc/values.yaml</code> and <code>free5gc-helm/charts/free5gc/charts/free5gc-amf/values.yaml</code> \u2026</li> </ul> <p>Notice:</p> <ol> <li>The UPF N3 interface is the most challenging aspect. Since the UE sends packets only to port 2152, the NodePort method is not suitable, and LoadBalancer is designed for HTTP, not UDP traffic. The simplest solution is to configure the UPF's N3 interface to use the host-only subnet, allowing the UE to send packets directly to the N3 interface via that subnet. Alternatively, you can modify only the SMF to advertise the gNB N3 interface as the VM2 host-only IP and use a kube-proxy service to forward packets to the pod IP. This can also be addressed using MACVLAN or IPVLAN CNI plugins to bridge the UPF pod directly onto the host network.For detailed configuration and result, refer to the appendix.</li> <li>We demonstrate the UPF ULCL configuration here; for a single UPF setup, refer to the section above.</li> </ol> NF parameter current value new value AMF global.n2network.masterIf eth0 enp0s8 AMF global.amf.service.ngap.enabled false true SMF global.n4network.masterIf eth0 enp0s8 SMF interfaceType: N3 endpoints 10.100.50.233 192.168.56.19 UPF global.n4network.masterIf eth0 enp0s8 UPF global.n3network.masterIf eth0 enp0s8 UPF global.n3network.subnetIP 10.100.50.232 192.168.56.0 UPF global.n3network.cidr 29 24 UPF global.n3network.gatewayIP 10.100.50.238 empty UPF global.n3network.excludeIP 10.100.50.238 192.168.56.254 UPF global.n6network.masterIf eth1 enp0s3 UPF global.n6network.subnetIP 10.100.100.0 10.0.2.0 UPF global.n6network.gatewayIP 10.100.100.1 10.0.2.2 UPF global.n6network.excludeIP 10.100.100.254 10.0.2.254 UPF global.n9network.masterIf eth0 enp0s8 UPF upf1.n6if.ipAddress 10.100.100.13 10.0.2.13 UPF upf2.n6if.ipAddress 10.100.100.14 10.0.2.14 UPF upfb.n3if.ipAddress 10.100.50.233 192.168.56.19 UPF upfb.n6if.ipAddress 10.100.100.12 10.0.2.15 ulcl-enabled-values.yaml N3 endpoints 10.100.50.233 192.168.56.19"},{"location":"blog/20250416/20250416/#persistent-volume-for-mongodb","title":"Persistent Volume for mongoDB","text":"<p>A Persistent Volume (PV) in Kubernetes is a storage resource provisioned independently of pods, enabling data persistence across pod restarts. It decouples storage from containers for stable, reusable storage.</p> <pre><code>apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: free5gc-pv-mongo\n  labels:\n    project: free5gc\nspec:\n  capacity:\n    storage: 8Gi\n  accessModes:\n  - ReadWriteOnce\n  persistentVolumeReclaimPolicy: Retain\n  local:\n    path: /home/vagrant/kubedata\n  nodeAffinity:\n    required:\n      nodeSelectorTerms:\n      - matchExpressions:\n        - key: kubernetes.io/hostname\n          operator: In\n          values:\n          # modify value to your hostname\n          - ns\n</code></pre>"},{"location":"blog/20250416/20250416/#persistent-volume-claim-for-mongodb","title":"Persistent Volume Claim for mongoDB","text":"<p>A Persistent Volume Claim (PVC) in Kubernetes is a user\u2019s request for storage, specifying size and access mode. It binds to a Persistent Volume, enabling pods to use persistent storage seamlessly.</p> <pre><code>apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: free5gc-pv-cert\n  labels:\n    project: free5gc  # Must match the selector in PVC\nspec:\n  capacity:\n    storage: 1Mi  # Must match the PVC request exactly\n  accessModes:\n    - ReadOnlyMany  # Must match the PVC access mode\n  persistentVolumeReclaimPolicy: Retain\n  local:\n    path: /home/vagrant/certdata  # Ensure this directory exists on the correct node\n  volumeMode: Filesystem\n  nodeAffinity:\n    required:\n      nodeSelectorTerms:\n        - matchExpressions:\n            - key: kubernetes.io/hostname\n              operator: In\n              values:\n                - ns  # Ensure this is the correct node name\n</code></pre>"},{"location":"blog/20250416/20250416/#multi-node-configuration","title":"Multi-node configuration","text":"<p>Change the nodeSelector field in each NF's values.yaml file. For example, update the UPF nodeSelector to correspond to ns2, and set the nodeSelector for other NFs to ns</p> <pre><code>Before\nnodeSelecotr: {}\nAfter\nnodeSelector:\n  # your desired node's host name\n  kubernetes.io/hostname: ns\n</code></pre>"},{"location":"blog/20250416/20250416/#run","title":"Run","text":"<p>After above configuration, we can build core and upf now.</p> <ol> <li> <p>Run Core &amp; UPF</p> <pre><code>kubectl create ns free5gc\nkubectl apply -f persistent-vol-for-mongodb.yaml\nkubectl apply -f persistent-vol-for-cert.yaml\nhelm -n free5gc install free5gc-v1 ./free5gc/\n</code></pre> <p></p> </li> <li> <p>Check NF deployment node</p> <ol> <li> <p>UPF in ns2</p> <p></p> </li> <li> <p>Other NF in ns</p> <p></p> </li> </ol> </li> <li> <p>Test the UPF forwarding by checking the output, which should be \"1\". If the output is different, ensure that the CNI and OS <code>ipv4_forwarding</code> configurations are correctly set.You can also refer to the appendix, under the Security Pod section, for more details.</p> <pre><code>kubectl exec -it -n free5gc &lt;upf-pod-name-above&gt; \\\n-- cat /proc/sys/net/ipv4/ip_forward\n</code></pre> </li> <li> <p>Check UPF N4 connection</p> <pre><code>kubectl logs &lt;upf-pod-name&gt; -n free5gc\n</code></pre> <p></p> </li> </ol>"},{"location":"blog/20250416/20250416/#local-ue-vm3-deployment","title":"Local UE VM3 deployment","text":""},{"location":"blog/20250416/20250416/#install-ueransim","title":"Install UERANSIM","text":"<p>https://github.com/aligungr/UERANSIM</p> <pre><code>cd UERANSIM\nbash &lt;&lt;EOF\nsudo apt install make -y\nsudo apt install gcc -y\nsudo apt install g++ -y \nsudo apt install libsctp-dev lksctp-tools -y\nsudo apt install iproute2 -y\nsudo snap install cmake --classic\nEOF\n# Be sure to use snap install cmake --classic for suitable cmake version\nmake\n</code></pre>"},{"location":"blog/20250416/20250416/#amf-service-expose","title":"AMF service expose","text":"<p>free5GC has the AMF N2 service configured as a <code>ClusterIP</code> by default, which prevents direct access to the pod on port 38412. To allow the local UE to connect, you need to change the service type to <code>NodePort</code>.</p> <pre><code>kubectl patch svc free5gc-v1-free5gc-amf-amf-n2 -n free5gc -p '{\"spec\": {\"type\": \"NodePort\"}}'\n</code></pre> <p>You can see 31412 is the port exposed.</p> <p></p>"},{"location":"blog/20250416/20250416/#configuration_1","title":"Configuration","text":"<p><code>UERANSIM/config/free5gc-gnb.yaml</code></p> current value new value notes ngapIp 127.0.0.1 192.168.56.118 VM3 host-only ip gtpIP 127.0.0.1 192.168.56.118 VM3 host-only ip amfConfig.address 127.0.0.1 192.168.56.119 VM1 host-only ip amfConfig.port 38412 31412 above exposed port"},{"location":"blog/20250416/20250416/#end-to-end-test","title":"End-to-end test","text":"<ol> <li> <p>Subscribe UE in webconsole</p> <ol> <li> <p>In VM1, expose the service for subscription</p> <pre><code>kubectl port-forward --address 192.168.56.119 --namespace free5gc svc/webui-service 5000:5000\n</code></pre> </li> <li> <p>Login to 192.168.56.119:5000 using the credentials (admin, free5gc), and create a subscriber using the default settings.</p> <p></p> </li> </ol> </li> <li> <p>You need three terminal</p> <ol> <li> <p>terminal 1: create gNB</p> <pre><code>./build/nr-gnb -c config/free5gc-gnb.yaml\n</code></pre> <p></p> </li> <li> <p>terminal 2: create UE</p> <pre><code>sudo ./build/nr-ue -c config/free5gc-ue.yaml\n</code></pre> <p></p> </li> <li> <p>terminal 3: ping test</p> <p></p> </li> </ol> </li> <li> <p>Check</p> <ol> <li> <p>In the UPF pod, install <code>tcpdump</code> (ensure a nameserver is configured, as the current UPF pod lacks DNS resolution).</p> <pre><code>echo \"nameserver 8.8.8.8\" &gt;&gt; /etc/resolv.conf &amp; apt install tcpdump -y\n</code></pre> <ol> <li> <p>N3 if</p> <p></p> </li> <li> <p>N9 if</p> <p></p> </li> </ol> </li> <li> <p>In upf1, install tcpdump too</p> <ol> <li> <p>N6 if</p> <p></p> </li> <li> <p>upfgtp</p> <p></p> </li> </ol> </li> </ol> </li> </ol>"},{"location":"blog/20250416/20250416/#appendix","title":"Appendix","text":""},{"location":"blog/20250416/20250416/#clusterip-service-kube-proxy","title":"ClusterIP service &amp; kube-proxy","text":"<p>I attempted to use a <code>ClusterIP</code> service with kube-proxy to forward UE packets from the VM2 host-only IP to the UPF pod IP, but the packets are being lost after being forwarded to the pod IP. This issue remains unresolved.</p> <ol> <li> <p>kube-proxy service</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: free5gc-upf-n3-externalip-service\n  namespace: free5gc\nspec:\n  type: ClusterIP\n  selector:\n    app.kubernetes.io/instance: free5gc-v1\n    app.kubernetes.io/name: free5gc-upf\n    nf: upfb\n    project: free5gc\n  ports:\n    - name: n3-gtpu\n      protocol: UDP\n      port: 2152          # Service \u5728\u53e2\u96c6\u5167\u90e8\u4ee5\u53ca\u5916\u90e8\u76e3\u807d\u7684\u57e0\n      targetPort: 2152    # UPF Pod \u5bb9\u5668\u5be6\u969b\u76e3\u807d\u7684 GTP-U \u57e0\n  externalIPs:\n    - 192.168.56.120     # \u6307\u5b9a Service \u76e3\u807d vm2 \u7684 IP \u5730\u5740\n</code></pre> </li> <li> <p>add --masquerade-all=true in <code>/var/snap/microk8s/current/args/kube-proxy</code></p> </li> </ol> <p>Can see src=10.1.4.159, mean flow-in DNAT success, but something went wrong after packet go inside upfb pod.</p> <p></p>"},{"location":"blog/20250416/20250416/#local-registry","title":"Local registry","text":"<p>Docker Hub may throttle the UPF pod due to excessive image pull requests (affecting only the UPF pod, for reasons unclear). To avoid this, set up a local registry and use a locally built UPF image.</p> <pre><code>sudo microk8s enable registry\ndocker pull free5gc/upf:v4.0.0\ndocker tag free5gc/upf:v4.0.0 localhost:32000/free5gc/upf:v4.0.0\ndocker push localhost:32000/free5gc/upf:v4.0.0\n</code></pre> <p>Update all UPF image names from <code>name: localhost:32000/free5gc/upf</code> to <code>name: free5gc/upf</code>. You can also refer to my Git commit for further details.  - https://github.com/qawl987/free5gc-helm/commit/7d82f68060596954cc0139f5a5a160f235e53f3a</p>"},{"location":"blog/20250416/20250416/#security-pod","title":"Security pod","text":"<p>Some VMs require the following additional setting for UPF. If you've already configured all <code>ipv4_forwarding</code> options, add the configuration below to all UPF pods as well.</p> <pre><code>free5gc-upf:\n  upf1:\n    podSecurityContext:\n      sysctls:\n        - name: net.ipv4.ip_forward\n          value: \"1\"\n</code></pre>"},{"location":"blog/20250416/20250416/#conclusion","title":"Conclusion","text":"<p>This guide walks through the steps for deploying and end-to-end testing the free5GC-Helm project. It demonstrates the deployment of two nodes (Core and UPF) within a single Kubernetes cluster, along with a locally deployed UE used for ping-based connectivity testing.</p>"},{"location":"blog/20250416/20250416/#reference","title":"Reference","text":"<p>From Theory to Practice: Implementing a 5G Core Network Using Open Source Tools | by Danilo Granados | Medium</p> <p>free5GC Helm Installation - free5GC</p> <p>https://github.com/Orange-OpenSource/towards5gs-helm/tree/main/charts/free5gc#networks-configuration</p>"},{"location":"blog/20250416/20250416/#about-me","title":"About me","text":"<p>Hi, I\u2019m Fang-Kai Ting, a newcomer to 5G and free5GC, and currently conducting research on Network Slicing. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20250416/20250416/#connect-with-me","title":"Connect with Me","text":"<p>Github:\u00a0qawl987</p>"},{"location":"blog/20250419/20250419/","title":"Unit test in free5GC's Network Function","text":"<p>In the Go programming language, testing is an essential part of writing reliable and maintainable software. Go provides a built-in tool called go test that makes it easy to write and run automated tests. This tool helps developers ensure that their code behaves as expected, catch bugs early, and make future changes with confidence.</p>"},{"location":"blog/20250419/20250419/#i-how-to-write-a-go-test-program","title":"I. How to write a Go test program","text":"<p>Here's a quick breakdown:</p> <ol> <li>Test files: Named with <code>_test.go</code> suffix (e.g., <code>math_test.go</code>)</li> <li>Test functions: Start with <code>Test</code> and take a <code>*testing.T</code> as a parameter (e.g., <code>func TestAdd(t *testing.T)</code>)</li> <li>Command: Execute <code>go test</code>. (e.g., <code>go test math_test.go</code>)</li> </ol>"},{"location":"blog/20250419/20250419/#example","title":"Example","text":"<p>math.go <pre><code>package math\n\nfunc Add(a, b int) int {\n    return a + b\n}\n</code></pre></p> <p>math_test.go <pre><code>package math\n\nimport \"testing\"\n\nfunc TestAdd(t *testing.T) {\n    result := Add(2, 3)\n    if result != 5 {\n        t.Errorf(\"Expected 5, but got %d\", result)\n    }\n}\n</code></pre></p> <p>Then you'd run:</p> <pre><code>go test\n</code></pre> <p>And you'll see output like:</p> <pre><code>PASS\nok      your/module/path    0.001s\n</code></pre>"},{"location":"blog/20250419/20250419/#flags-you-might-use","title":"Flags you might use:","text":"<ul> <li><code>go test -v</code>: Verbose output</li> <li><code>go test ./...</code>: Test all packages recursively</li> <li><code>go test -cover</code>: Show code coverage</li> <li><code>go test -run=TestAdd</code>: Run only a specific test</li> <li><code>go test -count=1</code>: Run the test again without test-cache, in order to run the test without getting the old result cache.</li> <li><code>go test -race</code>: Run the test with a built-in Data Race Detector.</li> <li><code>go test -p &lt;n&gt;</code>: Specify the number <code>&lt;n&gt;</code> of programs that can be run in parallel.</li> </ul>"},{"location":"blog/20250419/20250419/#ii-test-example-in-amf-create-ue-context","title":"II. Test Example in AMF: Create UE Context","text":"<ul> <li>Purpose: Verify that the AMF\u2019s SBI\u2010processor correctly handles a UE Context creation request that includes a binary NGAP \u201cHandover Required\u201d message.</li> <li>Key Techniques:</li> <li>Dependency injection of config and context (<code>initAMFConfig</code>).</li> <li>Mocking the AMF app interface with GoMock to intercept service calls.</li> <li>Using Gin\u2019s testing utilities (<code>httptest.NewRecorder()</code>, <code>gin.CreateTestContext</code>) to simulate HTTP requests.</li> <li>Testify for concise assertions.</li> </ul> <p>Here\u2019s a breakdown of what\u2019s happening in createUeContext_test.go:</p>"},{"location":"blog/20250419/20250419/#1-test-setup-and-configuration","title":"1. Test Setup and Configuration","text":"<pre><code>var testConfig = factory.Config{ \u2026 }\nfunc initAMFConfig() {\n    factory.AmfConfig = &amp;testConfig\n    amfContext := amf_context.GetSelf()\n    amf_context.InitAmfContext(amfContext)\n}\n</code></pre> <ul> <li><code>testConfig</code> defines an in\u2011memory AMF configuration (copied from <code>amfcfg.yaml</code>) with PLMN IDs, supported slices, timers, NGAP/SBI endpoints, etc.</li> <li><code>initAMFConfig()</code> injects this config into the global <code>factory.AmfConfig</code> and initializes the AMF context so that all subsequent calls see a fully\u2011formed AMF state.</li> </ul>"},{"location":"blog/20250419/20250419/#2-constructing-the-createuecontextrequest","title":"2. Constructing the CreateUeContextRequest","text":"<pre><code>CreateUeContextRequest := models.CreateUeContextRequest{\n    JsonData: &amp;models.UeContextCreateData{ \u2026 },\n    BinaryDataN2Information: buildHandoverRequiredNGAPBinaryData(),\n}\n</code></pre> <ul> <li><code>JsonData</code> holds the UE\u2019s SUPI, security capabilities, target RAN node ID, TAI, and a placeholder pointing to the binary N2 info (<code>Content\u2011Id: N2SmInfo</code>).  </li> <li><code>BinaryDataN2Information</code> carries the actual NGAP handover\u2010required message as bytes, generated by  <code>buildHandoverRequiredTransfer()</code>, <code>buildSourceToTargetTransparentTransfer(targetGNBID, targetCellID)</code>, and <code>buildHandoverRequiredNGAPBinaryData()</code>.</li> </ul>"},{"location":"blog/20250419/20250419/#3-the-core-test-testhandlecreateuecontextrequest","title":"3. The Core Test: <code>TestHandleCreateUEContextRequest</code>","text":"<pre><code>func TestHandleCreateUEContextRequest(t *testing.T) {\n    openapi.InterceptH2CClient()\n    defer openapi.RestoreH2CClient()\n    initAMFConfig()\n</code></pre> <ul> <li><code>openapi.InterceptH2CClient()</code> swaps in a testing HTTP client so that when the processor makes SBI (Service-Based Interface) calls, they go through the mock rather than real network.</li> <li>We call <code>initAMFConfig()</code> to ensure AMF context is ready.</li> </ul>"},{"location":"blog/20250419/20250419/#3a-test-cases","title":"3a. Test Cases","text":"<pre><code>testCases := []struct {\n    testDescription   string\n    resultDescription string\n    request           models.CreateUeContextRequest\n    responseBody      any\n    expectedHTTPResp  *httpwrapper.Response\n}{\n    {\n        testDescription: \"Valid Request\",\n        resultDescription: \"\",\n        request:         CreateUeContextRequest,\n        responseBody:      &amp;models.CreateUeContextResponse201{},\n        expectedHTTPResp: &amp;httpwrapper.Response{\n            Status: http.StatusCreated,\n            Body: models.CreateUeContextResponse201{ \u2026 },\n        },\n    },\n}\n</code></pre> <ul> <li>Only one case: a valid request should produce HTTP 201 Created and return a minimal <code>CreateUeContextResponse201</code> with the same SUPI and PDU session list.</li> <li>Note that the response body is established to receive the response generated by the tested function.</li> </ul>"},{"location":"blog/20250419/20250419/#3b-mocking-the-amf-application-interface","title":"3b. Mocking the AMF Application Interface","text":"<pre><code>mockAMF := service.NewMockAmfAppInterface(gomock.NewController(t))\nconsumer, _ := consumer.NewConsumer(mockAMF)\nprocessor, _ := processor.NewProcessor(mockAMF)\nservice.AMF = mockAMF\n\nmockAMF.EXPECT().Context().Return(amf_context.GetSelf()).AnyTimes()\nmockAMF.EXPECT().Consumer().Return(consumer).AnyTimes()\n</code></pre> <ul> <li>A GoMock\u2010generated <code>mockAMF</code> stands in for the real AMF app, so we can intercept calls during <code>HandleCreateUEContextRequest</code>.  </li> <li>We tell it to always return our initialized context and consumer whenever <code>.Context()</code> or <code>.Consumer()</code> is called</li> </ul>"},{"location":"blog/20250419/20250419/#3c-invoking-the-processor-and-verifying-the-response","title":"3c. Invoking the Processor and Verifying the Response","text":"<pre><code>processor.HandleCreateUEContextRequest(c, tc.request)\n\nhttpResp := httpRecorder.Result()\nrawBytes, _ := io.ReadAll(httpResp.Body)\nopenapi.Deserialize(tc.responseBody, rawBytes, \u2026)\n\nrequire.Equal(t, tc.expectedHTTPResp.Status, httpResp.StatusCode)\nrequire.Equal(t, expectedBytes, respBytes)\n</code></pre> <ul> <li>A Gin test context (<code>c</code>) captures the HTTP request and response.  </li> <li>We call <code>HandleCreateUEContextRequest</code>, then read back the HTTP status and body, deserialize into the expected model, and assert equality using Testify\u2019s <code>require.Equal</code>.</li> </ul>"},{"location":"blog/20250419/20250419/#4-result","title":"4. Result","text":"<p>Overall, the test examines that JSON + binary N2SM input to <code>HandleCreateUEContextRequest</code> yields the correct HTTP response under controlled, in\u2011memory conditions.</p> <p>For more details, please visit test file under AMF with this path: amf/internal/sbi/processor/createUeContext_test.go.</p>"},{"location":"blog/20250419/20250419/#iii-conclusion","title":"III. Conclusion","text":"<p>Testing helps keep free5GC reliable and easy to maintain. Using Go\u2019s built-in tools along with GoMock, Gin, and Testify, developers can check if important parts, like UE context creation, work correctly. The example shows how to test with both JSON and binary data in a safe, in-memory setup. This makes it easier to find bugs, improve code quality, and build better software. With good testing, free5GC becomes a stronger and more ready-to-use 5G core system.</p>"},{"location":"blog/20250419/20250419/#iv-reference","title":"IV. Reference","text":"<ul> <li>Go \u600e\u9ebc\u5beb\u6e2c\u8a66\u6848\u4f8b</li> <li>HTTP headers</li> <li>Golang: Unit tests with test gin context</li> <li>\u5982\u4f55\u5728Go \u4e2d\u8655\u7406JSON</li> <li>Data Race Detector - The Go Programming Language</li> <li>go command #Compile packages and dependencies</li> </ul>"},{"location":"blog/20250419/20250419/#about","title":"About","text":"<p>Hi, my name is Jeff Chen, I'm a newcommer of 5G core network.  My current focus is on developing AMF. If you notice any errors in this article, please reach out via Github! </p> <p>My GitHub link</p>"},{"location":"blog/20250423/20250423/","title":"Introduction to TNGF","text":"<p>Note</p> <p>Author: Pei-Chi, Cheng Date: 2025/04/23</p>"},{"location":"blog/20250423/20250423/#introduction","title":"Introduction","text":"<p>TNGF (Trusted Non-3GPP Gateway Function) is a network function defined in the 5G System Architecture. It acts as a gateway between trusted non-3GPP access networks (like Wi-Fi, etc.) and the 5G Core (5GC).</p> <p>TNGF enables UEs using trusted non-3GPP access to connect to the 5G Core, enabling them to access services such as mobility, session continuity, and policy enforcement just like on 3GPP access.</p>"},{"location":"blog/20250423/20250423/#registration-via-trusted-non-3gpp-access","title":"Registration via Trusted non-3GPP Access","text":""},{"location":"blog/20250423/20250423/#summary","title":"Summary","text":"<p>When a UE connects to the 5G Core via trusted Wi-Fi (such as an operator-provided home Wi-Fi), the registration procedure is very similar with the 5GC registration procedure over untrusted non-3GPP access. </p> <p>The UE uses a special method called EAP-5G to encapsulate its NAS messages. These encapsulated messages are sent to the TNGF, which simply forwards them to the AMF. Even though the messages pass through TNGF, the actual communication always happens between the UE and the AMF. </p>"},{"location":"blog/20250423/20250423/#1-access-selection-and-initial-connection","title":"1. Access Selection and Initial Connection","text":"<p>In the Trusted non-3GPP access registration procedure, the UE first selects a compatible Trusted non-3GPP Access Network (TNAN), such as a WLAN, based on its subscription information (e.g., PLMN or SNPN). This selection process allows the UE to discover access networks that offer \"5G connectivity.\" After selecting a TNAN, the UE establishes a Layer-2 connection with the Trusted Non-3GPP Access Point (TNAP), such as through 802.11 Association in Wi-Fi networks.</p> <p></p>"},{"location":"blog/20250423/20250423/#2-authentication-and-slice-aware-registration","title":"2. Authentication and Slice-Aware Registration","text":"<p>After establishing a Layer-2 connection with the TNAP, the UE initiates authentication to prove its identity and connect to the 5G Core Network (5GC). The UE sends a Network Access Identifier (NAI) via the TNAP, indicating its desired 5G connectivity (e.g., a specific PLMN or SNPN) and subscription context. The TNAP encapsulates the NAI in AAA messages (typically RADIUS) and forwards it to the TNGF. Acting as an AAA proxy, TNGF processes the TNAP\u2019s EAP-5G messages and forwards the encapsulated NAS messages to the AMF via the N2 interface, initiating the authentication process.</p> <p>Authentication is performed using the EAP-5G protocol directly between the UE and AMF, with TNGF relaying EAP-5G messages. Upon successful authentication, the UE and AMF each generate a TNGF Key, used for subsequent secure channel setup. The AMF sends the TNGF Key to TNGF via the N2 interface, and TNGF derives a TNAP Key from it. The TNAP Key secures the Layer-2 connection between the UE and TNAP (e.g., Wi-Fi WPA2/WPA3 security). This process ensures the UE\u2019s secure access to the 5GC and prepares for slice-based services (e.g., dedicated channels for different applications).</p> <p></p>"},{"location":"blog/20250423/20250423/#3-secure-channel-setup-and-ip-configuration","title":"3. Secure Channel Setup and IP Configuration","text":"<p>With authentication complete and security keys generated, the UE and TNAP perform a 4-way handshake (e.g., WPA2/WPA3) to establish a secure Layer-2 connection, protecting Wi-Fi wireless data. The UE then obtains an IP address from the TNAN, typically via DHCP or IPv6 Stateless Address Autoconfiguration.</p> <p>Using the TNGF IP address obtained from EAP-5G authentication, the UE establishes a secure channel (NWt) with TNGF via the IKEv2 protocol. This involves IKE_INIT and IKE_AUTH exchanges, with authentication based on the TNGF Key generated during authentication, using shared key authentication. TNGF verifies the UE\u2019s identity without involving a backend RADIUS server. Upon success, a signaling IPsec Security Association (SA) is established in tunnel mode, using null encryption to provide only integrity and authentication for NAS messages. NAS message confidentiality is ensured by the NAS protocol layer\u2019s encryption, transmitted over the NWt channel via TCP/IP/ESP.</p> <p>TNGF provides the UE with: - Inner IP address: For communication within the secure channel. - NAS_IP_ADDRESS and TCP port: For transmitting NAS messages. - DSCP value: To mark packet priority, which the UE and TNAP may map to Wi-Fi QoS prioritie.</p> <p>After establishing the signaling IPsec SA, the UE sets up a TCP connection using the NAS_IP_ADDRESS and TCP port. NAS messages are securely transmitted via TCP/IP/ESP in the NWt channel. With the NWt channel complete, the UE can securely access 5GC services, such as establishing PDU Sessions for data transfer.</p> <p></p>"},{"location":"blog/20250423/20250423/#4-slice-compatibility-check-and-policy-update","title":"4. Slice Compatibility Check and Policy Update","text":"<p>After the secure NWt connection is established, the TNGF notifies the AMF. The AMF then evaluates whether the UE\u2019s Requested NSSAI (network slice selections) is compatible with the TNGF's supported slice configuration. If compatible, the AMF sends a NAS Registration Accept message, allowing the UE to proceed with PDU session establishment and enabling further policy interactions via the PCF.</p> <p>If the TNGF is not compatible with the requested slices, the AMF may update the UE\u2019s access policies via the PCF. The AMF then sends a Registration Reject message, possibly including new TNAP/TNGF target information. The UE can then re-select a new TNAN and repeat the registration procedure with updated preferences.</p> <p></p>"},{"location":"blog/20250423/20250423/#pdu-session-establishment","title":"PDU Session Establishment","text":"<p>After registering to 5GC via trusted non-3GPP access, UE can establish a PDU Session using a procedure similar to N3IWF, with N3IWF replaced by TNGF and untrusted access point by TNAP. </p> <p></p> <p>TNGF sends TNGF Identities (N3 termination identifiers, such as FQDNs or IP addresses) and User Location Information (ULI) (e.g., cell ID) via N2. This enables the SMF to select a suitable UPF and allows the PCF to apply location-based policy control. The IKEv2 Create Child SA Request includes Additional QoS Information containing QoS Characteristics (linked to 5QI) and, for GBR flows, also GBR QoS Flow Information (MFBR, GFBR), guiding the UE's QoS resource reservation.</p> <p>For L4S QoS flows, the TNGF may establish dedicated IPsec Child SAs with DSCP marking. If the UE fails to reserve the requested QoS resources over the trusted non-3GPP access, it may reject the Child SA. Based on operator policy, the network may retry without including Additional QoS Information.</p>"},{"location":"blog/20250423/20250423/#understanding-the-roles-and-configuration-of-tngf-ue-tnap-tngf-and-free5gc-core","title":"Understanding the Roles and Configuration of TNGF UE, TNAP, TNGF, and free5GC Core","text":""},{"location":"blog/20250423/20250423/#system-architecture-overview","title":"System Architecture Overview","text":"<p>In a Trusted Non-3GPP Access scenario, the overall architecture is as follows:</p> <p><code>TNGF UE  &lt;---&gt;  TNAP  &lt;---&gt;  TNGF  &lt;---&gt;  free5GC Core</code></p> <p>This architecture leverages protocols such as EAP-5G for authentication, RADIUS for relaying authentication messages, and IKEv2 for establishing secure channels. The roles of each component are summarized below:</p> Component Role Brief Description TNGF UE Simulated User Equipment (UE) Connects to Wi-Fi via TNAP and initiates 5G core network registration. TNAP Simulated Trusted Wi-Fi AP Provides Wi-Fi access and forwards authentication messages to TNGF. TNGF Trusted Gateway Bridges TNAP and free5GC Core, handling authentication and NAS signaling. free5GC Core 5G Core Network Executes core functions like AMF, SMF, UPF, and AUSF for network management."},{"location":"blog/20250423/20250423/#component-configuration","title":"Component Configuration","text":"<p>Each component requires specific IP assignments and security parameters to ensure seamless and secure operation. The configuration details are divided into IP assignments and security parameters and functions.</p>"},{"location":"blog/20250423/20250423/#ip-assignment","title":"IP Assignment","text":"Component IP Assignment Notes free5GC Core Host or container IP Configured via Docker or host network settings. TNGF Dedicated IP Can share the same host as free5GC Core or run independently. TNAP Dedicated IP Simulated Wi-Fi AP, typically configured on an OpenWrt router. TNGF UE DHCP or static configuration Must be in the same subnet as TNAP for Wi-Fi connectivity."},{"location":"blog/20250423/20250423/#security-parameters-and-functions","title":"Security Parameters and Functions","text":"Component Main Functions Required Security Parameters free5GC Core 1. Executes AMF, SMF, UPF, AUSF.2. Receives NAS signaling from TNGF. No RADIUS parameters required. Ensure network policies allow NAS signaling from TNGF (N2 interface towards AMF). TNGF 1. Provides RADIUS Server functionality for TNAP.2. Acts as NAS Signaling Gateway between TNAP and free5GC Core. In <code>tngfcfg.yaml</code>: 1. <code>RadiusSecret</code>: Shared RADIUS secret with TNAP.  2. <code>RadiusBindAddress</code>:  IP address and port where TNGF listens for RADIUS messages.  3. <code>IKEBindAddress</code>:  IP address for establishing IKEv2 (NWt interface) with UE. TNAP 1. Provides Wi-Fi access for UEs. 2.  Encapsulates and forwards EAP-5G messages to TNGF via RADIUS. 1. Set <code>RADIUS</code> Server IP to the <code>RadiusBindAddress</code> configured on TNGF.2. Configure <code>RadiusSecret</code> identical to the RadiusSecret set in TNGF.3. Enable WPA2-Enterprise (EAP) authentication mode for Wi-Fi security. TNGF UE 1. Connects to TNAP via Wi-Fi.2. Initiates 5G core network registration through EAP-5G. In <code>wpa_supplicant.conf</code>: 1. <code>ssid</code>: Wi-Fi SSID broadcasted by TNAP.  2.<code>identity</code>: UE\u2019s EAP identity.  3. <code>password</code>: UE\u2019s EAP password (depending on authentication method)."},{"location":"blog/20250423/20250423/#communication-flow","title":"Communication Flow","text":"<p>The typical communication flow is as follows:</p> <ol> <li>Wi-Fi Connection and EAP-5G Initiation: TNGF UE initiates a Wi-Fi connection to TNAP, which leads TNAP to initiate an EAP-5G Identity Request towards UE.</li> <li>RADIUS Forwarding: TNAP encapsulates the EAP-5G message into a RADIUS Access-Request and forwards it to TNGF\u2019s RADIUS Server.</li> <li>NAS Signaling to AMF: TNGF extracts the NAS signaling message from the EAP-5G payload and forwards it to the AMF via the N2 interface.</li> <li>Authentication: AMF coordinates with AUSF (if needed) to authenticate the UE using EAP-5G credentials.</li> <li>Secure Channel: Upon successful authentication, TNGF establishes a secure NWt channel with TNGF UE using IKEv2.</li> <li>Secure NAS Signaling: Subsequent NAS signaling between TNGF UE and free5GC Core is transmitted securely over the NWt channel.</li> </ol>"},{"location":"blog/20250423/20250423/#difference-between-n3iwf-and-tngf","title":"Difference between N3IWF and TNGF","text":""},{"location":"blog/20250423/20250423/#what-is-n3iwf","title":"What Is N3IWF?","text":"<p>The N3IWF (Non-3GPP Interworking Function) is a critical network function in the 5G system architecture, serving as a gateway between untrusted non-3GPP access networks (e.g., public Wi-Fi) and the 5G Core Network. When a UE connects to the 5GC via an untrusted network, the N3IWF establishes a secure IPsec tunnel using IKEv2 and EAP-5G protocols for authentication, protecting both control and user plane data.  The UE first selects an N3IWF (based on PLMN or SNPN) and sends NAS messages encapsulated in EAP-5G, which the N3IWF forwards to the AMF via the N2 interface. After authentication, the N3IWF and UE establish a signaling IPsec SA for NAS message transmission (TCP/IP/ESP) and support network slice selection. Acting like a VPN gateway, the N3IWF ensures security and service continuity, including mobility, QoS, and policy enforcement, in untrusted environments.</p> <p></p>"},{"location":"blog/20250423/20250423/#comparison","title":"Comparison","text":"Item TNGF N3IWF Access Type Trusted non-3GPP Access (e.g., operator-managed Wi-Fi) Untrusted non-3GPP Access (e.g., public Wi-Fi) Trust Level The 5GC trusts the access network The 5GC does not trust the access network, requiring additional security mechanisms UE-Access Node Connectivity EAP-5G used for authentication, encapsulating NAS messages between UE and AMF via TNAP IKEv2 used to establish an IPsec tunnel; EAP-5G used inside the tunnel for NAS signaling IPsec Tunnel usage For control plane via NWt interface (null encryption, protects NAS message integrity and authentication) For control and user planes via NWu interface (full encryption, protects confidentiality, integrity, and authentication) NAS Communication NAS messages encapsulated in EAP-5G (during authentication) or TCP/IP/ESP (post-NWt setup), sent via N2/NGAP, similar to gNB NAS messages encapsulated in EAP-5G during authentication, then in TCP/IP/ESP over a fully encrypted IPsec tunnel post-NWu setup Typical Use Case Trusted Wi-Fi deployed by operators or partners, e.g., home or enterprise Wi-Fi Public or open Wi-Fi, e.g., in cafes, airports, or other unsecured networks Functional Role Acts like a gNB, supporting N2/NGAP for signaling and trusted access integration Acts like a VPN gateway, handling IPsec, EAP, and translation between non-3GPP access and 5GC"},{"location":"blog/20250423/20250423/#how-to-determine-if-a-non-3gpp-network-is-trusted","title":"How to Determine If a Non-3GPP Network Is Trusted?","text":"<ul> <li>Wi-Fi deployed by a telecom operator or with a trust agreement with the 5GC is considered trusted.</li> <li>Trusted networks register as a TNAP in the 5GC, connect via a TNGF, and support 3GPP authentication (e.g., EAP-5G).</li> <li>Trusted networks may offer special SSIDs or onboarding flows for mobile subscribers.</li> </ul>"},{"location":"blog/20250423/20250423/#conclusion","title":"Conclusion","text":"<p>Trusted non-3GPP access extends the 5G Core over operator-managed Wi-Fi, enabling secure, seamless connectivity and consistent mobile services beyond traditional RAN coverage.</p>"},{"location":"blog/20250423/20250423/#reference","title":"Reference","text":"<ul> <li>TS 23.502</li> <li>TS 23.501</li> <li>TS 133 501 - V16.17.0 - 5G</li> <li>5G: focus on N3IWF, TNGF, TWIF and W-5GAN</li> <li>Tngfue installation - free5GC</li> </ul>"},{"location":"blog/20250423/20250423/#about-me","title":"About me","text":"<p>Hi, I'm Peggy Cheng, a newcomer to 5G and the free5GC community. Feel free to tell me if there's any mistake in the article.</p>"},{"location":"blog/20250423/20250423/#connect-with-me","title":"Connect with Me","text":"<p>GitHub: HiImPeggy</p>"},{"location":"blog/20250430/20250430/","title":"Namespace-Based GTP5G Conflict Resolution for free5GC and PacketRusher","text":"<p>Note</p> <p>Author: Alonza Tu Date: 2025/04/30</p>"},{"location":"blog/20250430/20250430/#gtp5g-conflict-description","title":"GTP5G Conflict Description","text":"<p>When deploying free5GC and PacketRusher(RAN/UE) on the same physical machine, one common challenge is the conflict over the GTP5G network device. Both components attempt to bind and operate on the same virtual interface, which leads to PDU session establishment failure.</p> <p>To address this issue elegantly, we can leverage Linux network namespaces to isolate PacketRusher's network environment. In this blog post, we will walk through the process of setting up PacketRusher in a dedicated namespace, ensuring seamless coexistence with the free5GC core network on a single host.</p>"},{"location":"blog/20250430/20250430/#advantages-with-network-namespace","title":"Advantages with Network Namespace","text":"<p>As we know, free5GC provides a Docker Compose setup on GitHub, which allows deploying the core network along with RAN/UE components on the same machine. However, if we only want to test specific features or run components in debug mode, running the core network and RAN/UE directly on the host can be more convenient and flexible for development purposes.</p>"},{"location":"blog/20250430/20250430/#network-namespace-introduction","title":"Network Namespace Introduction","text":"<p>Network namespaces are a fundamental feature of the Linux kernel that provides isolation of network resources. Each namespace has its own network interfaces, routing tables, firewall rules, and network devices. This isolation ensures that processes in different namespaces cannot interfere with each other's network configurations, making it an ideal solution for our GTP5G conflict scenario.</p> <p>For a deeper understanding of Linux network devices and their management, you can refer to our previous blog post on Network Devices in Linux.</p>"},{"location":"blog/20250430/20250430/#network-namespace-deployment","title":"Network Namespace Deployment","text":""},{"location":"blog/20250430/20250430/#architecture-overview","title":"Architecture Overview","text":"<p>There will be an additional network namespace called <code>packetRusher_ns</code>, connected to the host network namespace via a veth pair( <code>prHost</code> &lt; - &gt;  <code>prVeth</code>).</p>"},{"location":"blog/20250430/20250430/#setup-step-by-step","title":"Setup Step by Step","text":"<ol> <li>Linux Network Namespace     a. Create the target network namespace         Here we create a network namespace called <code>packetRusher_ns</code>. <pre><code>sudo ip netns add packetRusher_ns 2&gt;/dev/null || true\n</code></pre>     b. Create the veth pair         Here we create a veth pair with one side is <code>prHost</code> and the other side is <code>prVeth</code>. <pre><code>sudo ip link add prHost type veth peer prVeth\n</code></pre>     c. Move veth peer to namespace         Now, we need to move <code>prVeth</code> into <code>packetRusher_ns</code>. <pre><code>sudo ip link set prVeth netns packetRusher_ns\n</code></pre>     d. Bring up the interfaces         After setting the veth pair, we need to bring them up in both host network namespace and <code>packetRusher_ns</code>. <pre><code>sudo ip link set prHost up\nsudo ip netns exec packetRusher_ns ip link set prVeth up\n</code></pre>     e. Configure IP addresses         Now we need to configure the specific IPs for both <code>prHost</code> and <code>prVeth</code>.         The IP class is <code>10.0.1.0/24</code> in this example. <pre><code>sudo ip addr add 10.0.1.1/24 dev prHost\nsudo ip netns exec packetRusher_ns ip addr add 10.0.1.2/24 dev prVeth\n</code></pre>     f. Configure routing in <code>packetRusher_ns</code>         We have to make <code>packetRusher_ns</code> know where to route the traffic. <pre><code>sudo ip netns exec packetRusher_ns ip route add default via 10.0.1.1\n</code></pre></li> <li> <p>free5GC Core Network    For core network configuration and local running, please refer to: Build and Install free5GC    Make sure to modify AMF/SMF/UPF's configuration YAML file:</p> <ul> <li> <p>~/free5gc/config/amfcfg.yaml</p> <p>Replace ngapIpList IP from 127.0.0.1 to your host ip, not <code>prHost</code>, namely from:</p> <pre><code>ngapIpList:  # the IP list of N2 interfaces on this AMF\n- 127.0.0.1\n</code></pre> <p>into</p> <pre><code>ngapIpList:  # the IP list of N2 interfaces on this AMF\n- &lt;your host ip, not prHost&gt;\n</code></pre> </li> <li> <p>~/free5gc/config/smfcfg.yaml</p> <p>In the entry inside <code>userplaneInformation / upNodes / UPF / interfaces / endpoints</code>, change the IP from 127.0.0.8 to your host ip, not <code>prHost</code>, namely from:</p> <pre><code>interfaces: # Interface list for this UPF\n- interfaceType: N3 # the type of the interface (N3 or N9)\n    endpoints: # the IP address of this N3/N9 interface on this UPF\n    - 127.0.0.8\n</code></pre> <p>into</p> <pre><code>interfaces: # Interface list for this UPF\n- interfaceType: N3 # the type of the interface (N3 or N9)\n    endpoints: # the IP address of this N3/N9 interface on this UPF\n    - &lt;your host ip, not prHost&gt;\n</code></pre> </li> <li> <p>~/free5gc/config/upfcfg.yaml</p> <p>Change GTPU IP from 127.0.0.8 into your host ip, not <code>prHost</code>, namely from:</p> <pre><code>gtpu:\n    forwarder: gtp5g\n    # The IP list of the N3/N9 interfaces on this UPF\n    # If there are multiple connection, set addr to 0.0.0.0 or list all the addresses\n    ifList:\n    - addr: 127.0.0.8\n      type: N3\n</code></pre> <p>into</p> <pre><code>gtpu:\n    forwarder: gtp5g\n    # The IP list of the N3/N9 interfaces on this UPF\n    # If there are multiple connection, set addr to 0.0.0.0 or list all the addresses\n    ifList:\n    - addr: &lt;your host ip, not prHost&gt;\n      type: N3\n</code></pre> </li> </ul> </li> <li> <p>PackerRusher    For PacketRusher setup, build, and local running, please refer to: PacketRusher: A new UE/gNB simulator and CP/UP load tester    Now, we're going to modify the configuration to make PacketRusher run in <code>packetRusher_ns</code>:</p> <ul> <li> <p>Modify IP field in <code>controlif</code> and <code>dataif</code> into the <code>prVeth</code>'s IP, like:</p> <pre><code>gnodeb:\n    controlif:\n        ip: \"10.0.1.2\" # prVeth's IP\n        port: 9487\n    dataif:\n        ip: \"10.0.1.2\" # prVeth's IP\n        port: 2152\n</code></pre> </li> <li> <p>Also set the AMF's IP as your core network's AMF's IP(the <code>ngapIpList</code> we set in the previous part):</p> <pre><code>amfif:\n    - ip: &lt;your host ip, not prHost&gt;\n</code></pre> </li> </ul> </li> <li> <p>Running     a. Start the core network in terminal-1: <pre><code>./run.sh\n</code></pre>     b. Create a new subscriber via web console:         For creating subscriber, please refer to: Create Subscriber via Webconsole</p> <p>c. Get into the <code>packetRusher_ns</code> in terminal-2 and terminal-3: <pre><code>sudo ip netns exec packetRusher_ns bash\n</code></pre> d. Start up the PacketRusher in terminal-2: <pre><code>./PacketRusher/packetrusher ue\n</code></pre> e. Data plane test in terminal-3: <pre><code>ping -I val0000000001 8.8.8.8\n</code></pre> f. Exit <code>packetRusher_ns</code> <pre><code>exit\n</code></pre></p> </li> <li> <p>Demo Result:</p> <p></p> <ul> <li>Left part is core network.</li> <li>Right part is PacketRusher and the <code>ping</code> test.</li> </ul> </li> <li> <p>Clean the <code>packerRusher_ns</code>     a. Bring down interface <pre><code>sudo ip link set prHost down 2&gt;/dev/null || true\n</code></pre>     b. Delete veth pair <pre><code>sudo ip link delete prHost 2&gt;/dev/null || true\n</code></pre>     c. Delete network namespace <pre><code>sudo ip netns delete packetRusher_ns 2&gt;/dev/null || true\n</code></pre></p> </li> </ol>"},{"location":"blog/20250430/20250430/#conclusion","title":"Conclusion","text":"<p>In this blog post, we explored a practical solution to resolve the GTP5G device conflict between free5GC and PacketRusher using Linux network namespaces. By isolating PacketRusher in a dedicated network namespace (<code>packetRusher_ns</code>), we successfully achieved the coexistence of both components on a single machine.</p> <p>This approach not only resolves the conflict but also provides better network isolation and management. The step-by-step guide and configuration examples provided should help developers set up their testing environment more efficiently, enabling smoother development and testing of core network functionalities.</p>"},{"location":"blog/20250430/20250430/#reference","title":"Reference","text":"<ul> <li>PacketRusher</li> <li>Network Devices in Linux</li> <li>PacketRusher: A new UE/gNB simulator and CP/UP load tester</li> <li>Build and Install free5GC</li> <li>Installing a UE/RAN Simulator</li> <li>Create Subscriber via Webconsole</li> </ul>"},{"location":"blog/20250430/20250430/#about-me","title":"About me","text":"<p>Hi, I'm Alonza, a core network developer currently contributing to the free5GC project. I'm passionate about exploring cutting-edge 5G technologies, with a recent focus on tunnel handling and its role in shaping next-generation connectivity. If you're also interested and have ideas to share, don't hesitate\u2014reach out to me!</p>"},{"location":"blog/20250430/20250430/#connect-with-me","title":"Connect with me","text":"<ul> <li>GitHub: https://github.com/Alonza0314</li> <li>Website: Alonza0314</li> <li>LinkedIn: Alonza Tu</li> </ul>"},{"location":"blog/20250509/20250509/","title":"Hands-On with sched_ext: Building Custom eBPF CPU Schedulers","text":""},{"location":"blog/20250509/20250509/#introduction","title":"Introduction","text":"<p>In part 1: Exploring sched_ext: BPF-Powered CPU Schedulers in the Linux Kernel, we explored the architecture and concepts behind <code>sched_ext</code>, Linux's framework for implementing custom CPU schedulers using eBPF. We examined how this revolutionary approach allows dynamically loading schedulers without kernel recompilation, and we compared different implementation styles including C-based (<code>scx_simple</code>), Rust-based (<code>scx_bpfland</code>,<code>scx_rustland</code>), and even potential Go implementations <code>scx_goland_core</code></p> <p>Now it's time to get our hands dirty. In this second part, we'll move from theory to practice by building our own custom schedulers using the <code>sched_ext</code> framework. Start with a minimal implementation to understand the basics, then gradually add more sophisticated scheduling policies to handle real-world scenarios.</p> <p>Such as network packet processing to optimized for packet-processing intensive workloads. By prioritizing packet-handling threads and optimizing CPU allocation, we can reduce latency and improve throughput in these critical systems.</p> <p>By the end of this hands-on guide, you'll have:</p> <ul> <li>Set up a proper development environment for <code>sched_ext</code></li> <li>Implemented and loaded your own custom BPF scheduler</li> <li>Explored different scheduling policies and their effects on performance</li> <li>Learned how to debug and test your scheduler under various workloads</li> </ul> <p>Let's dive into the practical world of CPU scheduling with eBPF!</p>"},{"location":"blog/20250509/20250509/#environment","title":"environment","text":"<p>To start building custom schedulers with <code>sched_ext</code>, we need to set up a proper development environment. Let's go through this process step by step so you can follow along on your own system.</p>"},{"location":"blog/20250509/20250509/#kernel-requirements-612","title":"Kernel Requirements (6.12+)","text":"<p><code>sched_ext</code> requires Linux kernel 6.12 or newer, we can use the mainline utility to easily install newer kernels:</p> <p><pre><code>sudo add-apt-repository ppa:cappelikan/ppa\nsudo apt update\nsudo apt install -y mainline\n</code></pre> </p>"},{"location":"blog/20250509/20250509/#cloning-and-building-the-sched_ext-project","title":"Cloning and Building the sched_ext Project","text":"<pre><code>git clone https://github.com/sched-ext/scx.git\ncd scx\n</code></pre> <pre><code># Install BPF development tools:\nsudo apt install libbpf-dev clang llvm libelf-dev\n\n#\u3000Build the schedulers using meson, you also need rust in your system\ncd ~/work/scx\nmeson setup build --prefix ~\nmeson compile -C build\nmeson install -C build\n</code></pre> <pre><code># sched_ext framework requires these configurations to work properly, check them\nfor config in BPF SCHED_CLASS_EXT BPF_SYSCALL BPF_JIT BPF_JIT_ALWAYS_ON BPF_JIT_DEFAULT_ON PAHOLE_HAS_BTF_TAG DEBUG_INFO_BTF SCHED_DEBUG DEBUG_INFO DEBUG_INFO_DWARF5 DEBUG_INFO_BTF_MODULES; do\n    grep -w CONFIG_$config /boot/config-$(uname -r)\ndone\n\n# you'll see:\nCONFIG_BPF=y\nCONFIG_SCHED_CLASS_EXT=y\nCONFIG_BPF_SYSCALL=y\nCONFIG_BPF_JIT=y\nCONFIG_BPF_JIT_ALWAYS_ON=y\nCONFIG_BPF_JIT_DEFAULT_ON=y\nCONFIG_DEBUG_INFO_BTF=y\nCONFIG_SCHED_DEBUG=y\nCONFIG_DEBUG_INFO=y\nCONFIG_DEBUG_INFO_DWARF5=y\nCONFIG_DEBUG_INFO_BTF_MODULES=y\n</code></pre>"},{"location":"blog/20250509/20250509/#implementation-of-an-even-cpu-only-scheduler-with-scx","title":"Implementation of an Even-CPU-Only Scheduler with SCX","text":""},{"location":"blog/20250509/20250509/#what-we-did-and-expected","title":"What We Did and Expected","text":"<p>We modified the scx_packet scheduler to distribute tasks exclusively to even-numbered CPUs (0, 2, 4, 6, 8) while keeping odd-numbered CPUs idle. This demonstrates fine-grained CPU control within the sched_ext framework.</p>"},{"location":"blog/20250509/20250509/#creating-the-initial-scheduler","title":"Creating the Initial Scheduler","text":"<p>Our custom scheduler mainly use same func with scx_simple, and I called it <code>scx_packet</code></p> <p>Now, let's modify our <code>scx_packet.bpf.c</code> file to implement our strategy of only using even-numbered CPUs. Here's our initial implementation: <pre><code>/* Main dispatch function that decides which tasks run on which CPUs */\nvoid BPF_STRUCT_OPS(packet_dispatch, s32 cpu, struct task_struct *prev)\n{\n    /* Only dispatch tasks to even-numbered CPUs */\n    if ((cpu &amp; 1) == 0) {\n        scx_bpf_dsq_move_to_local(SHARED_DSQ);\n    }\n    /* Odd-numbered CPUs remain idle as we don't dispatch tasks to them */\n}\n</code></pre></p> <p>but not much easy!</p>"},{"location":"blog/20250509/20250509/#encountering-and-fixing-stalls","title":"Encountering and Fixing Stalls","text":"<p>When we tested this initial implementation, we ran into a critical issue: <pre><code>kworker/u48:3[154254] triggered exit kind 1026:\n  runnable task stall (kworker/0:1[141497] failed to run for 30.357s)\n</code></pre></p> <p>This means that tasks that can only run on odd-numbered CPUs are stuck in a \"runnable\" state but never get scheduled to run. So we need to modify our implementation to ensure that:</p> <ul> <li>In <code>packet_select_cpu</code>:<ul> <li>Simplified to use the default selection, as the real control happens in enqueue and dispatch</li> </ul> </li> <li> <p>In <code>packet_enqueue</code>:</p> <ul> <li>Special-cases kernel threads with single-CPU affinity to respect their requirements</li> <li>Uses <code>scx_bpf_dsq_insert()</code> instead of queue insertion for better control</li> <li>For regular tasks, dispatches them to the shared queue Actively kicks an even CPU (0, 2, 4, etc.) to process tasks from the queue</li> </ul> </li> <li> <p>In <code>packet_dispatch</code>:</p> <ul> <li>Only allows even CPUs to consume from the shared queue</li> <li>Odd CPUs will only run tasks that were specifically dispatched to them (kernel threads)</li> </ul> </li> </ul>"},{"location":"blog/20250509/20250509/#the-comprehensive-solution","title":"The Comprehensive Solution","text":"<p>Let's build a comprehensive solution that respects system requirements while still implementing our even-CPU policy:</p> <pre><code>void BPF_STRUCT_OPS(packet_enqueue, struct task_struct *p, u64 enq_flags)\n{\n    stat_inc(1);    /* count global queueing */\n\n    /* Handle kernel threads with restricted CPU affinity */\n    if ((p-&gt;flags &amp; PF_KTHREAD) &amp;&amp; p-&gt;nr_cpus_allowed == 1) {\n        scx_bpf_dsq_insert(p, SCX_DSQ_LOCAL, SCX_SLICE_DFL, enq_flags);\n        return;\n    }\n\n    /* For all other tasks, use the shared queue for later dispatch to even CPUs */\n    if (fifo_sched) {\n        scx_bpf_dsq_insert(p, SHARED_DSQ, SCX_SLICE_DFL, enq_flags);\n    } else {\n        u64 vtime = p-&gt;scx.dsq_vtime;\n\n        /*\n         * Limit the amount of budget that an idling task can accumulate\n         * to one slice.\n         */\n        if (time_before(vtime, vtime_now - SCX_SLICE_DFL))\n            vtime = vtime_now - SCX_SLICE_DFL;\n\n        scx_bpf_dsq_insert_vtime(p, SHARED_DSQ, SCX_SLICE_DFL, vtime, enq_flags);\n    }\n\n    /* If we dispatched to the shared queue, kick an even CPU to process it */\n    s32 target_cpu = 0;  /* Start with CPU 0 */\n\n    /* Find the next even CPU by checking CPU 0, 2, 4, etc. */\n    for (s32 i = 0; i &lt; 5; i++) {  /* Limit to checking 5 CPUs to avoid BPF loop limits */\n        target_cpu = 2 * i;  /* Only even CPUs */\n        if (target_cpu &lt; 10) {  /* Assume max 10 CPUs, adjust if needed */\n            scx_bpf_kick_cpu(target_cpu, SCX_KICK_PREEMPT);\n            break;\n        }\n    }\n}\n</code></pre> <ul> <li> <p>Task Identification: We use <code>(p-&gt;flags &amp; PF_KTHREAD) &amp;&amp; p-&gt;nr_cpus_allowed == 1</code> to identify kernel threads with strict CPU affinity requirements.</p> </li> <li> <p>CPU Selection: The bitwise operation <code>(cpu &amp; 1) == 0</code> efficiently determines if a CPU is even-numbered (0, 2, 4...).</p> </li> <li>Dispatch Strategy:<ul> <li>Regular tasks go to the shared queue</li> <li>CPU-specific kernel threads go directly to their required local CPU queue</li> <li>Only even CPUs pull from the shared queue in the dispatch function</li> </ul> </li> </ul>"},{"location":"blog/20250509/20250509/#rebuild-and-run","title":"Rebuild and Run","text":"<p>In <code>scx/scheds/c/meson.build</code>, add our custom scheduler</p> <pre><code>c_scheds = ['scx_simple', 'scx_qmap', 'scx_central', 'scx_userland', 'scx_nest',\n            'scx_flatcg', 'scx_pair', 'scx_prev', 'scx_packet']\n</code></pre> <pre><code>meson setup build --reconfigure\nmeson compile -C build scx_packet\n\n# If successful, the binary will be available at build/scheds/c/scx_packet.\nsudo ./build/scheds/c/scx_packet\n\n# verified our scheduler\nvboxuser@sch:~/work/scx$ cat /sys/kernel/sched_ext/state /sys/kernel/sched_ext/*/ops 2&gt;/dev/null\nenabled\npacket\n</code></pre>"},{"location":"blog/20250509/20250509/#testing-our-custom-scheduler","title":"Testing Our Custom Scheduler","text":"<p>Now that we've implemented our even-CPU-only scheduler, it's time to put it to the test. We'll use two different types of workloads to verify its behavior:</p> <ul> <li>A CPU-intensive workload using stress-ng to see how tasks are distributed</li> <li>A graphics application (glxgears) to observe how our scheduler affects rendering performance</li> </ul>"},{"location":"blog/20250509/20250509/#installing-the-testing-tools","title":"Installing the Testing Tools","text":"<p>First, let's install stress-ng for CPU stress testing: <pre><code>sudo apt update\nsudo apt install -y stress-ng\n\nsudo apt install -y mangohud\nsudo apt install -y mesa-utils\n</code></pre></p>"},{"location":"blog/20250509/20250509/#test-1-cpu-stress-testing","title":"Test 1: CPU Stress Testing","text":"<p>Creates 5 worker processes performing intensive matrix multiplication</p> <p><pre><code>sudo stress-ng --cpu 5 --cpu-method matrixprod --timeout 15s\n</code></pre> <code>htop</code> should show activity primarily on CPUs 0, 2, 4, 6, 8 </p> <p>but what if we use <code>--cpu 10</code>?</p> <p>still only 5 cpu running!! </p>"},{"location":"blog/20250509/20250509/#test-2-graphics-performance-testing","title":"Test 2: Graphics Performance Testing","text":"<p><pre><code># Run glxgears with MangoHud overlay\nMANGOHUD=1 mangohud --dlsym glxgears -info\n</code></pre> This will display the FPS counter overlaid on the rotating gears. Note the FPS values and CPU utilization shown in the MangoHud overlay.</p> <p>In <code>scx_simple</code></p> <p></p> <p>In <code>scx_packet</code></p> <p></p> <p>Performance Metrics Analysis, the metrics perfectly align with the logical expectations: | Metric | scx_packet (Even CPUs) | scx_simple (All CPUs) | Difference | |--------|-------------------|-------------------|------------| | Bogo-ops | 5,603,885 | 8,479,124 | ~51% higher for all CPUs | | Bogo-ops-per-second | 546,351 | 830,616 | ~52% higher for all CPUs | | CPU usage per instance | 103.92% | 134.21% | ~29% higher for all CPUs | | MB received per second | 5.59 | 8.46 | ~51% higher for all CPUs |</p>"},{"location":"blog/20250509/20250509/#conclusion-and-future-work","title":"Conclusion and Future work","text":"<p>Our even-CPU scheduler demonstrates the basic principles of CPU control with <code>sched_ext</code>, but real-world applications like Free5GC or other networking stacks present more complex scheduling challenges. Let's explore how we might adapt our scheduler for packet processing workloads.</p>"},{"location":"blog/20250509/20250509/#optimizing-for-network-packet-processing","title":"Optimizing for Network Packet Processing","text":"<p>Packet processing workloads have unique characteristics that require specialized scheduling approaches:</p> <ul> <li>I/O Bound: Network interfaces generate interrupts when packets arrive, making some tasks I/O bound as they wait for new packets</li> <li>CPU Bound: Once packets arrive, processing them (parsing, encrypting/decrypting, routing) can be CPU intensive</li> </ul>"},{"location":"blog/20250509/20250509/#task-classification","title":"Task Classification","text":"<pre><code>/* Check if a task is a network-related process */\nstatic inline bool is_network_task(struct task_struct *p)\n{\n    /* Common network process names to prioritize */\n    const char *network_processes[] = {\"upf\", \"dpdk\", \"ovs\", \"xdp\"};\n\n    for (int i = 0; i &lt; sizeof(network_processes)/sizeof(network_processes[0]); i++) {\n        if (belong network task)\n            return true;\n    }\n\n    return false;\n}\n</code></pre>"},{"location":"blog/20250509/20250509/#prioritizing-packet-task","title":"Prioritizing Packet Task","text":"<p>we can also modify our enqueue function to give packet processing tasks higher priority <pre><code>void BPF_STRUCT_OPS(packet_enqueue, struct task_struct *p, u64 enq_flags)\n{\n\n\n    /* Prioritize network packet processing tasks */\n    if (is_network_task(p)) {\n        /* Use a shorter time slice for responsiveness */\n        u64 short_slice = SCX_SLICE_DFL / 2;\n\n        /* Give packet tasks negative vtime to prioritize them */\n        u64 priority_vtime = vtime_now - (SCX_SLICE_DFL * 2);\n\n        // same as before\n\n        return;\n    }\n}\n</code></pre></p>"},{"location":"blog/20250509/20250509/#next-steps","title":"Next Steps","text":"<ul> <li>Integrating with DPDK or XDP for Zero-Copy Packet Processing</li> <li>Benchmarking against standard schedulers with realistic network traffic</li> </ul>"},{"location":"blog/20250509/20250509/#reference","title":"Reference","text":"<ul> <li>sched-ext Tutorial</li> <li>\u5185\u6838\u8c03\u5ea6\u5ba2\u5236\u5316\u5229\u5668\uff1aSCHED_EXT</li> <li>BPF \u8d4b\u80fd\u8c03\u5ea6\u5668\uff1a\u4e07\u5b57\u8be6\u89e3 sched_ext \u5b9e\u73b0\u673a\u5236\u4e0e\u5de5\u4f5c\u6d41\u7a0b</li> <li>Pluggable CPU schedulers</li> <li>sched_ext: scheduler architecture and interfaces</li> <li>eBPF \u96a8\u7b46\uff08\u4e03\uff09\uff1asched_ext</li> <li>scx_goland_core</li> </ul>"},{"location":"blog/20250509/20250509/#about","title":"About","text":"<p>Hello, I'm William Lin. I'd like to share my excitement about being a member of the free5gc project, which is a part of the Linux Foundation. I'm always eager to discuss any aspects of core network development or related technologies.</p>"},{"location":"blog/20250509/20250509/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: williamlin0518</li> <li>Linkedin: Cheng Wei Lin</li> </ul>"},{"location":"blog/20250521/20250521/","title":"Go context in free5GC","text":"<p>Note</p> <p>Author: Yung-Hsuan, Tsao Date: 2025/05/21</p>"},{"location":"blog/20250521/20250521/#introduction","title":"Introduction","text":"<p>In the evolving landscape of 5G core networks, reliability, responsiveness, and clean resource management are critical. In free5GC, concurrency and lifecycle control are essential to ensuring system stability \u2014 especially when dealing with session handling, HTTP servers, and external service coordination. Go\u2019s context.Context package plays a key role in managing this complexity.</p>"},{"location":"blog/20250521/20250521/#what-is-go-context","title":"What is go context?","text":"<p>Go's <code>context.Context</code> is a standard library feature that allows users to manage deadlines, cancellation signals, and request-scoped values across API boundaries and goroutines. It's designed to control the operations lifecycle \u2014 for example, stopping a database call, an HTTP request, or a background task when a timeout is reached or a parent operation is canceled.</p> <p>At its core, a context provides:</p> <ul> <li>Cancellation propagation: Cancel a parent context, and all its children are canceled.</li> <li>Timeouts and deadlines: Automatically stop operations after a time limit.</li> <li>Scoped data: Carry request-specific data like IDs or tokens safely.</li> </ul> <p>There are two ways to declare <code>context</code>.</p> <ol> <li><code>context.Background()</code>: returns a non-nil <code>context</code>, often used as the root context in the program \u2014 something that never cancels, has no deadline, and no values.</li> <li><code>context.TODO()</code>: returns a non-nil, empty context, used as a placeholder when unsure what context to use or don\u2019t have the correct context value yet.</li> </ol> <p>After creating the parent category <code>context</code>, you can use it through the With functions to cope with various scenarios, such as:</p> <ul> <li>withCancel: Creates a new context that can be canceled manually. Useful when need to cancel operations explicitly, such as when a user disconnects, or a task finishes early.</li> </ul> <pre><code>func WithCancel(parent Context)(ctx Context, cancel CancelFunc)\n\n// example\nctx, cancel := context.WithCancel(context.Background())\ndefer cancel()\n</code></pre> <ul> <li>withTimeout: Creates a context that is automatically canceled after a given timeout duration.</li> </ul> <pre><code>func WithTimeout(parent Context, time time.Duration)(Context, CancelFunc)\n\n// example\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\n</code></pre> <ul> <li>withDeadline: Like <code>WithTimeout</code>, but sets a specific end time instead of a duration.</li> </ul> <pre><code>func WithDeadline(parent Context, deadline time.Time)(Context, CancelFunc)\n\n// example\ndeadline := time.Now().Add(10 * time.Second)\nctx, cancel := context.WithDeadline(context.Background(), deadline)\ndefer cancel()\n</code></pre> <ul> <li>WithValue: Returns a copy of the parent context with a key-value pair attached. Helpful in passing request-scoped metadata like user IDs, trace IDs, or auth tokens.</li> </ul> <pre><code>func WithValue(parent Context, key, val interface{}) Context\n\n// example\nctx := context.WithValue(context.Background(), \"userID\", 1234)\nuserID := ctx.Value(\"userID\")\n</code></pre>"},{"location":"blog/20250521/20250521/#example-cancelable-workers","title":"Example: Cancelable Workers","text":"<p>Following is a simple go function.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc worker(ctx context.Context, id int, workTime time.Duration) {\n    start := time.Now()\n    select {\n    case &lt;-time.After(workTime):\n        fmt.Printf(\"Worker %d: Finished work in %v\\n\", id, workTime)\n    case &lt;-ctx.Done():\n        elapsed := time.Since(start)\n        fmt.Printf(\"Worker %d: Canceled after %v (%v)\\n\",\n                   id, elapsed.Round(time.Millisecond), ctx.Err())\n    }\n}\n\nfunc main() {\n    ctx, cancel := context.WithCancel(context.Background())\n    defer cancel()\n\n    go worker(ctx, 1, 1*time.Second)\n    go worker(ctx, 2, 3*time.Second)\n    go worker(ctx, 3, 5*time.Second)\n\n    time.Sleep(2 * time.Second)\n    fmt.Println(\"Canceling all the workers...\")\n    cancel()\n\n    time.Sleep(time.Second)\n}\n</code></pre> <p>In this program, <code>context.Background()</code> is wrapped by <code>context.WithCancel</code>, which gives a new context(ctx) and a <code>cancel()</code> function.</p> <p><code>Ctx.Done()</code> is a channel that gets closed when <code>cancel()</code> is called.</p> <p>These allow all workers to listen for cancellation using the same <code>ctx</code>.</p> <pre><code>go worker(ctx, 1, 1*time.Second)\ngo worker(ctx, 2, 3*time.Second)\ngo worker(ctx, 3, 5*time.Second)\n</code></pre> <p>In this part, three workers each receive a shared <code>ctx</code>, a unique ID, and a different work duration. Each worker simulates doing some task by waiting for the given time using <code>time.After(workTime)</code>.</p> <pre><code>func worker(ctx context.Context, id int, workTime time.Duration) {\n    start := time.Now()\n    select {\n    case &lt;-time.After(workTime):\n        fmt.Printf(\"Worker %d: Finished work in %v\\n\", id, workTime)\n    case &lt;-ctx.Done():\n        elapsed := time.Since(start)\n        fmt.Printf(\"Worker %d: Canceled after %v (%v)\\n\",\n                   id, elapsed.Round(time.Millisecond), ctx.Err())\n    }\n}\n</code></pre> <p>Inside the worker function, each worker either:</p> <ul> <li>Work time to finish: prints a complete message</li> <li>Context to be canceled: prints cancel message and how long it worked</li> </ul> <p>As shown below, workers 2 and 3's work was canceled as expected.</p> <pre><code>Worker 1: Finished work in 1s\nCanceling all the workers...\nWorker 3: Canceled after 2s (context canceled)\nWorker 2: Canceled after 2s (context canceled)\n</code></pre>"},{"location":"blog/20250521/20250521/#example-multi-level-contexts","title":"Example: Multi-level Contexts","text":"<p>Go's <code>contxt</code> forms a tree-like hierarchy where a context can be derived from other contexts. This structure allows precise control over cancellation scope.</p> <p>Here is a sample code for multiple level contexts. Consider the following context tree:</p> <pre><code>ctx (root)\n|\u2500\u2500 ctx1 (WithCancel)\n\u2502   \u251c\u2500\u2500 ctx1a (WithTimeout)\n\u2502   \u2514\u2500\u2500 ctx1b (WithValue)\n\u2514\u2500\u2500 ctx2 (WithDeadline)\n</code></pre> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    ctx, cancel := context.WithCancel(context.Background())\n\n    ctx1, cancel1 := context.WithCancel(ctx)\n    ctx1a, _ := context.WithTimeout(ctx1, 2*time.Second)\n    ctx1b := context.WithValue(ctx1, \"key\", \"value\")\n\n    ctx2, cancel2 := context.WithDeadline(ctx, time.Now().Add(5*time.Second))\n\n    // simulate cancellation\n    cancel()\n\n    select {\n    case &lt;-ctx1a.Done():\n        fmt.Println(\"ctx1a canceled: \", ctx1a.Err())\n    case &lt;-time.After( * time.Second):\n        fmt.Println(\"ctx1a still alive\")\n    }\n\n    select {\n    case &lt;-ctx1b.Done():\n        fmt.Println(\"ctx1b canceled: \", ctx1b.Err())\n    case &lt;-time.After(3 * time.Second):\n        fmt.Println(\"ctx1b still alive\")\n    }\n\n    select {\n    case &lt;-ctx2.Done():\n        fmt.Println(\"ctx2 canceled: \", ctx1a.Err())\n    case &lt;-time.After(3 * time.Second):\n        fmt.Println(\"ctx2 still alive\")\n    }\n\n}\n</code></pre> <ol> <li> <p>Calling <code>cancel()</code> on <code>ctx</code></p> <p>Calling <code>cancel()</code> on the root context cancels all its child contexts, including <code>ctx1</code>, <code>ctx1a</code>, <code>ctx1b</code>, and <code>ctx2</code>. This demonstrates that canceling a parent cancels all of its descendants.</p> <pre><code>ctx1  canceled:  context canceled\nctx1a canceled:  context canceled\nctx1b canceled:  context canceled\nctx2  canceled:  context canceled\n</code></pre> </li> <li> <p>Calling <code>cancel()</code> on <code>ctx1</code></p> <p>Calling <code>cancel()</code> on <code>ctx1</code> cancels <code>ctx1</code> and its children (<code>ctx1a</code>, <code>ctx1b</code>) but does not affect the root <code>ctx</code> or its sibling <code>ctx2</code>. This shows that canceling a child context does not impact its parent or siblings.</p> <pre><code>ctx1  canceled:  context canceled\nctx1a canceled:  context canceled\nctx1b canceled:  context canceled\nctx2  still alive\n</code></pre> </li> <li> <p>Not calling any <code>cancel()</code> function</p> <p>If no <code>cancel()</code> function is called, contexts like <code>ctx1a</code> and <code>ctx2</code> will still get canceled automatically when their timeouts or deadlines are reached, while others remain unaffected.</p> <pre><code>ctx1  still alive\nctx1a canceled:  context deadline exceeded\nctx1b still alive\nctx2  canceled:  context deadline exceeded\n</code></pre> </li> </ol>"},{"location":"blog/20250521/20250521/#graceful-shutdown","title":"Graceful Shutdown","text":"<p>A recent section highlights how <code>context</code> allows us to coordinate and control concurrent tasks, enabling some to finish naturally while others are safely stopped. This control becomes crucial during shutdown in real-world services\u2014especially network functions like those in free5GC.</p> <p>In any long-running service, graceful shutdown is essential for ensuring a clean and controlled termination of processes. A graceful shutdown means the application:</p> <ul> <li>Stops accepting new requests</li> <li>Waits for in-progress operations to finish before exits</li> <li>Releases resources</li> <li>Notifies other systems/services</li> </ul>"},{"location":"blog/20250521/20250521/#example-amf-entry-point-in-free5gc","title":"Example: AMF Entry Point in free5GC","text":"<p>NFs in free5GC often need to manage user sessions(e.g., PDU sessions, UE context), maintain HTTP server connections, and interact with databases or external systems. If these are abruptly stopped(e.g., <code>kill -9</code> or <code>os.Exit()</code>), it can lead to:</p> <ul> <li>Lost session state: UE sessions maintained in memory are instantly discarded without notifying other network functions, which results in the inconsistent state across the core network.</li> <li>Stuck network tunnels: UPF tunnels that were established by SMF or UPF may not be released properly, wasting system resources and potentially causing traffic routing issues.</li> <li>Unreleased timers or goroutines: Services like AMF maintain NAS and timers. If not stopped cleanly, timers and their associated goroutins continue running in the background or are killed mid-execution, possibly leaking resources or creating zombie behavior.</li> </ul> <p>To support graceful shutdown in practice, free5GC components are designed to listen for OS signals and respond by cleaning up resources and terminating safely. This is typically handled using Go\u2019s context package and signal handling patterns.</p> <p>Take the <code>action()</code> function as an example, which is the main entry point for starting the AMF component in free5GC.</p> <pre><code>func action(cliCtx *cli.Context) error {\n    tlsKeyLogPath, err := initLogFile(cliCtx.StringSlice(\"log\"))\n    if err != nil {\n        return err\n    }\n\n    logger.MainLog.Infoln(\"AMF version: \", version.GetVersion())\n\n    ctx, cancel := context.WithCancel(context.Background())\n    sigCh := make(chan os.Signal, 1)\n    signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)\n\n    go func() {\n        &lt;-sigCh // Wait for interrupt signal to gracefully shutdown\n        cancel()// Notify each goroutine and wait them stopped\n    }()\n\n    cfg, err := factory.ReadConfig(cliCtx.String(\"config\"))\n    if err != nil {\n        return err\n    }\n    factory.AmfConfig = cfg\n\n    amf, err := service.NewApp(ctx, cfg, tlsKeyLogPath)\n    if err != nil {\n        return err\n    }\n    AMF = amf\n\n    amf.Start()\n\n    return nil\n}\n</code></pre> <p>In the function, a root context is created and will be passed down to the AMF application, enabling it to listen for cancellation signals.</p> <p>Sets up a channel <code>sigCh</code> to listen for OS signals like <code>os.Interrupt</code>(Ctrl+C) or <code>SIGTERM</code>(standard termination signal).</p> <p>The <code>func()</code> launches a goroutine that waits for the siganl. After receiving one, it calls <code>cancel()</code> to propagate the shutdown siganl to the context-aware componets.</p> <p></p>"},{"location":"blog/20250521/20250521/#example-httpservershutdown","title":"Example: http.Server.Shutdown","text":"<p>Individual services within a network function\u2014such as the SBI (Service-Based Interface) HTTP server\u2014also need to terminate cleanly. Simply killing the server risks breaking ongoing API transactions with other network functions like SMF or NRF.</p> <p>Go's standard library provides a dedicated method <code>http.Server.Shutdown()</code> to solve this. It allows network functions to terminate their servers without dropping API clients(e.g., other NF components) and helps maintain proper 5G core service coordination.</p> <pre><code>func (s *Server) Stop() {\n    const defaultShutdownTimeout time.Duration = 2 * time.Second\n\n    if s.httpServer != nil {\n        logger.SBILog.Infof(\"Stop SBI server (listen on %s)\", \n                            s.httpServer.Addr)\n        toCtx, cancel := context.WithTimeout(context.Background(), \n                                             defaultShutdownTimeout)\n        defer cancel()\n        if err := s.httpServer.Shutdown(toCtx); err != nil {\n            logger.SBILog.Errorf(\"Could not close SBI server: %#v\", err)\n        }\n    }\n}\n</code></pre> <p>A context with a 2-second timeout is created using <code>context.WithTimeout</code>. This context is later passed to <code>Shutdown()</code>, giving the server up to 2 seconds to complete any ongoing requests before forcibly closing. Without a timeout, a hanging request could block shutdown indefinitely.</p> <p>This approach ensures that the server does not abruptly terminate active connections, which is especially important in a 5G core environment where network functions must coordinate smoothly. By using <code>http.Server.Shutdown()</code> with a timeout context, the system preserves service integrity, avoids resource leaks, and promotes reliable communication between components during shutdown.</p>"},{"location":"blog/20250521/20250521/#conclusion","title":"Conclusion","text":"<p>Go context is not just a utility but a design pattern in concurrent programming. In free5GC, it helps enforce timeouts, propagate cancellations, and perform graceful shutdowns. These features are essential for building reliable telecom software, where timing and cleanup are non-negotiable.</p> <p>Adding comprehensive <code>context.Context</code> usage is a step toward production readiness for any service \u2014 including a 5G Core component as critical as the AMF.</p>"},{"location":"blog/20250521/20250521/#reference","title":"Reference","text":"<ul> <li>\u7528 10 \u5206\u9418\u4e86\u89e3 Go \u8a9e\u8a00 context package \u4f7f\u7528\u5834\u666f\u53ca\u4ecb\u7d39</li> <li>How to Terminate Go Programs Elegantly - A Guide to Graceful Shutdonws</li> <li>context package</li> </ul>"},{"location":"blog/20250521/20250521/#about","title":"About","text":"<p>Hi, I'm Yung-Hsuan! A newcomer to 5G and the free5GC community. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20250521/20250521/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: https://github.com/reki9185</li> </ul>"},{"location":"blog/20250625/20250625/","title":"A Practical Guide to Network Slicing and Traffic Steering with free5GC and OAI-MEC","text":"<p>Note</p> <p>Author: Fang-Kai Ting Date: 2025/07/03</p> <p>This guide provides a step-by-step walkthrough for implementing advanced 5G features on a free5GC deployment. It demonstrates how to configure OAI-MEC, create multiple network slices, and manage data paths using traffic steering with an Application Function (AF), culminating in a multi-slice, multi-MEC application architecture.</p> <p>Acknowledgements</p> <p>Special thanks to wilson30139 for providing many of the configuration files used in this lab. This article would not have been possible without his contributions.</p>"},{"location":"blog/20250625/20250625/#intro","title":"Intro","text":"<p>In a previous article, we described an architecture where the UPF is deployed on an edge node, with the rest of the core network functions residing on a central core node. We then ran a ping test using a local UE to validate the setup.</p> <p>This time, we will build upon that foundation by using the network slicing and traffic steering capabilities of the free5GC core. We will deploy a cluster containing two network slices. Each slice will have its own dedicated UPF and a simple Multi-access Edge Computing (MEC) application on the edge node. The main core network will host the other NFs and an identical application. This setup simulates a scenario where users in each network slice have a dedicated data plane and a specialized MEC application.</p> <p>For the detailed VM configuration, please refer to the previous article. All VM and cluster settings for this tutorial will remain the same.</p> <p>Optimizing free5GC Through Local UE Traffic and Dedicated UPF: A Multi-Node Helm Deployment Approach - free5GC</p> <p>It's important to note that we are using free5GC <code>v3.4.5</code>, because <code>v4.0.0</code> does not support traffic steering for the NEF (Network Exposure Function).</p> <p>The diagram below illustrates the final architecture. This article will guide you through three experiments to build this setup step-by-step.</p> <p></p>"},{"location":"blog/20250625/20250625/#lab-outline","title":"Lab outline","text":"<p>Part 1: OAI-MEC Installation Base on previous article structure, add the MEC Platform (MEP) and a MEC application, and then complete a basic ping test to verify the setup.</p> <p>Part 2: OAI-MEC App with Traffic Steering Integrate the OpenNESS Application Function (AF). Then, use the AF and the Network Exposure Function (NEF) to send new packet routing rules to the network.</p> <p>Part 3: Two Slices with Two MEC Apps and Traffic Steering Create and deploy two network slices. Next, use the MEP's gateway and registry mechanisms to enable service discovery for the MEC applications. Finally, apply traffic steering to achieve independent traffic control for each of the two slices.</p> <p>Each of the three experiments will cover the following sections:</p> <ol> <li>Architecture</li> <li>Tools Introduction</li> <li>Implementation and Configuration</li> <li>Execution Commands and Results</li> </ol>"},{"location":"blog/20250625/20250625/#lab-1-installing-the-oai-mec-platform","title":"Lab 1: Installing the OAI-MEC Platform","text":""},{"location":"blog/20250625/20250625/#architecture","title":"Architecture","text":"<p>Lab 1 will begin by deploying a MEC application on the edge node. We will then modify the UPF configuration to allow the UE (User Equipment) to route traffic to the external network via the <code>uesimtun0</code> interface, and also to direct traffic to the MEC application. We will use the OAI-MEC platform, available at OAI MEP repo. In the diagram, the green component represents the MEP (Multi-access Edge Computing Platform), which manages the entire lifecycle of the MEC application.</p> <p></p>"},{"location":"blog/20250625/20250625/#tools-introduction","title":"Tools Introduction","text":""},{"location":"blog/20250625/20250625/#oai-mec","title":"OAI-MEC","text":"<p>OAI-MEC is a project under the OpenAirInterface (OAI) banner that focuses on developing an open-source Multi-access Edge Computing (MEC) platform. It is designed to be compliant with the European Telecommunications Standards Institute (ETSI) MEC standards.</p> <p>The project provides key components like the MEC Platform (MEP) and a Radio Network Information Service (RNIS), enabling the deployment and management of edge applications. By integrating with OAI's 5G core and Radio Access Network (RAN), OAI-MEC allows developers and researchers to explore, test, and innovate on low-latency applications and services at the network edge, which is crucial for 5G use cases.</p> <ul> <li>OAI MEP registry This component tells the OAI MEP gateway where to find registered MEC applications and services.</li> <li>OAI MEP registry DB This database stores the service information that the OAI MEP registry relies on to function.</li> <li>OAI MEP gateway It receives API requests, asks the OAI MEP registry for the correct service location, and then forwards the request accordingly. It reads its own rules from the OAI MEP gateway DB.</li> <li>OAI MEP gateway DB This database holds the configuration rules that the OAI MEP gateway uses to manage and route traffic.</li> <li>OAI kong migration This is a process used to update the configuration data within the OAI MEP gateway DB, which in turn changes the behavior of the OAI MEP gateway.</li> </ul>"},{"location":"blog/20250625/20250625/#implementation-and-configuration","title":"Implementation and Configuration","text":"<p>Place <code>oai-mec</code> and <code>oai-mep</code> under the <code>free5GC-helm/charts</code> directory as shown in the diagram.</p> <p>The <code>oai-mep</code> and <code>oai-mec-app</code> are configuration files provided by wilson30139, which are modified from the original files at OAI GitLab.</p> <p>The original files can be found at this commit: MEP and MEC app file. You can copy and modify them as needed.</p> <p>For detailed reference on IP address modifications and other changes, see this commit: MEP and MEC app modification.</p> <pre><code>\u251c\u2500\u2500 charts\n\u2502   \u251c\u2500\u2500 app\n\u2502   \u251c\u2500\u2500 free5gc-amf\n...\n\u2502   \u251c\u2500\u2500 free5gc-webui\n\u2502   \u251c\u2500\u2500 oai-mec-app\n                \u251c\u2500\u2500 charts\n                \u251c\u2500\u2500 Chart.yaml\n                \u251c\u2500\u2500 templates\n                \u2502   \u251c\u2500\u2500 _helpers.tpl\n                \u2502   \u251c\u2500\u2500 mec-app-1\n                \u2502   \u2502   \u251c\u2500\u2500 mec-app-1-configmap.yaml\n                \u2502   \u2502   \u251c\u2500\u2500 mec-app-1-deployment.yaml\n                \u2502   \u2502   \u251c\u2500\u2500 mec-app-1-nad.yaml\n                \u2502   \u2502   \u2514\u2500\u2500 mec-app-1-service.yaml\n                \u2502   \u2514\u2500\u2500 NOTES.txt\n                \u2514\u2500\u2500 values.yaml\n\u2502   \u251c\u2500\u2500 oai-mep\n                \u251c\u2500\u2500 charts\n                \u251c\u2500\u2500 Chart.yaml\n                \u251c\u2500\u2500 templates\n                \u2502   \u251c\u2500\u2500 _helpers.tpl\n                \u2502   \u251c\u2500\u2500 kong-migration\n                \u2502   \u2502   \u251c\u2500\u2500 kong-migration-job.yaml\n                \u2502   \u2502   \u2514\u2500\u2500 kong-migration-nad.yaml\n                \u2502   \u251c\u2500\u2500 mep-gateway\n                \u2502   \u2502   \u251c\u2500\u2500 mep-gateway-deployment.yaml\n                \u2502   \u2502   \u251c\u2500\u2500 mep-gateway-nad.yaml\n                \u2502   \u2502   \u2514\u2500\u2500 mep-gateway-service.yaml\n                \u2502   \u251c\u2500\u2500 mep-gateway-db\n                \u2502   \u2502   \u251c\u2500\u2500 mep-gateway-db-deployment.yaml\n                \u2502   \u2502   \u251c\u2500\u2500 mep-gateway-db-nad.yaml\n                \u2502   \u2502   \u2514\u2500\u2500 mep-gateway-db-service.yaml\n                \u2502   \u251c\u2500\u2500 mep-registry\n                \u2502   \u2502   \u251c\u2500\u2500 mep-registry-deployment.yaml\n                \u2502   \u2502   \u251c\u2500\u2500 mep-registry-nad.yaml\n                \u2502   \u2502   \u2514\u2500\u2500 mep-registry-service.yaml\n                \u2502   \u251c\u2500\u2500 mep-registry-db\n                \u2502   \u2502   \u251c\u2500\u2500 mep-registry-db-deployment.yaml\n                \u2502   \u2502   \u251c\u2500\u2500 mep-registry-db-nad.yaml\n                \u2502   \u2502   \u2514\u2500\u2500 mep-registry-db-service.yaml\n                \u2502   \u2514\u2500\u2500 NOTES.txt\n                \u2514\u2500\u2500 values.yaml\n\u2502   \u2514\u2500\u2500 openness-af\n</code></pre> <ol> <li> <p>Modify all YAML configuration files for the MEP and MEC app.</p> <p>This includes, but is not limited to, updating the settings for the following components within the MEP:</p> <ul> <li>MEP gateway DB IP address</li> <li>MEP registry DB IP address</li> <li>kong-migration service</li> <li>MEP gateway IP address</li> <li>MEP registry IP address</li> <li>MEC app IP address</li> <li>Edge node name</li> <li>NAT network interface card name</li> <li>NAT network interface card</li> </ul> <p>An example of the required IP address modifications is shown in the figure below.</p> Name IP Address OAI MEP Gateway DB 10.0.2.3 OAI MEP Registry DB 10.0.2.4 OAI Kong Migration 10.0.2.5 OAI MEP Gateway 10.0.2.6 OAI MEP Registry 10.0.2.7 OAI MEC App 1 10.0.2.105 2. Modify the UPFb and UPF1 configurations. <pre><code># file path: charts/free5gc/charts/free5gc-upf/templates/upf1/upf1-configmap.yaml\niptables -A FORWARD -j ACCEPT\niptables -t nat -A POSTROUTING -s {{ $.Values.global.uesubnet }} -o n6 -j MASQUERADE \necho \"1200 n6if\" &gt;&gt; /etc/iproute2/rt_tables\nip rule add from {{ $.Values.global.uesubnet }} to 10.0.2.0/24 lookup main prio 20000\nip rule add from {{ $.Values.global.uesubnet }} table n6if prio 25000\nip route add default via {{ $.Values.global.n6network.gatewayIP }} dev n6 table n6if\n</code></pre> <pre><code># file path: charts/free5gc/charts/free5gc-upf/templates/upfb/upfb-configmap.yaml\niptables -A FORWARD -j ACCEPT\niptables -t nat -A POSTROUTING -s {{ $.Values.global.uesubnet }} -o n6 -j MASQUERADE  # Allow routing traffic comming from the UE SUBNET to the interface N6\niptables -t nat -A POSTROUTING -o n9 -j MASQUERADE\niptables -t nat -A POSTROUTING -o n3 -j MASQUERADE\nip rule add from {{ $.Values.global.uesubnet }} to 10.0.2.0/24 lookup main prio 20000\n</code></pre> <p>When a UE pings the <code>MEC app</code>, the default UPF rule inspects the routing table of the N6 interface. However, the <code>n6if</code> routing table only contains a default route: <code>default via 10.0.2.2 dev n6</code>.</p> <p>Therefore, a new rule must be added. This rule will ensure that when an IP packet originates from the <code>uesubnet</code> and is destined for the <code>10.0.2.0/24</code> network, the system will use the main routing tables of <code>upfb</code> and <code>upf1</code> to find the correct forwarding path to the <code>mec-app</code>.</p> <pre><code>ip rule add from {{ $.Values.global.uesubnet }} to 10.0.2.0/24 lookup main prio 20000\nip rule add from {{ $.Values.global.uesubnet }} table n6if prio 25000\n</code></pre> </li> </ol>"},{"location":"blog/20250625/20250625/#execution-commands-and-results","title":"Execution Commands and Results","text":"<p>After the deployment is complete, you can ping the <code>MEC app</code> from the <code>uesimtun0</code> interface. The traffic will be routed through <code>upfb</code> and <code>upf1</code>.</p> <p></p> <p></p>"},{"location":"blog/20250625/20250625/#lab-2-traffic-steering","title":"Lab 2: Traffic Steering","text":""},{"location":"blog/20250625/20250625/#architecture_1","title":"Architecture","text":"<p>In lab1, add a new <code>app</code> to the core network that is identical to the <code>MEC app</code>. Then, configure traffic steering to redirect traffic, which would normally be routed to this new core application, to the <code>MEC app</code> instead.</p> <p>Since both the ping command and traffic steering rules operate based on the destination IP address, the core application and the <code>MEC app</code> must be assigned the same IP address. As a result, they can share the same Network Attachment Definition (NAD).</p> <ol> <li> <p>After traffic steering: Branch UPF \u2192 Anchor UPF\u2192<code>app1</code></p> <p></p> </li> <li> <p>After traffic steering: Branch UPF \u2192 <code>mec-app1</code></p> <p></p> </li> </ol>"},{"location":"blog/20250625/20250625/#tools-introduction_1","title":"Tools Introduction","text":""},{"location":"blog/20250625/20250625/#af","title":"AF","text":"<p>The Application Function (AF) is a crucial element in the 5G architecture that allows external applications to interact with the 5G core network. Its primary role is to influence network behavior based on application-specific requirements.</p> <p>The AF provides information to the Policy Control Function (PCF) via the Network Exposure Function (NEF), enabling it to make informed decisions about Quality of Service (QoS) and traffic routing.</p> <p>This allows the network to dynamically create and manage PDU sessions.</p>"},{"location":"blog/20250625/20250625/#implementation-and-configuration_1","title":"Implementation and Configuration","text":""},{"location":"blog/20250625/20250625/#af_1","title":"AF","text":"<p>This is not part of the official free5GC project, so you need to add the AF (Application Function) Image to the Edge Node separately.</p> <ol> <li><code>git clone [https://github.com/danielh1204/opennessAF.git](https://github.com/danielh1204/opennessAF.git)</code></li> <li><code>cd opennessAF/af</code></li> <li><code>docker build -t af .</code></li> <li><code>docker save af:latest -o af.tar</code></li> <li><code>docker tag af:latest localhost:32000/af:latest</code></li> <li><code>docker push localhost:32000/af:latest</code><ol> <li>This step uses the local registry feature of MicroK8s.</li> <li><code>microk8s enable registry</code></li> </ol> </li> </ol> <p>The charts for <code>openness-af</code> are available in this commit: OpenNESS af file, and are also provided by wilson30139. You can download and modify them.</p> <p>For detailed configuration changes, please refer to this commit: OpenNESS af modification.</p>"},{"location":"blog/20250625/20250625/#app","title":"App","text":"<p>Copy the <code>MEC app</code> folder and rename it to <code>app</code>. This will be the application deployed on the core network, serving as the initial target for traffic steering.</p>"},{"location":"blog/20250625/20250625/#ti_datajson","title":"ti_data.json","text":"<p>This is the configuration file for traffic steering, which can be modified according to your specific requirements.</p> <ol> <li>dnn</li> <li>dnai</li> <li> <p>flowdescription</p> <pre><code>{\n    \"afServiceId\": \"Service1\",\n    \"dnn\": \"internet\",\n    \"snssai\": {\n        \"sst\": 1,\n        \"sd\": \"010203\"\n    },\n    \"anyUeInd\": true,\n    \"notificationDestination\": \"http://af:8000/test123\",\n    \"trafficFilters\": [\n        {\n            \"flowId\": 1,\n            \"flowDescriptions\": [\n                \"permit out ip from 10.0.2.105 to [uesubnetip](ex:10.1.0.0/24)\"\n            ]\n        }\n    ],\n    \"trafficRoutes\": [\n        {\n            \"dnai\": \"mec\"\n        }\n    ]\n}\n</code></pre> </li> </ol>"},{"location":"blog/20250625/20250625/#execution-commands-and-results_1","title":"Execution Commands and Results","text":""},{"location":"blog/20250625/20250625/#af-request-below-command-all-run-inside-af-pod","title":"AF request (Below command all run inside AF pod)","text":"<ol> <li><code>kubectl exec -it [AF Pod Name] -n free5gc -- sh</code></li> <li><code>vim ti_data.json</code><ol> <li>Paste the <code>ti_data.json</code> configuration from above. If needed, modify the <code>uesubnet</code> section to <code>10.1.0.0/24</code>.</li> <li>If you cannot use <code>curl</code> or <code>vim</code> within the AF pod, simply add them to the installation command in the AF <code>Dockerfile</code>.</li> </ol> </li> <li><code>curl -X POST -H \"Content-Type: application/json\" --data @./[File Name] http://[NEF Service IP Address]/3gpp-traffic- influence/v1/af001/subscriptions</code><ol> <li>ex: <code>curl -X POST -H \"Content-Type: application/json\" --data @./ti_data.json [http://10.152.183.217:80/3gpp-traffic-influence/v1/af001/subscriptions](http://10.152.183.217/3gpp-traffic-influence/v1/af001/subscriptions)</code></li> </ol> </li> </ol>"},{"location":"blog/20250625/20250625/#ping-test","title":"Ping test","text":"<ul> <li> <p>Before traffic steering:</p> <ul> <li>Left side: <code>upfb.n9</code> | Right side: <code>upf1.upfgtp</code></li> <li> <p><code>upfb.n9</code> \u2192 <code>upf1.upfgtp</code></p> <p></p> </li> </ul> </li> <li> <p>After traffic steering:</p> <ul> <li> <p><code>upfb.upfgtp</code></p> <p></p> </li> </ul> </li> </ul>"},{"location":"blog/20250625/20250625/#lab-3-two-slice-with-two-mec-app-with-traffic-steering","title":"Lab 3: Two slice with two MEC-app with traffic steering","text":"<ol> <li>Architecture</li> <li>Tools Introduction</li> <li>Implementation and Configuration</li> <li>Execution Commands and Results</li> </ol>"},{"location":"blog/20250625/20250625/#architecture_2","title":"Architecture","text":"<p>In Lab 3, you will need to use the web console to create two network slices. In the SMF and UPF configurations, you will then set up the traffic to route through its dedicated network slice. Finally, you will use traffic steering to control the traffic flow to the <code>MEC app</code>.</p> <p>First network slice (dedicated resources):</p> <ul> <li>Branch UPF1</li> <li>OAI MEC app 1</li> <li>Anchor UPF1</li> <li>app 1</li> </ul> <p>Second network slice (dedicated resources):</p> <ul> <li>Branch UPF2</li> <li>OAI MEC app 2</li> <li>Anchor UPF2</li> <li>app 2</li> </ul> <p>Shared Resources:</p> <ul> <li>Core Network NFs</li> <li>OAI-MEP</li> <li>AF</li> </ul> <p></p> <p></p>"},{"location":"blog/20250625/20250625/#tools-introduction_2","title":"Tools Introduction","text":""},{"location":"blog/20250625/20250625/#network-slicing","title":"Network Slicing","text":"<p>In free5GC, different network slices are distinguished using identifiers such as the S-NSSAI (Single Network Slice Selection Assistance Information) and DNN (Data Network Name).</p> <p>This allows each slice to be configured with its own dedicated UPF, making it possible to provide specialized services and guarantee specific QoS levels for each slice.</p>"},{"location":"blog/20250625/20250625/#implementation-and-configuration_2","title":"Implementation and Configuration","text":""},{"location":"blog/20250625/20250625/#amf-smf-upf-config","title":"AMF, SMF, UPF config","text":"<p>Referring to the architecture diagram above, here are the UPF names and their corresponding interface IP addresses.</p> <p>branch upf1: upfb</p> <p>branch upf2: upfb2</p> <p>anchor upf1: upf1</p> <p>anchor upf2: upf2</p> upfb upfb2 upf1 upf2 N3 192.168.56.19 192.168.56.38 X X N4 10.100.50.241 10.100.50.242 10.100.50.243 10.100.50.245 N6 10.0.2.15 10.0.2.16 10.0.2.13 10.0.2.14 N9 10.100.50.225 10.100.50.226 10.100.50.227 10.100.50.228 <p>The detailed configuration file for the following can be found in AMF, SMF, UPF modification</p>"},{"location":"blog/20250625/20250625/#amf","title":"AMF","text":"<p>Add <code>internet2</code> to the <code>supportDnnList</code>.</p>"},{"location":"blog/20250625/20250625/#smf","title":"SMF","text":"<p>Addition to <code>snssaiInfos</code></p> <pre><code>- sNssai:Add commentMore actions\n      sst: 1\n      sd: 112233\n    dnnInfos: # DNN information list\n      - dnn: internet2 # Data Network Name\n        dnaiList:\n          - mec2\n        dns: # the IP address of DNS\n          ipv4: 8.8.8.8\n          ipv6: 2001:4860:4860::8888\n</code></pre> <p>You need to configure <code>userplaneInformation</code> and <code>ueRoutingInfo</code> with the corresponding IP addresses and specify the specific paths for the two UEs.</p>"},{"location":"blog/20250625/20250625/#upf","title":"UPF","text":"<p>First, add a new UPF instance named <code>upfb2</code>.</p> <p>Then, modify the Helm template file at <code>free5gc-upf/templates/_helpers.tpl</code> to update the configurations for all relevant UPF instances: <code>upf1</code>, <code>upf2</code>, <code>upfb</code>, and the new <code>upfb2</code>.</p>"},{"location":"blog/20250625/20250625/#create-a-new-network-slice","title":"Create a new network slice","text":"<ol> <li> <p>Based on the screenshots from the free5GC v3.4.5 web console below, we will create a network slice named <code>internet2</code>.</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> </li> </ol>"},{"location":"blog/20250625/20250625/#when-a-ue-uses-the-oai-mec-app-service","title":"When a UE uses the OAI MEC App Service","text":"<p>In the UE VM, edit the <code>/etc/hosts</code> file (e.g., <code>vim /etc/hosts</code>) and add the following line:</p> <p><code>[OAI MEP Gateway IP Address] oai-mep.org</code></p>"},{"location":"blog/20250625/20250625/#use-the-local-mec-app-image","title":"Use the local <code>MEC app</code> image","text":"<p>The <code>MEC app</code> image often exceeds Docker's pull rate limits, causing the deployment to fail. Therefore, you need to build the image locally and push it to the MicroK8s local registry. You can find a reference for the Dockerfile at this commit: MEC app dockerfile.</p> <p>Modify the <code>mec-app-1-deployment.yaml</code> to use the image: <code>localhost:32000/mec-app1:v1</code>.</p>"},{"location":"blog/20250625/20250625/#ti_data2json","title":"ti_data2.json","text":"<p>The JSON file for UE2 traffic steering.</p> <pre><code>{\n    \"afServiceId\": \"Service2\",\n    \"dnn\": \"internet2\",\n    \"snssai\": {\n        \"sst\": 1,\n        \"sd\": \"112233\"\n    },\n    \"anyUeInd\": true,\n    \"notificationDestination\": \"http://af:8000/test123\",\n    \"trafficFilters\": [\n        {\n            \"flowId\": 2,\n            \"flowDescriptions\": [\n                \"permit out ip from 10.0.2.107 to [uesubnetip]\"\n            ]\n        }\n    ],\n    \"trafficRoutes\": [\n        {\n            \"dnai\": \"mec2\"\n        }\n    ]\n}\n</code></pre>"},{"location":"blog/20250625/20250625/#execution-commands-and-results_2","title":"Execution Commands and Results","text":""},{"location":"blog/20250625/20250625/#deployment-example","title":"Deployment example","text":"<p>The <code>MEC app</code> should have a 'Running' status. If it restarts repeatedly or gets stuck in a loop, it indicates a problem with the application.</p> <p></p>"},{"location":"blog/20250625/20250625/#ping-test_1","title":"Ping test","text":"<p><code>curl --interface uesimtun0 [http://oai-mep.org:8002/first_mec_app/v1/second_web_page](http://oai-mep.org:8002/first_mec_app/v1/second_web_page)</code></p> <p><code>curl --interface uesimtun1 [http://oai-mep.org:8002/second_mec_app/v1/second_web_page](http://oai-mep.org:8002/second_mec_app/v1/second_web_page)</code></p>"},{"location":"blog/20250625/20250625/#mec-app-e2e-test","title":"Mec-app E2E test","text":"<ol> <li> <p>Before traffic steering</p> <ol> <li>Using the MEP's gateway registry system to retrieve the <code>MEC app</code> content.</li> <li> <p><code>curl --interface uesimtun0 [http://oai-mep.org:8002/first_mec_app/v1/second_web_page](http://oai-mep.org:8002/first_mec_app/v1/second_web_page)</code></p> <p></p> </li> <li> <p><code>curl --interface uesimtun1 [http://oai-mep.org:8002/second_mec_app/v1/second_web_page](http://oai-mep.org:8002/second_mec_app/v1/second_web_page)</code></p> <p></p> </li> <li> <p>The following are the <code>tcpdump</code> results from each UPF. The N9 interface is on the left, and the <code>upfgtp</code> interface is on the right. As you can see, the traffic is still being routed from the branch UPF to the anchor UPF.</p> <ol> <li> <p>upf1</p> <p></p> </li> <li> <p>upf2</p> <p></p> </li> <li> <p>upfb</p> <p></p> </li> <li> <p>upfb2</p> <p></p> </li> </ol> </li> </ol> </li> <li> <p>Traffic steering command</p> <ol> <li><code>curl -X POST -H \"Content-Type: application/json\" --data @./ti_data.json [http://10.152.183.217:80/3gpp-traffic-influence/v1/af001/subscriptions](http://10.152.183.217/3gpp-traffic-influence/v1/af001/subscriptions)</code></li> <li><code>curl -X POST -H \"Content-Type: application/json\" --data @./ti_data2.json [http://10.152.183.217:80/3gpp-traffic-influence/v1/af001/subscriptions](http://10.152.183.217/3gpp-traffic-influence/v1/af001/subscriptions)</code></li> </ol> </li> <li> <p>After traffic steering</p> <ol> <li><code>curl --interface uesimtun0 [http://10.0.2.105/v1/second_web_page](http://10.0.2.105/v1/second_web_page)</code></li> <li> <p>The left side corresponds to the N9 interface, and the right side corresponds to the <code>upfgtp</code> interface.</p> <p>After traffic steering is applied, the traffic is sent directly out from the <code>upfgtp</code> interface of the branch UPF.</p> <ol> <li> <p>upf1</p> <p></p> </li> <li> <p>upfb</p> <p></p> </li> </ol> </li> <li> <p><code>curl --interface uesimtun1 [http://10.0.2.107/v1/second_web_page](http://10.0.2.107/v1/second_web_page)</code></p> <ol> <li> <p>upf2</p> <p></p> </li> <li> <p>upfb2</p> <p></p> </li> </ol> </li> </ol> </li> </ol>"},{"location":"blog/20250625/20250625/#appendix","title":"Appendix","text":"<p>Here are some additional commands you can use to verify if the traffic steering was successful.</p> <p>UDR</p> <ol> <li> <p><code>curl -X GET -H \"Content-Type: application/json\" [http://10.152.183.38/nudr-dr/v1/application-data/influenceData?dnns=internet](http://10.152.183.38/nudr-dr/v1/application-data/influenceData?dnns=internet)</code></p> <p></p> <p></p> </li> </ol> <p>NEF</p> <ol> <li> <p>query command</p> <ol> <li> <p><code>curl -X GET -H \"Content-Type: application/json\" [http://10.152.183.217/3gpp-traffic-influence/v1/af001/subscriptions?dnns=internet](http://10.152.183.217/3gpp-traffic-influence/v1/af001/subscriptions?dnns=internet)</code></p> <p>self: The final number is the ID you will use for the delete operation.</p> <p></p> </li> </ol> </li> <li> <p>delete command</p> <ol> <li><code>curl -X DELETE -H \"Content-Type: application/json\" [http://10.152.183.217/3gpp-traffic-influence/v1/af001/subscriptions/2](http://10.152.183.217/3gpp-traffic-influence/v1/af001/subscriptions/2)</code></li> </ol> </li> </ol>"},{"location":"blog/20250625/20250625/#conclusion","title":"Conclusion","text":"<p>This guide provides a step-by-step walkthrough for implementing advanced 5G features on a free5GC deployment. It demonstrates how to configure OAI-MEC, create multiple network slices, and manage data paths using traffic steering with an Application Function (AF), culminating in a multi-slice, multi-MEC application architecture.</p>"},{"location":"blog/20250625/20250625/#reference","title":"Reference","text":"<p>Files \u00b7 master \u00b7 oai / orchestration / oai-mec / oai-mep \u00b7 GitLab</p> <p>https://github.com/qawl987/free5gc-helm</p>"},{"location":"blog/20250625/20250625/#about-me","title":"About me","text":"<p>Hi, I\u2019m Fang-Kai Ting, a newcomer to 5G and free5GC, and currently conducting research on Network Slicing. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20250625/20250625/#connect-with-me","title":"Connect with Me","text":"<p>Github:\u00a0qawl987</p> <p>Linkedin: www.linkedin.com/in/\u65b9\u51f1-\u4e01-a26a7925a</p>"},{"location":"blog/20250709/20250709/","title":"Time Synchronization with Linux Precision Time Protocol","text":"<p>Note</p> <p>Author: Pei-Chi, Cheng Date: 2025/07/09</p>"},{"location":"blog/20250709/20250709/#introduction","title":"Introduction","text":"<p>Linux PTP (Precision Time Protocol) is a software suite designed to implement the IEEE 1588 precision time synchronization protocol on the Linux operating system, providing high-accuracy time synchronization capabilities. IEEE 1588 is primarily designed for applications that require microsecond or even nanosecond-level synchronization accuracy, such as industrial automation, communication networks (e.g., 5G time synchronization) and financial trading systems.</p> <p>And it provides two main tools: - <code>ptp4l</code>: A daemon that implements the PTP protocol and is responsible for coordinating and synchronizing time with other devices. - <code>phc2sys</code>: A daemon that synchronizes the hardware clock (PHC) with the system clock to ensure consistent time at the system level.</p> <p>The following show the relation between NIC, Linux PTP and system clock.</p> <p></p> <p>The package supports hardware timestamping and can achieve high synchronization accuracy when paired with PTP-capable NICs (such as the Intel\u00ae I210) and suitable drivers. Linux PTP enables reliable and efficient time synchronization on standard Linux systems.</p>"},{"location":"blog/20250709/20250709/#difference-between-ptp-gptp-and-ntp","title":"Difference between PTP, gPTP and NTP","text":"<p>1. PTP (Precision Time Protocol) is a high-precision time synchronization protocol capable of achieving microsecond to nanosecond-level accuracy, which defined by IEEE 1588. It is designed for environments that require strict time coordination, such as industrial automation and communication systems.</p> <p>2. gPTP (Generalized Precision Time Protocol) is a profile of PTP and is optimized for Time-Sensitive Networking (TSN), it is defined by IEEE 802.1AS. It simplifies certain aspects of PTP to enable faster and more stable synchronization in local networks. gPTP also introduces the Grand Master election mechanism (BMCA), making it suitable for automotive and industrial TSN applications. For more details on TSN, refer to Time-Sensitive Networking over 5G system - Introduction (Rel-16).</p> <p>3. NTP (Network Time Protocol) is a general-purpose time synchronization protocol commonly used on the internet. It typically provides millisecond-level accuracy and is widely adopted in servers and workstations. However, its precision is lower than that of PTP, making it unsuitable for applications requiring very high accuracy.</p> <p>In summary, PTP and gPTP offer much higher synchronization accuracy than NTP. gPTP is an optimized version of PTP for specific use cases, especially in local networks where high reliability and low-latency synchronization are essential.</p>"},{"location":"blog/20250709/20250709/#ptp-clock-roles","title":"PTP Clock Roles","text":"<p>Linux PTP operates in a hierarchical structure with different clock roles: - Grand Master Clock (GM): The primary reference clock, selected via the Best Master Clock Algorithm (BMCA), provides the time source for the PTP domain. - Ordinary Clock (OC): A single-port device that acts as either a master or slave, synchronizing to the GM or a higher-level clock. - Boundary Clock (BC): A multi-port device that synchronizes to a master on one port and acts as a master to slaves on other ports. - Transparent Clock (TC): A device that forwards PTP messages while compensating for residence time (the time a message spends in the device).</p> <p></p>"},{"location":"blog/20250709/20250709/#ptp-mode-and-message-exchange-steps","title":"PTP Mode and Message Exchange Steps","text":"<p>Linux PTP supports two synchronization modes: - One-Step Mode: Timestamps are embedded directly in Sync messages. - Two-Step Mode: Timestamps are sent in a separate Follow_Up message for higher accuracy.</p> <p>The synchronization process involves five key message types: 1. Announce Message - Purpose: Advertise clock properties and participate in the BMCA process. - Sent by: Ordinary and Boundary Clocks. - Content Includes:     - Clock accuracy     - Priority values (Priority1 and Priority2)     - Clock class and identity - Function: Enables BMCA to select the Grandmaster.</p> <p>2. Sync Message - Purpose: Transmit the current time (T1) from the Grandmaster to the Slave. - Sent by: Grandmaster. - Timestamp: T1 is recorded when the Sync message leaves the Grandmaster.</p> <p>If the device is a 1-step clock, T1 is embedded directly in the Sync message. If it is a 2-step clock, the timestamp T1 is sent later in a Follow_Up message.</p> <p>3. Follow_Up Message (for 2-step clocks) - Purpose: Provides the precise T1 timestamp for the Sync message - Sent by: 2-step Grandmaster. - Usage: Ensures slaves receive accurate transmission times.</p> <p>4. Delay_Req Message - Purpose: Measure path delay between Slave and Grandmaster. - Sent by: Slave. - Timestamp: T2 is recorded when Delay_Req leaves the Slave.</p> <p>5. Delay_Resp Message - Purpose: Reply to the Delay_Req with the exact time (T3) it was received. - Sent by: Grandmaster. - Content: Contains timestamp T3</p> <p>Using these timestamps, the slave calculates: - Mean Path Delay: <code>[(t2 - t1) + (t4 - t3)] / 2</code> - Time offset: <code>[(t2 - t1) - (t4 - t3)] / 2</code></p> <p></p>"},{"location":"blog/20250709/20250709/#setting-up-linux-ptp","title":"Setting Up Linux PTP","text":""},{"location":"blog/20250709/20250709/#1-checking-system-requirements","title":"1. Checking System Requirements","text":""},{"location":"blog/20250709/20250709/#checking-network-interface-card-nic","title":"Checking Network Interface Card (NIC)","text":"<p>To confirm if your system has a PTP-capable NIC (e.g., Intel\u00ae I210), use the following command in Ubuntu: <pre><code>lspci | grep -i ethernet\n</code></pre></p> <p>If the NIC is exist, you should see output similar to: <pre><code>02:00.0 Ethernet controller: Intel Corporation I210 Gigabit Network Connection (rev 03)\n</code></pre></p> <p>If no relevant output appears, verify your NIC and consider rebooting the system.</p>"},{"location":"blog/20250709/20250709/#checking-linux-kernel","title":"Checking Linux Kernel","text":"<p>In order to run Linux PTP, you need Linux kernel version 3.0 or newer. Check your kernel version with: <pre><code>uname -r\n</code></pre></p> <p>And you will see something like: <pre><code>5.15.0-106-generic\n</code></pre></p>"},{"location":"blog/20250709/20250709/#checking-timestamping-support","title":"Checking Timestamping Support","text":"<p>Next, verify if your NIC supports PTP using: <pre><code>ethtool -T &lt;interface name&gt;\n</code></pre></p> <p>This command displays the NIC\u2019s timestamping capabilities. For example, hardware timestamping support might look like: <pre><code>Time stamping parameters for eth6:\nCapabilities:\n        hardware-transmit     (SOF_TIMESTAMPING_TX_HARDWARE)\n        software-transmit     (SOF_TIMESTAMPING_TX_SOFTWARE)\n        hardware-receive      (SOF_TIMESTAMPING_RX_HARDWARE)\n        software-receive      (SOF_TIMESTAMPING_RX_SOFTWARE)\n        software-system-clock (SOF_TIMESTAMPING_SOFTWARE)\n        hardware-raw-clock    (SOF_TIMESTAMPING_RAW_HARDWARE)\nPTP Hardware Clock: 1\nHardware Transmit Timestamp Modes:\n        off                   (HWTSTAMP_TX_OFF)\n        on                    (HWTSTAMP_TX_ON)\nHardware Receive Filter Modes:\n        none                  (HWTSTAMP_FILTER_NONE)\n        all                   (HWTSTAMP_FILTER_ALL)\n</code></pre></p> <p>If only software timestamping is supported, the output may look like: <pre><code>Time stamping parameters for enp6s0:\nCapabilities:\n        software-transmit     (SOF_TIMESTAMPING_TX_SOFTWARE)\n        software-receive      (SOF_TIMESTAMPING_RX_SOFTWARE)\n        software-system-clock (SOF_TIMESTAMPING_SOFTWARE)\nPTP Hardware Clock: none\nHardware Transmit Timestamp Modes: none\nHardware Receive Filter Modes: none\n</code></pre></p>"},{"location":"blog/20250709/20250709/#2-installing-linux-ptp","title":"2. Installing Linux PTP","text":"<p>To get Linux PTP, use the following command. <pre><code>git clone http://git.code.sf.net/p/linuxptp/code linuxptp\ncd linuxptp/\nmake\nsudo make install\n</code></pre></p>"},{"location":"blog/20250709/20250709/#3-synchronizing-to-ptp-hardware-clock-phc","title":"3. Synchronizing to PTP Hardware Clock (PHC)","text":"<p>For hardware timestamping, use the following commands:</p> <p>Master Side: <pre><code>sudo ptp4l -i &lt;interface name&gt; -H -m \n</code></pre></p> <p>Slave Side: <pre><code>sudo ptp4l -i &lt;interface name&gt; -H -m -s\n</code></pre></p> <ul> <li><code>-i</code> : Specifies the network interface.</li> <li><code>-H</code> : Enables hardware timestamping.</li> <li><code>-m</code> : Outputs synchronization messages to the terminal.</li> <li><code>-s</code> : Designates the slave role.</li> </ul> <p>Below is the result of master side and slave side: Master side(enp4s0): </p> <p>Slave side (enp5s0): </p> <p>When <code>ptp4l</code> runs, the master side selects a local clock as the best master, while the slave side synchronizes to a foreign master. Clock status is indicated by <code>s0</code> (unlocked), <code>s1</code> (synchronizing), or <code>s2</code> (locked). Hardware timestamping typically achieves <code>s2</code> quickly, while software timestamping (using <code>-S</code> instead of <code>-H</code>) may show all states.  If <code>ptp4l</code> consistently reports offsets below 100 ns, the PHC is synchronized.</p>"},{"location":"blog/20250709/20250709/#4-synchronizing-to-system-clock","title":"4. Synchronizing to System Clock","text":"<p>To synchronize the PHC to the system clock, use <code>phc2sys</code> on master and slave sides: <pre><code>sudo phc2sys -s &lt;interface name&gt; -c CLOCK_REALTIME -O 0 -m\n</code></pre></p> <ul> <li><code>-s</code> : Specifies the source network interface.</li> <li><code>-c</code> : Sets the target clock (CLOCK_REALTIME is the Linux system clock).</li> <li><code>-O 0</code> : Sets the offset to 0.</li> <li><code>-m</code> : Outputs synchronization information to the terminal.</li> </ul> <p>Example output: </p> <p>If <code>phc2sys</code> consistently reports offsets below 100 ns, the system clock is synchronized.</p>"},{"location":"blog/20250709/20250709/#conclusion","title":"Conclusion","text":"<p>Linux PTP provides a robust solution for high-precision time synchronization, supporting microsecond to nanosecond accuracy for demanding applications. By leveraging PTP-capable hardware and the ptp4l and phc2sys tools, users can achieve reliable synchronization in environments like 5G networks and TSN systems. </p>"},{"location":"blog/20250709/20250709/#reference","title":"Reference","text":"<ul> <li>Support of Time Sensitive Communication and Time Synchronization in 5G system - Introduction (Rel-17)</li> <li>Time-Sensitive Networking over 5G system - Introduction (Rel-16)</li> <li>Chapter 15. Using Precision Time Protocol hardware | Red Hat Product Documentation</li> <li>linuxptp</li> <li>Synchronizing Time with Linux* PTP</li> <li>12 - \u5229\u7528LinuxPTP\u8fdb\u884c\u65f6\u95f4\u540c\u6b65(\u8f6f/\u786c\u4ef6\u65f6\u95f4\u6233) - \u7814\u4e00\u539f\u521b</li> </ul>"},{"location":"blog/20250709/20250709/#about-me","title":"About me","text":"<p>Hi, I'm Peggy Cheng, a newcomer to 5G and the free5GC community. Feel free to tell me if there's any mistake in the article.</p>"},{"location":"blog/20250709/20250709/#connect-with-me","title":"Connect with Me","text":"<p>GitHub: HiImPeggy</p>"},{"location":"blog/20250723/20250723/","title":"Flexible GTP-U Handling: A Userspace Implementation","text":"<p>Note</p> <p>Author: Alonza Tu Date: 2025/07/23</p>"},{"location":"blog/20250723/20250723/#introduction","title":"Introduction","text":"<p>In current open source RAN and UE simulators, the GTP-U function is usually implemented in kernel space. For example, PacketRusher uses the gtp5g kernel module to handle GTP packet forwarding.</p> <p>However, if we want more flexible control over GTP-U, moving it to user space is a better choice. The goal of this project is to test the dynamic NR-DC feature in free5GC. Although moving GTP-U to user space may incur some performance overhead, it offers greater flexibility for development and testing.</p>"},{"location":"blog/20250723/20250723/#overview","title":"Overview","text":"<p>Here is an example of the ICMP process, i.e., <code>ping</code>.</p>"},{"location":"blog/20250723/20250723/#uplink","title":"Uplink","text":"<pre><code>graph LR\n    UE_Kernel([\"&lt;b&gt;UE Kernel&lt;/b&gt;&lt;br/&gt;ping 8.8.8.8\"])\n    TUN([\"&lt;b&gt;TUN&lt;br/&gt;ueTun0&lt;/b&gt;\"])\n    UE_Sim([\"&lt;b&gt;UE Simulator&lt;/b&gt;\"])\n    RAN_Sim([\"&lt;b&gt;RAN Simulator&lt;/b&gt;\"])\n    UPF([\"&lt;b&gt;UPF&lt;/b&gt;&lt;br/&gt;UDP 2152\"])\n\n    UE_Kernel -.-&gt;|\"ICMP Packet\"| TUN\n    TUN -- \"User Data\" --&gt; UE_Sim\n    UE_Sim -- \"TCP\" --&gt; RAN_Sim\n    RAN_Sim -- \"Encapsulate GTP-U &lt;br/&gt; with TEID\" --&gt; UPF\n\n    %% \u6a23\u5f0f\u7f8e\u5316\n    classDef kernel fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef tun fill:#fffde7,stroke:#fbc02d,stroke-width:2px;\n    classDef sim fill:#e8f5e9,stroke:#388e3c,stroke-width:2px;\n    classDef ran fill:#f3e5f5,stroke:#8e24aa,stroke-width:2px;\n    classDef gtpu fill:#fbe9e7,stroke:#d84315,stroke-width:2px;\n    classDef upf fill:#ede7f6,stroke:#5e35b1,stroke-width:2px;\n\n    class UE_Kernel kernel;\n    class TUN tun;\n    class UE_Sim sim;\n    class RAN_Sim ran;\n    class GTPU gtpu;\n    class UPF upf;</code></pre> <ol> <li>Create a TUN device in the UE to serve as a virtual network interface for user traffic.</li> <li>The UE reads packets from the TUN device in user space and sends them to the RAN simulator via TCP.</li> <li>The RAN simulator receives the data from the UE and encapsulates the packets as GTP-U packets with the assigned TEID.</li> <li>The RAN simulator sends the encapsulated GTP-U packets to the UPF over UDP (port 2152).</li> </ol>"},{"location":"blog/20250723/20250723/#downlink","title":"Downlink","text":"<pre><code>graph LR\n  UPF([\"&lt;b&gt;UPF&lt;/b&gt;&lt;br/&gt;UDP 2152\"])\n  RAN_Sim([\"&lt;b&gt;RAN Simulator&lt;/b&gt;\"])\n  UE_Sim([\"&lt;b&gt;UE Simulator&lt;/b&gt;\"])\n  TUN([\"&lt;b&gt;TUN&lt;br/&gt;ueTun0&lt;/b&gt;\"])\n  UE_Kernel([\"&lt;b&gt;UE Kernel&lt;/b&gt;&lt;br/&gt;ping reply\"])\n\n  UPF -- \"GTP-U Packet\" --&gt; RAN_Sim\n  RAN_Sim -- \"Decapsulate GTP-U&lt;br/&gt;with TEID\" --&gt; UE_Sim\n  UE_Sim -- \"User Data\" --&gt; TUN\n  TUN -.-&gt;|\"ICMP Reply\"| UE_Kernel\n\n  %% \u6a23\u5f0f\u7f8e\u5316\n  classDef upf fill:#ede7f6,stroke:#5e35b1,stroke-width:2px;\n  classDef ran fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n  classDef sim fill:#e8f5e9,stroke:#388e3c,stroke-width:2px;\n  classDef tun fill:#fffde7,stroke:#fbc02d,stroke-width:2px;\n  classDef kernel fill:#f3e5f5,stroke:#8e24aa,stroke-width:2px;\n\n  class UPF upf;\n  class RAN_Sim ran;\n  class UE_Sim sim;\n  class TUN tun;\n  class UE_Kernel kernel;</code></pre> <ol> <li>When the UPF has data to send to the UE, it encapsulates the data into a GTP-U packet and sends it via UDP (port 2152) to the RAN simulator.</li> <li>The RAN simulator receives the GTP-U packet, decapsulates it based on the TEID, and forwards the original IP packet to the corresponding UE.</li> <li>The UE simulator receives the packet in user space and writes the raw packet into the TUN device.</li> <li>The UE kernel processes the packet and generates a response (e.g., ping reply).</li> </ol>"},{"location":"blog/20250723/20250723/#implementation","title":"Implementation","text":"<p>To describe the implementation, we will separate the infrastructure into UE and RAN components.</p> <p>Tip</p> <p>The connections mentioned here only consider the data plane.</p>"},{"location":"blog/20250723/20250723/#at-ue","title":"At UE","text":"<p>After the PDU session establishment procedure, the UE will receive configuration messages, including the UE IP address.</p>"},{"location":"blog/20250723/20250723/#bring-up-a-network-device-in-kernel-space","title":"Bring up a network device in kernel space","text":"<p>This network device will act as an entry point for user traffic from kernel space to user space. We use the water library to create and manage TUN devices.</p> <ol> <li> <p>Using the water library to bring up a network device:</p> <pre><code>tunCfg := water.Config{ DeviceType: water.TUN }\ntunCfg.Name = ueTunnelDeviceName\n</code></pre> </li> <li> <p>Set up the device with UE IP:</p> <pre><code>cmds := [][]string{\n  {\"ip\", \"addr\", \"add\", fmt.Sprintf(\"%s/32\", ip), \"dev\", ueTunnelDeviceName},\n  {\"ip\", \"link\", \"set\", \"dev\", ueTunnelDeviceName, \"up\"},\n}\n\nfor _, cmd := range cmds {\n  if err := exec.Command(cmd[0], cmd[1:]...).Run(); err != nil {\n    return nil, fmt.Errorf(\"error bringing up tunnel device: %v\", err)\n  }\n}\n</code></pre> </li> </ol>"},{"location":"blog/20250723/20250723/#set-up-packet-forwarding-channels","title":"Set up packet forwarding channels","text":"<p>Here we will set up two channels to transmit packets between the READER and TRANSMITTER.</p> <ol> <li> <p>Uplink (read from tunnel device and send to RAN):</p> <pre><code>u.readFromTun = make(chan []byte)\ngo func() {\n  buffer := make([]byte, 4096)\n  for {\n    n, err := ueTunnelDevice.Read(buffer)\n    if err != nil {\n      return\n    }\n    u.readFromTun &lt;- buffer[:n]\n  }\n}()\n</code></pre> </li> <li> <p>Downlink (receive from RAN and write to tunnel device):</p> <pre><code>u.readFromRan = make(chan []byte)\ngo func() {\n  buffer := make([]byte, 4096)\n  for {\n    n, err := u.ranDataPlaneConn.Read(buffer)\n    if err != nil {\n      if errors.Is(err, net.ErrClosed) {\n        return\n      }\n      return\n    }\n    u.readFromRan &lt;- buffer[:n]\n  }\n}()\n</code></pre> </li> </ol>"},{"location":"blog/20250723/20250723/#data-plane-packet-handler-transmit-packets-between-tun-and-ran","title":"Data plane packet handler (transmit packets between TUN and RAN)","text":"<p>Using <code>select</code> statement with for loops to handle bidirectional traffic.</p> <pre><code>for {\n    select {\n    case buffer := &lt;-u.readFromTun:\n        n, err := u.ranDataPlaneConn.Write(buffer)\n        if err != nil {\n            if errors.Is(err, net.ErrClosed) {\n                return\n            }\n        }\n    case buffer := &lt;-u.readFromRan:\n        n, err := u.ueTunnelDevice.Write(buffer)\n        if err != nil {\n          return\n        }\n    }\n}\n</code></pre>"},{"location":"blog/20250723/20250723/#at-ran","title":"At RAN","text":"<p>The RAN will maintain a MAP for mapping each TEID to its corresponding UE connection.</p>"},{"location":"blog/20250723/20250723/#uplink-ran-receives-packets-from-ue-and-formats-them-as-gtp-packets-for-sending-to-upf","title":"Uplink (RAN receives packets from UE and formats them as GTP packets for sending to UPF)","text":"<ol> <li> <p>RAN continuously reads from the UE connection and formats the packet as a GTP packet:</p> <pre><code>buffer, gtpChannel := make([]byte, 4096), make(chan []byte)\nfor {\n    n, err := ueDataPlaneConn.Read(buffer)\n    if err != nil {\n        if errors.Is(err, net.ErrClosed) || errors.Is(err, io.EOF) {\n            return\n        }\n    }\n\n    tmp := make([]byte, n)\n    copy(tmp, buffer[:n])\n    go formatGtpPacketAndWriteToGtpChannel(ulTeidBytes, tmp, g.gtpChannel, g.GnbLogger)\n}\n</code></pre> </li> <li> <p>RAN formats a GTP header with the corresponding TEID and encapsulates it in front of the original packet. Then this GTP packet will be written to the gtpChannel for later transmission:</p> <pre><code>gtpHeader := make([]byte, 12)\n\ngtpHeader[0] = 0x32\ngtpHeader[1] = 0xff\nbinary.BigEndian.PutUint16(gtpHeader[2:], uint16(len(packet)+4))\ncopy(gtpHeader[4:], teid)\ngtpHeader[8], gtpHeader[9], gtpHeader[10], gtpHeader[11] = 0x00, 0x00, 0x00, 0x00\n\ngtpPacket := append(gtpHeader, packet...)\ngtpChannel &lt;- gtpPacket\n</code></pre> </li> <li> <p>RAN reads GTP packets from gtpChannel and sends them to UPF (N3 Connection):</p> <pre><code>for {\n    select {\n    case &lt;-ctx.Done():\n        return\n    case packet := &lt;-gtpChannel:\n        n, err := n3Conn.Write(packet)\n        if err != nil {\n          return\n        }\n    }\n}\n</code></pre> </li> </ol>"},{"location":"blog/20250723/20250723/#downlink-ran-receives-packets-from-upf-and-removes-their-gtp-header-for-sending-to-ue","title":"Downlink (RAN receives packets from UPF and removes their GTP header for sending to UE)","text":"<ol> <li> <p>Receive the GTP packet from N3 connection and pass the packet to the forward function:</p> <pre><code>for {\n    n, err := n3Conn.Read(buffer)\n    if err != nil {\n        if errors.Is(err, net.ErrClosed) {\n            return\n        }\n    }\n    go forwardPacketToUe(buffer[:n], teidToConn, gnbLogger)\n}\n</code></pre> </li> <li> <p>Parse the GTP packet and forward to the UE connection by TEID (from MAP):</p> <pre><code>teid, payload, err := parseGtpPacket(gtpPacket)\nif err != nil {\n    return\n}\n\nconn, found := teidToConn.Load(teid)\nif !found {\n    return\n}\n\nn, err := conn.(net.Conn).Write(payload)\nif err != nil {\n  return\n}\n</code></pre> </li> <li> <p>GTP packet parsing function:</p> <pre><code>func parseGtpPacket(gtpPacket []byte) (string, []byte, error) {\n    basicHeader, headerLength := gtpPacket[:8], 8\n    pduSessionType, pduSessionLength := byte(0x85), 2\n\n    if basicHeader[0]&amp;0x02 != 0 {\n        headerLength += 3\n    }\n\n    for {\n        if gtpPacket[headerLength] == 0x00 {\n            headerLength += 1\n            break\n        } else {\n            switch gtpPacket[headerLength] {\n            case pduSessionType:\n                extensionHeaderLength := gtpPacket[headerLength+1]\n                headerLength += 2\n                headerLength += int(extensionHeaderLength) * pduSessionLength\n            default:\n                return \"\", nil, fmt.Errorf(\"unknown GTP extension header type: %d\", gtpPacket[headerLength])\n            }\n        }\n    }\n\n    return hex.EncodeToString(basicHeader[4:]), gtpPacket[headerLength:], nil\n}\n</code></pre> </li> </ol>"},{"location":"blog/20250723/20250723/#conclusion","title":"Conclusion","text":"<p>This document presents a comprehensive design for implementing GTP-U functionality in user space, providing greater flexibility for testing and development purposes, particularly for dynamic NR-DC features in free5GC. The implementation separates concerns between UE and RAN components, with clear packet forwarding mechanisms for both uplink and downlink traffic.</p> <p>The key benefits of this approach include:</p> <ul> <li>Enhanced control over GTP-U packet processing</li> <li>Better debugging and monitoring capabilities</li> <li>Easier integration with test frameworks</li> <li>Flexibility in implementing custom GTP-U behaviors</li> </ul> <p>While there may be some performance overhead compared to kernel-space implementations, the gained flexibility makes this approach valuable for research and development scenarios.</p>"},{"location":"blog/20250723/20250723/#reference","title":"Reference","text":"<p>If you want more detailed information, please refer to the links below for the complete RAN/UE simulator implementation.</p> <ul> <li>free-ran-ue offcial wesite</li> <li>free-ran-ue github</li> </ul>"},{"location":"blog/20250723/20250723/#about-me","title":"About me","text":"<p>Hi, I'm Alonza, a core network developer currently contributing to the free5GC project. I am also working on the development of free-ran-ue, a userspace RAN/UE simulator. If you have any ideas or would like to collaborate, feel free to reach out!</p>"},{"location":"blog/20250723/20250723/#connect-with-me","title":"Connect with me","text":"<ul> <li>GitHub: https://github.com/Alonza0314</li> <li>Website: Alonza0314</li> <li>LinkedIn: Alonza Tu</li> </ul>"},{"location":"blog/20250726/","title":"\u5229\u7528 Custom eBPF-based Schedulers \u6539\u5584\u7db2\u8def\u6548\u80fd","text":"<p>Note</p> <p>Author: Ian Chen Date: 2025/07/26</p> <p>Linux Kernel \u81ea v6.12 \u958b\u59cb\u652f\u63f4 sched_ext\uff0c\u5b83\u5141\u8a31\u4f7f\u7528\u8005\u85c9\u7531 eBPF \u7a0b\u5f0f\u4f86\u5b9a\u7fa9\u81ea\u8a02\u7684 CPU \u6392\u7a0b\u5668\u3002\u9019\u500b\u529f\u80fd\u4f7f\u5f97\u958b\u767c\u8005\u80fd\u5920\u5275\u5efa\u66f4\u9748\u6d3b\u548c\u9ad8\u6548\u7684\u6392\u7a0b\u7b56\u7565\uff0c\u4ee5\u6eff\u8db3\u7279\u5b9a\u7684\u6027\u80fd\u9700\u6c42\u3002 \u7b46\u8005\u6df1\u53d7 scx \u5c08\u6848\u7684\u555f\u767c\uff0c\u4e26\u4e14\u53c3\u8003 scx_rustland \u7684\u6982\u5ff5\uff0c\u5be6\u4f5c\u4e86\u8b93\u958b\u767c\u8005\u80fd\u5920\u4f7f\u7528 golang \u8a9e\u8a00\u4f86\u64b0\u5beb\u81ea\u8a02\u6392\u7a0b\u5668\u7684\u6846\u67b6 scx_goland_core\u3002</p>"},{"location":"blog/20250726/#scx-5g","title":"scx \u8207 5G \u9818\u57df\u7d50\u5408\u7684\u53ef\u80fd\u6027","text":"<p>\u5c0d\u65bc 5G \u8207 scx \u7684\u7d50\u5408\uff0c\u5df2\u7d93\u6709\u4e9b\u8a31\u8a0e\u8ad6 [1] [2] [3]\u3002\u7136\u800c\uff0c\u8003\u616e\u5230\u73fe\u4ee3 Cloud-Native App (5G Core Network) \u7684\u7279\u6027\uff0c\u76ee\u524d\u5c1a\u6c92\u6709\u76f8\u95dc\u6848\u4f8b\u63a2\u8a0e scx \u5982\u4f55\u5728\u96f2\u539f\u751f\u67b6\u69cb\u4e0a\u904b\u4f5c\u3002</p> <p> \u5716\u4e00\uff1aAPI \u67b6\u69cb</p> <p>\u5c0d\u6b64\uff0c\u7b46\u8005\u63d0\u51fa\u4e86\u4e00\u500b\u521d\u6b65\u7684\u60f3\u6cd5\uff0c\u57fa\u65bc scx_goland_core \u6846\u67b6\u958b\u767c\u4e86\u4e00\u500b\u53ef\u5728\u96f2\u539f\u751f\u74b0\u5883\u4e2d\u904b\u884c\u7684\u81ea\u8a02\u6392\u7a0b\u5668 Gthulhu\uff0c\u5b83\u53ef\u4ee5\u90e8\u7f72\u65bc Kubernetes \u7fa4\u96c6\u4e2d\uff0c\u900f\u904e\u90e8\u7f72\u7684\u65b9\u5f0f\u7ba1\u7406\u53e2\u96c6\u4e2d\u5927\u91cf\u7bc0\u9ede\u7684\u6392\u7a0b\u7b56\u7565\u3002</p> <p>\u6211\u5011\u53ef\u4ee5\u900f\u904e Restful API \u5c0d Gthulhu API server \u4e0b\u9054\u6392\u7a0b\u7b56\u7565\uff0c\u8b93 API server \u70ba\u6211\u5011\u627e\u51fa\u9700\u8981\u8abf\u6574\u7684 workloads\u3002\u8207\u6b64\u540c\u6642\uff0cGthulhu \u6703\u5b9a\u671f\u5411 API server \u767c\u9001\u5fc3\u8df3\u8a0a\u606f\uff0c\u4e26\u5728\u5fc5\u8981\u6642\u66f4\u65b0\u6392\u7a0b\u7b56\u7565\u3002</p> <p>\u95dc\u65bc Gthulhu \u7684\u8a73\u7d30\u8cc7\u8a0a\uff0c\u8acb\u53c3\u8003 Gthulhu Docs\u3002</p>"},{"location":"blog/20250726/#gthulhu","title":"\u725b\u5200\u5c0f\u8a66\uff1a\u89c0\u5bdf Gthulhu \u8f09\u5165\u5f8c\u8cc7\u6599\u5c64\u7684\u6548\u80fd\u5dee\u7570","text":"<p>\u5728\u672c\u6b21\u5be6\u9a57\u4e2d\uff0c\u7b46\u8005\u7684\u6a5f\u5668\u904b\u4f5c \u5728 Ubuntu 24.04 LTS \u4e0a\uff0c\u4f7f\u7528 Linux Kernel 6.12\u3002\u5be6\u9a57\u7684\u76ee\u7684\u662f\u89c0\u5bdf Gthulhu \u5728\u8f09\u5165\u5f8c\u5c0d\u8cc7\u6599\u5c64\u6548\u80fd\u7684\u5f71\u97ff\u3002</p> <p>\u8a66\u9a57\u74b0\u5883\u5982\u4e0b\uff1a</p> <ul> <li>VM1 (Ubuntu 24.04 LTS, Linux Kernel 6.12)<ul> <li>\u90e8\u7f72 free5GC v4.0.1</li> </ul> </li> <li>VM2 (Ubuntu 20.04 LTS, Linux Kernel 5.4.0)<ul> <li>\u90e8\u7f72 UERANSIM</li> </ul> </li> </ul> <p></p> <p>\u5f85 PDU Session \u5efa\u7acb\u5f8c\uff0c\u7b46\u8005\u4f7f\u7528 <code>ping</code> \u5de5\u5177\u5c0d UPF N6 \u4ecb\u9762\u9032\u884c\u6e2c\u8a66\uff0c\u4e26\u89c0\u5bdf\u5728\u8f09\u5165 Gthulhu \u524d\u5f8c\u7684\u5ef6\u9072\u8b8a\u5316\u3002</p> <p></p> <p>\u8f09\u5165\u524d\uff0cLinux \u9810\u8a2d\u7684\u6392\u7a0b\u5668\u70ba EEVDF\uff0cRTT \u76f8\u95dc\u53c3\u6578\u5982\u4e0b\uff1a</p> <ul> <li>rtt min = 1.263 ms</li> <li>rtt avg = 1.907 ms</li> <li>rtt max = 6.405 ms</li> <li>rtt mdev = 0.657 ms</li> </ul> <p>rtt min/avg/max/mdev = 1.222/1.864/3.771/0.433 ms \u8f09\u5165 Gthulhu \u5f8c\uff0cRTT \u53c3\u6578\u8b8a\u5316\u5982\u4e0b\uff1a</p> <ul> <li>rtt min = 1.222 ms</li> <li>rtt avg = 1.864 ms</li> <li>rtt max = 3.771 ms</li> <li>rtt mdev = 0.433 ms</li> </ul> <p>\u7531\u6b64\u53ef\u898b\uff0c\u8f09\u5165 Gthulhu \u5f8c\uff0cRTT \u7684\u5e73\u5747\u503c\u548c\u6700\u5927\u503c\u5747\u6709\u6240\u4e0b\u964d\uff0c\u986f\u793a\u51fa Gthulhu \u5728\u8cc7\u6599\u5c64\u7684\u6392\u7a0b\u4e0a\u78ba\u5be6\u6709\u52a9\u65bc\u964d\u4f4e\u5ef6\u9072\u3002</p>"},{"location":"blog/20250726/#gtp5g","title":"\u5c0d GTP5G \u9032\u884c\u6700\u4f73\u5316\u6392\u7a0b","text":"<p>\u6839\u64da\u524d\u9762\u7684\u5be6\u9a57\u7d50\u679c\u53ef\u4ee5\u5f97\u77e5\uff0c\u5728\u4e0d\u5c0d\u6392\u7a0b\u5668\u9032\u884c\u4efb\u4f55\u8abf\u6574\u7684\u524d\u63d0\u4e0b\uff0cGthulhu \u78ba\u5be6\u6709\u6548\u7684\u964d\u4f4e RTT \u7684\u8868\u73fe\u3002\u90a3\u9ebc\uff0c\u6211\u5011\u6709\u6a5f\u6703\u5229\u7528\u7db2\u8def\u5b50\u7cfb\u7d71\u7684\u77e5\u8b58\u7d50\u5408 Gthulhu \u66f4\u9032\u4e00\u6b65\u5c0d GTP5G \u9032\u884c\u8abf\u6559\u55ce\uff1f</p> <p>Note</p> <p>\u5be6\u9a57\u74b0\u5883\u5982\u4e0b\uff1a - 5GC on kubernetes - N3/N6 \u4f7f\u7528 Multus CNI \u5efa\u7acb macvlan interfaces\uff08N6 \u7d81\u5b9a enp7s0\uff0cN3 \u4ecb\u9762\u7d81\u5b9a dummy interface\uff09</p>"},{"location":"blog/20250726/#downlink-cpu","title":"\u89c0\u5bdf Downlink \u7531\u54ea\u4e00\u500b cpu \u8ca0\u8cac\u8655\u7406","text":"<pre><code>$ grep enp7s0 /proc/interrupts\n\n 159:     116096     131508     763166     532207    4697697    3924514   24589811    5660340   29315073   11862910   25971964    8494127    1935719    2420802    5149765     948266    6835920    2126158    1825640    1044404  IR-PCI-MSIX-0000:07:00.0    0-edge      enp7s0\n</code></pre> <p>\u900f\u904e\u4e0a\u65b9\u57f7\u884c\u7684\u547d\u4ee4\u53ef\u4ee5\u5f97\u77e5 enp7s0 \u5c0d\u61c9\u7684 IRQ \u70ba 159\uff0c\u63a5\u8457\u5229\u7528 <code>cat /proc/irq/${IRQ}/smp_affinity_list</code> \u53ef\u4ee5\u5f97\u77e5 IRQ 159 \u7d81\u5b9a\u7684 CPU\uff1a <pre><code>$ cat /proc/irq/159/smp_affinity_list\n11\n</code></pre> \u7576 enp7s0 \u6536\u5230\u4f86\u81ea Data Network \u7684\u5c01\u5305\uff0c\u6703\u63a5\u5c01\u5305\u9001\u5f80 UPF Container \u5c0d\u61c9\u7684 n6 interface\uff0c\u800c N6 interface \u6703\u5c07 downlink \u5c01\u5305\u8f49\u9001\u81f3\u865b\u64ec\u4ecb\u9762 gtp5g \u5167\u3002 \u56e0\u6b64\uff0c\u8655\u7406 gtp5g downlink \u6d41\u91cf\u7684 CPU \u61c9\u8a72\u662f CPU 11\uff0c\u9019\u4e00\u9ede\u53ef\u4ee5\u900f\u904e eBPF program \u9a57\u8b49\u3002</p> <p>\u5728\u7b46\u8005\u5148\u524d\u64b0\u5beb\u7684 Debug gtp5g kernel module using stacktrace and eBPF \u4e00\u6587\u4e2d\u5df2\u7d93\u63a2\u8a0e\u904e\u4f7f\u7528 eBPF \u8ffd\u8e64 kernel module \u7684\u53ef\u80fd\u6027\uff0c\u53ea\u8981\u8ffd\u8e64\u4e00\u4e0b gtp5g \u7684 source code \u4fbf\u53ef\u4ee5\u5f97\u77e5 downlink \u5c01\u5305\u6700\u5f8c\u6703\u9032\u5165 <code>gtp5g_xmit_skb_ipv4</code>\uff0c\u4f7f\u7528 <code>sudo cat /sys/kernel/tracing/available_filter_functions | grep gtp5g</code> \u4e5f\u53ef\u5f97\u77e5\u8a72\u51fd\u5f0f\u5728 available_filter_functions \u6e05\u55ae\u5167\u3002</p> <pre><code>SEC(\"fentry/gtp5g_xmit_skb_ipv4\")\nint BPF_PROG(capture_skb, struct sk_buff *skb, struct gtp5g_pktinfo *pktinfo)\n{\n    __u64 pid_tgid = bpf_get_current_pid_tgid();\n    __u32 pid = pid_tgid &amp; 0xFFFFFFFF;\n    __u32 tgid = pid_tgid &gt;&gt; 32;\n    __u32 cpu = bpf_get_smp_processor_id();\n\n    bpf_printk(\"gtp5g_xmit_skb_ipv4: PID=%u, TGID=%u, CPU=%u\", pid, tgid, cpu);\n    return 0;\n}\n</code></pre> <p>\u5c07\u4e0a\u8ff0\u7684 eBPF \u7a0b\u5f0f\u8f09\u5165\u5230\u6838\u5fc3\u5f8c\uff0c\u5229\u7528 UERANSIM \u5efa\u7acb PDU Session \u5411 <code>8.8.8.8</code> \u767c\u9001 ICMP \u5c01\u5305\u6642\uff0c\u6211\u5011\u5373\u53ef\u89c0\u5bdf eBPF \u7a0b\u5f0f\u7684\u8f38\u51fa\uff1a</p> <pre><code>gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156182.987076: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156183.987343: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156184.986858: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156185.987004: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156186.987574: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156187.987330: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156188.987722: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156189.988054: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156190.988038: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n        kubelite-3377186 [011] b.s21 6156191.987614: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=3377186, TGID=3376931, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156192.987963: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156193.987763: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156194.988095: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n</code></pre> <p>\u5f9e eBPF \u7a0b\u5f0f\u7684\u8f38\u51fa\u53ef\u5f97\u77e5\uff0cgtp5g \u7684 downlink \u6d41\u91cf\u78ba\u5be6\u7531 CPU 11 \u8ca0\u8cac\u8655\u7406\uff0c\u8207\u5148\u524d\u7684\u731c\u6e2c\u76f8\u540c\u3002 \u7576\u6211\u4f7f\u7528 <code>echo \"12\" | sudo tee /proc/irq/159/smp_affinity_list</code> \u4fee\u6539 IRQ 159 \u7d81\u5b9a\u7684 CPU \u5f8c\uff0ceBPF \u7a0b\u5f0f\u7684\u8f38\u51fa\u4e5f\u6703\u99ac\u4e0a\u6539\u8b8a\uff1a</p> <pre><code>gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=12\n          &lt;idle&gt;-0       [012] b.s31 6156445.013125: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=12\n          &lt;idle&gt;-0       [012] b.s31 6156446.012413: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=12\n          &lt;idle&gt;-0       [012] b.s31 6156447.012498: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=12\n          &lt;idle&gt;-0       [012] b.s31 6156448.013280: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=12\n          &lt;idle&gt;-0       [012] b.s31 6156449.012909: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=12\n          &lt;idle&gt;-0       [012] b.s31 6156450.013119: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=12\n          &lt;idle&gt;-0       [012] b.s31 6156451.013496: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=12\n</code></pre> <p>\u88dc\u5145\uff1a IRQ \u7d81\u5b9a\u7684 CPU \u6709\u53ef\u80fd\u6703\u88ab irqbalance \u52d5\u614b\u7684\u66f4\u65b0\uff0c\u5efa\u8b70\u53ef\u4ee5\u7528 <code>$ sudo systemctl stop irqbalance</code> \u66ab\u6642\u95dc\u9589 irqbalance\u3002</p> <p>\u8a71\u8aaa\u56de\u4f86\uff0c\u5373\u4f7f\u5c07 irqbalance \u95dc\u9589\uff0ceBPF \u7a0b\u5f0f\u7684\u8f38\u51fa\u4ecd\u6709\u53ef\u80fd\u51fa\u73fe\u975e\u9810\u671f\u60c5\u6cc1\u3002 \u7576\u6211\u5c07 ICMP \u7684\u76ee\u6a19\u5f9e\u5916\u90e8 IP \u6539\u70ba UPF container \u672c\u8eab N6 \u7db2\u5361\u7684 IP \u6642\uff0ceBPF \u7a0b\u5f0f\u7684\u8f38\u51fa\u5982\u4e0b\uff1a</p> <pre><code>          nr-gnb-168420  [016] b.s41 6158463.012636: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=16\n          nr-gnb-168420  [016] b.s41 6158464.012282: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=16\n          nr-gnb-168420  [017] b.s41 6158465.012408: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=17\n          nr-gnb-168420  [017] b.s41 6158466.012551: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=17\n          nr-gnb-168420  [016] b.s41 6158467.012401: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=16\n          nr-gnb-168420  [006] b.s41 6158468.012565: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=6\n          nr-gnb-168420  [006] b.s41 6158469.012700: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=6\n          nr-gnb-168420  [006] b.s41 6158470.012549: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=6\n          nr-gnb-168420  [006] b.s41 6158471.012763: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=6\n          nr-gnb-168420  [006] b.s41 6158472.012862: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=6\n</code></pre> <p>\u57fa\u672c\u4e0a\u57f7\u884c <code>gtp5g_xmit_skb_ipv4</code> \u7684 CPU \u4e00\u5b9a\u6703\u662f scheduler \u70ba <code>nr-gnb</code> process \u5206\u914d\u7684 CPU\u3002\u539f\u56e0\u4e5f\u5f88\u7c21\u55ae\uff0c\u56e0\u70ba\u9001\u5f80 N6 \u7db2\u5361\u7684\u5c01\u5305\u6703\u5728 Container \u5167\u8655\u7406\u5b8c\u7562\uff0c\u4e0d\u6703\u7d93\u904e enp7s0 \u7db2\u5361\uff0c\u6240\u4ee5\u5c01\u5305\u5f9e UERANSIM \u50b3\u51fa\u4e00\u8def\u5230 N6 \u8fd4\u56de\u90fd\u6703\u5728\u540c\u4e00\u500b\u4e0a\u4e0b\u6587\u5167\u8655\u7406\u5b8c\u7562\u3002</p> <p>\u4e86\u89e3 Linux \u6838\u5fc3\u8655\u7406\u5c01\u5305\u7684\u884c\u70ba\u5f8c\uff0c\u6211\u5011\u53ef\u4ee5\u5be6\u9a57\u770b\u770b\u7576\u7cfb\u7d71\u6eff\u8f09\u7684\u60c5\u6cc1\u4e0b\uff0cUERANSIM \u900f\u904e uesimtun0 \u5411 UPF N6 IP \u767c\u9001 ICMP echo request \u7684\u8868\u73fe\u3002</p>"},{"location":"blog/20250726/#gthulhu_1","title":"Gthulhu \u7684\u7d44\u614b\u8a2d\u5b9a","text":"<p>\u5728\u672c\u6b21\u5be6\u9a57\u4e2d\uff0c\u7d44\u614b\u7684\u8a2d\u5b9a\u56fa\u5b9a\u5982\u4e0b\uff1a</p> <pre><code># Gthulhu Scheduler Configuration\n# This configuration file allows you to adjust scheduler parameters before eBPF program loading\n\nscheduler:\n  # Default time slice in nanoseconds (default: 5000000 = 5ms)\n  slice_ns_default: 2000000\n\n  # Minimum time slice in nanoseconds (default: 500000 = 0.5ms)\n  slice_ns_min: 500000\napi:\n  enabled: false\n  url: http://127.0.0.1:8080\n  interval: 5\ndebug: false\nearly_processing: false\nbuiltin_idle: false\n</code></pre>"},{"location":"blog/20250726/#stress-ng","title":"\u4f7f\u7528 <code>stress-ng</code> \u7522\u751f\u8ca0\u8f09","text":"<pre><code>$ stress-ng -c 20 --timeout 60s --metrics-brief\n</code></pre>"},{"location":"blog/20250726/#ping","title":"\u4f7f\u7528 <code>ping</code> \u9032\u884c\u6e2c\u8a66","text":"<p>Gthulhu scheduler \u501f\u9451\u4e86 scx_rustland \u7684\u8a2d\u8a08\uff0c\u56e0\u6b64\uff0c\u5728\u672c\u5be6\u9a57\u4e2d\u6211\u5011\u4f7f\u7528 scx_rustland \u4f5c\u70ba\u5c0d\u7167\u7d44\uff1a</p> <pre><code>/UERANSIM # taskset -c 5 ping 10.10.2.60 -I uesimtun0 -c 10\nPING 10.10.2.60 (10.10.2.60): 56 data bytes\n64 bytes from 10.10.2.60: seq=0 ttl=64 time=75.589 ms\n64 bytes from 10.10.2.60: seq=1 ttl=64 time=75.917 ms\n64 bytes from 10.10.2.60: seq=2 ttl=64 time=63.919 ms\n64 bytes from 10.10.2.60: seq=3 ttl=64 time=71.934 ms\n64 bytes from 10.10.2.60: seq=4 ttl=64 time=72.005 ms\n64 bytes from 10.10.2.60: seq=5 ttl=64 time=64.108 ms\n64 bytes from 10.10.2.60: seq=6 ttl=64 time=83.945 ms\n64 bytes from 10.10.2.60: seq=7 ttl=64 time=100.525 ms\n64 bytes from 10.10.2.60: seq=8 ttl=64 time=59.987 ms\n64 bytes from 10.10.2.60: seq=9 ttl=64 time=63.940 ms\n\n--- 10.10.2.60 ping statistics ---\n10 packets transmitted, 10 packets received, 0% packet loss\nround-trip min/avg/max = 59.987/73.186/100.525 ms\n</code></pre> <p>\u6211\u5011\u53ef\u4ee5\u89c0\u5bdf\u51fa\uff1a\u7576\u7cfb\u7d71\u7684\u6bcf\u500b CPU \u6eff\u8f09\u6642\uff0cscx_rustland \u5728\u8655\u7406\u5c01\u5305\u7684\u6548\u7387\u4e0a\u975e\u5e38\u7cdf\u7cd5\u3002\u9019\u500b\u554f\u984c\u5728 Gthulhu \u6392\u7a0b\u5668\u4e0a\u4ea6\u7136\uff1a</p> <pre><code>/UERANSIM # taskset -c 5 ping 10.10.2.60 -I uesimtun0 -c 10\nPING 10.10.2.60 (10.10.2.60): 56 data bytes\n64 bytes from 10.10.2.60: seq=0 ttl=64 time=22.085 ms\n64 bytes from 10.10.2.60: seq=1 ttl=64 time=59.904 ms\n64 bytes from 10.10.2.60: seq=2 ttl=64 time=96.299 ms\n64 bytes from 10.10.2.60: seq=3 ttl=64 time=20.349 ms\n64 bytes from 10.10.2.60: seq=4 ttl=64 time=71.244 ms\n64 bytes from 10.10.2.60: seq=5 ttl=64 time=28.001 ms\n64 bytes from 10.10.2.60: seq=6 ttl=64 time=74.964 ms\n64 bytes from 10.10.2.60: seq=7 ttl=64 time=59.977 ms\n64 bytes from 10.10.2.60: seq=8 ttl=64 time=32.617 ms\n64 bytes from 10.10.2.60: seq=9 ttl=64 time=90.945 ms\n\n--- 10.10.2.60 ping statistics ---\n10 packets transmitted, 10 packets received, 0% packet loss\nround-trip min/avg/max = 20.349/55.638/96.299 ms\n</code></pre> <p>\u63a5\u8457\uff0c\u8b93\u6211\u5011\u5617\u8a66\u4ee5\u4e0b\u505a\u6cd5\uff0c\u770b\u80fd\u4e0d\u80fd\u964d\u4f4e round-trip-time\uff1a</p> <ul> <li>\u5c07\u67d0\u500b CPU\uff08\u9019\u88e1\u4f7f\u7528 CPU 5\uff09\u7d66 UERANSIM\u3001<code>icmp</code> \u5de5\u5177</li> <li>\u82e5\u5176\u4ed6\u4efb\u52d9\u88ab\u5206\u914d\u5230 CPU 5\uff0c\u5247\u96a8\u6a5f\u70ba\u5b83\u5206\u914d\u5176\u4ed6 CPU</li> </ul> <p>\u76f8\u95dc\u6539\u52d5\u8acb\u53c3\u8003\uff1a</p> <pre><code>    // ...\n    log.Println(\"scheduler started\")\n+   var specialPid int32 = 168420 // Special case for PID 168420\n+   var specialPidCpu int32 = 5\n\n    for true {\n        select {\n        case &lt;-ctx.Done():\n            log.Println(\"context done, exiting scheduler loop\")\n            return\n        default:\n        }\n        sched.DrainQueuedTask(bpfModule)\n        t = sched.GetTaskFromPool()\n        if t == nil {\n            bpfModule.BlockTilReadyForDequeue(ctx)\n        } else if t.Pid != -1 {\n            task = core.NewDispatchedTask(t)\n            err, cpu = bpfModule.SelectCPU(t)\n            if err != nil {\n                log.Printf(\"SelectCPU failed: %v\", err)\n            }\n\n+           if t.Pid == specialPid {\n+               if specialPidCpu == -1 &amp;&amp; cpu != core.RL_CPU_ANY {\n+                   specialPidCpu = cpu\n+               } else {\n+                   cpu = specialPidCpu\n+               }\n+           } else {\n+               if cpu == core.RL_CPU_ANY {\n+                   // ramdom select cpu 0-19\n+                   cpu = int32(rand.Intn(20))\n+               }\n+               if specialPidCpu == cpu {\n+                   if (cpu &amp; 1) == 1 {\n+                       cpu = cpu - 1\n+                   } else {\n+                       cpu = cpu + 1\n+                   }\n+               }\n+           }\n\n            // Evaluate used task time slice.\n            nrWaiting := core.GetNrQueued() + core.GetNrScheduled() + 1\n            task.Vtime = t.Vtime\n</code></pre> <p>Special pid <code>168420</code> \u662f\u900f\u904e eBPF \u7a0b\u5f0f\u89c0\u5bdf\u51fa\u8ca0\u8cac\u57f7\u884c <code>gtp5g_xmit_skb_ipv4()</code> \u7684 process id\uff1a</p> <pre><code>          nr-gnb-770208  [005] b.s41 6233538.456200: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] bNs41 6233711.301750: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] bNs41 6233712.346565: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] bNs41 6233713.312931: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] bNs41 6233714.314609: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] bNs41 6233715.340537: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] b.s41 6233716.337300: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] b.s41 6233717.389852: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] b.s41 6233718.387986: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] b.s41 6233719.368526: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] bNs41 6233720.396073: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n</code></pre> <p>\u5b8c\u6210\u4fee\u6539\u5f8c\uff0c\u8b93\u6211\u5011\u5617\u8a66\u91cd\u65b0\u57f7\u884c Gthulhu \u4e26\u518d\u6b21\u6e2c\u8a66\uff1a</p> <pre><code>/UERANSIM # taskset -c 5 ping 10.10.2.60 -I uesimtun0 -c 10\nPING 10.10.2.60 (10.10.2.60): 56 data bytes\n64 bytes from 10.10.2.60: seq=0 ttl=64 time=0.767 ms\n64 bytes from 10.10.2.60: seq=1 ttl=64 time=1.150 ms\n64 bytes from 10.10.2.60: seq=2 ttl=64 time=1.120 ms\n64 bytes from 10.10.2.60: seq=3 ttl=64 time=0.968 ms\n64 bytes from 10.10.2.60: seq=4 ttl=64 time=1.002 ms\n64 bytes from 10.10.2.60: seq=5 ttl=64 time=0.601 ms\n64 bytes from 10.10.2.60: seq=6 ttl=64 time=1.132 ms\n64 bytes from 10.10.2.60: seq=7 ttl=64 time=0.833 ms\n64 bytes from 10.10.2.60: seq=8 ttl=64 time=0.666 ms\n64 bytes from 10.10.2.60: seq=9 ttl=64 time=0.795 ms\n\n--- 10.10.2.60 ping statistics ---\n10 packets transmitted, 10 packets received, 0% packet loss\nround-trip min/avg/max = 0.601/0.903/1.150 ms\n</code></pre> <p>\u5f9e\u7d50\u679c\u4f86\u770b\uff0c\u4fee\u6539\u5f8c\u7684 Gthulhu \u6392\u7a0b\u5668\u5728\u9ad8\u8ca0\u8f09\u7684\u60c5\u6cc1\u4e0b\u4f7f UPF \u80fd\u5728\u77ed\u6642\u9593\u5167\u8655\u7406\u4f86\u81ea UERANSIM \u7684\u5c01\u5305\u3002\u9019\u6a23\u7684\u8868\u73fe\u8207\u6211\u5011\u9810\u671f\u7684\u4e00\u81f4\u3002</p>"},{"location":"blog/20250726/#rtt","title":"\u900f\u904e\u81ea\u5b9a\u7fa9\u7d44\u614b\u964d\u4f4e RTT","text":"<p>\u524d\u9762\u7684\u7684\u5be6\u9a57\u4e2d\uff0c\u6211\u5011\u70ba\u7279\u5b9a\u7684 process \u5206\u914d\u4e86\u5c08\u7528\u7684 CPU\uff0c\u9019\u6a23\u7684\u505a\u6cd5\u78ba\u5be6\u80fd\u5920\u5728\u9ad8\u8ca0\u8f09\u7684\u60c5\u6cc1\u4e0b\u63d0\u5347 RTT \u7684\u8868\u73fe\u3002\u7136\u800c\uff0c\u9019\u7a2e\u65b9\u6cd5\u4e26\u4e0d\u901a\u7528\uff0c\u56e0\u70ba\u6bcf\u500b\u7cfb\u7d71\u7684\u8ca0\u8f09\u60c5\u6cc1\u548c\u5de5\u4f5c\u8ca0\u8f09\u53ef\u80fd\u6703\u6709\u6240\u4e0d\u540c\u3002 \u56e0\u6b64\uff0cGthulhu \u767c\u5c55\u51fa\u4e00\u5957\u81ea\u5b9a\u7fa9\u7684\u7d44\u614b\u8a2d\u5b9a\uff0c\u8b93\u4f7f\u7528\u8005\u80fd\u5920\u6839\u64da\u81ea\u5df1\u7684\u9700\u6c42\u8abf\u6574\u6392\u7a0b\u7b56\u7565\uff0c\u5c08\u6848\u539f\u59cb\u78bc\u8acb\u53c3\u8003 Gthulhu/api\u3002</p> <pre><code>{\n  \"server\": {\n    \"port\": \":8080\",\n    \"read_timeout\": 15,\n    \"write_timeout\": 15,\n    \"idle_timeout\": 60\n  },\n  \"logging\": {\n    \"level\": \"info\",\n    \"format\": \"text\"\n  },\n  \"jwt\": {\n    \"private_key_path\": \"./config/jwt_private_key.key\",\n    \"token_duration\": 24\n  },\n  \"strategies\": {\n    \"default\": [\n      {\n        \"priority\": true,\n        \"execution_time\": 20000,\n        \"selectors\": [\n          {\n            \"key\": \"app\",\n            \"value\": \"ueransim-macvlan\"\n          }\n        ],\n        \"command_regex\": \"nr-gnb|nr-ue|ping\"\n      }\n    ]\n  }\n}\n</code></pre> <p>\u900f\u904e\u4e0a\u65b9\u7684 json \u6a94\u6848\uff0capi server \u80fd\u5920\u627e\u51fa\u5c0d\u61c9\u7684 processes\uff0c\u4e26\u5c07\u9019\u4e9b process \u7684\u6392\u7a0b\u7b56\u7565\u66f4\u65b0\u81f3 Gthulhu\u3002 \u5982\u679c\u8a72\u4efb\u52d9\u7684 <code>\"priority\": true</code>\uff0c\u5247\u8a72\u4efb\u52d9\u672c\u8eab\u80fd\u5920\u6436\u4f54\u5176\u4ed6\u975e <code>\"priority\": true</code> \u7684\u4efb\u52d9\uff0c\u5927\u5927\u7684\u964d\u4f4e\u4efb\u52d9\u5f9e <code>runnable</code> \u5230 <code>running</code> \u7684\u6642\u9593\u3002 \u5728 free5GC \u7684\u6574\u5408\u6848\u4f8b\u4e2d\uff0c\u964d\u4f4e ueransim \u7684\u6392\u7a0b\u5ef6\u9072\u4ee3\u8868\u8457 UPF \u80fd\u5920\u66f4\u5feb\u7684\u8655\u7406\u4f86\u81ea RAN \u7684\u5c01\u5305\uff0c\u9032\u800c\u964d\u4f4e\u6574\u9ad4\u7684 RTT\u3002</p> <p>\u4e0a\u65b9\u5f71\u7247\u5c55\u793a\u4e86\u5728\u9ad8\u8ca0\u8f09\u7684\u60c5\u6cc1\u4e0b\uff0cGthulhu \u5982\u4f55\u900f\u904e\u81ea\u5b9a\u7fa9\u7684\u6392\u7a0b\u7b56\u7565\u986f\u8457\u964d\u4f4e RTT \u7684\u8868\u73fe\u3002</p> <p>\u6b64\u5916\uff0cGthulhu \u4e5f\u652f\u63f4\u7c21\u6613\u7684 WEB GUI\uff0c\u8b93\u4f7f\u7528\u8005\u80fd\u5920\u66f4\u76f4\u89c0\u5730\u7ba1\u7406\u548c\u76e3\u63a7\u6392\u7a0b\u7b56\u7565\u3002</p>"},{"location":"blog/20250726/#_1","title":"\u7d50\u8ad6","text":"<p>5G \u63d0\u51fa\u4e86\u7db2\u8def\u5207\u7247\u7684\u6982\u5ff5\uff0c\u671f\u5f85\u900f\u904e\u5c07\u5be6\u9ad4\u7db2\u8def\u5207\u5206\u6210\u591a\u500b\u865b\u64ec\u7db2\u8def\u4f86\u63d0\u4f9b\u4e0d\u540c\u7684\u670d\u52d9\u54c1\u8cea\u3002\u6709\u4e86 Gthulhu \u9019\u6a23\u7684\u81ea\u8a02\u6392\u7a0b\u5668\uff0c\u6211\u5011\u53ef\u4ee5\u66f4\u9748\u6d3b\u5730\u7ba1\u7406\u548c\u512a\u5316\u9019\u4e9b\u865b\u64ec\u7db2\u8def\u7684\u6027\u80fd\uff0c\u5c07\u4e0d\u540c\u696d\u52d9\u9700\u6c42\u7684 UPF \u90e8\u7f72\u5728\u4e0d\u540c\u7684\u7bc0\u9ede\u4e0a\uff0c\u4e26\u6839\u64da\u5be6\u969b\u9700\u6c42\u8abf\u6574\u6392\u7a0b\u7b56\u7565\u3002</p>"},{"location":"blog/20250726/#_2","title":"\u95dc\u65bc\u4f5c\u8005","text":"<p>Ian Chen \u662f\u4e00\u540d\u71b1\u8877\u65bc\u958b\u6e90\u6280\u8853\u7684\u958b\u767c\u8005\uff0c\u5c08\u6ce8\u65bc 5G \u548c\u96f2\u539f\u751f\u67b6\u69cb\u7684\u7814\u7a76\u3002\u4ed6\u767c\u8d77\u4e86 Gthulhu \u5c08\u6848\uff0c\u540c\u6642\u4e5f\u662f free5GC \u7684\u4e3b\u8981\u8ca2\u737b\u8005\uff0c\u81f4\u529b\u65bc\u63a8\u5ee3\u548c\u5be6\u73fe 5G \u7db2\u8def\u7684\u958b\u6e90\u89e3\u6c7a\u65b9\u6848\u3002</p>"},{"location":"blog/20250726/index.en/","title":"Improving Network Performance with Custom eBPF-based Schedulers","text":"<p>Note</p> <p>Author: Ian Chen Date: 2025/07/26</p> <p>Linux Kernel has supported sched_ext since v6.12, which allows users to define custom CPU schedulers through eBPF programs. This feature enables developers to create more flexible and efficient scheduling strategies to meet specific performance requirements.</p> <p>The author was deeply inspired by the scx project and, referring to the concept of scx_rustland, implemented a framework scx_goland_core that allows developers to write custom schedulers using the Go language.</p>"},{"location":"blog/20250726/index.en/#potential-integration-of-scx-with-5g-domain","title":"Potential Integration of scx with 5G Domain","text":"<p>Regarding the combination of 5G and scx, there has been some discussion [1] [2] [3]. However, considering the characteristics of modern Cloud-Native Apps (5G Core Network), there are currently no related cases exploring how scx operates on cloud-native architectures.</p> <p> Figure 1: API Architecture</p> <p>In response, the author proposes an initial idea and developed a custom scheduler Gthulhu based on the scx_goland_core framework that can run in cloud-native environments. It can be deployed in Kubernetes clusters and manage scheduling policies for numerous nodes in the cluster through deployment.</p> <p>We can issue scheduling policies to the Gthulhu API server through RESTful APIs, allowing the API server to identify workloads that need adjustment. Meanwhile, Gthulhu periodically sends heartbeat messages to the API server and updates scheduling policies when necessary.</p> <p>For detailed information about Gthulhu, please refer to Gthulhu Docs.</p>"},{"location":"blog/20250726/index.en/#first-trial-observing-data-plane-performance-differences-after-loading-gthulhu","title":"First Trial: Observing Data Plane Performance Differences After Loading Gthulhu","text":"<p>In this experiment, the author's machine runs on Ubuntu 24.04 LTS with Linux Kernel 6.12. The experiment aims to observe the impact of Gthulhu on data plane performance after loading.</p> <p>The test environment is as follows:</p> <ul> <li>VM1 (Ubuntu 24.04 LTS, Linux Kernel 6.12)<ul> <li>Deploy free5GC v4.0.1</li> </ul> </li> <li>VM2 (Ubuntu 20.04 LTS, Linux Kernel 5.4.0)<ul> <li>Deploy UERANSIM</li> </ul> </li> </ul> <p></p> <p>After establishing the PDU Session, the author used the <code>ping</code> tool to test the UPF N6 interface and observed latency changes before and after loading Gthulhu.</p> <p></p> <p>Before loading, Linux's default scheduler was EEVDF, with RTT parameters as follows:</p> <ul> <li>rtt min = 1.263 ms</li> <li>rtt avg = 1.907 ms</li> <li>rtt max = 6.405 ms</li> <li>rtt mdev = 0.657 ms</li> </ul> <p>After loading Gthulhu, the RTT parameters changed as follows:</p> <ul> <li>rtt min = 1.222 ms</li> <li>rtt avg = 1.864 ms</li> <li>rtt max = 3.771 ms</li> <li>rtt mdev = 0.433 ms</li> </ul> <p>From these results, we can see that after loading Gthulhu, both the average and maximum RTT values decreased, indicating that Gthulhu indeed helps reduce latency in data plane scheduling.</p>"},{"location":"blog/20250726/index.en/#optimizing-gtp5g-scheduling","title":"Optimizing GTP5G Scheduling","text":"<p>Based on the previous experimental results, we can see that without any scheduler adjustments, Gthulhu effectively reduces RTT performance. So, can we leverage knowledge of the network subsystem combined with Gthulhu to further optimize GTP5G?</p> <p>Note</p> <p>Experimental environment: - 5GC on kubernetes - N3/N6 use Multus CNI to create macvlan interfaces (N6 bound to enp7s0, N3 interface bound to dummy interface)</p>"},{"location":"blog/20250726/index.en/#observing-which-cpu-handles-downlink-processing","title":"Observing Which CPU Handles Downlink Processing","text":"<pre><code>$ grep enp7s0 /proc/interrupts\n\n 159:     116096     131508     763166     532207    4697697    3924514   24589811    5660340   29315073   11862910   25971964    8494127    1935719    2420802    5149765     948266    6835920    2126158    1825640    1044404  IR-PCI-MSIX-0000:07:00.0    0-edge      enp7s0\n</code></pre> <p>From the command above, we can see that enp7s0 corresponds to IRQ 159. Next, using <code>cat /proc/irq/${IRQ}/smp_affinity_list</code>, we can determine which CPU IRQ 159 is bound to:</p> <pre><code>$ cat /proc/irq/159/smp_affinity_list\n11\n</code></pre> <p>When enp7s0 receives packets from the Data Network, it forwards them to the n6 interface corresponding to the UPF Container, and the N6 interface forwards downlink packets to the virtual interface gtp5g. Therefore, the CPU handling gtp5g downlink traffic should be CPU 11, which can be verified through an eBPF program.</p> <p>In the author's previous article Debug gtp5g kernel module using stacktrace and eBPF, the possibility of using eBPF to trace kernel modules was explored. By examining the gtp5g source code, we can see that downlink packets eventually enter <code>gtp5g_xmit_skb_ipv4</code>. Using <code>sudo cat /sys/kernel/tracing/available_filter_functions | grep gtp5g</code> also confirms that this function is in the available_filter_functions list.</p> <pre><code>SEC(\"fentry/gtp5g_xmit_skb_ipv4\")\nint BPF_PROG(capture_skb, struct sk_buff *skb, struct gtp5g_pktinfo *pktinfo)\n{\n    __u64 pid_tgid = bpf_get_current_pid_tgid();\n    __u32 pid = pid_tgid &amp; 0xFFFFFFFF;\n    __u32 tgid = pid_tgid &gt;&gt; 32;\n    __u32 cpu = bpf_get_smp_processor_id();\n\n    bpf_printk(\"gtp5g_xmit_skb_ipv4: PID=%u, TGID=%u, CPU=%u\", pid, tgid, cpu);\n    return 0;\n}\n</code></pre> <p>After loading the above eBPF program into the kernel, when using UERANSIM to establish a PDU Session and send ICMP packets to <code>8.8.8.8</code>, we can observe the eBPF program output:</p> <pre><code>gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156182.987076: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156183.987343: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156184.986858: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156185.987004: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156186.987574: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156187.987330: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156188.987722: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156189.988054: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156190.988038: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n        kubelite-3377186 [011] b.s21 6156191.987614: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=3377186, TGID=3376931, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156192.987963: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156193.987763: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n          &lt;idle&gt;-0       [011] b.s31 6156194.988095: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=11\n</code></pre> <p>From the eBPF program output, we can confirm that gtp5g's downlink traffic is indeed handled by CPU 11, consistent with our previous speculation. When I use <code>echo \"12\" | sudo tee /proc/irq/159/smp_affinity_list</code> to modify the CPU bound to IRQ 159, the eBPF program output immediately changes:</p> <pre><code>gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=12\n          &lt;idle&gt;-0       [012] b.s31 6156445.013125: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=12\n          &lt;idle&gt;-0       [012] b.s31 6156446.012413: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=12\n          &lt;idle&gt;-0       [012] b.s31 6156447.012498: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=12\n          &lt;idle&gt;-0       [012] b.s31 6156448.013280: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=12\n          &lt;idle&gt;-0       [012] b.s31 6156449.012909: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=12\n          &lt;idle&gt;-0       [012] b.s31 6156450.013119: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=12\n          &lt;idle&gt;-0       [012] b.s31 6156451.013496: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=0, TGID=0, CPU=12\n</code></pre> <p>Note: The CPU bound to IRQ may be dynamically updated by irqbalance. It's recommended to use <code>$ sudo systemctl stop irqbalance</code> to temporarily disable irqbalance.</p> <p>That said, even with irqbalance disabled, the eBPF program output may still show unexpected situations. When I changed the ICMP target from an external IP to the UPF container's own N6 interface IP, the eBPF program output was as follows:</p> <pre><code>          nr-gnb-168420  [016] b.s41 6158463.012636: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=16\n          nr-gnb-168420  [016] b.s41 6158464.012282: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=16\n          nr-gnb-168420  [017] b.s41 6158465.012408: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=17\n          nr-gnb-168420  [017] b.s41 6158466.012551: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=17\n          nr-gnb-168420  [016] b.s41 6158467.012401: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=16\n          nr-gnb-168420  [006] b.s41 6158468.012565: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=6\n          nr-gnb-168420  [006] b.s41 6158469.012700: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=6\n          nr-gnb-168420  [006] b.s41 6158470.012549: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=6\n          nr-gnb-168420  [006] b.s41 6158471.012763: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=6\n          nr-gnb-168420  [006] b.s41 6158472.012862: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=168420, TGID=168410, CPU=6\n</code></pre> <p>Basically, the CPU executing <code>gtp5g_xmit_skb_ipv4</code> will always be the CPU that the scheduler allocates to the <code>nr-gnb</code> process. The reason is simple: packets sent to the N6 interface are processed completely within the container and don't pass through the enp7s0 interface, so packets from UERANSIM all the way to N6 and back are handled within the same context.</p> <p>Understanding the Linux kernel's packet processing behavior, we can experiment to see how UERANSIM performs when sending ICMP echo requests to the UPF N6 IP through uesimtun0 under system full load conditions.</p>"},{"location":"blog/20250726/index.en/#gthulhu-configuration-settings","title":"Gthulhu Configuration Settings","text":"<p>In this experiment, the configuration settings are fixed as follows:</p> <pre><code># Gthulhu Scheduler Configuration\n# This configuration file allows you to adjust scheduler parameters before eBPF program loading\n\nscheduler:\n  # Default time slice in nanoseconds (default: 5000000 = 5ms)\n  slice_ns_default: 2000000\n\n  # Minimum time slice in nanoseconds (default: 500000 = 0.5ms)\n  slice_ns_min: 500000\napi:\n  enabled: false\n  url: http://127.0.0.1:8080\n  interval: 5\ndebug: false\nearly_processing: false\nbuiltin_idle: false\n</code></pre>"},{"location":"blog/20250726/index.en/#using-stress-ng-to-generate-load","title":"Using <code>stress-ng</code> to Generate Load","text":"<pre><code>$ stress-ng -c 20 --timeout 60s --metrics-brief\n</code></pre>"},{"location":"blog/20250726/index.en/#testing-with-ping","title":"Testing with <code>ping</code>","text":"<p>Since the Gthulhu scheduler borrows from the design of scx_rustland, we use scx_rustland as the control group in this experiment:</p> <pre><code>/UERANSIM # taskset -c 5 ping 10.10.2.60 -I uesimtun0 -c 10\nPING 10.10.2.60 (10.10.2.60): 56 data bytes\n64 bytes from 10.10.2.60: seq=0 ttl=64 time=75.589 ms\n64 bytes from 10.10.2.60: seq=1 ttl=64 time=75.917 ms\n64 bytes from 10.10.2.60: seq=2 ttl=64 time=63.919 ms\n64 bytes from 10.10.2.60: seq=3 ttl=64 time=71.934 ms\n64 bytes from 10.10.2.60: seq=4 ttl=64 time=72.005 ms\n64 bytes from 10.10.2.60: seq=5 ttl=64 time=64.108 ms\n64 bytes from 10.10.2.60: seq=6 ttl=64 time=83.945 ms\n64 bytes from 10.10.2.60: seq=7 ttl=64 time=100.525 ms\n64 bytes from 10.10.2.60: seq=8 ttl=64 time=59.987 ms\n64 bytes from 10.10.2.60: seq=9 ttl=64 time=63.940 ms\n\n--- 10.10.2.60 ping statistics ---\n10 packets transmitted, 10 packets received, 0% packet loss\nround-trip min/avg/max = 59.987/73.186/100.525 ms\n</code></pre> <p>We can observe that when every CPU in the system is fully loaded, scx_rustland performs very poorly in packet processing efficiency. This problem also exists with the Gthulhu scheduler:</p> <pre><code>/UERANSIM # taskset -c 5 ping 10.10.2.60 -I uesimtun0 -c 10\nPING 10.10.2.60 (10.10.2.60): 56 data bytes\n64 bytes from 10.10.2.60: seq=0 ttl=64 time=22.085 ms\n64 bytes from 10.10.2.60: seq=1 ttl=64 time=59.904 ms\n64 bytes from 10.10.2.60: seq=2 ttl=64 time=96.299 ms\n64 bytes from 10.10.2.60: seq=3 ttl=64 time=20.349 ms\n64 bytes from 10.10.2.60: seq=4 ttl=64 time=71.244 ms\n64 bytes from 10.10.2.60: seq=5 ttl=64 time=28.001 ms\n64 bytes from 10.10.2.60: seq=6 ttl=64 time=74.964 ms\n64 bytes from 10.10.2.60: seq=7 ttl=64 time=59.977 ms\n64 bytes from 10.10.2.60: seq=8 ttl=64 time=32.617 ms\n64 bytes from 10.10.2.60: seq=9 ttl=64 time=90.945 ms\n\n--- 10.10.2.60 ping statistics ---\n10 packets transmitted, 10 packets received, 0% packet loss\nround-trip min/avg/max = 20.349/55.638/96.299 ms\n</code></pre> <p>Next, let's try the following approach to see if we can reduce round-trip-time:</p> <ul> <li>Assign a specific CPU (using CPU 5 here) to UERANSIM and the <code>icmp</code> tool</li> <li>If other tasks are assigned to CPU 5, randomly assign them to other CPUs</li> </ul> <p>Related changes can be found in:</p> <pre><code>    // ...\n    log.Println(\"scheduler started\")\n+   var specialPid int32 = 168420 // Special case for PID 168420\n+   var specialPidCpu int32 = 5\n\n    for true {\n        select {\n        case &lt;-ctx.Done():\n            log.Println(\"context done, exiting scheduler loop\")\n            return\n        default:\n        }\n        sched.DrainQueuedTask(bpfModule)\n        t = sched.GetTaskFromPool()\n        if t == nil {\n            bpfModule.BlockTilReadyForDequeue(ctx)\n        } else if t.Pid != -1 {\n            task = core.NewDispatchedTask(t)\n            err, cpu = bpfModule.SelectCPU(t)\n            if err != nil {\n                log.Printf(\"SelectCPU failed: %v\", err)\n            }\n\n+           if t.Pid == specialPid {\n+               if specialPidCpu == -1 &amp;&amp; cpu != core.RL_CPU_ANY {\n+                   specialPidCpu = cpu\n+               } else {\n+                   cpu = specialPidCpu\n+               }\n+           } else {\n+               if cpu == core.RL_CPU_ANY {\n+                   // ramdom select cpu 0-19\n+                   cpu = int32(rand.Intn(20))\n+               }\n+               if specialPidCpu == cpu {\n+                   if (cpu &amp; 1) == 1 {\n+                       cpu = cpu - 1\n+                   } else {\n+                       cpu = cpu + 1\n+                   }\n+               }\n+           }\n\n            // Evaluate used task time slice.\n            nrWaiting := core.GetNrQueued() + core.GetNrScheduled() + 1\n            task.Vtime = t.Vtime\n</code></pre> <p>Special pid <code>168420</code> was observed through the eBPF program as the process id responsible for executing <code>gtp5g_xmit_skb_ipv4()</code>:</p> <pre><code>          nr-gnb-770208  [005] b.s41 6233538.456200: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] bNs41 6233711.301750: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] bNs41 6233712.346565: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] bNs41 6233713.312931: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] bNs41 6233714.314609: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] bNs41 6233715.340537: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] b.s41 6233716.337300: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] b.s41 6233717.389852: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] b.s41 6233718.387986: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] b.s41 6233719.368526: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n          nr-gnb-770208  [005] bNs41 6233720.396073: bpf_trace_printk: gtp5g_xmit_skb_ipv4: PID=770208, TGID=770198, CPU=5\n</code></pre> <p>After completing the modifications, let's try running Gthulhu again and test once more:</p> <pre><code>/UERANSIM # taskset -c 5 ping 10.10.2.60 -I uesimtun0 -c 10\nPING 10.10.2.60 (10.10.2.60): 56 data bytes\n64 bytes from 10.10.2.60: seq=0 ttl=64 time=0.767 ms\n64 bytes from 10.10.2.60: seq=1 ttl=64 time=1.150 ms\n64 bytes from 10.10.2.60: seq=2 ttl=64 time=1.120 ms\n64 bytes from 10.10.2.60: seq=3 ttl=64 time=0.968 ms\n64 bytes from 10.10.2.60: seq=4 ttl=64 time=1.002 ms\n64 bytes from 10.10.2.60: seq=5 ttl=64 time=0.601 ms\n64 bytes from 10.10.2.60: seq=6 ttl=64 time=1.132 ms\n64 bytes from 10.10.2.60: seq=7 ttl=64 time=0.833 ms\n64 bytes from 10.10.2.60: seq=8 ttl=64 time=0.666 ms\n64 bytes from 10.10.2.60: seq=9 ttl=64 time=0.795 ms\n\n--- 10.10.2.60 ping statistics ---\n10 packets transmitted, 10 packets received, 0% packet loss\nround-trip min/avg/max = 0.601/0.903/1.150 ms\n</code></pre> <p>From the results, the modified Gthulhu scheduler enables the UPF to process packets from UERANSIM in a short time under high load conditions. This performance is consistent with our expectations.</p>"},{"location":"blog/20250726/index.en/#reducing-rtt-through-custom-configuration","title":"Reducing RTT through Custom Configuration","text":"<p>In the previous experiments, we allocated dedicated CPUs for specific processes, which indeed improved RTT performance under high load conditions. However, this approach is not universal, as each system's load conditions and workloads may differ. Therefore, Gthulhu has developed a set of custom configuration settings that allow users to adjust scheduling strategies according to their needs. For the project source code, please refer to Gthulhu/api.</p> <pre><code>{\n  \"server\": {\n    \"port\": \":8080\",\n    \"read_timeout\": 15,\n    \"write_timeout\": 15,\n    \"idle_timeout\": 60\n  },\n  \"logging\": {\n    \"level\": \"info\",\n    \"format\": \"text\"\n  },\n  \"jwt\": {\n    \"private_key_path\": \"./config/jwt_private_key.key\",\n    \"token_duration\": 24\n  },\n  \"strategies\": {\n    \"default\": [\n      {\n        \"priority\": true,\n        \"execution_time\": 20000,\n        \"selectors\": [\n          {\n            \"key\": \"app\",\n            \"value\": \"ueransim-macvlan\"\n          }\n        ],\n        \"command_regex\": \"nr-gnb|nr-ue|ping\"\n      }\n    ]\n  }\n}\n</code></pre> <p>Through the above JSON file, the API server can identify corresponding processes and update these processes' scheduling strategies to Gthulhu. If a task has <code>\"priority\": true</code>, the task itself can preempt other non-<code>\"priority\": true</code> tasks, significantly reducing the time from <code>runnable</code> to <code>running</code> state. In the free5GC integration case, reducing ueransim's scheduling delay means that the UPF can process packets from the RAN more quickly, thereby reducing overall RTT.</p> <p>The above video demonstrates how Gthulhu significantly reduces RTT performance through custom scheduling strategies under high load conditions.</p> <p>Additionally, Gthulhu also supports a simple WEB GUI, allowing users to manage and monitor</p>"},{"location":"blog/20250726/index.en/#conclusion","title":"Conclusion","text":"<p>5G introduces the concept of network slicing, expecting to provide different service qualities by dividing physical networks into multiple virtual networks. With custom schedulers like Gthulhu, we can more flexibly manage and optimize the performance of these virtual networks, deploy UPFs with different business requirements on different nodes, and adjust scheduling strategies according to actual needs.</p>"},{"location":"blog/20250726/index.en/#about-the-author","title":"About the Author","text":"<p>Ian Chen is a developer passionate about open source technology, focusing on research in 5G and cloud-native architectures. He initiated the Gthulhu project and is also a major contributor to free5GC, dedicated to promoting and implementing open source solutions for 5G networks.</p>"},{"location":"blog/20250903/","title":"Handover in Non-Terrestrial Networks","text":"<p>Note</p> <p>Author: Yung-Hsuan, Tsao Date: 2025/09/03</p> <p>As 5G evolves toward global connectivity, Non-Terrestrial Networks (NTN) have become a key enabler for extending mobile services beyond the reach of traditional terrestrial infrastructure. By leveraging satellites\u2014particularly Low Earth Orbit (LEO) constellations\u2014and high-altitude platforms, NTN promises to deliver coverage in remote, rural, and maritime regions where deploying ground-based base stations is impractical or economically unfeasible.</p> <p>One of the most critical challenges in NTN integration is handover (HO), which allows a user device (UE) to maintain an ongoing session while moving across different cells, satellites, or between terrestrial and non-terrestrial domains. Unlike conventional terrestrial handover, NTN handover is complicated by rapid satellite movement, longer propagation delays, Doppler effects, and frequent service beam changes. These characteristics demand new approaches to mobility management within the 5G Core (5GC) and Radio Access Network (RAN).</p> <p>This blog explores how NTN handover works, why it fundamentally differs from terrestrial scenarios, and what technical solutions are emerging to ensure seamless mobility across the sky and ground.</p>"},{"location":"blog/20250903/#why-handover-is-different-in-ntn","title":"Why Handover is Different in NTN","text":"<p>Handover in terrestrial 5G networks is already a complex process, but in NTN it becomes significantly more challenging due to the unique characteristics of satellite communication.</p> <ul> <li>Satellite Mobility: LEO satellites orbit the Earth in about 90\u2013120 minutes, so a UE may need to switch satellites every few minutes, resulting in widespread handover events compared to terrestrial networks.</li> <li>Doppler Effect: High relative velocities cause large Doppler shifts, complicating synchronization and stability during HO.</li> <li>Backhaul Constraints: Satellite feeder links may be capacity-limited or weather-dependent, influencing HO reliability.</li> </ul> <p>In short, NTN handover requires adaptations in mobility management, timing, and signaling beyond terrestrial assumptions.</p>"},{"location":"blog/20250903/#types-of-ntn-handover","title":"Types of NTN Handover","text":"<p>Handover can occur at different levels depending on the network topology and user movement to ensure seamless mobility in Non-Terrestrial Networks. The main categories are:</p> <p>1. Intra-Satellite Handover Occurs when UE switches between beams of the same satellite. Common in spot-beam architectures, where a single satellite projects multiple coverage areas to increase capacity. Like handovers in terrestrial networks, beam transitions are often more frequent due to satellite footprint movement.</p> <p>2. Inter-Satellite Handover Happens when the UE transitions from one satellite to another. Particularly frequent in LEO constellations, where satellites have fast-moving orbits and limited visibility duration. Coordinating between the NTN gateway, 5GC, and the Radio Access Network (RAN) is required to maintain session continuity.</p> <p>3. NTN to TN Handover A UE may move between terrestrial 5G and NTN coverage in hybrid deployments. This handover ensures service continuity when users travel from urban areas (dense terrestrial cells) to remote regions (served by satellites)\u2014often considered one of the most challenging scenarios because of significant differences in latency, Doppler, and scheduling strategies.</p>"},{"location":"blog/20250903/#conditional-handover","title":"Conditional Handover","text":"<p>Unlike traditional handovers where the source gNB immediately triggers a switch, Conditional Handover (CHO) allows the UE to pre-receive handover configurations and execute the switch autonomously when certain conditions are met (e.g., signal quality, timing, or position). This is particularly useful in NTN scenarios, where fast-moving LEO satellites cause frequent changes in serving cells.</p> <p></p> <ul> <li>[2] The source gNB requests CHO for one or more candidate cells belonging to one or more candidate gNBs.</li> <li>[3-4] A CHO request message is sent for each candidate cell. Candidate gNBs provide CHO responses with configurations of possible target cells.</li> <li>[5] The source gNB delivers these candidate cell configurations and execution conditions to the UE.</li> <li>[6] The UE acknowledges and stores them while staying connected to the source gNB.</li> <li>[7a-8] When one of the candidate cells meets the CHO condition, the UE independently detaches from the source gNB and completes handover to the selected target gNB.</li> </ul> <p>Any unused candidate configurations are discarded once the handover is successful.</p>"},{"location":"blog/20250903/#key-benefits-for-ntn","title":"Key Benefits for NTN","text":"<ul> <li>Reduced Interruption: UE doesn\u2019t wait for back-and-forth signaling at handover.</li> <li>Resilience to Delay: Useful in satellite links where RTT is higher than in terrestrial links.</li> <li>Frequent HO Handling: Helps mitigate the overhead caused by rapid satellite movement (handover every few minutes in LEO).</li> </ul>"},{"location":"blog/20250903/#ntn-handover-in-the-5g-core-architecture","title":"NTN Handover in the 5G Core Architecture","text":""},{"location":"blog/20250903/#control-plane-perspective","title":"Control Plane Perspective","text":"<p>From the control plane perspective, NTN handover is primarily orchestrated by the 5G Core:</p> <ul> <li>AMF (Access and Mobility Management Function)<ul> <li>Manages UE registration, context transfer, and mobility events.</li> <li>Handles signaling for HO requests and target cell selection.</li> </ul> </li> <li>SMF (Session Management Function)<ul> <li>Ensures session continuity by managing PDU session contexts during path switches.</li> <li>Coordinates with the UPF to redirect data flows post-handover.</li> </ul> </li> <li>NG-RAN Integration<ul> <li>gNBs (or TNGF for satellite access) report measurement events and initiate HO procedures.</li> <li>Control-plane signaling is adapted to cope with higher delays and Doppler effects.</li> </ul> </li> </ul> <p>The key challenge is ensuring UE context transfer happens fast enough to prevent session drops despite long propagation delays.</p>"},{"location":"blog/20250903/#data-plane-perspective","title":"Data Plane Perspective","text":"<p>On the data plane, the UPF plays a crucial role in maintaining uninterrupted user traffic flow:</p> <ul> <li>Path Switch Procedure: When the serving gNB changes (e.g., due to inter-satellite HO), the UPF must update its forwarding path.</li> <li>Session Anchoring: New UPFs may be selected to optimize latency or resource use.</li> <li>Latency Considerations: With satellite backhaul, rerouting packets through different gateways introduces additional delay. Efficient path switching is essential to minimize service interruption.</li> </ul>"},{"location":"blog/20250903/#conclusion","title":"Conclusion","text":"<p>NTN handover is more than a simple extension of terrestrial mobility procedures\u2014it represents one of the core challenges of integrating satellites into the 5G system. With satellites rushing, introducing high delays, and demanding frequent beam or satellite switches, mobility management must evolve to ensure seamless global coverage.</p> <p>Looking ahead, a combination of predictive algorithms, smarter session anchoring, and advanced multi-connectivity strategies will be essential for achieving reliable NTN handovers. As 5G moves toward 6G, seamless mobility across space and ground will be a defining feature of next-generation connectivity.</p>"},{"location":"blog/20250903/#reference","title":"Reference","text":"<ul> <li>TS 38.300</li> <li>3GPP Release 18</li> </ul>"},{"location":"blog/20250903/#about","title":"About","text":"<p>Hi, I'm Yung-Hsuan! A newcomer to 5G and the free5GC community. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20250903/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: https://github.com/reki9185</li> </ul>"},{"location":"blog/20250913/20250913/","title":"GTP5G-Tracer: Detailed Project Explanation","text":""},{"location":"blog/20250913/20250913/#overview","title":"Overview","text":"<p>gtp5g-tracer is an eBPF-based network tracing tool specifically designed to monitor and trace GTP-U (GPRS Tunneling Protocol User Plane) traffic in 5G networks. It provides real-time visibility into packet flows through the GTP5G kernel module, which is crucial for debugging and monitoring 5G network performance.</p>"},{"location":"blog/20250913/20250913/#what-is-gtp5g","title":"What is GTP5G?","text":"<p>GTP (GPRS Tunneling Protocol) is a fundamental protocol in mobile networks that has been used from 2G/GPRS through 5G networks. Here's why it's important:</p>"},{"location":"blog/20250913/20250913/#gtp5g-tracer","title":"GTP5G-Tracer","text":""},{"location":"blog/20250913/20250913/#uplink-flow-ue-internet","title":"Uplink Flow (UE \u2192 Internet)","text":"<pre><code>+--------+        +--------+        +----------------+        +---------+\n|   UE   | -----&gt; |  gNB   | -----&gt; | UPF GTP Module | -----&gt; | Internet|\n+--------+        +--------+        +----------------+        +---------+\n                                           |\n                                           | gtp5g_encap_recv() called\n                                           \u2193\n                  +------------------------------------------+\n                  | BPF fentry hook triggered                |\n                  | - Logs PID, TGID, CPU                    |\n                  | - Logs device name (e.g., wlp2s0)        |\n                  +------------------------------------------+\n                                           |\n                                           | GTP packet processing\n                                           | - GTP header removed\n                                           | - Inner IP packet extracted\n                                           \u2193\n                  +------------------------------------------+\n                  | BPF fexit hook triggered                 |\n                  | - Logs PID, TGID, CPU                    |\n                  | - Logs device name (e.g., upfgtp)        |\n                  +------------------------------------------+\n                                           |\n                                           \u2193\n                                    Packet continues\n                                    to destination\n</code></pre>"},{"location":"blog/20250913/20250913/#downlink-flow-internet-ue","title":"Downlink Flow (Internet \u2192 UE)","text":"<pre><code>+---------+        +----------------+        +--------+        +--------+\n| Internet| -----&gt; | UPF GTP Module | -----&gt; |  gNB   | -----&gt; |   UE   |\n+---------+        +----------------+        +--------+        +--------+\n                          |\n                          | gtp5g_xmit_skb_ipv4() called\n                          \u2193\n                  +------------------------------------------+\n                  | BPF fentry hook triggered                |\n                  | - Logs PID, TGID, CPU                    |\n                  | - Logs device name (e.g., upfgtp)        |\n                  +------------------------------------------+\n                          |\n                          | GTP packet processing\n                          | - GTP header added\n                          | - IP packet encapsulated\n                          \u2193\n                  +------------------------------------------+\n                  | BPF fexit hook triggered                 |\n                  | - Logs PID, TGID, CPU                    |\n                  | - Logs device name (e.g., wlp2s0)        |\n                  +------------------------------------------+\n                          |\n                          \u2193\n                    Packet continues\n                    to destination\n</code></pre>"},{"location":"blog/20250913/20250913/#understanding-the-log","title":"Understanding the Log","text":"<p>The logs from the GTP5G tracer provide valuable insights into the packet flow through the GTP tunnels in our 5G network. Let's break down what each part of the log means:</p> <p>after: <pre><code>sudo cat /sys/kernel/debug/tracing/trace_pipe\n</code></pre></p> <pre><code>irq/135-iwlwifi-457     [007] ..s21 534515.160592: bpf_trace_printk: fexit/gtp5g_encap_recv: PID=457, TGID=457, CPU=7\nirq/135-iwlwifi-457     [007] ..s21 534515.160594: bpf_trace_printk: fexit/gtp5g_encap_recv: DEV=upfgtp\n</code></pre>"},{"location":"blog/20250913/20250913/#uplink-packet-example","title":"Uplink Packet Example","text":"<pre><code># Entry point - Packet arrives from UE\nirq/135-iwlwifi-457     [007] ..s21 534516.239030: bpf_trace_printk: fentry/gtp5g_encap_recv: PID=457, TGID=457, CPU=7\nirq/135-iwlwifi-457     [007] ..s21 534516.239035: bpf_trace_printk: fentry/gtp5g_encap_recv: DEV=wlp2s0\n\n# Exit point - Packet processed and forwarded\nirq/135-iwlwifi-457     [007] ..s21 534516.239047: bpf_trace_printk: fexit/gtp5g_encap_recv: PID=457, TGID=457, CPU=7\nirq/135-iwlwifi-457     [007] ..s21 534516.239048: bpf_trace_printk: fexit/gtp5g_encap_recv: DEV=upfgtp\n</code></pre>"},{"location":"blog/20250913/20250913/#analysis","title":"Analysis:","text":"<ol> <li>Packet arrives on wireless interface (<code>wlp2s0</code>)</li> <li>GTP5G module processes it (taking 17 microseconds)</li> <li>Packet exits on UPF GTP interface (<code>upfgtp</code>)</li> <li>Processing happens in interrupt context (<code>irq/135-iwlwifi</code>)</li> <li>Same CPU (7) handles the entire operation</li> </ol>"},{"location":"blog/20250913/20250913/#downlink-packet-example-hypothetical","title":"Downlink Packet Example (Hypothetical)","text":"<pre><code># Entry point - Packet arrives from Internet\nkworker/3:1-1234        [003] ..s21 534517.345030: bpf_trace_printk: fentry/gtp5g_xmit_skb_ipv4: PID=1234, TGID=1234, CPU=3\nkworker/3:1-1234        [003] ..s21 534517.345035: bpf_trace_printk: fentry/gtp5g_xmit_skb_ipv4: DEV=upfgtp\n\n# Exit point - Packet processed and forwarded\nkworker/3:1-1234        [003] ..s21 534517.345047: bpf_trace_printk: fexit/gtp5g_xmit_skb_ipv4: PID=1234, TGID=1234, CPU=3\nkworker/3:1-1234        [003] ..s21 534517.345048: bpf_trace_printk: fexit/gtp5g_xmit_skb_ipv4: DEV=wlp2s0\n</code></pre> <p>Analysis: 1. Packet arrives on UPF GTP interface (<code>upfgtp</code>) 2. GTP5G module processes it (taking 12 microseconds) 3. Packet exits on wireless interface (<code>wlp2s0</code>) 4. Processing happens in kernel worker context 5. Same CPU (3) handles the entire operation</p>"},{"location":"blog/20250913/20250913/#log-components","title":"Log Components","text":"<ol> <li>Process Information: <code>irq/135-iwlwifi-457</code></li> <li>This shows the process handling the packet</li> <li><code>irq/135-iwlwifi</code> indicates it's an interrupt handler for the WiFi interface</li> <li> <p><code>457</code> is the process ID</p> </li> <li> <p>CPU Core: <code>[007]</code></p> </li> <li> <p>The packet is being processed on CPU core 7</p> </li> <li> <p>Timestamp: <code>534515.160592</code></p> </li> <li> <p>Time in seconds since system boot when this event occurred</p> </li> <li> <p>Trace Source: <code>bpf_trace_printk</code></p> </li> <li> <p>Indicates the log was generated by our eBPF program using the <code>bpf_printk()</code> function</p> </li> <li> <p>Function and Event Type: <code>fexit/gtp5g_encap_recv</code></p> </li> <li><code>fexit</code> means this is logged at the exit point of the function</li> <li> <p><code>gtp5g_encap_recv</code> is the function being traced (handling uplink traffic)</p> </li> <li> <p>Process Details: <code>PID=457, TGID=457, CPU=7</code></p> </li> <li>PID: Process ID handling the packet</li> <li>TGID: Thread Group ID (main process ID)</li> <li> <p>CPU: Confirms which CPU core is processing the packet</p> </li> <li> <p>Interface: <code>DEV=upfgtp</code> or <code>DEV=wlp2s0</code></p> </li> <li>The network device handling the packet</li> <li><code>upfgtp</code> is the GTP tunnel interface for the User Plane Function</li> <li><code>wlp2s0</code> is likely your wireless network interface</li> </ol>"},{"location":"blog/20250913/20250913/#packet-flow-analysis","title":"Packet Flow Analysis","text":"<p>Looking at the sequence of logs:</p> <pre><code>irq/135-iwlwifi-457     [007] ..s21 534516.239030: bpf_trace_printk: fentry/gtp5g_encap_recv: PID=457, TGID=457, CPU=7\nirq/135-iwlwifi-457     [007] ..s21 534516.239035: bpf_trace_printk: fentry/gtp5g_encap_recv: DEV=wlp2s0\nirq/135-iwlwifi-457     [007] ..s21 534516.239047: bpf_trace_printk: fexit/gtp5g_encap_recv: PID=457, TGID=457, CPU=7\nirq/135-iwlwifi-457     [007] ..s21 534516.239048: bpf_trace_printk: fexit/gtp5g_encap_recv: DEV=upfgtp\n</code></pre> <p>This sequence shows a complete uplink packet flow:</p> <ol> <li>Packet Entry (<code>fentry/gtp5g_encap_recv</code>):</li> <li>A packet enters the <code>gtp5g_encap_recv</code> function</li> <li>It comes from the wireless interface <code>wlp2s0</code></li> <li> <p>This is the start of uplink processing (UE \u2192 Core Network)</p> </li> <li> <p>Packet Exit (<code>fexit/gtp5g_encap_recv</code>):</p> </li> <li>The same packet exits the function after processing</li> <li>It's now associated with the <code>upfgtp</code> interface</li> <li> <p>This shows the packet has been successfully encapsulated in a GTP tunnel</p> </li> <li> <p>Processing Time:</p> </li> <li>The time difference between entry and exit (534516.239047 - 534516.239030 = 0.000017 seconds or 17 microseconds)</li> <li>This represents the processing overhead of GTP encapsulation</li> </ol>"},{"location":"blog/20250913/20250913/#what-this-tells-us","title":"What This Tells Us","text":"<ol> <li>Uplink Traffic Flow:</li> <li>The logs show packets coming from the wireless interface (likely from a UE)</li> <li>These packets are being encapsulated into GTP tunnels</li> <li> <p>They exit through the UPF's GTP interface toward the core network</p> </li> <li> <p>GTP Tunnel Operation:</p> </li> <li>The GTP5G module is successfully receiving packets from the wireless interface</li> <li>It's processing them through the <code>gtp5g_encap_recv</code> function</li> <li> <p>It's forwarding them through the GTP tunnel interface</p> </li> <li> <p>Performance Insights:</p> </li> <li>Processing time is in microseconds, showing efficient packet handling</li> <li>The same CPU core (7) handles the entire operation, avoiding inter-core communication overhead</li> <li>The interrupt handler for the wireless card is directly involved in the GTP processing</li> </ol>"},{"location":"blog/20250913/20250913/#significance-for-5g-networks","title":"Significance for 5G Networks","text":"<p>These logs confirm that:</p> <ol> <li>The GTP5G kernel module is correctly handling uplink traffic</li> <li>Packets are being properly encapsulated into GTP tunnels</li> <li>The data path from UE to core network is functioning</li> </ol> <p>This tracing capability is valuable for: - Debugging GTP tunnel issues - Performance analysis of the 5G user plane - Verifying correct packet flow in a 5G deployment - Identifying potential bottlenecks in packet processing</p>"},{"location":"blog/20250913/20250913/#bpf-tracing-vs-traditional-tracing-methods","title":"BPF Tracing vs. Traditional Tracing Methods","text":"Feature BPF Tracing tcpdump Overhead Very low Medium Kernel Modification No No Granularity Function level Packet level Context Information Rich (PID, CPU, etc.) Limited Dynamic Attachment Yes N/A Safety Verified by kernel N/A Performance Impact Minimal Medium"},{"location":"blog/20250913/20250913/#next-steps-hand-on-some-new-entry","title":"Next Steps: Hand-on some new entry","text":"<p>To gain further insights: 1. Compare with downlink traffic (look for <code>gtp5g_xmit_skb_ipv4</code> entries) 2. Correlate with actual application performance 3. Monitor under different load conditions 4. Compare processing times across different packet types and sizes </p> <p>List available functions in GTP5G: <pre><code>wirelab@wirelab-14Z980-G-AA52C2:~/work/gtp5g-tracer$ sudo cat /sys/kernel/tracing/available_filter_functions | grep \"gtp5g\"\n[sudo] password for wirelab: \nget_dbg_lvl [gtp5g]\nset_dbg_lvl [gtp5g]\nip_string [gtp5g]\ngtp5g_dev_uninit [gtp5g]\ngtp5g_dev_init [gtp5g]\ngtp5g_find_dev [gtp5g]\nupdate_usage_statistic [gtp5g]\ngtp5g_dev_xmit [gtp5g]\ndev_hashtable_new [gtp5g]\ngtp5g_hashtable_free [gtp5g]\ngtp5g_encap_disable.part.0 [gtp5g]\ngtp5g_encap_disable_locked [gtp5g]\n    .\n    .\n    .\n</code></pre></p> <p>These functions handle the main packet processing flow:</p> Function Description Tracing Value <code>gtp5g_encap_recv</code> Handles uplink GTP packets High - Entry point for uplink traffic <code>gtp5g_xmit_skb_ipv4</code> Transmits downlink packets High - Entry point for downlink traffic <code>gtp5g_handle_skb_ipv4</code> Processes IPv4 packets High - Core packet handling <code>gtp5g_push_header</code> Adds GTP header to packets Medium - Header encapsulation <code>ip4_find_route</code> Finds routing for IPv4 packets Medium - Routing decisions <code>ip_xmit</code> Transmits IP packets Medium - Final transmission <p>These functions handle QoS enforcement and traffic policing:</p> Function Description Tracing Value <code>policePacket</code> Applies traffic policing High - QoS enforcement <code>update_counter</code> Updates traffic counters Medium - Traffic accounting <code>update_usage_statistic</code> Updates usage statistics Medium - Usage tracking <code>check_counter</code> Checks traffic counters Low - Counter verification <p>These functions handle device initialization and management:</p> Function Description Tracing Value <code>gtp5g_dev_init</code> Initializes GTP5G device Medium - Device setup <code>gtp5g_dev_uninit</code> Uninitializes GTP5G device Medium - Device cleanup <code>gtp5g_find_dev</code> Finds GTP5G device Low - Device lookup <code>gtp5g_link_setup</code> Sets up GTP5G link Medium - Link establishment"},{"location":"blog/20250913/20250913/#enhanced-gtp5g-tracing-advanced-analysis-guide","title":"Enhanced GTP5G Tracing: Advanced Analysis Guide","text":"<p>This document provides a comprehensive explanation of the enhanced GTP5G tracer, focusing on the advanced features we've implemented and how to interpret the detailed trace output.</p>"},{"location":"blog/20250913/20250913/#1-introduction-to-enhanced-tracing","title":"1. Introduction to Enhanced Tracing","text":"<p>The enhanced GTP5G tracer provides deep visibility into the GTP5G kernel module's packet processing pipeline. Our advanced tracing features now capture:</p> <ul> <li>Packet lengths at various processing stages</li> <li>High-precision timestamps for performance analysis</li> <li>Hexadecimal representation of memory pointers</li> <li>Device transitions during packet processing</li> <li>GTP packet detection</li> <li>Packet metadata presence</li> </ul>"},{"location":"blog/20250913/20250913/#2-key-enhancements","title":"2. Key Enhancements","text":""},{"location":"blog/20250913/20250913/#21-packet-length-tracking","title":"2.1 Packet Length Tracking","text":"<p>We now track packet sizes throughout the processing pipeline:</p> <pre><code>if (skb)\n{\n    skb_len = skb-&gt;len;\n    bpf_printk(\"fentry/gtp5g_xmit_skb_ipv4: LEN=%u, TS=%llu\", skb_len, ts);\n}\n</code></pre> <p>This allows us to observe GTP header overhead and packet transformations.</p>"},{"location":"blog/20250913/20250913/#22-high-precision-timestamps","title":"2.2 High-Precision Timestamps","text":"<p>Nanosecond timestamps enable precise performance measurements:</p> <pre><code>__u64 ts = bpf_ktime_get_ns();\nbpf_printk(\"fexit/gtp5g_push_header: RET=0x%x (skb ptr), LEN=%u, TS=%llu\", ret, skb_len, ts);\n</code></pre>"},{"location":"blog/20250913/20250913/#23-improved-return-value-presentation","title":"2.3 Improved Return Value Presentation","text":"<p>Return values are now displayed in hexadecimal with explanatory comments:</p> <pre><code>bpf_printk(\"fexit/gtp5g_handle_skb_ipv4: PID=%u, TGID=%u, RET=0x%x (skb ptr)\", pid, tgid, ret);\n</code></pre>"},{"location":"blog/20250913/20250913/#24-device-transition-tracking","title":"2.4 Device Transition Tracking","text":"<p>We explicitly track which network interfaces packets traverse:</p> <pre><code>if (skb &amp;&amp; skb-&gt;dev)\n{\n    bpf_printk(\"fentry/gtp5g_xmit_skb_ipv4: DEV=%s\", skb-&gt;dev-&gt;name);\n}\n</code></pre>"},{"location":"blog/20250913/20250913/#3-packet-flow-analysis","title":"3. Packet Flow Analysis","text":""},{"location":"blog/20250913/20250913/#31-uplink-flow-ue-core-network","title":"3.1 Uplink Flow (UE \u2192 Core Network)","text":"<p>The trace clearly shows the uplink packet flow:</p> <pre><code># Packet arrives on external interface (wlp2s0)\nirq/135-iwlwifi-457 [007] ..s21 592868.790221: bpf_trace_printk: fentry/gtp5g_encap_recv: DEV=wlp2s0\nirq/135-iwlwifi-457 [007] ..s21 592868.790223: bpf_trace_printk: fentry/gtp5g_encap_recv: GTP packet detected (len &gt;= 8)\nirq/135-iwlwifi-457 [007] ..s21 592868.790225: bpf_trace_printk: fentry/gtp5g_encap_recv: PID=457, TGID=457, CPU=7, LEN=108\n\n# PDR lookup succeeds\nirq/135-iwlwifi-457 [007] ..s21 592868.790227: bpf_trace_printk: fentry/pdr_find_by_gtp1u: PID=457, TGID=457\nirq/135-iwlwifi-457 [007] ..s21 592868.790230: bpf_trace_printk: fexit/pdr_find_by_gtp1u: PID=457, PDR=Found\n\n# Packet exits on internal interface (upfgtp) after processing\nirq/135-iwlwifi-457 [007] ..s21 592868.790238: bpf_trace_printk: fexit/gtp5g_encap_recv: PID=457, TGID=457, CPU=7\nirq/135-iwlwifi-457 [007] ..s21 592868.790239: bpf_trace_printk: fexit/gtp5g_encap_recv: DEV=upfgtp\n</code></pre> <p>Key observations: - Initial packet length: 108 bytes (includes GTP header) - GTP packet detection confirms GTP-U protocol - PDR lookup succeeds, indicating proper rule configuration - Device transition: wlp2s0 (external) \u2192 upfgtp (internal)</p>"},{"location":"blog/20250913/20250913/#32-downlink-flow-core-network-ue","title":"3.2 Downlink Flow (Core Network \u2192 UE)","text":"<p>The downlink flow is equally well-documented:</p> <pre><code># Packet starts on internal interface (upfgtp)\nirq/135-iwlwifi-457 [007] b.s21 592868.797649: bpf_trace_printk: fentry/gtp5g_handle_skb_ipv4: PID=457, TGID=457, CPU=7\nirq/135-iwlwifi-457 [007] b.s21 592868.797650: bpf_trace_printk: fentry/gtp5g_handle_skb_ipv4: DEV=upfgtp\n\n# GTP header addition (encapsulation)\nirq/135-iwlwifi-457 [007] b.s21 592868.797655: bpf_trace_printk: fentry/gtp5g_push_header: PID=457, TGID=457, LEN=84\nirq/135-iwlwifi-457 [007] b.s21 592868.797655: bpf_trace_printk: fentry/gtp5g_push_header: DEV=upfgtp\nirq/135-iwlwifi-457 [007] b.s21 592868.797657: bpf_trace_printk: fexit/gtp5g_push_header: RET=0xc02cc8d0 (skb ptr), LEN=100, TS=592873802793332\n\n# Packet handling completed with new size\nirq/135-iwlwifi-457 [007] b.s21 592868.797661: bpf_trace_printk: fexit/gtp5g_handle_skb_ipv4: LEN=100, TS=592873802797124\nirq/135-iwlwifi-457 [007] b.s21 592868.797662: bpf_trace_printk: fexit/gtp5g_handle_skb_ipv4: PID=457, TGID=457, RET=0x13dfa000 (skb ptr)\n\n# Packet transmission begins\nirq/135-iwlwifi-457 [007] b.s21 592868.797664: bpf_trace_printk: fentry/gtp5g_xmit_skb_ipv4: DEV=upfgtp\nirq/135-iwlwifi-457 [007] b.s21 592868.797664: bpf_trace_printk: fentry/gtp5g_xmit_skb_ipv4: LEN=100, TS=592873802800132\nirq/135-iwlwifi-457 [007] b.s21 592868.797665: bpf_trace_printk: fentry/gtp5g_xmit_skb_ipv4: pktinfo exists\n\n# Packet exits on external interface with final size\nirq/135-iwlwifi-457 [007] b.s21 592868.797680: bpf_trace_printk: fexit/gtp5g_xmit_skb_ipv4: DEV=wlp2s0\nirq/135-iwlwifi-457 [007] b.s21 592868.797681: bpf_trace_printk: fexit/gtp5g_xmit_skb_ipv4: LEN=170, TS=592873802816526\n</code></pre> <p>Key observations: - Initial packet length: 84 bytes (IP packet) - After GTP header addition: 100 bytes (+16 bytes GTP header) - Final packet length: 170 bytes (additional headers added during transmission) - Device transition: upfgtp (internal) \u2192 wlp2s0 (external) - Return values shown as memory pointers (0xc02cc8d0, 0x13dfa000)</p>"},{"location":"blog/20250913/20250913/#4-performance-analysis","title":"4. Performance Analysis","text":""},{"location":"blog/20250913/20250913/#41-function-processing-time","title":"4.1 Function Processing Time","text":"<p>With high-precision timestamps, we can calculate processing times:</p> <pre><code># gtp5g_push_header function\nEntry: TS=592873802793332\nExit:  TS=592873802797124\nDuration: 3,792 nanoseconds (3.8 microseconds)\n\n# gtp5g_xmit_skb_ipv4 function\nEntry: TS=592873802800132\nExit:  TS=592873802816526\nDuration: 16,394 nanoseconds (16.4 microseconds)\n</code></pre>"},{"location":"blog/20250913/20250913/#42-gtp-header-overhead","title":"4.2 GTP Header Overhead","text":"<p>The traces clearly show the GTP header size:</p> <pre><code>Before encapsulation: 84 bytes\nAfter encapsulation:  100 bytes\nGTP header overhead:  16 bytes\n</code></pre>"},{"location":"blog/20250913/20250913/#conclusion","title":"Conclusion","text":"<p>The enhanced GTP5G tracer provides unprecedented visibility into the GTP5G kernel module's packet processing pipeline. With detailed packet length tracking, high-precision timestamps, improved return value presentation, and device transition tracking, it's now possible to gain deep insights into GTP-U packet processing, troubleshoot issues, and optimize performance.</p> <p>This level of visibility is essential for understanding, debugging, and optimizing 5G User Plane Function (UPF) implementations, making it an invaluable tool for 5G core network development and operations.</p>"},{"location":"blog/20250913/20250913/#about","title":"About","text":"<p>Hello, I'm William Lin. I'd like to share my excitement about being a member of the free5GC project, which is a part of the Linux Foundation. I'm always eager to discuss any aspects of core network development or related technologies.</p>"},{"location":"blog/20250913/20250913/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: williamlin0518</li> <li>Linkedin: Cheng Wei Lin</li> </ul>"},{"location":"blog/20251003/","title":"Visualizing 5G Core Metrics with Prometheus and Grafana on free5gc-helm","text":"<p>Note</p> <p>Author: Guo-Cheng Wu Date: 2025/10/03</p> <p>The telecommunications landscape is undergoing a monumental shift, transitioning from monolithic, hardware-centric systems to a cloud-native paradigm. As projects like <code>free5gc-helm</code> demonstrate, the future of 5G lies in containerized microservices orchestrated on platforms like Kubernetes. This evolution brings incredible benefits in scalability, resilience, and portability, allowing network functions to be deployed and scaled with unprecedented agility.</p> <p>However, this dynamic, distributed environment also introduces new challenges. With network functions running as dozens of pods across a cluster, how do we track their health? How do we measure performance, identify bottlenecks, or diagnose issues in real-time? The answer is observability. We need robust tools to collect, store, and visualize the vast amount of metrics these systems generate.</p> <p>This is where the powerful open-source duo of Prometheus and Grafana comes in. Prometheus provides a scalable and reliable time-series database for collecting metrics, while Grafana offers a flexible and intuitive platform for visualizing them.</p> <p>This blog post will serve as a comprehensive guide to integrating this monitoring stack with the <code>free5gc-helm</code> deployment. We will start by introducing the core concepts of Prometheus and Grafana, explaining their specific roles in monitoring a 5G core network, and finally, walk you through the exact steps to get everything up and running.</p>"},{"location":"blog/20251003/#what-is-prometheus","title":"What is Prometheus?","text":"<p>Prometheus is an open-source monitoring and alerting toolkit originally created at SoundCloud in 2012. It has since been widely adopted and is now a graduated project of the Cloud Native Computing Foundation (CNCF). At its core, Prometheus stores monitoring data as time series, where each metric is recorded with a timestamp and optional labels for richer context. It offers a powerful query language (PromQL) for flexible analysis, collects data through an efficient pull model over HTTP, and supports both static configuration and service discovery for target detection.</p>"},{"location":"blog/20251003/#key-features","title":"Key Features","text":"<ul> <li> <p>Multi-dimensional Data Model: Prometheus stores data as time series, where each series is identified by a metric name and a set of key-value pairs. This allows for powerful and flexible querying.</p> </li> <li> <p>Service Discovery: Prometheus can be configured to automatically discover targets to monitor. In Kubernetes, it can dynamically find pods and services based on their labels and annotations, eliminating the need to manually configure every single microservice.</p> </li> <li> <p>PromQL (Prometheus Query Language): A flexible and powerful functional query language designed specifically for time-series data. PromQL allows you to select, aggregate, and perform calculations on your metrics in real-time.</p> </li> <li> <p>Alerting: Prometheus integrates with the Alertmanager component, which handles alerts and notifications based on defined rules, ensuring that operators are notified of issues before they impact users.</p> </li> </ul>"},{"location":"blog/20251003/#what-is-grafana","title":"What is Grafana?","text":"<p>While Prometheus is excellent at collecting and storing data, its built-in graphing capabilities are basic and intended primarily for ad-hoc querying. To truly understand your data, you need a powerful visualization tool, and this is where Grafana shines.</p> <p>Grafana is an open-source observability platform that connects to a wide range of data sources, with Prometheus being one of the most popular. It enables users to build, explore, and share interactive dashboards, offering a unified view of complex systems.</p>"},{"location":"blog/20251003/#key-features_1","title":"Key Features","text":"<ul> <li> <p>Rich Visualizations: A wide variety of panels and plugins let you display metrics and logs in different formats \u2014 from time-series graphs and gauges to tables, and heatmaps.</p> </li> <li> <p>Dynamic Dashboards: Build reusable dashboards with template variables, enabling teams to quickly filter, drill down, and compare data across different environments or time ranges.</p> </li> <li> <p>Flexible Data Sources: Grafana is not tied to a single backend. You can mix queries from multiple data sources within the same dashboard, making it a powerful tool for heterogeneous systems.</p> </li> <li> <p>Exploration Tools: Easily run ad-hoc queries, explore metrics side by side, or pivot from metrics to logs with preserved labels for faster troubleshooting.</p> </li> <li> <p>Integrated Alerting: Define and manage alerts visually from your panels. Grafana continuously evaluates these rules and can send notifications to popular channels such as Slack, PagerDuty, or OpsGenie.</p> </li> </ul>"},{"location":"blog/20251003/#prometheus-and-grafana-in-the-5g-core-context","title":"Prometheus and Grafana in the 5G Core Context","text":"<p>So, how do these tools apply specifically to a free5GC deployment? A 5G core is a complex system of interconnected NFs, each responsible for a critical part of the network's operation. To ensure reliability and performance, we need to monitor Key Performance Indicators (KPIs) from each of these NFs.</p> <p>There are some metrics we can track in free5GC:</p> <ul> <li> <p>AMF:</p> <ul> <li>Number of active PDU sessions.</li> <li>Number of UEs that are connected to the core network.</li> <li>Number of UEs currently in the handover procedure.</li> </ul> </li> <li> <p>Other NFs:</p> <ul> <li>The latency of requests sent to other NFs.</li> <li>The total number of outbound SBI requests sent by an NF.</li> </ul> </li> </ul>"},{"location":"blog/20251003/#a-practical-guide-integrating-with-free5gc-helm","title":"A Practical Guide: Integrating with free5gc-helm","text":"<p>Starting from v4.2.0, free5GC includes support for Prometheus, which can be used with both free5gc-compose and free5gc-helm.</p> <p>In the following example, we will demonstrate how to set up and integrate Prometheus and Grafana with free5GC using <code>free5gc-helm</code>.</p>"},{"location":"blog/20251003/#step-1-deploy-free5gc-with-free5gc-helm","title":"Step 1: Deploy free5GC with free5gc-helm","text":"<p>You can follow our official guide to deploy free5gc-helm.</p> <p>Before installing, you need to update the configuration file of the NF you want to monitor and enable metrics. For example, to enable metrics for AMF, you should modify the <code>~/free5gc-helm/charts/free5gc/charts/free5gc-amf/values.yaml</code>, and set <code>metrics.enable</code> to <code>true</code>. </p> <p>After installing free5gc-helm, verify that all pods are running:</p> <ul> <li><code>kubectl get pods -n free5gc</code></li> </ul>"},{"location":"blog/20251003/#step-2-deploy-prometheus-and-grafana","title":"Step 2: Deploy Prometheus and Grafana","text":"<p>Use the Prometheus Community Kubernetes Helm Charts to install Prometheus and Grafana.</p> <ul> <li><code>helm repo add prometheus-community https://prometheus-community.github.io/helm-charts</code></li> <li><code>helm repo update</code></li> <li><code>helm install prometheus prometheus-community/kube-prometheus-stack -n free5gc</code></li> </ul> <p>After installation, confirm the pods are running:</p> <ul> <li><code>kubectl get pods -n free5gc</code> </li> </ul>"},{"location":"blog/20251003/#step-3-deploy-the-podmonitor-to-link-prometheus-and-free5gc","title":"Step 3: Deploy the PodMonitor to Link Prometheus and free5GC","text":"<p>This step links Prometheus with your free5GC pods. We provide a ready-to-use configuration file for a PodMonitor, which instructs the Prometheus Operator on how to discover and scrape metrics from the pods.</p> <ul> <li><code>cd ~/free5gc-helm/charts/free5gc</code></li> <li><code>kubectl apply -f prometheus.yaml</code> <p>Note: This example assumes free5GC is deployed in the <code>free5gc</code> namespace.</p> </li> </ul>"},{"location":"blog/20251003/#step-4-access-prometheus-and-grafana","title":"Step 4: Access Prometheus and Grafana","text":"<p>Once the <code>PodMonitor</code> is applied, the Prometheus Operator will automatically configure the Prometheus server to begin scraping your free5GC pods.</p>"},{"location":"blog/20251003/#access-prometheus","title":"Access Prometheus","text":"<ul> <li><code>kubectl port-forward --address 0.0.0.0 prometheus-prometheus-kube-prometheus-prometheus-0 9090:9090 -n free5gc</code></li> </ul> <p>Open your browser and confirm Prometheus is collecting metrics from each free5GC NF. </p>"},{"location":"blog/20251003/#access-grafana","title":"Access Grafana","text":"<p>First, check the Grafana pod name</p> <ul> <li><code>kubectl get pods -n free5gc</code></li> </ul> <p>Then, port-forward to access Grafana:</p> <ul> <li><code>kubectl port-forward --address 0.0.0.0 &lt;grafana_pod_name&gt; 3000:3000 -n free5gc</code></li> </ul> <p>You should see the login page of Grafana </p> <p>Log in with the default credentials:</p> <ul> <li>Username: admin</li> <li>Password: prom-operator</li> </ul>"},{"location":"blog/20251003/#step-5-add-the-prometheus-data-source-in-grafana","title":"Step 5: Add the Prometheus Data Source in Grafana","text":"<p>If the data source isn't automatically configured, you can add it manually.</p> <ol> <li>In Grafana, navigate to: <code>Home &gt; Connections &gt; Data sources &gt; Add new data source</code>.</li> <li> <p>Select Prometheus and configure the Prometheus server URL as <code>http://prometheus-operated.monitoring.svc:9090</code>. </p> </li> <li> <p>Click Save &amp; Test. Once successful, you can start exploring your metrics.</p> </li> </ol>"},{"location":"blog/20251003/#step-6-explore-free5gc-data-in-grafana","title":"Step 6: Explore free5GC Data in Grafana","text":"<p>Before building a dashboard, the best place to verify that Grafana is receiving data from Prometheus is the Explore view.</p> <ol> <li>In the Grafana side menu, click the Explore icon.</li> <li>At the top of the page, select the Prometheus data source from the dropdown menu.</li> <li>In the query editor's Metrics browser, you can type <code>free5gc_</code> to see a list of all available metrics from your 5G core.</li> <li>Select a metric to query, for example, <code>free5gc_sbi_outbound_request_total</code>.</li> <li>Click the Run query button in the top-right corner.</li> </ol> <p>You should now see a graph displaying the real-time data for that metric, confirming that your observability pipeline is fully operational. </p>"},{"location":"blog/20251003/#building-your-first-dashboard","title":"Building Your First Dashboard","text":"<p>Now that you've confirmed data is flowing, you can create dashboards to visualize it. A dashboard is a collection of panels, with each panel displaying the result of a specific query. Navigate to the Dashboards section and click Create dashboard to build your first visualization.</p> <p>For your convenience, we have provided a starter dashboard that you can import directly. Simply copy the JSON model in Appendix and paste it into Grafana's import tool.</p>"},{"location":"blog/20251003/#conclusion","title":"Conclusion","text":"<p>The transition to a cloud-native 5G architecture is not just about containerizing network functions; it's about embracing the rich ecosystem of tools that make these dynamic systems manageable. By integrating Prometheus and Grafana with the <code>free5gc-helm</code> project, you unlock a powerful observability stack, transforming raw operational data into actionable insights. You are no longer flying blind; you now have the instrumentation to measure, analyze, and optimize your 5G core network with confidence, ensuring a more resilient and performant service for the future.</p>"},{"location":"blog/20251003/#reference","title":"reference","text":"<ul> <li>Prometheus official website</li> <li>Grafana Github</li> </ul>"},{"location":"blog/20251003/#about-me","title":"About me","text":"<p>Hi, I\u2019m Guo-Cheng Wu, a newcomer to 5G and free5GC, and currently conducting research on Network Slicing. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20251003/#connect-with-me","title":"Connect with Me","text":"<p>Github: https://github.com/leowu0407</p>"},{"location":"blog/20251003/#appendix","title":"Appendix","text":"<ul> <li>Grafana JSON Model <pre><code>{\n  \"__inputs\": [\n    {\n      \"name\": \"DS_PROMETHEUS\",\n      \"label\": \"prometheus\",\n      \"description\": \"\",\n      \"type\": \"datasource\",\n      \"pluginId\": \"prometheus\",\n      \"pluginName\": \"Prometheus\"\n    }\n  ],\n  \"__elements\": {},\n  \"__requires\": [\n    {\n      \"type\": \"grafana\",\n      \"id\": \"grafana\",\n      \"name\": \"Grafana\",\n      \"version\": \"12.1.1\"\n    },\n    {\n      \"type\": \"datasource\",\n      \"id\": \"prometheus\",\n      \"name\": \"Prometheus\",\n      \"version\": \"1.0.0\"\n    },\n    {\n      \"type\": \"panel\",\n      \"id\": \"stat\",\n      \"name\": \"Stat\",\n      \"version\": \"\"\n    },\n    {\n      \"type\": \"panel\",\n      \"id\": \"timeseries\",\n      \"name\": \"Time series\",\n      \"version\": \"\"\n    }\n  ],\n  \"annotations\": {\n    \"list\": [\n      {\n        \"builtIn\": 1,\n        \"datasource\": {\n          \"type\": \"grafana\",\n          \"uid\": \"-- Grafana --\"\n        },\n        \"enable\": true,\n        \"hide\": true,\n        \"iconColor\": \"rgba(0, 211, 255, 1)\",\n        \"name\": \"Annotations &amp; Alerts\",\n        \"target\": {\n          \"limit\": 100,\n          \"matchAny\": false,\n          \"tags\": [],\n          \"type\": \"dashboard\"\n        },\n        \"type\": \"dashboard\"\n      }\n    ]\n  },\n  \"editable\": true,\n  \"fiscalYearStartMonth\": 0,\n  \"graphTooltip\": 0,\n  \"id\": null,\n  \"links\": [],\n  \"panels\": [\n    {\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              {\n                \"color\": \"green\",\n                \"value\": 0\n              },\n              {\n                \"color\": \"red\",\n                \"value\": 80\n              }\n            ]\n          }\n        },\n        \"overrides\": []\n      },\n      \"gridPos\": {\n        \"h\": 8,\n        \"w\": 12,\n        \"x\": 0,\n        \"y\": 0\n      },\n      \"id\": 1,\n      \"options\": {\n        \"colorMode\": \"value\",\n        \"graphMode\": \"area\",\n        \"justifyMode\": \"auto\",\n        \"orientation\": \"auto\",\n        \"percentChangeColorMode\": \"standard\",\n        \"reduceOptions\": {\n          \"calcs\": [\n            \"lastNotNull\"\n          ],\n          \"fields\": \"\",\n          \"values\": false\n        },\n        \"showPercentChange\": false,\n        \"textMode\": \"auto\",\n        \"wideLayout\": true\n      },\n      \"pluginVersion\": \"12.1.1\",\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\",\n            \"uid\": \"${DS_PROMETHEUS}\"\n          },\n          \"editorMode\": \"builder\",\n          \"expr\": \"sum(clamp_min(free5gc_amf_business_ue_connectivity{instance=~\\\"$instance\\\"}, 0))\",\n          \"legendFormat\": \"__auto\",\n          \"range\": true,\n          \"refId\": \"A\"\n        }\n      ],\n      \"title\": \"Connected UEs\",\n      \"type\": \"stat\"\n    },\n    {\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              {\n                \"color\": \"green\",\n                \"value\": 0\n              },\n              {\n                \"color\": \"red\",\n                \"value\": 80\n              }\n            ]\n          }\n        },\n        \"overrides\": []\n      },\n      \"gridPos\": {\n        \"h\": 8,\n        \"w\": 12,\n        \"x\": 12,\n        \"y\": 0\n      },\n      \"id\": 2,\n      \"options\": {\n        \"colorMode\": \"value\",\n        \"graphMode\": \"area\",\n        \"justifyMode\": \"auto\",\n        \"orientation\": \"auto\",\n        \"percentChangeColorMode\": \"standard\",\n        \"reduceOptions\": {\n          \"calcs\": [\n            \"lastNotNull\"\n          ],\n          \"fields\": \"\",\n          \"values\": false\n        },\n        \"showPercentChange\": false,\n        \"textMode\": \"auto\",\n        \"wideLayout\": true\n      },\n      \"pluginVersion\": \"12.1.1\",\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\",\n            \"uid\": \"${DS_PROMETHEUS}\"\n          },\n          \"editorMode\": \"builder\",\n          \"expr\": \"sum(free5gc_amf_business_active_pdu_session_current_count{instance=~\\\"$instance\\\"})\",\n          \"legendFormat\": \"__auto\",\n          \"range\": true,\n          \"refId\": \"A\"\n        }\n      ],\n      \"title\": \"Active PDU Sessions\",\n      \"type\": \"stat\"\n    },\n    {\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"axisBorderShow\": false,\n            \"axisCenteredZero\": false,\n            \"axisColorMode\": \"text\",\n            \"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"barAlignment\": 0,\n            \"barWidthFactor\": 0.6,\n            \"drawStyle\": \"line\",\n            \"fillOpacity\": 10,\n            \"gradientMode\": \"opacity\",\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            },\n            \"insertNulls\": false,\n            \"lineInterpolation\": \"linear\",\n            \"lineWidth\": 1,\n            \"pointSize\": 5,\n            \"scaleDistribution\": {\n              \"type\": \"linear\"\n            },\n            \"showPoints\": \"auto\",\n            \"spanNulls\": false,\n            \"stacking\": {\n              \"group\": \"A\",\n              \"mode\": \"none\"\n            },\n            \"thresholdsStyle\": {\n              \"mode\": \"off\"\n            }\n          },\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              {\n                \"color\": \"green\",\n                \"value\": 0\n              },\n              {\n                \"color\": \"red\",\n                \"value\": 80\n              }\n            ]\n          }\n        },\n        \"overrides\": []\n      },\n      \"gridPos\": {\n        \"h\": 16,\n        \"w\": 24,\n        \"x\": 0,\n        \"y\": 8\n      },\n      \"id\": 4,\n      \"options\": {\n        \"legend\": {\n          \"calcs\": [],\n          \"displayMode\": \"list\",\n          \"placement\": \"bottom\",\n          \"showLegend\": true\n        },\n        \"tooltip\": {\n          \"hideZeros\": false,\n          \"mode\": \"multi\",\n          \"sort\": \"none\"\n        }\n      },\n      \"pluginVersion\": \"12.1.1\",\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\",\n            \"uid\": \"${DS_PROMETHEUS}\"\n          },\n          \"editorMode\": \"builder\",\n          \"expr\": \"sum by (nf_type) (rate(free5gc_sbi_outbound_request_total{nf_type=~\\\"$nf_type\\\", instance=~\\\"$instance\\\"}[1m]))\",\n          \"legendFormat\": \"{{nf_type}}\",\n          \"range\": true,\n          \"refId\": \"A\"\n        }\n      ],\n      \"title\": \"SBI Outbound Request Rate (1m avg)\",\n      \"type\": \"timeseries\"\n    },\n    {\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"color\": {\n            \"mode\": \"palette-classic\"\n          },\n          \"custom\": {\n            \"axisBorderShow\": false,\n            \"axisCenteredZero\": false,\n            \"axisColorMode\": \"text\",\n            \"axisLabel\": \"\",\n            \"axisPlacement\": \"auto\",\n            \"barAlignment\": 0,\n            \"barWidthFactor\": 0.6,\n            \"drawStyle\": \"line\",\n            \"fillOpacity\": 10,\n            \"gradientMode\": \"opacity\",\n            \"hideFrom\": {\n              \"legend\": false,\n              \"tooltip\": false,\n              \"viz\": false\n            },\n            \"insertNulls\": false,\n            \"lineInterpolation\": \"linear\",\n            \"lineWidth\": 1,\n            \"pointSize\": 5,\n            \"scaleDistribution\": {\n              \"type\": \"linear\"\n            },\n            \"showPoints\": \"auto\",\n            \"spanNulls\": false,\n            \"stacking\": {\n              \"group\": \"A\",\n              \"mode\": \"none\"\n            },\n            \"thresholdsStyle\": {\n              \"mode\": \"off\"\n            }\n          },\n          \"mappings\": [],\n          \"thresholds\": {\n            \"mode\": \"absolute\",\n            \"steps\": [\n              {\n                \"color\": \"green\",\n                \"value\": 0\n              },\n              {\n                \"color\": \"red\",\n                \"value\": 80\n              }\n            ]\n          },\n          \"unit\": \"s\"\n        },\n        \"overrides\": []\n      },\n      \"gridPos\": {\n        \"h\": 16,\n        \"w\": 24,\n        \"x\": 0,\n        \"y\": 24\n      },\n      \"id\": 5,\n      \"options\": {\n        \"legend\": {\n          \"calcs\": [],\n          \"displayMode\": \"list\",\n          \"placement\": \"bottom\",\n          \"showLegend\": true\n        },\n        \"tooltip\": {\n          \"hideZeros\": false,\n          \"mode\": \"multi\",\n          \"sort\": \"none\"\n        }\n      },\n      \"pluginVersion\": \"12.1.1\",\n      \"targets\": [\n        {\n          \"datasource\": {\n            \"type\": \"prometheus\",\n            \"uid\": \"${DS_PROMETHEUS}\"\n          },\n          \"editorMode\": \"builder\",\n          \"expr\": \"(sum by (nf_type, target_service_name) (rate(free5gc_sbi_outbound_request_duration_seconds_sum{nf_type=~\\\"$nf_type\\\", instance=~\\\"$instance\\\"}[1m])) / sum by (nf_type, target_service_name) (rate(free5gc_sbi_outbound_request_duration_seconds_count{nf_type=~\\\"$nf_type\\\", instance=~\\\"$instance\\\"}[1m])))\",\n          \"legendFormat\": \"{{nf_type}} to {{target_service_name}}\",\n          \"range\": true,\n          \"refId\": \"A\"\n        }\n      ],\n      \"title\": \"Average SBI Request Latency (1m avg)\",\n      \"type\": \"timeseries\"\n    }\n  ],\n  \"refresh\": \"5s\",\n  \"schemaVersion\": 41,\n  \"tags\": [],\n  \"templating\": {\n    \"list\": [\n      {\n        \"current\": {},\n        \"datasource\": {\n          \"type\": \"prometheus\",\n          \"uid\": \"${DS_PROMETHEUS}\"\n        },\n        \"definition\": \"label_values(free5gc_sbi_outbound_request_total, nf_type)\",\n        \"includeAll\": true,\n        \"multi\": true,\n        \"name\": \"nf_type\",\n        \"options\": [],\n        \"query\": {\n          \"query\": \"label_values(free5gc_sbi_outbound_request_total, nf_type)\",\n          \"refId\": \"StandardVariableQuery\"\n        },\n        \"refresh\": 1,\n        \"regex\": \"\",\n        \"type\": \"query\"\n      },\n      {\n        \"current\": {},\n        \"datasource\": {\n          \"type\": \"prometheus\",\n          \"uid\": \"${DS_PROMETHEUS}\"\n        },\n        \"definition\": \"label_values(up, instance)\",\n        \"includeAll\": true,\n        \"multi\": true,\n        \"name\": \"instance\",\n        \"options\": [],\n        \"query\": {\n          \"query\": \"label_values(up, instance)\",\n          \"refId\": \"StandardVariableQuery\"\n        },\n        \"refresh\": 1,\n        \"regex\": \"\",\n        \"type\": \"query\"\n      }\n    ]\n  },\n  \"time\": {\n    \"from\": \"now-5m\",\n    \"to\": \"now\"\n  },\n  \"timepicker\": {},\n  \"timezone\": \"\",\n  \"title\": \"free5GC - Core Network Overview\",\n  \"uid\": \"68300355-86a7-4e3f-b15f-5f5a89160a6f\",\n  \"version\": 16,\n  \"weekStart\": \"\"\n}\n</code></pre></li> </ul>"},{"location":"blog/20251008/20251008/","title":"Getting Started with ns-3: A Guide to Network Simulation and 5G Modeling","text":"<p>Note</p> <p>Author: Pei-Chi, Cheng Date: 2025/10/08</p>"},{"location":"blog/20251008/20251008/#1-introduction","title":"1. Introduction","text":"<p>ns-3 is a discrete-event network simulator designed primarily for academic research and education. Unlike network emulation tools that mimic real-world networks, ns-3 focuses on simulating network behavior in a controlled, virtual environment. It is widely used to study network protocols, evaluate performance, and test network designs.</p>"},{"location":"blog/20251008/20251008/#what-is-discrete-event-simulation","title":"What is Discrete-Event Simulation?","text":"<p>Discrete-event simulation processes events (e.g., packet transmission, node movement) at specific time points, making it efficient for modeling complex network scenarios without continuous computation.</p>"},{"location":"blog/20251008/20251008/#key-features","title":"Key Features","text":"<ul> <li>Modular Design: ns-3 is highly modular, allowing users to customize and extend its functionality.</li> <li>Protocol Support: Supports a wide range of protocols including IPv4/IPv6, TCP/UDP, LTE/5G, Wi-Fi, and more.</li> <li>Event-Driven: Operates as a discrete-event simulator, processing events in a time-based sequence.</li> <li>Programming APIs: Provides APIs for both C++ and Python, catering to different user preferences.</li> </ul>"},{"location":"blog/20251008/20251008/#use-cases","title":"Use Cases","text":"<ul> <li>Researching and developing network protocols.</li> <li>Designing and testing network topologies.</li> <li>Simulating wireless, satellite, or mobile networks.</li> <li>Educational demonstrations for networking concepts.</li> </ul>"},{"location":"blog/20251008/20251008/#2-installation-and-environment-setup","title":"2. Installation and Environment Setup","text":""},{"location":"blog/20251008/20251008/#system-requirements","title":"System Requirements","text":"<p>ns-3 is primarily developed for Linux environments, with Ubuntu being the most commonly used platform. Required tools include:</p> <ul> <li>g++: C++ compiler.</li> <li>Python: For scripting and PyBind support.</li> <li>CMake: For build configuration.</li> <li>Additional dependencies like libxml2, sqlite, and others may be needed depending on modules.</li> </ul>"},{"location":"blog/20251008/20251008/#installation-steps","title":"Installation Steps","text":""},{"location":"blog/20251008/20251008/#step-1-install-dependencies","title":"Step 1: Install Dependencies:","text":"<pre><code>sudo apt update\nsudo apt install -y git g++ python3 python3-dev \\\n  cmake ninja-build pkg-config sqlite3 \\\n  libsqlite3-dev libboost-all-dev \\\n  libgsl-dev libgtk-3-dev\n</code></pre>"},{"location":"blog/20251008/20251008/#step-2-download-ns-3-source-code-using-version-342-as-an-example","title":"Step 2: Download ns-3 Source Code (using version 3.42 as an example)","text":"<pre><code>wget https://www.nsnam.org/releases/ns-allinone-3.42.tar.bz2\ntar xfj ns-allinone-3.42.tar.bz2\ncd ns-allinone-3.42/ns-3.42\n</code></pre>"},{"location":"blog/20251008/20251008/#step-3-configure-and-build","title":"Step 3: Configure and Build:","text":"<pre><code>./ns3 configure --enable-examples --enable-tests\n./ns3 build\n</code></pre> <p>Upon successful compilation, the terminal will display the configured modules, indicating which packages are included in your ns-3 simulator. </p>"},{"location":"blog/20251008/20251008/#step-4-verify-installation","title":"Step 4: Verify Installation:","text":"<p>Run a sample program to confirm the setup: <pre><code>./ns3 run hello-simulator\n</code></pre> A successful run will produce output confirming the simulator is operational. </p>"},{"location":"blog/20251008/20251008/#macos-installation-notes","title":"macOS Installation Notes","text":"<p>For macOS, install dependencies using Homebrew: <pre><code>brew install git python3 cmake ninja pkg-config sqlite boost gsl gtk+3\n</code></pre> For Windows, use WSL2 with Ubuntu or a Docker container.</p>"},{"location":"blog/20251008/20251008/#3-understanding-ns-3-directory-structure","title":"3. Understanding ns-3 Directory Structure","text":"<p>To navigate ns-3 effectively, understanding its directory structure is crucial. Below are key folders and their purposes:</p> Directory Description <code>scratch/</code> User-written test scripts for quick experiments <code>examples/</code> Official example programs demonstrating built-in features <code>src/</code> Core protocol modules (e.g., Wi-Fi, LTE, TCP/IP stack) <code>utils/</code> Utility tools for trace analysis and data collection <code>contrib/</code> Community-contributed extensions (e.g., 5G LENA) <code>build/</code> Compiled binaries and output files"},{"location":"blog/20251008/20251008/#4-compiling-and-running-simulations","title":"4. Compiling and Running Simulations","text":""},{"location":"blog/20251008/20251008/#running-a-scratch-program","title":"Running a Scratch Program","text":"<p>To execute a user-written script (e.g., mytest) in the <code>scratch/</code> directory: <pre><code>./ns3 run scratch/mytest\n</code></pre> Note: In older ns-3 versions, use <code>./waf</code> instead of <code>./ns3</code>: <pre><code>./waf run scratch/mytest\n</code></pre></p>"},{"location":"blog/20251008/20251008/#running-an-example","title":"Running an Example","text":"<p>To execute an official example: <pre><code>./ns3 run examples/tutorial/first.cc\n</code></pre></p>"},{"location":"blog/20251008/20251008/#adding-parameters","title":"Adding Parameters","text":"<p>Pass custom parameters to simulations: <pre><code>./ns3 run \"scratch/mytest --param=5 --duration=10s\"\n</code></pre></p>"},{"location":"blog/20251008/20251008/#5-example-the-3gpp-channel-model-simulation","title":"5. Example: The 3GPP Channel Model Simulation","text":""},{"location":"blog/20251008/20251008/#overview","title":"Overview","text":"<p>The <code>cttc-3gpp-channel-example.cc</code> from the 5G LENA module simulates a 5G NR network with:</p> <ul> <li>RemoteHost: Sends UDP traffic to user equipment (UEs).</li> <li>PGW: Connects UEs to the external network.</li> <li>gNB1, gNB2: 5G base stations.</li> <li>UE1, UE2: User equipment nodes.</li> </ul> <p>The simulation configures:</p> <ul> <li>3GPP TR 38.901 channel model.</li> <li>Antennas, beamforming, and TDMA-RR scheduler.</li> <li>UDP downlink traffic (10 packets per UE).</li> </ul> <p>The TR 38.901 model provides realistic channel characteristics for 5G, supporting scenarios like:</p> <ul> <li>UMa (Urban Macro): High base stations in urban areas.</li> <li>RMa (Rural Macro): Wide coverage in rural settings.</li> <li>UMi-StreetCanyon: Urban street-level environments.</li> </ul>"},{"location":"blog/20251008/20251008/#code-example","title":"Code Example","text":"<p>Below is the core code for <code>cttc-3gpp-channel-example.cc</code>. It leverages ns-3 Helper classes to simplify the setup of complex network components.</p> <pre><code>// Copyright (c) 2019 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n/**\n * \\file cttc-3gpp-channel-example.cc\n * \\ingroup examples\n * \\brief Channel Example\n *\n * This example describes how to setup a simulation using the 3GPP channel model\n * from TR 38.901. Topology consists by default of 2 UEs and 2 gNbs, and can be\n * configured to be either mobile or static scenario.\n *\n * The output of this example are default NR trace files that can be found in\n * the root ns-3 project folder.\n */\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/nr-helper.h\"\n#include \"ns3/nr-mac-scheduler-tdma-rr.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/nr-point-to-point-epc-helper.h\"\n#include \"ns3/point-to-point-helper.h\"\n#include &lt;ns3/antenna-module.h&gt;\n#include &lt;ns3/buildings-helper.h&gt;\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    std::string scenario = \"UMa\"; // scenario\n    double frequency = 28e9;      // central frequency\n    double bandwidth = 100e6;     // bandwidth\n    double mobility = false;      // whether to enable mobility\n    double simTime = 1;           // in second\n    double speed = 1;             // in m/s for walking UT.\n    bool logging = true; // whether to enable logging from the simulation, another option is by\n                         // exporting the NS_LOG environment variable\n    double hBS;          // base station antenna height in meters\n    double hUT;          // user antenna height in meters\n    double txPower = 40; // txPower\n    enum BandwidthPartInfo::Scenario scenarioEnum = BandwidthPartInfo::UMa;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"scenario\",\n                 \"The scenario for the simulation. Choose among 'RMa', 'UMa', 'UMi-StreetCanyon', \"\n                 \"'InH-OfficeMixed', 'InH-OfficeOpen'.\",\n                 scenario);\n    cmd.AddValue(\"frequency\", \"The central carrier frequency in Hz.\", frequency);\n    cmd.AddValue(\"mobility\",\n                 \"If set to 1 UEs will be mobile, when set to 0 UE will be static. By default, \"\n                 \"they are mobile.\",\n                 mobility);\n    cmd.AddValue(\"logging\", \"If set to 0, log components will be disabled.\", logging);\n    cmd.Parse(argc, argv);\n\n    // enable logging\n    if (logging)\n    {\n        // LogComponentEnable (\"ThreeGppSpectrumPropagationLossModel\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"ThreeGppPropagationLossModel\", LOG_LEVEL_ALL);\n        // LogComponentEnable (\"ThreeGppChannelModel\", LOG_LEVEL_ALL);\n        // LogComponentEnable (\"ChannelConditionModel\", LOG_LEVEL_ALL);\n        // LogComponentEnable (\"UdpClient\", LOG_LEVEL_INFO);\n        // LogComponentEnable (\"UdpServer\", LOG_LEVEL_INFO);\n        // LogComponentEnable (\"NrRlcUm\", LOG_LEVEL_LOGIC);\n        // LogComponentEnable (\"NrPdcp\", LOG_LEVEL_INFO);\n    }\n\n    /*\n     * Default values for the simulation. We are progressively removing all\n     * the instances of SetDefault, but we need it for legacy code (LTE)\n     */\n    Config::SetDefault(\"ns3::NrRlcUm::MaxTxBufferSize\", UintegerValue(999999999));\n\n    // set mobile device and base station antenna heights in meters, according to the chosen\n    // scenario\n    if (scenario == \"RMa\")\n    {\n        hBS = 35;\n        hUT = 1.5;\n        scenarioEnum = BandwidthPartInfo::RMa;\n    }\n    else if (scenario == \"UMa\")\n    {\n        hBS = 25;\n        hUT = 1.5;\n        scenarioEnum = BandwidthPartInfo::UMa;\n    }\n    else if (scenario == \"UMi-StreetCanyon\")\n    {\n        hBS = 10;\n        hUT = 1.5;\n        scenarioEnum = BandwidthPartInfo::UMi_StreetCanyon;\n    }\n    else if (scenario == \"InH-OfficeMixed\")\n    {\n        hBS = 3;\n        hUT = 1;\n        scenarioEnum = BandwidthPartInfo::InH_OfficeMixed;\n    }\n    else if (scenario == \"InH-OfficeOpen\")\n    {\n        hBS = 3;\n        hUT = 1;\n        scenarioEnum = BandwidthPartInfo::InH_OfficeOpen;\n    }\n    else\n    {\n        NS_ABORT_MSG(\"Scenario not supported. Choose among 'RMa', 'UMa', 'UMi-StreetCanyon', \"\n                     \"'InH-OfficeMixed', and 'InH-OfficeOpen'.\");\n    }\n\n    // create base stations and mobile terminals\n    NodeContainer gnbNodes;\n    NodeContainer ueNodes;\n    gnbNodes.Create(2);\n    ueNodes.Create(2);\n\n    // position the base stations\n    Ptr&lt;ListPositionAllocator&gt; gnbPositionAlloc = CreateObject&lt;ListPositionAllocator&gt;();\n    gnbPositionAlloc-&gt;Add(Vector(0.0, 0.0, hBS));\n    gnbPositionAlloc-&gt;Add(Vector(0.0, 80.0, hBS));\n    MobilityHelper gnbMobility;\n    gnbMobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    gnbMobility.SetPositionAllocator(gnbPositionAlloc);\n    gnbMobility.Install(gnbNodes);\n\n    // position the mobile terminals and enable the mobility\n    MobilityHelper uemobility;\n    uemobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    uemobility.Install(ueNodes);\n\n    if (mobility)\n    {\n        ueNodes.Get(0)-&gt;GetObject&lt;MobilityModel&gt;()-&gt;SetPosition(\n            Vector(90, 15, hUT)); // (x, y, z) in m\n        ueNodes.Get(0)-&gt;GetObject&lt;ConstantVelocityMobilityModel&gt;()-&gt;SetVelocity(\n            Vector(0, speed, 0)); // move UE1 along the y axis\n\n        ueNodes.Get(1)-&gt;GetObject&lt;MobilityModel&gt;()-&gt;SetPosition(\n            Vector(30, 50.0, hUT)); // (x, y, z) in m\n        ueNodes.Get(1)-&gt;GetObject&lt;ConstantVelocityMobilityModel&gt;()-&gt;SetVelocity(\n            Vector(-speed, 0, 0)); // move UE2 along the x axis\n    }\n    else\n    {\n        ueNodes.Get(0)-&gt;GetObject&lt;MobilityModel&gt;()-&gt;SetPosition(Vector(90, 15, hUT));\n        ueNodes.Get(0)-&gt;GetObject&lt;ConstantVelocityMobilityModel&gt;()-&gt;SetVelocity(Vector(0, 0, 0));\n\n        ueNodes.Get(1)-&gt;GetObject&lt;MobilityModel&gt;()-&gt;SetPosition(Vector(30, 50.0, hUT));\n        ueNodes.Get(1)-&gt;GetObject&lt;ConstantVelocityMobilityModel&gt;()-&gt;SetVelocity(Vector(0, 0, 0));\n    }\n\n    /*\n     * Create NR simulation helpers\n     */\n    Ptr&lt;NrPointToPointEpcHelper&gt; nrEpcHelper = CreateObject&lt;NrPointToPointEpcHelper&gt;();\n    Ptr&lt;IdealBeamformingHelper&gt; idealBeamformingHelper = CreateObject&lt;IdealBeamformingHelper&gt;();\n    Ptr&lt;NrHelper&gt; nrHelper = CreateObject&lt;NrHelper&gt;();\n    nrHelper-&gt;SetBeamformingHelper(idealBeamformingHelper);\n    nrHelper-&gt;SetEpcHelper(nrEpcHelper);\n\n    /*\n     * Spectrum configuration. We create a single operational band and configure the scenario.\n     */\n    BandwidthPartInfoPtrVector allBwps;\n    CcBwpCreator ccBwpCreator;\n    const uint8_t numCcPerBand = 1; // in this example we have a single band, and that band is\n                                    // composed of a single component carrier\n\n    /* Create the configuration for the CcBwpHelper. SimpleOperationBandConf creates\n     * a single BWP per CC and a single BWP in CC.\n     *\n     * Hence, the configured spectrum is:\n     *\n     * |---------------Band---------------|\n     * |---------------CC-----------------|\n     * |---------------BWP----------------|\n     */\n    CcBwpCreator::SimpleOperationBandConf bandConf(frequency,\n                                                   bandwidth,\n                                                   numCcPerBand,\n                                                   scenarioEnum);\n    OperationBandInfo band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);\n    // Initialize channel and pathloss, plus other things inside band.\n    nrHelper-&gt;InitializeOperationBand(&amp;band);\n    allBwps = CcBwpCreator::GetAllBwps({band});\n\n    // Configure ideal beamforming method\n    idealBeamformingHelper-&gt;SetAttribute(\"BeamformingMethod\",\n                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));\n\n    // Configure scheduler\n    nrHelper-&gt;SetSchedulerTypeId(NrMacSchedulerTdmaRR::GetTypeId());\n\n    // Antennas for the UEs\n    nrHelper-&gt;SetUeAntennaAttribute(\"NumRows\", UintegerValue(2));\n    nrHelper-&gt;SetUeAntennaAttribute(\"NumColumns\", UintegerValue(4));\n    nrHelper-&gt;SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject&lt;IsotropicAntennaModel&gt;()));\n\n    // Antennas for the gNbs\n    nrHelper-&gt;SetGnbAntennaAttribute(\"NumRows\", UintegerValue(8));\n    nrHelper-&gt;SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(8));\n    nrHelper-&gt;SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject&lt;IsotropicAntennaModel&gt;()));\n\n    // install nr net devices\n    NetDeviceContainer gnbNetDev = nrHelper-&gt;InstallGnbDevice(gnbNodes, allBwps);\n    NetDeviceContainer ueNetDev = nrHelper-&gt;InstallUeDevice(ueNodes, allBwps);\n\n    int64_t randomStream = 1;\n    randomStream += nrHelper-&gt;AssignStreams(gnbNetDev, randomStream);\n    randomStream += nrHelper-&gt;AssignStreams(ueNetDev, randomStream);\n\n    nrHelper-&gt;GetGnbPhy(gnbNetDev.Get(0), 0)-&gt;SetTxPower(txPower);\n    nrHelper-&gt;GetGnbPhy(gnbNetDev.Get(1), 0)-&gt;SetTxPower(txPower);\n\n    // When all the configuration is done, explicitly call UpdateConfig ()\n    for (auto it = gnbNetDev.Begin(); it != gnbNetDev.End(); ++it)\n    {\n        DynamicCast&lt;NrGnbNetDevice&gt;(*it)-&gt;UpdateConfig();\n    }\n\n    for (auto it = ueNetDev.Begin(); it != ueNetDev.End(); ++it)\n    {\n        DynamicCast&lt;NrUeNetDevice&gt;(*it)-&gt;UpdateConfig();\n    }\n\n    // create the internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr&lt;Node&gt; pgw = nrEpcHelper-&gt;GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr&lt;Node&gt; remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.010)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n\n    Ipv4AddressHelper ipv4h;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n\n    Ptr&lt;Ipv4StaticRouting&gt; remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost-&gt;GetObject&lt;Ipv4&gt;());\n    remoteHostStaticRouting-&gt;AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(ueNodes);\n\n    Ipv4InterfaceContainer ueIpIface;\n    ueIpIface = nrEpcHelper-&gt;AssignUeIpv4Address(NetDeviceContainer(ueNetDev));\n\n    // assign IP address to UEs, and install UDP downlink applications\n    uint16_t dlPort = 1234;\n    ApplicationContainer clientApps;\n    ApplicationContainer serverApps;\n    for (uint32_t u = 0; u &lt; ueNodes.GetN(); ++u)\n    {\n        Ptr&lt;Node&gt; ueNode = ueNodes.Get(u);\n        // Set the default gateway for the UE\n        Ptr&lt;Ipv4StaticRouting&gt; ueStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(ueNode-&gt;GetObject&lt;Ipv4&gt;());\n        ueStaticRouting-&gt;SetDefaultRoute(nrEpcHelper-&gt;GetUeDefaultGatewayAddress(), 1);\n\n        UdpServerHelper dlPacketSinkHelper(dlPort);\n        serverApps.Add(dlPacketSinkHelper.Install(ueNodes.Get(u)));\n\n        UdpClientHelper dlClient(ueIpIface.GetAddress(u), dlPort);\n        dlClient.SetAttribute(\"Interval\", TimeValue(MicroSeconds(1)));\n        // dlClient.SetAttribute (\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n        dlClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n        dlClient.SetAttribute(\"PacketSize\", UintegerValue(1500));\n        clientApps.Add(dlClient.Install(remoteHost));\n    }\n\n    // attach UEs to the closest gNB\n    nrHelper-&gt;AttachToClosestGnb(ueNetDev, gnbNetDev);\n\n    // start server and client apps\n    serverApps.Start(Seconds(0.4));\n    clientApps.Start(Seconds(0.4));\n    serverApps.Stop(Seconds(simTime));\n    clientApps.Stop(Seconds(simTime - 0.2));\n\n    // enable the traces provided by the nr module\n    nrHelper-&gt;EnableTraces();\n\n    AnimationInterface anim(\"3gpp-channel.xml\");\n\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n\n    Ptr&lt;UdpServer&gt; serverApp = serverApps.Get(0)-&gt;GetObject&lt;UdpServer&gt;();\n    uint64_t receivedPackets = serverApp-&gt;GetReceived();\n\n    Simulator::Destroy();\n\n    if (receivedPackets == 10)\n    {\n        return EXIT_SUCCESS;\n    }\n    else\n    {\n        return EXIT_FAILURE;\n    }\n}\n</code></pre>"},{"location":"blog/20251008/20251008/#key-components-explained","title":"Key Components Explained","text":""},{"location":"blog/20251008/20251008/#node-and-mobility-setup","title":"Node and Mobility Setup","text":"<pre><code>NodeContainer gnbNodes;\nNodeContainer ueNodes;\ngnbNodes.Create(2);\nueNodes.Create(2);\n</code></pre> <p>Nodes are placed using <code>ListPositionAllocator</code> and controlled by <code>MobilityHelper</code>, which determines if the UEs are static or moving.</p>"},{"location":"blog/20251008/20251008/#helper-classes","title":"Helper Classes","text":"<p>Helpers simplify the creation of complex ns-3 objects. In this example:</p> Helper Purpose <code>NodeContainer</code> Creates and manages multiple nodes. <code>MobilityHelper</code> Assigns mobility or static positions to nodes. <code>NrHelper</code> Installs 5G gNB/UE devices and configures PHY/MAC layers. <code>NrPointToPointEpcHelper</code> Sets up the EPC (core) network and connects to the Internet. <code>IdealBeamformingHelper</code> Simulates 5G directional beamforming. <code>CcBwpCreator</code> Defines carrier bandwidth parts (BWPs) and frequency bands. <code>ThreeGppChannelHelper</code> Models 3GPP channel propagation characteristics. <p>These helpers abstract away internal complexity, allowing you to focus on system-level design instead of wiring individual components.</p>"},{"location":"blog/20251008/20251008/#epc-and-internet-configuration","title":"EPC and Internet Configuration","text":"<pre><code>Ptr&lt;NrPointToPointEpcHelper&gt; nrEpcHelper = CreateObject&lt;NrPointToPointEpcHelper&gt;();\nPtr&lt;Node&gt; pgw = nrEpcHelper-&gt;GetPgwNode();\n</code></pre> <p>A Point-to-Point link connects the PGW to a remote host, simulating the Internet backbone. The IPv4 stack and static routing are configured for connectivity.</p>"},{"location":"blog/20251008/20251008/#applications","title":"Applications","text":"<p>Each UE runs a UDP server, and the remote host sends 10 packets: <pre><code>UdpClientHelper dlClient(ueIpIface.GetAddress(u), dlPort);\ndlClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\ndlClient.SetAttribute(\"PacketSize\", UintegerValue(1500));\n</code></pre> This allows performance evaluation (throughput, delay, etc.) across the simulated 5G channel.</p>"},{"location":"blog/20251008/20251008/#visualization","title":"Visualization","text":"<p><pre><code>AnimationInterface anim(\"3gpp-channel.xml\");\n</code></pre> The AnimationInterface exports simulation data for NetAnim, allowing visual inspection of node mobility and packet exchanges.  NetAnim provides a graphical way to analyze your ns-3 simulation. Once your script generates <code>3gpp-channel.xml</code>, follow these steps:</p>"},{"location":"blog/20251008/20251008/#install-qt-required-for-netanim-gui","title":"Install Qt (required for NetAnim GUI):","text":"<pre><code>brew install qt\n</code></pre>"},{"location":"blog/20251008/20251008/#compile-netanim","title":"Compile NetAnim","text":"<pre><code>cd netanim-3.42\nqmake NetAnim.pro\nmake\n</code></pre>"},{"location":"blog/20251008/20251008/#run-netanim","title":"Run NetAnim:","text":"<pre><code>./NetAnim\n</code></pre> <p>Launch NetAnim, and you\u2019ll see the initial interface.  </p> <p>NetAnim provides three different views of the simulation:</p> <ul> <li> <p>Animator: Displays node positions, movements, and packet animations. The network topology, including nodes and their links, becomes visible. Click the file icon (top-left) and select 3gpp-channel.xml, you can see as following. </p> </li> <li> <p>Stats: Shows statistics for nodes. </p> </li> <li> <p>Packets: Visualizes packet flows between nodes. </p> </li> </ul> <p>NetAnim allows you to confirm topology correctness and visually inspect the packet flow throughout the simulation.</p>"},{"location":"blog/20251008/20251008/#conclusion","title":"Conclusion","text":"<p>ns-3 is a powerful and flexible simulation framework capable of modeling a wide range of network technologies. Its modular architecture allows researchers and developers to easily combine different layers of the protocol stack, experiment with realistic mobility and propagation models, and evaluate system performance under diverse scenarios.</p> <p>In this guide, we introduced the fundamentals of ns-3 and also explored a practical example using the 5G LENA module to simulate a 3GPP-compliant 5G network, complete with EPC integration, beamforming, and traffic modeling.</p> <p>To deepen your understanding, explore the official <code>examples/</code> directory, which contains well-documented sample scripts covering various protocols and use cases. You can also explore the <code>contrib/</code> directory to clone and integrate additional modules such as 5G LENA or mmWave.</p> <p>By experimenting with these examples and modules, you\u2019ll discover how ns-3 can serve as a robust research and prototyping platform for next-generation communication systems.</p>"},{"location":"blog/20251008/20251008/#reference","title":"Reference","text":"<ul> <li>[ns-3] mac\u5b89\u88dd\u6307\u5357\u53ca\u57fa\u672c\u4ecb\u7d39</li> <li>ns-3 Tutorial</li> <li>cttc-3gpp-channel-example.cc File Reference</li> </ul>"},{"location":"blog/20251008/20251008/#about-me","title":"About me","text":"<p>Hi, I'm Peggy Cheng, a newcomer to 5G and the free5GC community. Feel free to tell me if there's any mistake in the article.</p>"},{"location":"blog/20251008/20251008/#connect-with-me","title":"Connect with Me","text":"<p>GitHub: HiImPeggy</p>"},{"location":"blog/20251015/20251015/","title":"NGAP Introduction","text":"<p>Note</p> <p>Author: Wei, Chang Date: 2025/10/15</p> <p>NGAP (Next-Generation Application Protocol) is the control-plane protocol on the N2 interface between NG-RAN (gNB) and the 5GC (AMF). It defines modular Elementary Procedures (EPs) that carry Information Elements (IEs) to establish identities and capabilities, transport NAS end-to-end, manage UE context and PDU session resources, and support mobility (handover, path switch). Messages are ASN.1 APER-encoded and run over SCTP/IP, relying on shared identifiers (RAN-UE-NGAP-ID, AMF-UE-NGAP-ID, PDU Session ID) and transport anchors (TEIDs/IPs) to maintain state across procedures.</p>"},{"location":"blog/20251015/20251015/#main-functions","title":"Main functions","text":"<ul> <li>Paging: Notify the RAN to locate the UE.</li> <li>UE Context Management: Create, modify, and release the UE context in both the AMF and the gNB.</li> <li>PDU Session Management: Manage the UE\u2019s PDU sessions, e.g., establishing and releasing the resources required for connectivity to the UPF.</li> <li>Mobility Management: Handle handover procedures as the UE moves between different gNBs.</li> <li>NAS Message Transport: Transparently transfer NAS messages between the UE and the AMF.</li> <li>NG Interface Management: Manage the NGAP connection between the RAN and the AMF.</li> </ul>"},{"location":"blog/20251015/20251015/#message-model","title":"Message model","text":"<p>Every NGAP PDU (Protocol Data Unit) is exactly one of: - initiatingMessage (request/trigger) - successfulOutcome (positive response) - unsuccessfulOutcome (negative response)</p> <p>Messages are made of IEs (Information Elements). Each IE has id / criticality / presence.</p>"},{"location":"blog/20251015/20251015/#presence","title":"Presence","text":"<ul> <li>Mandatory: This IE must be present in the message. If it\u2019s missing, it\u2019s a protocol error and the whole message/procedure is typically discarded or fails.</li> <li>Optional: This IE may be present or absent; omission is not an error.</li> </ul>"},{"location":"blog/20251015/20251015/#assigned-criticality","title":"Assigned Criticality","text":"<p>This tells the receiver how to handle the IE if there\u2019s an issue. - reject: If this IE is problematic, reject the entire message/procedure; treat it as a failure. - ignore: If this IE is problematic, ignore this IE and continue processing the rest of the message.</p>"},{"location":"blog/20251015/20251015/#elementary-procedures-eps","title":"Elementary Procedures (EPs)","text":"<p>There are two types of elementary procedure classified into Class 1 and Class 2. - Class 1: Elementary Procedures with response (success and/or failure)</p> <p> - Class 2: Elementary Procedures without response.</p> <p></p>"},{"location":"blog/20251015/20251015/#interdependencies","title":"Interdependencies","text":"<ul> <li>Sequential: Initiating message \u2192 response (success/failure); failures abort or trigger error handling.</li> <li>Contextual: Later procedures depend on earlier context (e.g., UE context before resource setup).</li> <li>Shared IEs: UE IDs, security info, session details reused within/across procedures.</li> </ul>"},{"location":"blog/20251015/20251015/#key-procedure-summaries-ies-presence-criticality","title":"Key Procedure Summaries &amp; IEs (Presence / Criticality)","text":""},{"location":"blog/20251015/20251015/#1-ng-setup-request-gnbamf","title":"(1) NG Setup Request (gNB\u2192AMF)","text":"<p>Purpose: Introduce gNB; establish NG parameters.</p> <p>Key IEs</p> IE Presence Criticality Global RAN Node ID M reject RAN node name O ignore Supported TA List M reject default paging DRX M ignore <p>Effect: Registers gNB identity; constrains UE placement (TA/PLMN match).</p>"},{"location":"blog/20251015/20251015/#2-ng-setup-response-amfgnb","title":"(2) NG Setup Response (AMF\u2192gNB)","text":"<p>Purpose: Confirm setup; provide AMF identity/capacity.</p> <p>Key IEs</p> IE Presence Criticality AMF Name M reject Served GUAMI List M reject PLMN Support List M reject Relative AMF Capacity M ignore <p>Effect: gNB caches AMF identifiers; slice/PLMN alignment influences routing.</p>"},{"location":"blog/20251015/20251015/#3-initial-ue-message-gnbamf","title":"(3) Initial UE Message (gNB\u2192AMF)","text":"<p>Purpose: First UE-associated NGAP; carry initial NAS.</p> <p>Key IEs</p> IE Presence Criticality RAN-UE-NGAP-ID M reject NAS-PDU M reject User Location Information M reject RRC Establishment Cause M ignore 5G-S-TMSI O reject UE Context Request O ignore <p>Processing notes (38.413-8.6.1.2): - gNB allocates unique RAN-UE-NGAP-ID and includes it. - NAS-PDU is forwarded without interpretation. - Selected PLMN is indicated by PLMN Identity in the TAI (network sharing). - If UE Context Request present, AMF triggers Initial Context Setup. - Additional optional IEs (AMF Set ID, CE-mode-B, LTE-M indication, EDT Session, NPN info) are handled per TS 23.501/23.502.</p>"},{"location":"blog/20251015/20251015/#4-downlink-nas-transport-amfgnb","title":"(4) Downlink NAS Transport (AMF\u2192gNB)","text":"<p>Purpose: Deliver NAS to UE (e.g., Authentication Request, SMC, Registration Accept, PDU Session Accept).</p> <p>Key IEs</p> IE Presence Criticality AMF-UE-NGAP-ID M reject RAN-UE-NGAP-ID M reject NAS-PDU M reject"},{"location":"blog/20251015/20251015/#5-uplink-nas-transport-gnbamf","title":"(5) Uplink NAS Transport (gNB\u2192AMF)","text":"<p>Purpose: Forward UE NAS to AMF when a UE-associated logical NG-connection exists.</p> <p>Key IEs</p> IE Presence Criticality AMF-UE-NGAP-ID M reject RAN-UE-NGAP-ID M reject NAS-PDU M reject User Location Information M ignore <p>Note: NAS is transferred without interpretation in NG-RAN.</p>"},{"location":"blog/20251015/20251015/#6-initial-context-setup-request-amf-gnb","title":"(6) Initial Context Setup Request (AMF \u2192 gNB)","text":"<p>Purpose: Establish the UE\u2019s initial control-plane and user-plane context at the gNB after authentication/authorization.</p> <p>Key IEs</p> IE Presence Criticality AMF-UE-NGAP-ID M reject RAN-UE-NGAP-ID M reject GUAMI M reject Allowed NSSAI M reject UE Security Capabilities M reject Security Key M reject NAS-PDU O ignore Redirection Voice Fallback O ignore <p>Effect - gNB creates the UE context and configures required resources based on the above security/slice parameters; prepares for subsequent session setup. - Common side effect: triggers the gNB\u2019s RRC Security Mode Command.</p>"},{"location":"blog/20251015/20251015/#7-initial-context-setup-response-gnb-amf","title":"(7) Initial Context Setup Response (gNB \u2192 AMF)","text":"<p>Purpose: Indicates successful completion of the initial context setup initiated by the request; confirms radio/security configuration is in place at the gNB.</p> <p>Key IEs</p> IE Presence Criticality AMF-UE-NGAP-ID M ignore RAN-UE-NGAP-ID M ignore <p>Effect: AMF acknowledges the UE context is active at the gNB; the UE can proceed with further signaling and data transfer (including subsequent NAS and PDU Session resource procedures).</p>"},{"location":"blog/20251015/20251015/#8-pdu-session-resource-setup-request-amfgnb","title":"(8) PDU Session Resource Setup Request (AMF\u2192gNB)","text":"<p>Purpose: Assign resources on Uu and NG-U for one/more PDU sessions; set up DRBs/QoS flows.</p> <p>Key IEs</p> IE Presence Criticality AMF-UE-NGAP-ID M reject RAN-UE-NGAP-ID M reject RAN Paging Priority O ignore NAS-PDU O reject PDU Session Resource Setup List SUReq M reject"},{"location":"blog/20251015/20251015/#9-pdu-session-resource-setup-response-gnbamf","title":"(9) PDU Session Resource Setup Response (gNB\u2192AMF)","text":"<p>Key IEs</p> IE Presence Criticality AMF-UE-NGAP-ID M ignore RAN-UE-NGAP-ID M ignore PDU Session Resource Setup List SURes O ignore"},{"location":"blog/20251015/20251015/#test","title":"Test","text":""},{"location":"blog/20251015/20251015/#ng-setup-requestresponse","title":"NG Setup Request/Response","text":"<p>gNB:</p> <p></p> <p>AMF: </p> <p></p> <p>The first two steps are non-UE-associated, not yet tied to a specific UE.</p>"},{"location":"blog/20251015/20251015/#initial-ue-message","title":"Initial UE Message","text":"<p>gNB: </p> <p></p> <p>AMF: </p> <p></p>"},{"location":"blog/20251015/20251015/#downlink-uplink-nas-transport","title":"Downlink / Uplink NAS Transport","text":"<p>gNB: </p> <p></p> <p>AMF: </p> <p></p>"},{"location":"blog/20251015/20251015/#initial-context-setup-request","title":"Initial Context Setup Request","text":"<p>gNB: </p> <p></p> <p>AMF: </p> <p></p>"},{"location":"blog/20251015/20251015/#initial-context-setup-response","title":"Initial Context Setup Response","text":"<p>gNB: </p> <p></p> <p>AMF: </p> <p></p>"},{"location":"blog/20251015/20251015/#pdu-session-resource-setup-request","title":"PDU Session Resource Setup Request","text":"<p>gNB: </p> <p></p> <p>AMF: </p> <p></p>"},{"location":"blog/20251015/20251015/#pdu-session-resource-setup-response","title":"PDU Session Resource Setup Response","text":"<p>gNB: </p> <p></p> <p>AMF:</p> <p></p>"},{"location":"blog/20251015/20251015/#reference","title":"Reference","text":"<ul> <li>TS 38.413</li> <li>5G/NR Network  - NGAP/N2 Interface</li> <li>Week 3: Protocol Stack</li> </ul>"},{"location":"blog/20251015/20251015/#about","title":"About","text":"<p>Hi, I'm Wei, Chang! A newcomer to 5G and the free5GC community. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"blog/20251015/20251015/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: https://github.com/wiwi878</li> </ul>"},{"location":"blog/20251029/20251029/","title":"Introduction to 5G AKA","text":"<p>Note</p> <p>Author: Che-Wei Lin Date: 2025/10/29</p>"},{"location":"blog/20251029/20251029/#introduction","title":"Introduction","text":"<p>The 5G Authentication and Key Agreement (5G AKA) protocol is the primary authentication mechanism defined by 3GPP to secure communication between a user device (UE) and the network. It ensures mutual authentication between the User Equipment (UE), the Serving Network (SN), and the Home Network (HN), while also generating cryptographic keys used to protect subsequent data exchanges.</p> <p>In this article, we\u2019ll walk through the 5G AKA procedure and highlight selected segments of its implementation in free5GC, combining protocol concepts with practical implementation.</p>"},{"location":"blog/20251029/20251029/#quick-terms","title":"Quick terms","text":"<ul> <li><code>USIM</code>: Secure element holding the long-term key K and performing AKA functions</li> <li><code>SEAF</code>: Security Anchor Function (typically co-located with AMF; holds anchor keys)</li> <li><code>ARPF</code>: Authentication credential Repository and Processing Function (in UDM; generates auth vectors)</li> <li><code>SUPI</code>: Subscriber permanent identifier </li> <li><code>SUCI</code>: Concealed SUPI</li> <li><code>SNname (SNN)</code>: Serving Network Name</li> <li><code>RES*</code>: UE\u2019s computed response</li> <li><code>XRES*</code>: Expected response computed on the home side</li> <li><code>HRES*/HXRES*</code>: Hashed versions used for verification at AUSF/SEAF boundary</li> <li><code>CK</code>, <code>IK</code>: AKA cipher/integrity base keys used as inputs to 5G KDFs</li> <li><code>K</code>: Long-term secret in USIM and ARPF</li> <li><code>K_AUSF</code>: Key derived from CK/IK and SNN on both UE and AUSF sides</li> <li><code>K_SEAF</code>: Anchor key delivered to the serving network after successful auth</li> <li><code>K_AMF</code>: Key derived at UE and AMF from K_SEAF; source for NAS/AS keys</li> </ul>"},{"location":"blog/20251029/20251029/#5g-aka-procedure-and-steps-with-free5gc-code-spotlights","title":"5G AKA procedure and steps (with free5GC code spotlights)","text":"<p>5G AKA follows a challenge-and-response protocol. At a high level, the UE proves knowledge of a secret (K) shared with its home network. The home network creates an authentication challenge; the UE validates it and computes a response. If the response matches what the home network expects, both sides derive fresh keys and the serving network gets an anchor key to secure the session.</p> <p>Here is an overview of how the 5G AKA procedure works: Figure 1. The 5G AKA procedure (source: 3GPP TS 33.501). </p> <p>Note: The step numbers in the following explanation do not strictly correspond to those shown in the figure above.</p>"},{"location":"blog/20251029/20251029/#1-registration-request-and-identity-protection","title":"1. Registration request and identity protection","text":"<ul> <li>UE \u2192 gNB \u2192 AMF/SEAF: Sends a Registration Request carrying <code>SUCI</code>.</li> </ul>"},{"location":"blog/20251029/20251029/#2-vector-acquisition-from-the-home-network","title":"2. Vector acquisition from the home network","text":"<ul> <li>SEAF/AMF \u2192 AUSF: Ask for an auth vector.</li> <li>AUSF \u2192 UDM/ARPF: Request 5G-HE-AKA vector for the subscriber (UDM de\u2011conceals <code>SUCI</code> to <code>SUPI</code>).</li> <li>UDM/ARPF generates <code>RAND</code>, <code>AUTN</code>, <code>RES</code>, <code>CK</code>, <code>IK</code>; then derives <code>XRES*</code> and <code>K_AUSF</code>.</li> </ul> <p>Code spotlight (<code>XRES*</code> derivation and 5G-HE auth vector) udm/internal/sbi/processor/generate_auth_data.go: <pre><code>// Key = CK || IK, per TS 33.501\nkey := append(CK, IK...)\nFC := ueauth.FC_FOR_RES_STAR_XRES_STAR_DERIVATION\nP0 := []byte(authInfoRequest.ServingNetworkName) // SNN\nP1 := RAND\nP2 := RES\n\nkdfValForXresStar, err := ueauth.GetKDFValue(\n    key, FC,\n    P0, ueauth.KDFLen(P0),\n    P1, ueauth.KDFLen(P1),\n    P2, ueauth.KDFLen(P2),\n)\nxresStar := kdfValForXresStar[len(kdfValForXresStar)/2:]\n\n// Fill in rand, xres, autn, ckPrime, ikPrime\nav.Rand = hex.EncodeToString(RAND)\nav.Xres = hex.EncodeToString(RES)\nav.Autn = hex.EncodeToString(AUTN)\nav.CkPrime = hex.EncodeToString(ckPrime)\nav.IkPrime = hex.EncodeToString(ikPrime)\nav.AvType = models.AvType_EAP_AKA_PRIME\n</code></pre></p>"},{"location":"blog/20251029/20251029/#3-network-challenges-the-ue","title":"3. Network challenges the UE","text":"<ul> <li>AUSF \u2192 AMF: Provides <code>RAND</code>, <code>AUTN</code>, and <code>HXRES*</code> plus <code>SNN</code> context.</li> <li>AMF \u2192 UE: Sends NAS Authentication Request (<code>RAND</code>, <code>AUTN</code>).</li> </ul> <p>Code spotlight (AUSF computing <code>HXRES*</code> to include in 5G-SE AV): ausf/internal/sbi/processor/ue_authentication.go: <pre><code>// Derive HXRES* from XRES*\nconcat := authInfoResult.AuthenticationVector.Rand + authInfoResult.AuthenticationVector.XresStar\nvar hxresStarBytes []byte\nif bytes, err := hex.DecodeString(concat); err != nil {\n    // ...\n} else {\n    hxresStarBytes = bytes\n}\nhxresStarAll := sha256.Sum256(hxresStarBytes)\nhxresStar := hex.EncodeToString(hxresStarAll[16:]) // last 128 bits\n</code></pre></p> <p>Code spotlight (AMF building Authentication Request) amf/internal/gmm/message/build.go: <pre><code>// Set RAND (16 bytes) into NAS IE\nrand, err := hex.DecodeString(av5gAka.Rand)\nif err != nil { return nil, err }\nauthenticationRequest.AuthenticationParameterRAND =\n    nasType.NewAuthenticationParameterRAND(nasMessage.AuthenticationRequestAuthenticationParameterRANDType)\nvar tmp [16]byte\ncopy(tmp[:], rand[0:16])\nauthenticationRequest.AuthenticationParameterRAND.SetRANDValue(tmp)\n\n// Set AUTN (16 bytes) into NAS IE\nautn, err := hex.DecodeString(av5gAka.Autn)\nif err != nil { return nil, err }\nauthenticationRequest.AuthenticationParameterAUTN =\n    nasType.NewAuthenticationParameterAUTN(nasMessage.AuthenticationRequestAuthenticationParameterAUTNType)\ncopy(tmp[:], autn[0:16])\nauthenticationRequest.AuthenticationParameterAUTN.SetAUTNValue(tmp)\n</code></pre></p>"},{"location":"blog/20251029/20251029/#4-ue-validates-autn-and-computes-res-derives-keys","title":"4. UE validates <code>AUTN</code> and computes <code>RES*</code>, derives keys","text":"<ul> <li>UE checks <code>AUTN</code> MAC and <code>SQN</code> freshness; if ok, computes <code>RES</code>, <code>CK</code>, <code>IK</code>.</li> <li>UE derives <code>RES*</code>, <code>K_AUSF</code> (from <code>CK||IK</code>, <code>SNN</code>, <code>SQN\u2295AK</code>) and then <code>K_SEAF</code> from <code>K_AUSF</code>; derives <code>K_AMF</code> later with <code>SUPI</code> binding and <code>ABBA</code>.</li> </ul> <p>Code spotlight (UE test harness deriving <code>K_AUSF</code> \u2192 <code>K_SEAF</code> \u2192 <code>K_AMF</code>) free5gc/test/ranUe.go: <pre><code>P1 := SQNxorAK\nKausf, err := ueauth.GetKDFValue(key, FC, P0, ueauth.KDFLen(P0), P1, ueauth.KDFLen(P1))\nif err != nil { fatal.Fatalf(\"GetKDFValue error: %+v\", err) }\n\nP0 = []byte(snName)\nKseaf, err := ueauth.GetKDFValue(Kausf, ueauth.FC_FOR_KSEAF_DERIVATION, P0, ueauth.KDFLen(P0))\nif err != nil { fatal.Fatalf(\"GetKDFValue error: %+v\", err) }\n\nP0 = []byte(groups[1]) // SUPI digits\nL0 := ueauth.KDFLen(P0)\nP1 = []byte{0x00, 0x00} // ABBA\nL1 := ueauth.KDFLen(P1)\n\nue.Kamf, err = ueauth.GetKDFValue(Kseaf, ueauth.FC_FOR_KAMF_DERIVATION, P0, L0, P1, L1)\nif err != nil { fatal.Fatalf(\"GetKDFValue error: %+v\", err) }\n</code></pre></p>"},{"location":"blog/20251029/20251029/#5-serving-network-verification-and-ausf-confirmation","title":"5. Serving-network verification and AUSF confirmation","text":"<ul> <li>UE \u2192 SEAF: Sends <code>RES*</code> in NAS Authentication Response.</li> <li>SEAF computes <code>HRES* = SHA-256(RAND || RES*)</code> and compares with <code>HXRES*</code>. If they match, authentication is successful from the serving network viewpoint; SEAF forwards <code>RES*</code> to AUSF for home-network confirmation.</li> <li>AUSF compares <code>RES*</code> with stored <code>XRES*</code>. If equal, AUSF confirms success and provides <code>K_SEAF</code> (and <code>SUPI</code> if <code>SUCI</code> was used).</li> </ul> <p>Code spotlight (AUSF: <code>RES*</code> confirmation and return of <code>K_SEAF</code>) ausf/internal/sbi/processor/ue_authentication.go: <pre><code>// Compare RES* with stored XRES*\nif strings.EqualFold(updateConfirmationData.ResStar, ausfCurrentContext.XresStar) {\n    confirmDataRsp.AuthResult = models.AusfUeAuthenticationAuthResult_SUCCESS\n    confirmDataRsp.Supi  = currentSupi\n    confirmDataRsp.Kseaf = ausfCurrentContext.Kseaf\n} else {\n    ausfCurrentContext.AuthStatus = models.AusfUeAuthenticationAuthResult_FAILURE\n    confirmDataRsp.AuthResult = models.AusfUeAuthenticationAuthResult_FAILURE\n}\n</code></pre></p>"},{"location":"blog/20251029/20251029/#6-security-context-establishment-in-the-serving-network","title":"6. Security context establishment in the serving network","text":"<ul> <li>UE and AMF derive <code>K_AMF</code> from <code>K_SEAF</code>, then NAS keys; gNB later derives <code>K_gNB</code> and AS keys for RRC/UP.</li> </ul> <p>Code spotlight (UE test harness deriving NAS algorithm keys from <code>K_AMF</code>) free5gc/test/ranUe.go: <pre><code>// Security Key\nP0 := []byte{security.NNASEncAlg}\nL0 := ueauth.KDFLen(P0)\nP1 := []byte{ue.CipheringAlg}\nL1 := ueauth.KDFLen(P1)\n\nkenc, err := ueauth.GetKDFValue(ue.Kamf, ueauth.FC_FOR_ALGORITHM_KEY_DERIVATION, P0, L0, P1, L1)\nif err != nil { fatal.Fatalf(\"GetKDFValue error: %+v\", err)}\ncopy(ue.KnasEnc[:], kenc[16:32])\n\n// Integrity Key\nP0 = []byte{security.NNASIntAlg}\nL0 = ueauth.KDFLen(P0)\nP1 = []byte{ue.IntegrityAlg}\nL1 = ueauth.KDFLen(P1)\n\nkint, err := ueauth.GetKDFValue(ue.Kamf, ueauth.FC_FOR_ALGORITHM_KEY_DERIVATION, P0, L0, P1, L1)\nif err != nil { fatal.Fatalf(\"GetKDFValue error: %+v\", err)}\ncopy(ue.KnasInt[:], kint[16:32])\n</code></pre></p>"},{"location":"blog/20251029/20251029/#7-resynchronization-only-if-needed","title":"7. Resynchronization (only if needed)","text":"<ul> <li>If UE detects <code>AUTN</code> failure due to sequence number drift, UE \u2192 SEAF/AMF: Sends <code>AUTS</code> for resync.</li> <li>AUSF relays resync to UDM; UDM re-generates vectors with new <code>SQN</code> and flow restarts.</li> </ul> <p>Code spotlight (UDM Milenage helpers used for MAC-A/MAC-S and AK/AUTN calculations) udm/internal/util/milenage.go: <pre><code>// Generate AKA params and extract AUTN tail (MAC-A)\nik, ck, xres, autn, err := milenage.GenerateAKAParameters(opc, k, rand, sqn, amf)\n\n// For MAC-S, use resync AMF (0000)\nresyncAMFBytes, err := hex.DecodeString(\"0000\")\nif err != nil {return err}\nikS, ckS, xresS, autnS, err := milenage.GenerateAKAParameters(opc, k, rand, sqn, resyncAMFBytes)\n</code></pre></p>"},{"location":"blog/20251029/20251029/#8-reauthentication-and-handovers","title":"8. Re\u2011authentication and handovers","text":"<ul> <li>5G supports efficient re\u2011auth flows and a key hierarchy so that subsequent procedures (e.g., mobility, handovers, access changes) don\u2019t require repeating full home authentication unless needed.</li> </ul>"},{"location":"blog/20251029/20251029/#kdf-reference-used-across-free5gc","title":"KDF reference used across free5GC","text":"<p>free5GC\u2019s shared KDF utility implements TS 33.220/33.501 HMAC\u2011SHA256 KDF and function codes util/ueauth/ueauth.go: <pre><code>const (\n    FC_FOR_CK_PRIME_IK_PRIME_DERIVATION  = \"20\"\n    FC_FOR_KSEAF_DERIVATION              = \"6C\"\n    FC_FOR_RES_STAR_XRES_STAR_DERIVATION = \"6B\"\n    FC_FOR_KAUSF_DERIVATION              = \"6A\"\n    FC_FOR_KAMF_DERIVATION               = \"6D\"\n    FC_FOR_KGNB_KN3IWF_DERIVATION        = \"6E\"\n    FC_FOR_NH_DERIVATION                 = \"6F\"\n    FC_FOR_ALGORITHM_KEY_DERIVATION      = \"69\"\n    FC_FOR_KTIPSEC_KTNAP_DERIVATION      = \"84\"\n)\n\nfunc GetKDFValue(key []byte, FC string, param ...[]byte) ([]byte, error) {\n    kdf := hmac.New(sha256.New, key)\n\n    var S []byte\n    if STmp, err := hex.DecodeString(FC); err != nil {return nil, fmt.Errorf(\"GetKDFValue FC decode failed: %+v\", err)} \n    else {\n        S = STmp    \n    }\n\n    for _, p := range param {\n        S = append(S, p...)\n    }\n\n    if _, err := kdf.Write(S); err != nil {return nil, fmt.Errorf(\"GetKDFValue KDF write failed: %+v\", err)}\n    sum := kdf.Sum(nil)\n    return sum, nil\n}\n</code></pre></p>"},{"location":"blog/20251029/20251029/#conclusion","title":"Conclusion","text":"<p>Through its structured challenge\u2013response process and layered key system, 5G AKA enables mutual authentication between the UE, serving network, and home network while securely generating session-specific keys. By exploring the protocol together with its implementation in free5GC, we can see how 3GPP\u2019s specifications are brought to life in software\u2014from authentication vector generation and verification to the derivation of keys across different network functions.</p>"},{"location":"blog/20251029/20251029/#reference","title":"Reference","text":"<ul> <li>TS 33.501</li> <li>5G Security</li> <li>5G AKA\u534f\u8bae\u8be6\u89e3</li> <li>References to implementation:<ul> <li>AUSF, HXRES*, K_SEAF, confirmation: ausf/internal/sbi/processor/ue_authentication.go</li> <li>UDM, vector and XRES*, K_AUSF: udm/internal/sbi/processor/generate_auth_data.go</li> <li>AMF, NAS Authentication Request build: amf/internal/gmm/message/build.go</li> <li>Util KDF: util/ueauth/ueauth.go</li> <li>UE test harness (KAMF/NAS keys): free5gc/test/ranUe.go</li> </ul> </li> </ul>"},{"location":"blog/20251029/20251029/#about","title":"About","text":"<p>Hello! I'm Che Wei, Lin, and I\u2019ve recently begun my journey into 5G technology and the free5GC community. I hope you found this blog post helpful, and please feel free to reach out if you notice any errors or have suggestions for improvement.</p>"},{"location":"blog/20251029/20251029/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: Zach1113</li> </ul>"},{"location":"blog/20251105/20251105/","title":"Introduction of Xn and NG(N2) based handover","text":"<p>Note</p> <p>Author: Kai-Hung, Hu Date: 2025/11/05</p>"},{"location":"blog/20251105/20251105/#key-terms-and-abbreviations","title":"Key Terms and Abbreviations","text":""},{"location":"blog/20251105/20251105/#1-key-terms","title":"1. Key Terms","text":"<ul> <li>NG: The interface connecting NG-RAN nodes to the 5G Core (5GC).</li> <li>RACS: Radio Access Capability Signaling - mechanism to efficiently handle UE radio capabilities using capability IDs instead of full capability sets.</li> <li>RRC_CONNECTED state:  It means the UE has an active connection with the network and can send/receive data. In this state, the network knows the UE's exact location and can coordinate its mobility through handover procedures.</li> <li>Xn: The interface connecting two NG-RAN nodes.</li> </ul>"},{"location":"blog/20251105/20251105/#2-abbreviations","title":"2. Abbreviations","text":"<ul> <li>AN: Access Network</li> <li>CN PDB: Core Network Packet Delay Budget</li> <li>DL: Downlink (network to UE)</li> <li>HO: Handover</li> <li>NG-RAN: Next Generation Radio Access Network</li> <li>RLF: Radio Link Failure</li> <li>RRM: Radio Resource Management</li> <li>PSA: PDU Session Anchor</li> <li>S-AMF: Source AMF</li> <li>S-NG-RAN: Source NG-RAN</li> <li>S-UPF: Source UPF</li> <li>T-AMF: Target AMF</li> <li>T-NG-RAN: Target NG-RAN</li> <li>T-UPF: Target UPF</li> <li>UL: Uplink (UE to network)</li> </ul>"},{"location":"blog/20251105/20251105/#what-is-handover","title":"What is Handover","text":"<p>Handover (HO) is a fundamental mobility management procedure in 5G networks that enables seamless service continuity when a User Equipment (UE) moves between different cells while maintaining an active connection. When a UE in RRC_CONNECTED state transitions from one cell (source cell) to another (target cell), handover ensures that ongoing data sessions, voice calls, and other services continue without interruption.</p>"},{"location":"blog/20251105/20251105/#handover-triggering-conditions","title":"Handover Triggering Conditions","text":"<p>Handover can be triggered by various conditions:</p> <ul> <li>Radio Conditions: When signal quality or strength from the serving cell degrades below a threshold, and a neighboring cell offers better radio conditions.</li> <li>Load Balancing: When a cell becomes heavily loaded, UEs may be handed over to less congested cells to optimize network resources.</li> <li>Service Requirements: When a specific service (e.g., voice call) is unavailable in the current system, triggering inter-system handover.</li> </ul>"},{"location":"blog/20251105/20251105/#handover-procedure","title":"Handover Procedure","text":"<p> Figure 1. handover procedure (source: A survey on the handover management in 5G-NR cellular networks: aspects, approaches and challenges)</p> <p>A typical handover will go through the following stages:</p>"},{"location":"blog/20251105/20251105/#1-a3-event-condition-neighbor-becomes-offset-better-than-spcell","title":"1. A3 Event Condition (Neighbor becomes offset better than SpCell)","text":"<ul> <li>Event A3: The \"Quality\" Handover.</li> <li>What it means: \"My neighbor cell is now significantly better (by a configured offset) than my current serving cell.\"</li> <li>Common Use Case: This is the most common event for mobility optimization and load balancing. The network uses this to proactively move a UE to a better cell, even if the current cell is still perfectly fine. This ensures the UE always has the best quality of service and prevents cells from becoming overloaded.</li> </ul>"},{"location":"blog/20251105/20251105/#2-time-to-trigger-ttt","title":"2. Time-to-Trigger (TTT)","text":"<p>Before initiating handover, the UE waits for a Time-to-Trigger (TTT) period to confirm that the A3 condition is stable and not just a momentary spike. This waiting period prevents unnecessary handovers, especially \"ping-pong handovers\" where the UE would bounce back and forth between cells.</p> <ul> <li>Short TTT: Quick handover response, but risk of unnecessary handovers</li> <li>Long TTT: More stable decisions, but risk of delayed handover when needed</li> </ul>"},{"location":"blog/20251105/20251105/#3-measurement-report","title":"3. Measurement Report","text":"<p>If the A3 condition remains true for the entire TTT duration, the UE sends a Measurement Report (MR) to the serving base station (gNB). This report contains:</p> <ul> <li>Signal quality measurements of the current cell</li> <li>Signal quality measurements of neighboring cells</li> </ul>"},{"location":"blog/20251105/20251105/#4-handover-command","title":"4. Handover Command","text":"<p>After receiving the measurement report, the serving gNB:</p> <ol> <li>Makes a handover decision based on the measurements</li> <li>Coordinates with the target gNB to prepare resources for the UE</li> <li>If the target gNB accepts, sends a Handover Command to the UE</li> </ol> <p>The handover command includes all the configuration information the UE needs to connect to the target cell (e.g., target cell ID, new radio resources, security parameters).</p>"},{"location":"blog/20251105/20251105/#5-handover-completion","title":"5. Handover Completion","text":"<p>The UE:</p> <ol> <li>Detaches from the source cell</li> <li>Connects to the target cell using the provided configuration</li> <li>Sends a Handover Complete message to the target gNB</li> </ol> <p>At this point, the handover is successful, and the UE continues its services through the new cell. The network updates routing paths to ensure data flows to the correct location.</p>"},{"location":"blog/20251105/20251105/#types-of-handover-in-5g","title":"Types of Handover in 5G","text":"<p>5G supports multiple handover types based on the network architecture and interfaces available:</p> <ul> <li>Xn-based Handover: Direct handover between two gNBs connected via the Xn interface, coordinated entirely within the RAN without core network involvement.</li> <li>NG(N2)-based Handover: Handover coordinated through the 5G Core via the N2 interface (connecting gNB to AMF) when the Xn interface is unavailable between source and target gNBs.</li> <li>Intra-gNB Handover: UE moves between cells/DUs within the same CU.</li> <li>Inter-System Handover: Transition between different systems (e.g., 5G to 4G) using the N26 interface.</li> <li>Inter-RAT Handover: Movement between different Radio Access Technologies.</li> </ul> <p>I will focus on Xn-based Handover and NG(N2)-based Handover in this article.</p>"},{"location":"blog/20251105/20251105/#xn-based-handover-procedure","title":"Xn-based Handover Procedure","text":"<p>Xn-based handover is a direct handover procedure between two gNBs (base stations) connected via the Xn interface. This type of handover is optimized for efficiency by handling mobility within the Radio Access Network (RAN) itself, and most of handover preparation/execution phases are involved in source NG-RAN and Target NG-RAN.</p>"},{"location":"blog/20251105/20251105/#key-characteristics-of-xn-based-handover","title":"Key Characteristics of Xn-based Handover","text":""},{"location":"blog/20251105/20251105/#1-direct-ran-to-ran-coordination","title":"1. Direct RAN-to-RAN Coordination","text":"<ul> <li>The source and target gNBs communicate directly through the Xn interface to coordinate the handover</li> <li>Few core network (AMF/SMF) involvement during preparation and execution phases</li> <li>Faster handover decision-making and reduced signaling overhead</li> </ul>"},{"location":"blog/20251105/20251105/#2-three-phase-process","title":"2. Three-Phase Process","text":"<p>The picture shows the overall procedure of Intra-AMF/UPF handover: Figure 2. Intra-AMF Intra-UPF handover (source: TS 38.300)</p> <p>The Xn-based handover follows a structured three-phase approach:</p> <p>Phase 1: Handover Preparation</p> <ol> <li>Source gNB decides to initiate handover based on measurement reports</li> <li>Source gNB sends a Handover Request to the target gNB via Xn interface</li> <li>Target gNB performs admission control (checks if it has resources available)</li> <li>If accepted, target gNB prepares resources and sends Handover Request Acknowledge with RRC configuration for the UE</li> </ol> <p>Phase 2: Handover Execution</p> <ol> <li>Source gNB sends RRC Reconfiguration (handover command) to the UE</li> <li>UE detaches from source gNB and synchronizes with target gNB</li> <li>Source gNB forwards buffered data to target gNB to prevent data loss</li> <li>Source gNB sends SN Status Transfer message to maintain packet sequence continuity</li> </ol> <p>Phase 3: Handover Completion</p> <ol> <li>UE successfully connects to target gNB and sends RRC Reconfiguration Complete</li> <li>Target gNB sends Path Switch Request to AMF to update the user plane path</li> <li>AMF triggers the UPF to switch the data path from source gNB to target gNB</li> <li>After path switch confirmation, target gNB sends UE Context Release to source gNB</li> <li>Source gNB releases all resources associated with the UE</li> </ol>"},{"location":"blog/20251105/20251105/#3-data-forwarding","title":"3. Data Forwarding","text":"<ul> <li>Direct data forwarding: Source gNB can forward downlink packets directly to target gNB via the Xn interface</li> <li>Minimizes data loss during the handover transition</li> <li>Improves service continuity for ongoing sessions</li> </ul>"},{"location":"blog/20251105/20251105/#4-upf-handling","title":"4. UPF Handling","text":"<p>Xn-based handover can occur with different UPF scenarios:</p> <ul> <li>Without UPF re-allocation: The existing UPF continues to serve the UE</li> <li>With intermediate UPF insertion: SMF decides that insertion of a new additional intermediate UPF is needed</li> <li>With intermediate UPF re-allocation: SMF decides that the intermediate UPF needs to be changed</li> </ul> <p>I will introduce the detailed procedure of type \"Without UPF re-allocation\" with Figure. 3. If you are interested in the other two cases, you can also check the detailed procedure on TS 23.502. </p>"},{"location":"blog/20251105/20251105/#detailed-procedure-steps","title":"Detailed Procedure Steps","text":"<p>Based on TS 23.502 Section 4.9.1.2.2 (Xn-based inter NG-RAN handover without UPF re-allocation), the handover procedure follows these steps: Figure 3. Xn-based handover without UPF re-allocation (source: TS 23.502)</p> <p>Step 0: Source NG-RAN initiates the inter NG-RAN Xn handover procedure for UE in RRC_CONNECTED state</p> <ul> <li>Handover is triggered based on UE measurement reports and RRM information</li> <li>Source gNB prepares UE context information for target gNB</li> </ul> <p>Step 1a (Optional): Source NG-RAN provides RAN usage data report to AMF during handover execution phase</p> <p>Step 1b: Target NG-RAN sends N2 Path Switch Request to AMF</p> <p>This message contains:</p> <ul> <li>List of PDU Sessions to be switched with N2 SM Information</li> <li>List of PDU Sessions that failed to be established</li> <li>UE Location Information</li> <li>Established QoS Flows status (active/not active)</li> </ul> <p>Target NG-RAN informs AMF that the UE has moved to the new target cell</p> <p>Step 2: AMF sends Nsmf_PDUSession_UpdateSMContext Request to SMF</p> <ul> <li>AMF invokes this service operation for each PDU Session</li> <li>Includes indication whether PDU Session is to be switched or rejected</li> </ul> <p>Steps 3-4: SMF communicates with UPF via N4 Session Modification</p> <ul> <li>Step 3: CN Tunnel Info of UPF connecting to Target NG-RAN and connection to Source NG-RAN may be different, e.g. Source and Target NG-RAN are in different IP domains. Then, the SMF may ask the UPF to allocate new CN Tunnel Info.</li> <li>Step 4: For the PDU Sessions that are switched, UPF returns N4 Session Modification Response message to the SMF after requested PDU Sessions are switched.</li> </ul> <p>Step 5: UPF sends end marker packets to assist reordering function</p> <ul> <li>One or more end marker packets sent for each N3 tunnel on the old path</li> <li>UPF starts sending downlink packets to Target NG-RAN</li> </ul> <p>Step 6: SMF sends Nsmf_PDUSession_UpdateSMContext Response to AMF</p> <ul> <li>Contains N2 SM Information (CN Tunnel Info, updated CN PDB for accepted QoS Flows)</li> <li>Includes information for PDU Sessions which have been switched successfully</li> </ul> <p>Step 7: AMF sends N2 Path Switch Request Acknowledge to Target NG-RAN</p> <ul> <li>Aggregates CN Tunnel Info received from all SMFs</li> <li>Sends aggregated information as N2 SM Information</li> <li>If none of the requested PDU Sessions switched successfully, AMF sends N2 Path Switch Request Failure instead</li> </ul> <p>Step 8: Target NG-RAN sends Release Resources message to Source NG-RAN</p> <ul> <li>Confirms success of the handover</li> <li>Triggers release of resources at Source NG-RAN</li> </ul> <p>Step 9 (Conditional): UE may initiate Mobility Registration Update procedure if triggered</p>"},{"location":"blog/20251105/20251105/#ngn2-based-handover-procedure","title":"NG(N2)-based Handover Procedure","text":"<p>NG(N2)-based handover is used when there is no Xn interface between the source and target gNBs. In this scenario, the handover coordination is performed through the core network (specifically via the AMF) using the N2 interface. This type of handover involves more core network signaling but ensures mobility support even when direct RAN-to-RAN connectivity is unavailable.</p>"},{"location":"blog/20251105/20251105/#key-characteristics-of-n2-based-handover","title":"Key Characteristics of N2-based Handover","text":""},{"location":"blog/20251105/20251105/#1-core-network-coordination","title":"1. Core Network Coordination","text":"<ul> <li>Handover is coordinated through the AMF (Access and Mobility Management Function) via N2 interface</li> <li>AMF acts as the intermediary between source gNB and target gNB</li> <li>Higher signaling overhead compared to Xn-based handover due to core network involvement</li> </ul>"},{"location":"blog/20251105/20251105/#2-two-phase-process","title":"2. Two-Phase Process","text":"<p>The overall N2-based handover follows a two-phase approach:</p> <p>Phase 1: Preparation Phase</p> <ol> <li>Source gNB sends Handover Required message to source AMF with target information</li> <li>Source AMF may select a new target AMF if the current AMF cannot serve the target area</li> <li>AMF coordinates with SMF to prepare UPF resources and tunnel information</li> <li>Target AMF sends Handover Request to target gNB with UE context and PDU session information</li> <li>Target gNB performs admission control and sends Handover Request Acknowledge</li> </ol> <p>Phase 2: Execution Phase</p> <ol> <li>Source AMF aggregates responses and sends Handover Command back to source gNB</li> <li>Source gNB sends Handover Command (RRC Reconfiguration) to UE</li> <li>UE detaches from source gNB and synchronizes with target gNB</li> <li>Data forwarding occurs (direct or indirect via UPF)</li> <li>UE sends Handover Confirm to target gNB after successful synchronization</li> <li>Target gNB sends Handover Notify to target AMF</li> <li>AMF triggers SMF to switch the user plane path to target gNB</li> <li>Source gNB resources are released after path switch completion</li> </ol>"},{"location":"blog/20251105/20251105/#3-data-forwarding-options","title":"3. Data Forwarding Options","text":"<ul> <li>Direct Forwarding: If IP connectivity and security associations exist between source and target gNB, data can be forwarded directly</li> <li>Indirect Forwarding: When direct forwarding is unavailable</li> </ul>"},{"location":"blog/20251105/20251105/#4-amf-relocation-support","title":"4. AMF Relocation Support","text":"<ul> <li>Intra-AMF Handover: Source and target gNBs served by same AMF</li> <li>Inter-AMF Handover: Requires AMF relocation when UE moves to an area served by different AMF. Source AMF transfers UE context to target AMF and target AMF becomes the new serving AMF</li> </ul>"},{"location":"blog/20251105/20251105/#detailed-procedure-steps_1","title":"Detailed Procedure Steps","text":"<p>Based on TS 23.502 Section 4.9.1.3.2 and 4.9.1.3.3, the N2-based handover procedure follows these steps: Figure 4. N2-based handover preparation phase (source: TS 23.502)</p>"},{"location":"blog/20251105/20251105/#preparation-phase","title":"Preparation Phase","text":"<p>Step 1: Source gNB sends Handover Required to source AMF</p> <ul> <li>It contains:<ul> <li>Target ID (identifies target gNB and cell)</li> <li>Source to Target transparent container (UE context, RAN information, QoS flows for data forwarding)</li> <li>PDU Session IDs of all active PDU sessions</li> <li>Direct Forwarding Path Availability indication (if source gNB can forward data directly to target gNB)</li> </ul> </li> </ul> <p>Step 2: Source AMF selects target AMF (if needed)</p> <ul> <li>If source AMF cannot serve the UE, it selects a new target AMF based on AMF Selection Function</li> </ul> <p>Step 3 (Conditional): Source AMF sends Namf_Communication_CreateUEContext Request to target AMF</p> <ul> <li>Transfers complete UE context information</li> <li>This step is skipped if source AMF can still serve the UE</li> </ul> <p>Step 4 (Conditional): Target AMF sends Nsmf_PDUSession_UpdateSMContext Request to SMF for each PDU Session</p> <ul> <li>Provides PDU Session ID, Target ID, T-AMF ID, N2 SM Information</li> </ul> <p>Steps 5-6: SMF interacts with UPF via N4 Session Establishment/Modification</p> <ul> <li>Step 5 (Conditional): SMF checks if target gNB location is within service area of current UPF. If UE moved out of UPF service area, SMF selects new intermediate UPF (Target UPF)</li> <li>Step 6a-6b (Conditional): If new UPF needed, SMF updates PDU Session Anchor (PSA UPF) with CN Tunnel Info on N9 interface</li> <li>Step 6c-6d (Conditional): SMF establishes N4 session with Target UPF (intermediate), receives CN Tunnel Info for N3 interface</li> </ul> <p>Step 7: SMF sends Nsmf_PDUSession_UpdateSMContext Response to target AMF</p> <ul> <li>It Contains N2 SM Information with:<ul> <li>N3 UP address and UL CN Tunnel ID of UPF for target gNB</li> <li>QoS parameters, security enforcement information</li> <li>Data forwarding availability indication</li> </ul> </li> <li>If UPF cannot serve target area and no alternative is available, SMF provides reason for non-acceptance</li> </ul> <p>Step 8: Target AMF supervises SMF responses</p> <ul> <li>Waits for all SMF responses or until maximum wait time expires, AMF continues the N2 handover procedure.</li> </ul> <p>Step 9: Target AMF sends Handover Request to target gNB</p> <ul> <li>It contains:<ul> <li>Source to Target transparent container</li> <li>N2 SM Information list (tunnel info, QoS parameters for each accepted PDU session)</li> <li>N2 MM Information (Security information, Mobility Restriction List)</li> <li>UE Radio Capability ID (if RACS supported)</li> </ul> </li> </ul> <p>Step 10: Target gNB sends Handover Request Acknowledge to target AMF</p> <ul> <li>It contains:<ul> <li>Target to Source transparent container (RRC configuration for UE)</li> <li>List of PDU Sessions successfully prepared with N2 SM information (N3 AN Tunnel Info)</li> <li>List of PDU Sessions that failed to be established with failure reasons</li> <li>Data forwarding tunnel addresses (if target gNB supports data forwarding)</li> </ul> </li> </ul> <p>Steps 11a-11f: AMF and SMF coordinate data forwarding setup</p> <ul> <li>Step 11a: AMF forwards target gNB's N2 SM response to SMF for each PDU session</li> <li>Step 11b-11c (Conditional): If indirect forwarding needed and UPF re-allocated, SMF configures Target UPF with forwarding tunnels</li> <li>Step 11d-11e (Conditional): SMF configures Source UPF with data forwarding information (either Target UPF tunnel or Target gNB tunnel)</li> <li>Step 11f: SMF sends DL forwarding tunnel information back to target AMF<ul> <li>DL forwarding tunnel information:<ul> <li>Direct forwarding: SMF includes the T-RAN N3 forwarding information the SMF received in step 11a</li> <li>Indirect forwarding: setup in step 11b or 11d, then the SMF includes the T-UPF or S-UPF DL forwarding information</li> </ul> </li> </ul> </li> </ul> <p>Step 12 (Conditional): Target AMF sends Namf_Communication_CreateUEContext Response to source AMF</p> <ul> <li>It contains:<ul> <li>Target to Source transparent container (RRC configuration for UE)</li> <li>N2 SM Information (DL forwarding tunnel info)</li> <li>List of PDU Sessions that failed to be setup</li> <li>Target AMF ID (if AMF was relocated)</li> </ul> </li> </ul> <p> Figure 5. N2-based handover execution phase (source: TS 23.502)</p>"},{"location":"blog/20251105/20251105/#execution-phase","title":"Execution Phase","text":"<p>Step 1: Source AMF sends Handover Command to source gNB</p> <ul> <li>It contains:<ul> <li>Target to Source transparent container</li> <li>List of PDU Sessions to be handed over with N2 SM information (forwarding addresses)</li> <li>List of PDU Sessions failed to be setup</li> </ul> </li> </ul> <p>Step 2: Source gNB sends Handover Command (RRC Reconfiguration) to UE</p> <ul> <li>UE container includes RRC configuration from target gNB</li> <li>UE uses this configuration to connect to target cell</li> </ul> <p>Steps 2a-2c: Source gNB sends Uplink RAN Status Transfer to source AMF</p> <ul> <li>Source AMF forwards this to target AMF (if AMF relocated)</li> <li>Target AMF sends Downlink RAN Status Transfer to target gNB</li> <li>Ensures continuity and integrity of data during the handover from source RAN to target RAN</li> </ul> <p>Step 3: Data forwarding begins</p> <ul> <li>Downlink packets from PSA UPF continue to source gNB via source UPF</li> <li>Source gNB forwards buffered DL data to target gNB (direct or indirect via UPF)</li> <li>Uplink packets from UE at target gNB are sent to Target UPF and PSA UPF</li> </ul> <p>Step 4: UE sends Handover Confirm to target gNB</p> <ul> <li>After successful synchronization with target cell</li> <li>Confirms UE has completed the handover at UE side</li> </ul> <p>Step 5: Target gNB sends Handover Notify to target AMF</p> <ul> <li>Confirms successful handover at RAN side</li> <li>Triggers user plane path switch procedures</li> </ul> <p>Steps 6a-6c: AMF notifications and PDU session handling</p> <ul> <li>Step 6a (Conditional): Target AMF notifies source AMF via Namf_Communication_N2InfoNotify (if AMF relocated)<ul> <li>Start a timer in S-AMF to supervise when resources in S-RAN can be released</li> </ul> </li> <li>Step 6b (Conditional): Source AMF acknowledges</li> <li>Step 6c (Conditional): Source AMF releases PDU sessions not accepted by target AMF (e.g., S-NSSAI not available)</li> </ul> <p>Step 7: Target AMF sends Nsmf_PDUSession_UpdateSMContext Request to SMF</p> <ul> <li>Includes Handover Complete indication for each PDU session</li> <li>Handover Complete indication is used to indicate the success of the N2 Handover</li> </ul> <p>Steps 8-10: SMF switches user plane path</p> <ul> <li>Steps 8a-8b (Conditional): It happens when new T-UPF is inserted or an existing intermediate S-UPF is re-allocated</li> <li>Steps 9a-9b (Conditional): If happens when UPF not re-allocated</li> <li>Steps 10a-10b (Conditional): SMF updates PSA UPF with new tunnel information<ul> <li>step 10a and 10b are skipped if T-UPF is not inserted or an existing intermediate S-UPF is not re-allocated</li> </ul> </li> </ul> <p>Step 11: SMF sends Nsmf_PDUSession_UpdateSMContext Response to target AMF</p> <ul> <li>Confirms handover completion for PDU session</li> <li>If indirect forwarding used, SMF starts timer to release forwarding resources</li> </ul> <p>Step 12: UE initiates Mobility Registration Update</p> <ul> <li>Updates registration with target AMF</li> <li>Target AMF performs subset of registration procedure (skips context transfer steps since already done)</li> </ul> <p>Steps 13a-13b (Conditional): SMF releases source UPF resources</p> <ul> <li>After forwarding timer expires, SMF sends N4 Session Release Request to source UPF</li> <li>Source UPF releases resources and confirms with N4 Session Release Response</li> <li>If indirect forwarding used, resource of indirect forwarding is also released</li> </ul> <p>Steps 14a-14b: Source gNB resource release</p> <ul> <li>After timer in step 6a expires, AMF sends UE Context Release Command to source gNB</li> <li>Source gNB releases all resources and responds with UE Context Release Complete</li> </ul> <p>Steps 15a-15b (Conditional): SMF releases indirect forwarding resources in Target UPF (if applicable)</p> <ul> <li>After indirect forwarding timer expires, SMF sends N4 Session Modification Request to Target UPF to release indirect forwarding resources</li> <li>T-UPF replies with N4 Session Modification Response to confirm the release</li> </ul>"},{"location":"blog/20251105/20251105/#conclusion","title":"Conclusion","text":"<p>Xn-based handover offers lower latency and reduced signaling through direct RAN-to-RAN coordination, ideal for seamless mobility with minimal core network involvement. However, it requires Xn interface connectivity between gNBs.</p> <p>N2-based handover provides universal mobility support even without Xn interface, enabling inter-AMF scenarios and cross-operator handovers. The trade-off is increased core network signaling overhead and higher handover latency.</p>"},{"location":"blog/20251105/20251105/#reference","title":"Reference","text":"<ul> <li>TS 23.502</li> <li>TS 38.300</li> <li>TS 38.331</li> <li>5G Handover</li> <li>A survey on the handover management in 5G-NR cellular networks: aspects, approaches and challenges</li> </ul>"},{"location":"blog/20251105/20251105/#about","title":"About","text":"<p>Hello! I'm Kai-Hung Hu, and I'm just starting my exploration of 5G technology and the free5GC community. I hope this blog post has been informative. If you spot any mistakes or have ideas for improvement, please don't hesitate to get in touch.</p>"},{"location":"blog/20251105/20251105/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: carlhus</li> </ul>"},{"location":"blog/20251112/20251112/","title":"Getting Started with go-gtp5gnl: Userspace Control of GTP-U for free5GC UPF","text":"<p>Note</p> <p>Author: Kai-Xu, Zhan Date: 2025/11/12</p>"},{"location":"blog/20251112/20251112/#introduction","title":"Introduction","text":"<p>The go-gtp5gnl project bridges user-space control logic and kernel-space GTP-U data forwarding by providing a Go-native Netlink interface to the Linux gtp5g kernel module. It allows free5GC\u2019s UPF\u2014or any custom UPF built on top of gtp5g\u2014to program kernel-level PDR, FAR, and QER rules that implement GTP-U encapsulation, forwarding, and QoS behavior. This article provides a hands-on walkthrough of using go-gtp5gnl to observe, modify, and verify PFCP-controlled GTP-U state in free5GC. You will learn how to list, edit, and recreate rules in real time to understand how the UPF enforces 5G user-plane logic.</p> <p>Goal: By the end, you will understand how go-gtp5gnl connects the 3GPP PFCP control plane to kernel-level forwarding on the N3/N6 interfaces\u2014making it an indispensable tool for debugging and research.</p>"},{"location":"blog/20251112/20251112/#environment-setup","title":"Environment Setup","text":""},{"location":"blog/20251112/20251112/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install free5GC: https://free5gc.org/guide/3-install-free5gc/</li> <li>Install UERANSIM: https://free5gc.org/guide/5-install-ueransim/</li> <li>Install gtp5g kernel module: https://github.com/free5gc/gtp5g</li> </ul>"},{"location":"blog/20251112/20251112/#building-go-gtp5gnl","title":"Building go-gtp5gnl","text":"<p>Clone and build the project to obtain the command-line utility gtp5g-tunnel:</p> <pre><code>git clone https://github.com/free5gc/go-gtp5gnl.git\ncd go-gtp5gnl/\ngo build -o gtp5g-tunnel ./cmd/gogtp5g-tunnel\n</code></pre>"},{"location":"blog/20251112/20251112/#understanding-go-gtp5gnl-commands","title":"Understanding Go-gtp5gnl Commands","text":""},{"location":"blog/20251112/20251112/#command-overview","title":"Command Overview","text":"<p>The go-gtp5gnl library and CLI expose Netlink interfaces to manipulate kernel objects representing PDR, FAR, and QER entities. </p> <ul> <li>PDR (Packet Detection Rule) \u2013 Identifies packets belonging to a PDU Session.  </li> <li>FAR (Forwarding Action Rule) \u2013 Specifies what action is applied.  </li> <li>QER (QoS Enforcement Rule) \u2013 Defines QoS parameters.</li> </ul> <p>Each rule type supports the operations add, get, mod, del, and list.</p> Operation Description add Create a new rule entry in the kernel. get Retrieve current rule(s) from kernel. mod Modify attributes of an existing rule. del Delete a rule from the kernel. list Display all rules of a given type."},{"location":"blog/20251112/20251112/#usage","title":"Usage","text":"<ul> <li>List all PDR/FAR/QER: <pre><code>sudo ./gtp5g-tunnel list [pdr/far/qer]\n</code></pre></li> <li>Get/Del/Add/Mod PDR/FAR/QER: <pre><code>sudo ./gtp5g-tunnel [get/del/add/mod] [PDR/FAR/QER] [interface_name] [seid] [id] [option]\n</code></pre></li> </ul>"},{"location":"blog/20251112/20251112/#practical-usage-of-go-gtp5gnl","title":"Practical Usage of Go-gtp5gnl","text":"<p>Before testing go-gtp5gnl, verify that you can successfully create a UE instance using UERANSIM and attach it to the free5GC core network. A successful registration and PDU Session establishment indicate that the environment is ready for go-gtp5gnl testing.</p>"},{"location":"blog/20251112/20251112/#inspecting-pdrs","title":"Inspecting PDRs","text":"<p>Use <code>sudo ./gtp5g-tunnel list pdr</code> to list all PDRs. The output will look like this: <pre><code>{\n\"ID\": 3,\n\"Precedence\": 128,\n\"PDI\": {\n  \"SrcIntf\": null,\n  \"UEAddr\": \"10.60.0.1\",\n  \"FTEID\": {\n    \"TEID\": 2,\n    \"GTPuAddr\": \"192.168.56.102\"\n  },\n  \"SDF\": {\n    \"FD\": {\n      \"Action\": 1,\n      \"Dir\": 2,\n      \"Proto\": 255,\n      \"Src\": {\n        \"IP\": \"0.0.0.0\",\n        \"Mask\": \"AAAAAA==\"\n      },\n      \"Dst\": {\n        \"IP\": \"1.1.1.1\",\n        \"Mask\": null\n      },\n      \"SrcPorts\": null,\n      \"DstPorts\": null\n    },\n    \"TTC\": null,\n    \"SPI\": null,\n    \"FL\": null,\n    \"BID\": null\n  },\n  \"EPFs\": null\n},\n\"OuterHdrRemoval\": 0,\n\"FARID\": 3,\n\"QERID\": [\n  1,\n  3\n],\n\"URRID\": [\n  1,\n  2,\n  8,\n  7\n],\n\"SEID\": 1,\n\"PDNType\": null\n}, \n{\n\"ID\": 4,\n\"Precedence\": 128,\n\"PDI\": {\n  \"SrcIntf\": null,\n  \"UEAddr\": \"10.60.0.1\",\n  \"FTEID\": null,\n  \"SDF\": {\n    \"FD\": {\n      \"Action\": 1,\n      \"Dir\": 2,\n      \"Proto\": 255,\n      \"Src\": {\n        \"IP\": \"1.1.1.1\",\n        \"Mask\": null\n      },\n      \"Dst\": {\n        \"IP\": \"0.0.0.0\",\n        \"Mask\": \"AAAAAA==\"\n      },\n      \"SrcPorts\": null,\n      \"DstPorts\": null\n    },\n    \"TTC\": null,\n    \"SPI\": null,\n    \"FL\": null,\n    \"BID\": null\n  },\n  \"EPFs\": null\n},\n\"OuterHdrRemoval\": null,\n\"FARID\": 4,\n\"QERID\": [\n  1,\n  3\n],\n\"URRID\": [\n  1,\n  2,\n  8,\n  7\n],\n\"SEID\": 1,\n\"PDNType\": null\n}\n</code></pre></p> <p>Example truncated for brevity \u2014 other PDR entries omitted.</p>"},{"location":"blog/20251112/20251112/#pdr-information-elements","title":"PDR Information Elements","text":"Parameter Description ID Unique identifier of the PDR. Must be unique within the same SEID. Precedence Rule priority (smaller numbers have higher priority). SEID Session Endpoint ID that identifies the PFCP Session this rule belongs to.All PDRs for the same UE PDU Session share the same SEID. PDI Packet Detection Information defines which packets match this rule."},{"location":"blog/20251112/20251112/#pdi-details","title":"PDI Details","text":"Parameter Description SrcIntf The source interface of the incoming packet. UEAddr UE IPv4 address.This PDR handles traffic to or from this IP. FTEID Defines the GTP-U tunnel endpoint by combining a TEID and an IP address SDF Specifies the service data flow filter(s) used for packet detection."},{"location":"blog/20251112/20251112/#fteid-fully-qualified-tunnel-endpoint-identifier-details","title":"FTEID (Fully Qualified Tunnel Endpoint Identifier) Details","text":"Parameter Description TEID Tunnel Endpoint ID is an identifier for the GTP-U tunnel.Used to recognize packets received from the gNB. GTPuAddr Local GTP-U address.The N3 interface IP address of the UPF that listens for GTP-U packets from the gNB. <p>Important Rule: </p> <ul> <li>FTEID present \u2192 Uplink traffic (GTP-U packets from gNB/UE). </li> <li>FTEID null \u2192 Downlink traffic (plain IP packets from N6/Internet).</li> </ul>"},{"location":"blog/20251112/20251112/#sdf-service-data-flow-details","title":"SDF (Service Data Flow) Details","text":"Parameter Description Action SDF action.<code>1</code> = This rule permits matching traffic. Dir Traffic direction.<code>2</code> = Out Proto IP protocol number Src Source Address<ul><li>IP<li>Mask<ul> Dst Destination Address<ul><li>IP<li>Mask<ul>"},{"location":"blog/20251112/20251112/#inspecting-fars","title":"Inspecting FARs","text":"<p>The PDR defines which packets are detected by the UPF. Packets that match this PDR are then handled according to their associated Forwarding Action Rule (FAR), which specifies how the UPF should process or forward them. Now, let\u2019s use <code>sudo ./gtp5g-tunnel list far</code> to examine the configured FARs and see how these packets are processed.</p> <pre><code>{\n\"ID\": 3,\n\"Action\": 2,\n\"Param\": null,\n\"PDRIDs\": [\n  3\n],\n\"BARID\": null,\n\"SEID\": 1\n},\n{\n\"ID\": 1,\n\"Action\": 2,\n\"Param\": null,\n\"PDRIDs\": [\n  1\n],\n\"BARID\": null,\n\"SEID\": 1\n},\n{\n\"ID\": 4,\n\"Action\": 2,\n\"Param\": {\n  \"Creation\": {\n    \"Desc\": 256,\n    \"TEID\": 1,\n    \"PeerAddr\": \"192.168.56.101\",\n    \"Port\": 2152\n  },\n  \"Policy\": null,\n  \"TosTc\": 0\n},\n\"PDRIDs\": [\n  4\n],\n\"BARID\": null,\n\"SEID\": 1\n},\n</code></pre> <p>Example truncated for brevity \u2014 other FAR entries omitted.</p>"},{"location":"blog/20251112/20251112/#far-information-elements","title":"FAR Information Elements","text":"Parameter Description ID Unique identifier of the FAR. Must be unique within the same SEID. Action Apply action.<code>1</code> = drop the pakcets<code>2</code> = Forward the packets. SEID Session Endpoint ID that identifies the PFCP Session this rule belongs to.All FARs for the same UE PDU Session share the same SEID. Param Forwarding Parameters. <p>From the above demonstration, PDR with ID 3 is an uplink rule, matching GTP-U packets arriving from the RAN. Its corresponding FAR (FAR ID 3) has no forwarding parameters, meaning the packets are decapsulated and delivered locally toward the data network. Conversely, PDR with ID 4 is a downlink rule, where the associated FAR (FAR ID 4) contains forwarding parameters (TEID and peer address) used to encapsulate and send packets back to the gNB through GTP-U.</p>"},{"location":"blog/20251112/20251112/#inspecting-qers","title":"Inspecting QERs","text":"<p>Next, let's use <code>sudo ./gtp5g-tunnel list qer</code> to examine the configured QERs. <pre><code>{\n\"ID\": 3,\n\"Gate\": 0,\n\"MBR\": {\n  \"ULHigh\": 812,\n  \"ULLow\": 128,\n  \"UL_Kbps\": 208000,\n  \"DLHigh\": 812,\n  \"DLLow\": 128,\n  \"DL_Kbps\": 208000\n},\n\"GBR\": {\n  \"ULHigh\": 0,\n  \"ULLow\": 0,\n  \"UL_Kbps\": 0,\n  \"DLHigh\": 0,\n  \"DLLow\": 0,\n  \"DL_Kbps\": 0\n},\n\"CorrID\": 0,\n\"RQI\": 0,\n\"QFI\": 2,\n\"PPI\": 0,\n\"PDRIDs\": [\n  4,\n  3\n],\n\"SEID\": 1\n},\n</code></pre></p> <p>Example truncated for brevity \u2014 other QER entries omitted.</p>"},{"location":"blog/20251112/20251112/#qer-information-elements","title":"QER Information Elements","text":"Parameter Description ID Unique identifier of the QER. Must be unique within the same SEID. QFI QoS Flow Identifier.Identifies the QoS Flow within a PDU Session.Value range: (0 ~ 63) RQI Reflective QoS Indicator.Indicates whether reflective QoS is triggered.<code>0</code> = Not triggered.<code>1</code> = Triggered. PPP Packet Per Flow presence flag.Specifies whether the Packet Per Flow Indicator (PPI) is included in the QER.<code>0</code> = Not present.<code>1</code> = Present. PPI Packet Per Flow Indicator.Marks packets with a priority level or DSCP value for differentiated handling.Value range: (0 ~ 7) SEID Session Endpoint Identifier identifying the PFCP session this QER belongs to."},{"location":"blog/20251112/20251112/#mbr-and-gbr-details","title":"MBR and GBR Details","text":"Parameter Description ULHigh / ULLow Encoded uplink maximum (or guaranteed) bit rate split into two fields per 3GPP spec (High/Low octets). UL_Kbps Readable uplink bit rate in Kbps derived from the encoded values. DLHigh / DLLow Encoded downlink maximum (or guaranteed) bit rate. DL_Kbps Readable downlink bit rate in Kbps derived from the encoded values."},{"location":"blog/20251112/20251112/#modifying-far","title":"Modifying FAR","text":"<p>After understanding how to inspect PDRs, FARs, and QERs, let\u2019s move on to modify an existing FAR (Forwarding Action Rule) to block traffic and then restore it.</p>"},{"location":"blog/20251112/20251112/#step-1-verify-initial-state-ue-should-be-reachable","title":"Step 1: Verify initial state (UE should be reachable)","text":"<p><pre><code># Executed on UERANSIM\nping 1.1.1.1 -I ueransim0 -c 5\n</code></pre> If the UPF and UERANSIM are properly connected, you should see successful ping replies from 1.1.1.1.</p>"},{"location":"blog/20251112/20251112/#step-2-modify-far-3-change-action-from-2-forward-to-1-drop","title":"Step 2: Modify FAR 3 \u2013 change action from 2 (Forward) to 1 (Drop)","text":"<p><pre><code># Executed on free5GC\nsudo ./gtp5g-tunnel mod far upfgtp 1:3 --action 1\n</code></pre> This updates FAR ID 3 under SEID 1 to drop packets instead of forwarding them.</p>"},{"location":"blog/20251112/20251112/#step-3-re-test-connectivity-ping-should-fail-or-timeout","title":"Step 3: Re-test connectivity (ping should fail or timeout)","text":"<p><pre><code># Executed on UERANSIM\nping 1.1.1.1 -I ueransim0 -c 5\n</code></pre> Since this PDR defines the uplink traffic path from the UE (via gNB) toward the data network, removing it prevents packets from reaching the external destination.</p>"},{"location":"blog/20251112/20251112/#step-4-restore-far-3-to-forwarding-state","title":"Step 4: Restore FAR 3 to forwarding state","text":"<pre><code># Executed on free5GC\nsudo ./gtp5g-tunnel mod far upfgtp 1:3 --action 2\n</code></pre>"},{"location":"blog/20251112/20251112/#step-5-test-again-connectivity-should-be-restored","title":"Step 5: Test again (connectivity should be restored)","text":"<p><pre><code># Executed on UERANSIM\nping 1.1.1.1 -I ueransim0 -c 5\n</code></pre> If pings succeed again, it confirms that the mod operation has correctly re-applied the forwarding rule.</p>"},{"location":"blog/20251112/20251112/#deleting-and-re-adding-pdrs","title":"Deleting and Re-Adding PDRs","text":"<p>Next, you\u2019ll experiment with removing and re-adding PDRs (Packet Detection Rules) to observe how the UPF handles missing or re-created rules.</p>"},{"location":"blog/20251112/20251112/#step-1-delete-pdr-1-and-pdr-3","title":"Step 1: Delete PDR 1 and PDR 3","text":"<p>These rules typically correspond to the uplink flow for your UE session.</p> <pre><code># Executed on free5GC\nsudo ./gtp5g-tunnel del pdr upfgtp 1:1\nsudo ./gtp5g-tunnel del pdr upfgtp 1:3\n</code></pre>"},{"location":"blog/20251112/20251112/#step-2-test-connectivity-again-should-fail","title":"Step 2: Test connectivity again (should fail)","text":"<p><pre><code># Executed on UERANSIM\nping 1.1.1.1 -I ueransim0 -c 5\n</code></pre> With no matching uplink PDRs, the UPF cannot identify sending traffic, causing packet drops or timeouts.</p>"},{"location":"blog/20251112/20251112/#step-3-re-add-pdr-3-based-on-its-original-configuration","title":"Step 3: Re-add PDR 3 based on its original configuration","text":"<p><pre><code># Executed on free5GC\nsudo ./gtp5g-tunnel add pdr upfgtp 1:3 \\\n  --pcd 128 \\\n  --hdr-rm 0 \\\n  --far-id 3 \\\n  --ue-ipv4 10.60.0.1 \\\n  --f-teid 2 192.168.56.102 \\\n  --qer-id 1 \\\n  --qer-id 3\n</code></pre> This command recreates PDR ID 3 with its corresponding parameters \u2014 linking it again to FAR 3 and QER 1/3 for the same UE.</p>"},{"location":"blog/20251112/20251112/#step-4-test-once-more-connectivity-should-recover","title":"Step 4: Test once more (connectivity should recover)","text":"<p><pre><code># Executed on UERANSIM\nping 1.1.1.1 -I ueransim0 -c 5\n</code></pre> A successful ping confirms that the add operation has restored proper forwarding behavior.</p>"},{"location":"blog/20251112/20251112/#conclusion","title":"Conclusion","text":"<p>The go-gtp5gnl framework offers full userspace visibility and control of kernel-based GTP-U tunnels. Through the experiments above, you have:</p> <ul> <li>Inspected PFCP-translated kernel rules (PDR, FAR, QER).</li> <li>Modified actions and observed instant traffic impact.</li> <li>Re-created rules to validate real-time UPF behavior.</li> </ul> <p>By unifying Go\u2019s ease of use with Netlink\u2019s power, go-gtp5gnl becomes an ideal platform for 5G UPF debugging, QoS experimentation, and academic research on user-plane optimization.</p>"},{"location":"blog/20251112/20251112/#references","title":"References","text":"<ul> <li>3GPP TS 29.244</li> <li>3GPP TS 23.212</li> <li>free5GC Project</li> <li>gtp5g Kernel Module</li> <li>go-gtp5gnl Library</li> <li>Linux Netlink and Generic Netlink</li> </ul>"},{"location":"blog/20251112/20251112/#about","title":"About","text":"<p>Hello, I'm Kai-Xu Zhan. I'm honored to be a new member of the free5GC project under the Linux Foundation. As someone who is still learning and growing in the field of 5G core network development, I'm enthusiastic about contributing to the community and expanding my knowledge in telecommunications technologies. I welcome any guidance or feedback as I continue to familiarize myself with the project.</p>"},{"location":"blog/20251112/20251112/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: KASHZKX</li> </ul>"},{"location":"blog/20251119/20251119/","title":"NEF PFD Management Implementation and Testing","text":"<p>Note</p> <p>Author: Yu-Chen, Chan Date: 2025/11/19</p>"},{"location":"blog/20251119/20251119/#1-introduction","title":"1. Introduction","text":"<p>This experiment conducts in-depth research and testing on the Network Exposure Function (NEF) in the free5GC open-source 5G core network system, with a particular focus on the implementation and validation of Packet Flow Description (PFD) Management functionality. PFD Management is a critical feature defined in the 3GPP standards, allowing Application Functions (AF) to describe application traffic characteristics to the core network through NEF, thereby enabling application-level traffic control and optimization.</p> <p>In this experiment, we established a complete testing environment to simulate interactions between AF and NEF, implementing PFD transaction creation, query, and update operations. During the experiment, we discovered and fixed three critical bugs in the free5GC source code, including NEF's lack of automatic AF creation mechanism, UDR response logic errors, and API version mismatches. Through these fixes, we successfully verified that NEF's PFD Management functionality complies with the 3GPP TS 29.522 standard and can correctly perform data persistence operations with the UDR (Unified Data Repository).</p> <p>This experiment not only validates the functional correctness of free5GC but also provides complete automated test scripts and detailed operation guides, laying an important foundation for subsequent 5G network application development and testing. The experimental results demonstrate that the repaired system can stably handle PFD management requests, establishing a foundation for implementing application-aware 5G network services.</p> <p>Test Scope Statement: All tests in this document are conducted on a single-machine loopback (127.0.0.x) deployment without RAN/UE connection, validating only the NEF\u2194UDR data plane and persistence mechanism, excluding actual user-plane traffic steering. This experiment focuses on validating the correctness of the PFD Management API and the data persistence workflow.</p>"},{"location":"blog/20251119/20251119/#2-background-and-motivation","title":"2. Background and Motivation","text":""},{"location":"blog/20251119/20251119/#21-5g-network-exposure-function-nef","title":"2.1 5G Network Exposure Function (NEF)","text":"<p>In the 5G core network architecture, the Network Exposure Function (NEF) plays a critical bridging role, responsible for securely exposing core network capabilities to external applications. According to the 3GPP TS 23.501 standard, the main functions of NEF include:</p> <ol> <li>Capability Exposure: Provides standardized RESTful API interfaces (defined in TS 29.522), allowing third-party applications to use network functions</li> <li>Security Control: Performs authentication, authorization, and traffic management on external requests to protect the core network. According to 3GPP standards, NEF northbound API should use OAuth2 Client Credentials or CAPIF (Common API Framework) for authorization verification</li> <li>Information Translation: Performs data format conversion and parameter mapping between external APIs and internal network functions</li> <li>Event Notification: Notifies subscribed applications of network events (such as QoS changes, location updates)</li> </ol> <p>Security Statement for This Experiment: This test environment is based on a closed laboratory network (127.0.0.x loopback), without OAuth2/CAPIF authorization mechanisms and TLS encryption enabled. NEF does not authenticate AF. This configuration is only suitable for development and functional verification and is not recommended for production environments. In production deployments, complete security mechanisms should be implemented according to 3GPP TS 29.522 specifications.</p> <p>NEF is an important network function in the 5G Service-Based Architecture (SBA), interacting with other network functions through Service-Based Interfaces.</p>"},{"location":"blog/20251119/20251119/#22-packet-flow-description-pfd-management","title":"2.2 Packet Flow Description (PFD) Management","text":"<p>PFD Management is one of the important services provided by NEF, defined in the 3GPP TS 29.522 specification. This service allows Application Functions (AF) to provide application traffic description information to the 5G core network, enabling the network to identify and process data flows of specific applications.</p> <p>Main Purposes:</p> <ul> <li>Application Detection: Allows AF to describe application traffic characteristics to the core network, enabling SMF/UPF to identify application traffic</li> <li>Traffic Optimization: Performs more precise QoS control and routing decisions based on application layer information</li> <li>Dynamic Update: Supports applications to dynamically update their traffic descriptions at runtime (through PUT/PATCH operations)</li> <li>Cross-Domain Management: Implements information exchange between the application layer (AF) and network layer (SMF/PCF)</li> </ul> <p>PFD Components (according to TS 29.522):</p> <ul> <li>Flow Descriptions: Traffic filtering rules based on IP 5-tuple (source/destination IP, port, protocol), defined in TS 29.212</li> <li>URLs: URL patterns used by applications, supporting regular expression matching</li> <li>Domain Names: Domain names accessed by applications, supporting wildcards (such as <code>*.example.com</code>)</li> </ul> <p>Application Scenarios:</p> <ul> <li>Traffic optimization for video streaming services</li> <li>Low-latency routing for gaming applications</li> <li>Dedicated network slices for enterprise applications</li> </ul>"},{"location":"blog/20251119/20251119/#23-experimental-motivation","title":"2.3 Experimental Motivation","text":"<p>The main motivations for this experiment include:</p> <ol> <li>Functional Verification: Verify whether NEF's PFD Management functionality in free5GC complies with 3GPP standards</li> <li>Interoperability Testing: Test interactions between NEF and other network functions (UDR, PCF)</li> <li>Issue Discovery: Identify and fix errors that may exist in the implementation</li> <li>Test Automation: Establish reusable test environments and scripts</li> <li>Documentation Improvement: Provide developers with detailed operation guides and best practices</li> </ol>"},{"location":"blog/20251119/20251119/#3-data-flow","title":"3. Data Flow","text":"<ol> <li>AF \u2192 NEF: Application sends PFD management requests through the 3gpp-pfd-management API</li> <li>NEF \u2192 NRF: NEF queries NRF for UDR service discovery information (Service Discovery)</li> <li>NEF \u2192 UDR: NEF forwards PFD data to UDR for persistent storage through the Nudr_DataRepository (TS 29.510) service</li> <li>UDR \u2192 MongoDB: UDR writes PFD data to the <code>applicationData.pfds</code> collection in the MongoDB database</li> <li>NEF \u2190 UDR: UDR returns operation results to NEF (201 Created or 200 OK)</li> <li>AF \u2190 NEF: NEF returns results to AF</li> </ol> <p>Service-Based Architecture (SBA) Explanation: This workflow is a typical example of 5G SBA architecture. NEF does not hardcode the UDR URL but performs service discovery through NRF to obtain UDR's <code>nudr-dr</code> service base URI (e.g., <code>http://127.0.0.4:8000/nudr-dr/v1</code>), then calls <code>/application-data/pfds/{appId}</code> to store PFD. This dynamic discovery mechanism is the core design philosophy of SBA, enabling flexible deployment and scaling of network functions.</p>"},{"location":"blog/20251119/20251119/#4-core-concepts","title":"4. Core Concepts","text":""},{"location":"blog/20251119/20251119/#41-packet-flow-description-pfd","title":"4.1 Packet Flow Description (PFD)","text":"<p>Definition: According to 3GPP TS 29.522, PFD is a set of rules used to identify application traffic. Each PFD is identified by a unique <code>pfdId</code> and can contain one or more of the following attributes:</p>"},{"location":"blog/20251119/20251119/#411-flow-descriptions","title":"4.1.1 Flow Descriptions","text":"<p>Traffic description based on IP 5-tuple, defined in 3GPP TS 29.212 (Policy and Charging Control): <pre><code>permit &lt;direction&gt; &lt;protocol&gt; from &lt;source&gt; &lt;port&gt; to &lt;destination&gt; &lt;port&gt;\n</code></pre></p> <p>Syntax Elements:</p> <ul> <li><code>&lt;direction&gt;</code>: <code>in</code> (downlink) or <code>out</code> (uplink)</li> <li><code>&lt;protocol&gt;</code>: <code>ip</code>, <code>tcp</code>, <code>udp</code>, etc.</li> <li><code>&lt;source&gt;/&lt;destination&gt;</code>: IP address or CIDR notation</li> <li><code>&lt;port&gt;</code>: Port number or <code>any</code></li> </ul> <p>Examples:</p> <ul> <li><code>permit in ip from 192.168.1.0/24 to any</code></li> <li><code>permit out tcp from any to 10.0.0.0/8 8080</code></li> </ul> <p>Note: The flowDescriptions syntax follows the format of 3GPP TS 29.212 (PCC rules / traffic filters). free5GC directly accepts this string format and passes it down to SMF/UPF for traffic identification and policy control. This explains why you see this firewall-rule-like string format in the JSON payload rather than structured five-tuple objects.</p>"},{"location":"blog/20251119/20251119/#412-urls","title":"4.1.2 URLs","text":"<p>URL pattern matching using regular expressions (PCRE format): <pre><code>^https://example\\.com(/\\S*)?$\n</code></pre></p> <p>Purpose: Used to identify HTTP/HTTPS-based application traffic</p>"},{"location":"blog/20251119/20251119/#413-domain-names","title":"4.1.3 Domain Names","text":"<p>List of domain names used by applications, supporting wildcards: <pre><code>[\"example.com\", \"*.example.org\", \"api.service.net\"]\n</code></pre></p> <p>Purpose: Used for DNS query interception and traffic identification</p>"},{"location":"blog/20251119/20251119/#42-pfd-transaction","title":"4.2 PFD Transaction","text":"<p>PFD Transaction is the basic unit for NEF to manage PFD data, containing:</p> <ul> <li>Transaction ID: Unique identifier, automatically generated by NEF</li> <li>AF ID (scsAsID): Application Function identifier that initiates the request. In 3GPP TS 29.522, it's called <code>scsAsId</code> (SCS/AS Identifier). In this experiment, \"AF001\" is used as the example AF identifier</li> <li>PFD Datas: Mapping of PFD data for one or more applications</li> </ul> <p>Structure example: <pre><code>{\n  \"self\": \"http://127.0.0.5:8000/3gpp-pfd-management/v1/AF001/transactions/6\",\n  \"pfdDatas\": {\n    \"app_1761902997\": {\n      \"externalAppId\": \"app_1761902997\",\n      \"self\": \"http://127.0.0.5:8000/.../applications/app_1761902997\",\n      \"pfds\": {\n        \"pfd001\": { ... },\n        \"pfd002\": { ... }\n      }\n    }\n  }\n}\n</code></pre></p>"},{"location":"blog/20251119/20251119/#43-application-id-external-application-id","title":"4.3 Application ID (External Application ID)","text":"<p>External Application ID is a globally unique identifier used to identify applications:</p> <ul> <li>Provided by AF, remains unique throughout the core network</li> <li>Used to correlate application information between different network functions</li> <li>This experiment uses timestamps to ensure uniqueness: <code>app_$(date +%s)</code></li> </ul>"},{"location":"blog/20251119/20251119/#44-nef-roles","title":"4.4 NEF Roles","text":"<p>In PFD Management, NEF plays the following roles:</p>"},{"location":"blog/20251119/20251119/#441-api-gateway","title":"4.4.1 API Gateway","text":"<ul> <li>Provides standardized RESTful API interfaces</li> <li>Handles HTTP/JSON format requests and responses</li> <li>Implements API specifications defined in 3GPP TS 29.522</li> </ul>"},{"location":"blog/20251119/20251119/#442-data-translator","title":"4.4.2 Data Translator","text":"<ul> <li>Converts external API's PfdData to internal PfdDataForApp format</li> <li>Handles mapping relationships between different data models</li> </ul> <p>Conversion example: <pre><code>// External format (PfdData) - Used for Nnef API\ntype PfdData struct {\n    ExternalAppId string          // External application identifier\n    Pfds          map[string]Pfd  // PFD mapping, keyed by pfdId\n}\n\n// Internal format (PfdDataForApp) - Used for Nudr API\ntype PfdDataForApp struct {\n    ApplicationId string         // Application identifier\n    Pfds          []PfdContent   // PFD array (not map)\n}\n</code></pre></p> <p>Conversion Explanation: </p> <ul> <li>NEF receives <code>map[string]Pfd</code> format data from AF</li> <li>NEF sends <code>[]PfdContent</code> format data to UDR</li> <li><code>externalAppId</code> maps to <code>applicationId</code></li> <li>Map structure converts to Array structure to conform to UDR's data model</li> </ul>"},{"location":"blog/20251119/20251119/#443-transaction-manager","title":"4.4.3 Transaction Manager","text":"<ul> <li>Creates and manages PFD Transactions</li> <li>Generates unique Transaction IDs</li> <li>Maintains associations between AF and Transactions</li> </ul>"},{"location":"blog/20251119/20251119/#444-service-consumer","title":"4.4.4 Service Consumer","text":"<ul> <li>Interacts with NRF for service discovery</li> <li>Interacts with UDR for data persistence</li> <li>Handles authentication and authorization between services</li> </ul>"},{"location":"blog/20251119/20251119/#45-service-based-interface-sbi","title":"4.5 Service-Based Interface (SBI)","text":""},{"location":"blog/20251119/20251119/#451-nnef_pfdmanagement-service","title":"4.5.1 Nnef_PFDManagement Service","text":"<p>NEF's externally provided PFD management service, compliant with 3GPP TS 29.522 (5G System; Network Exposure Function Northbound APIs) specifications, including the following operations:</p> Operation HTTP Method URI Pattern Function Success Status Code Create Transaction POST <code>/{scsAsId}/transactions</code> Create new PFD transaction 201 Created Get Transactions GET <code>/{scsAsId}/transactions</code> Get all transactions 200 OK Get Transaction GET <code>/{scsAsId}/transactions/{transId}</code> Get specific transaction 200 OK Update Transaction PUT <code>/{scsAsId}/transactions/{transId}</code> Update transaction content 200 OK Delete Transaction DELETE <code>/{scsAsId}/transactions/{transId}</code> Delete transaction 204 No Content Update Application PUT <code>/{scsAsId}/transactions/{transId}/applications/{appId}</code> Update application PFD 200 OK Patch Application PATCH <code>/{scsAsId}/transactions/{transId}/applications/{appId}</code> Partially update PFD 200 OK Delete Application DELETE <code>/{scsAsId}/transactions/{transId}/applications/{appId}</code> Delete application PFD 204 No Content <p>Note: <code>scsAsId</code> is the AF (Application Function) identifier. In this experiment, \"AF001\" is used.</p>"},{"location":"blog/20251119/20251119/#452-nudr_datarepository-service","title":"4.5.2 Nudr_DataRepository Service","text":"<p>Data storage service provided by UDR, compliant with 3GPP TS 29.504 (5G System; Unified Data Repository Services) / TS 29.510 (Network Function Repository Services) specifications:</p> Operation HTTP Method URI Pattern Function Success Status Code Create/Update PFD PUT <code>/application-data/pfds/{appId}</code> Store/update PFD data 201 Created / 200 OK Query PFD GET <code>/application-data/pfds/{appId}</code> Query specific application's PFD 200 OK Query Multiple PFDs GET <code>/application-data/pfds?appId={id1}&amp;appId={id2}</code> Batch query multiple applications 200 OK Delete PFD DELETE <code>/application-data/pfds/{appId}</code> Delete PFD data 204 No Content <p>Note: PUT operation returns different status codes based on whether the resource already exists:</p> <ul> <li>201 Created: Resource created for the first time</li> <li>200 OK: Resource already exists and is updated</li> </ul> <p>Important Note: MongoDB is not a 3GPP-defined network function but rather the backend database implementation for UDR in free5GC. UDR, as a 3GPP NF, provides the standardized Nudr_DataRepository API, while the actual data is stored in MongoDB.</p>"},{"location":"blog/20251119/20251119/#46-data-persistence","title":"4.6 Data Persistence","text":""},{"location":"blog/20251119/20251119/#461-mongodb-data-structure","title":"4.6.1 MongoDB Data Structure","text":"<pre><code>// Collection: applicationData.pfds\n{\n  \"_id\": ObjectId(\"...\"),\n  \"applicationId\": \"app_1761902997\",\n  \"pfds\": [\n    {\n      \"pfdId\": \"pfd001\",\n      \"flowDescriptions\": [\n        \"permit in ip from 192.168.1.0/24 to any\",\n        \"permit out ip from any to 10.0.0.0/8\"\n      ],\n      \"urls\": [\"https://example.com/app\"],\n      \"domainNames\": [\"example.com\"]\n    },\n    {\n      \"pfdId\": \"pfd002\",\n      \"flowDescriptions\": [\n        \"permit in ip from 172.16.0.0/12 to any\"\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"blog/20251119/20251119/#462-data-lifecycle","title":"4.6.2 Data Lifecycle","text":"<ol> <li>Create: AF sends POST request, NEF creates Transaction, UDR stores to MongoDB</li> <li>Update: AF sends PUT/PATCH request, UDR updates data in MongoDB</li> <li>Query: Network functions (such as SMF) can query PFD data from UDR for traffic identification</li> <li>Delete: AF sends DELETE request, UDR deletes data from MongoDB</li> </ol>"},{"location":"blog/20251119/20251119/#47-error-handling","title":"4.7 Error Handling","text":""},{"location":"blog/20251119/20251119/#471-http-status-code-definitions","title":"4.7.1 HTTP Status Code Definitions","text":"<p>According to 3GPP TS 29.522 and REST standards, NEF PFD Management uses the following status codes:</p> HTTP Status Code Type Meaning Use Case 200 OK Success Operation completed successfully PUT/GET update or query succeeded 201 Created Success Resource created successfully POST creates transaction, PUT creates new PFD 204 No Content Success Deletion successful, no return content DELETE request succeeded 400 Bad Request Client Error Request format error JSON format error, parameter validation failed 403 Forbidden Client Error Insufficient permissions AF not authorized to access resource 404 Not Found Client Error Resource does not exist Transaction/Application ID does not exist 409 Conflict Client Error Resource conflict Application ID duplicate 500 Internal Server Error Server Error Internal processing error Database connection failed, internal logic error 503 Service Unavailable Server Error Service temporarily unavailable UDR service unreachable"},{"location":"blog/20251119/20251119/#472-pfd-report-error-report","title":"4.7.2 PFD Report (Error Report)","text":"<p>When PFD data processing fails, NEF returns a PfdReport:</p> <pre><code>{\n  \"pfdReports\": {\n    \"APP_ID_DUPLICATED\": {\n      \"externalAppIds\": [\"app001\"],\n      \"failureCode\": \"APP_ID_DUPLICATED\"\n    }\n  }\n}\n</code></pre> <p>Failure Codes:</p> <ul> <li><code>APP_ID_DUPLICATED</code>: Application ID is already used by another AF/Transaction</li> <li><code>MALFUNCTION</code>: System internal error (such as UDR connection failure)</li> </ul> <p>Note: Implementation details (error code naming, return fields, specific behavior) may vary slightly depending on free5GC version and commit. The above description is based on the v4.0.1 version tested in this experiment.</p>"},{"location":"blog/20251119/20251119/#5-experiment-and-testing","title":"5. Experiment and Testing","text":""},{"location":"blog/20251119/20251119/#51-experimental-environment-preparation","title":"5.1 Experimental Environment Preparation","text":""},{"location":"blog/20251119/20251119/#511-system-requirements","title":"5.1.1 System Requirements","text":"<pre><code># Operating System Information\nOS: Ubuntu 25.04\nKernel: Linux 6.14.0-34-generic\nShell: /bin/bash\n\n# Software Requirements\n\n- Go 1.22.5\n- MongoDB 7.x\n- mongosh 2.5.8\n- free5GC v4.0.1 (based on main branch as of 2025-10-31)\n- curl 8.12.1\n- jq (JSON processing tool)\n</code></pre> <p>Version Notes:</p> <ul> <li>This experiment is based on free5GC v4.0.1 for testing and patching.</li> <li>This experiment uses bare-metal deployment, manually starting all network functions using <code>./run.sh</code>, rather than docker-compose or free5gc-compose containerized deployment.</li> <li>If readers use different versions or deployment methods, they may need to adjust relevant configurations and scripts.</li> </ul>"},{"location":"blog/20251119/20251119/#512-starting-free5gc","title":"5.1.2 Starting free5GC","text":"<pre><code># Enter free5GC directory\ncd /free5gc\n\n# Start all network functions\n./run.sh\n\n# Verify service status\nps aux | grep -E \"nef|pcf|udr|nrf\" | grep -v grep\n</code></pre> <p>Expected Output: <pre><code>ubuntu25   65043  0.0  0.2 1244292 22048 ?  Sl  09:04  0:00 ./bin/nrf -c ./config/nrfcfg.yaml\nubuntu25   65100  0.0  0.2 1246576 22408 ?  Sl  09:04  0:00 ./bin/pcf -c ./config/pcfcfg.yaml\nubuntu25   65184  0.0  0.1 1239492 16412 ?  Sl  09:04  0:00 ./bin/nef -c ./config/nefcfg.yaml\nubuntu25   65200  0.2  0.2 1244400 21588 ?  Sl  09:04  0:00 ./bin/udr -c ./config/udrcfg.yaml\n</code></pre></p>"},{"location":"blog/20251119/20251119/#52-discovered-and-fixed-bugs","title":"5.2 Discovered and Fixed Bugs","text":""},{"location":"blog/20251119/20251119/#521-bug-1-nef-lacks-automatic-af-creation-mechanism","title":"5.2.1 Bug #1: NEF Lacks Automatic AF Creation Mechanism","text":"<p>Problem Description: In the original code, NEF checks whether the AF exists when processing POST requests. If it doesn't exist, it directly returns a 404 error, preventing first-time AFs from creating PFD Transactions.</p> <p>File Location: <code>nef/internal/sbi/processor/pfd.go</code></p> <p>Original Code: <pre><code>af := nefCtx.GetAf(scsAsID)\nif af == nil {\n    return &amp;HandlerResponse{http.StatusNotFound, nil, openapi.ProblemDetailsDataNotFound(DetailNoAF)}\n}\n</code></pre></p> <p>Problem Analysis:</p> <ul> <li>AF should be automatically created on first use, not pre-registered</li> <li>This does not align with the design philosophy of 3GPP standards</li> <li>Requires manual pre-creation of AF during testing</li> </ul> <p>Fixed Code: <pre><code>af := nefCtx.GetAf(scsAsID)\nif af == nil {\n    // Auto-create AF if it doesn't exist\n    af = nefCtx.NewAf(scsAsID)\n    nefCtx.AddAf(af)\n}\n</code></pre></p> <p>Reasons for Fix:</p> <ol> <li>Compliant with Standards: 3GPP TS 29.522 does not require AF pre-registration</li> <li>Simplified Operations: Reduces testing and deployment complexity</li> <li>Improved Usability: AF can dynamically start using NEF services</li> </ol> <p>Considerations:</p> <ul> <li>This fix is suitable for development and testing environments, simplifying the AF usage workflow</li> <li>In production environments, the following issues need to be considered:</li> <li>Concurrency Safety: If two POST requests are initiated for the same AF ID almost simultaneously, there may be a race condition</li> <li>State Persistence: AF context may be lost after NEF restart, requiring database persistence or AF re-registration mechanism</li> <li>Authorization Control: Should be combined with OAuth2/CAPIF mechanisms to ensure only legitimate AFs can create transactions</li> </ul>"},{"location":"blog/20251119/20251119/#522-bug-2-udr-response-handling-logic-error","title":"5.2.2 Bug #2: UDR Response Handling Logic Error","text":"<p>Problem Description: The UDR's <code>PutApplicationDataIndividualPfdToDBProcedure</code> function, when processing PUT requests, executes <code>c.JSON()</code> call twice regardless of whether the data is newly created or updated, causing the second call to fail (because the HTTP response has already been sent).</p> <p>File Location: <code>udr/internal/sbi/processor/default.go</code></p> <p>Original Code: <pre><code>if existed {\n    c.JSON(http.StatusOK, data)\n}\nc.JSON(http.StatusCreated, data)  // \u2190 Always executes, causing error\n</code></pre></p> <p>Problem Analysis:</p> <ul> <li>Missing <code>else</code> branch, causing logic error</li> <li>When data already exists, it first returns 200 OK, then attempts to return 201 Created again</li> <li>Go's gin framework generates a warning on the second <code>c.JSON()</code> call: <code>[GIN] Headers were already written</code></li> <li>Although the response has been sent to the client, the gin framework logs the error, affecting log readability</li> <li>The second call does not change the sent HTTP response but violates correct programming practices</li> </ul> <p>Fixed Code: <pre><code>if existed {\n    c.JSON(http.StatusOK, data)\n} else {\n    c.JSON(http.StatusCreated, data)\n}\n</code></pre></p> <p>Reasons for Fix:</p> <ol> <li>Compliant with HTTP Semantics: Newly created resource returns 201, updated existing resource returns 200</li> <li>Fixes Response Error: Avoids errors caused by double responses</li> <li>Compliant with REST Standards: Correct behavior for PUT requests</li> </ol>"},{"location":"blog/20251119/20251119/#523-bug-3-api-version-mismatch","title":"5.2.3 Bug #3: API Version Mismatch","text":"<p>Problem Description: UDR uses the API path prefix <code>/nudr-dr/v2</code>, while NEF as a UDR client uses <code>/nudr-dr/v1</code>, causing all API calls to UDR to return 404.</p> <p>File Location: <code>udr/pkg/factory/config.go</code></p> <p>Original Code: <pre><code>UdrDrResUriPrefix = \"/nudr-dr/v2\"\n</code></pre></p> <p>Problem Analysis:</p> <ul> <li>NEF's OpenAPI client generated code uses v1 version</li> <li>UDR's routing configuration uses v2 version</li> <li>Version mismatch causes route not found, returning 404</li> <li>This is a configuration inconsistency issue</li> </ul> <p>Verifying the Problem: <pre><code># Test v1 endpoint (fails)\ncurl -X GET http://127.0.0.4:8000/nudr-dr/v1/application-data/pfds\n# Returns: 404 page not found\n\n# Test v2 endpoint (succeeds)\ncurl -X GET http://127.0.0.4:8000/nudr-dr/v2/application-data/pfds\n# Returns: []\n</code></pre></p> <p>Fixed Code: <pre><code>UdrDrResUriPrefix = \"/nudr-dr/v1\"  // Changed to v1 to match NEF\n</code></pre></p> <p>Reasons for Fix:</p> <ol> <li>Maintain Consistency: All components use the same API version</li> <li>Match OpenAPI Specifications: NEF's client code is generated based on v1 specifications</li> <li>Avoid Regenerating Code: Modifying UDR's configuration is simpler than regenerating NEF's client code</li> </ol> <p>Important Notes:</p> <ul> <li>The spirit of this fix is \"to make UDR compatible with the current NEF-generated v1 API client implementation\", not to indicate that v2 API is definitely wrong</li> <li>In the future, free5GC may uniformly upgrade all components to v2 API, which may require reverse adjustment or synchronous upgrade</li> <li>This is a temporary measure during the version transition period; ultimately, the free5GC project should uniformly decide which API version to use</li> </ul> <p>Verifying the Fix: <pre><code># Test v1 endpoint (should succeed now)\ncurl -X GET http://127.0.0.4:8000/nudr-dr/v1/application-data/pfds\n# Returns: []\n</code></pre></p>"},{"location":"blog/20251119/20251119/#53-creating-test-scripts","title":"5.3 Creating Test Scripts","text":""},{"location":"blog/20251119/20251119/#531-nef-log-monitoring-script","title":"5.3.1 NEF Log Monitoring Script","text":"<p>File: <code>/monitor_nef.sh</code></p> <pre><code>#!/bin/bash\n\n# NEF Log Monitor Script\n# Automatically find the latest log file\nLOG_DIR=$(ls -td /home/ubuntu25/free5gc/log/*/ 2&gt;/dev/null | head -1)\nLOG_FILE=\"${LOG_DIR}free5gc.log\"\n\necho \"==========================================\"\necho \"Monitoring NEF Logs\"\necho \"Log File: $LOG_FILE\"\necho \"==========================================\"\necho \"\"\necho \"Waiting for NEF activity...\"\necho \"\"\n\n# Monitor NEF logs in real-time\ntail -f \"$LOG_FILE\" | grep --line-buffered -E \"NEF|nnef-pfdmanagement|PFD\" | while read line; do\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S')] $line\"\ndone\n</code></pre> <p>Usage: <pre><code>chmod +x /monitor_nef.sh\n\n# Execute in a new terminal window\n/monitor_nef.sh\n</code></pre></p> <p>Functional Description:</p> <ul> <li>Real-time monitoring of NEF log output</li> <li>Filters out logs related to PFD Management</li> <li>Adds timestamps for easier analysis</li> </ul>"},{"location":"blog/20251119/20251119/#532-pcf-log-monitoring-script-optional","title":"5.3.2 PCF Log Monitoring Script (Optional)","text":"<p>Important Note: PCF is not involved in this experiment's PFD Management workflow. PCF is primarily used for NEF's another service: Traffic Influence (traffic routing control for specific UEs), interacting with NEF through the <code>Npcf_PolicyAuthorization</code> interface. This experiment only focuses on PFD Management + UDR persistence, so no related activity will be seen in PCF logs.</p> <p>The following script is for reference only, applicable for future expansion of the experiment to per-UE traffic influence scenarios.</p> <p>File: <code>/monitor_pcf.sh</code></p> <pre><code>#!/bin/bash\n\n# PCF Log Monitor Script\n# Automatically find the latest log file\nLOG_DIR=$(ls -td /home/ubuntu25/free5gc/log/*/ 2&gt;/dev/null | head -1)\nLOG_FILE=\"${LOG_DIR}free5gc.log\"\n\necho \"==========================================\"\necho \"Monitoring PCF Logs\"\necho \"Log File: $LOG_FILE\"\necho \"==========================================\"\necho \"\"\necho \"Waiting for PCF activity...\"\necho \"\"\n\n# Monitor PCF logs in real-time\ntail -f \"$LOG_FILE\" | grep --line-buffered -E \"PCF|npcf-policyauthorization|PolicyAuthorization\" | while read line; do\n    echo \"[$(date '+%Y-%m-%d %H:%M:%S')] $line\"\ndone\n</code></pre> <p>Usage: <pre><code>chmod +x /monitor_pcf.sh\n\n# Execute in a new terminal window (only for traffic influence experiments)\n/monitor_pcf.sh\n</code></pre></p>"},{"location":"blog/20251119/20251119/#533-af-pfd-test-main-script","title":"5.3.3 AF PFD Test Main Script","text":"<p>File: <code>/af_pfd_test.sh</code></p> <pre><code>#!/bin/bash\n\n# AF PFD Management Test Script\n# This script demonstrates the PFD transaction creation and data upload via NEF\n\nNEF_BASE_URL=\"http://127.0.0.5:8000\"\nAF_ID=\"AF001\"\nAPP_ID=\"app_$(date +%s)\"  # Use timestamp to make it unique\n\necho \"==========================================\"\necho \"AF PFD Management Experiment\"\necho \"==========================================\"\necho \"App ID: $APP_ID\"\necho \"\"\n\n# Step 2: Create PFD Transaction (POST)\necho \"[Step 2] Creating PFD Transaction...\"\necho \"Endpoint: POST ${NEF_BASE_URL}/3gpp-pfd-management/v1/${AF_ID}/transactions\"\necho \"\"\n\nPOST_RESPONSE=$(curl -s -w \"\\nHTTP_STATUS:%{http_code}\" -X POST \\\n  \"${NEF_BASE_URL}/3gpp-pfd-management/v1/${AF_ID}/transactions\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"{\n    \\\"pfdDatas\\\": {\n      \\\"$APP_ID\\\": {\n        \\\"externalAppId\\\": \\\"$APP_ID\\\",\n        \\\"pfds\\\": {\n          \\\"pfd001\\\": {\n            \\\"pfdId\\\": \\\"pfd001\\\",\n            \\\"flowDescriptions\\\": [\n              \\\"permit in ip from 192.168.1.0/24 to any\\\"\n            ]\n          }\n        }\n      }\n    }\n  }\")\n\nHTTP_STATUS=$(echo \"$POST_RESPONSE\" | grep \"HTTP_STATUS\" | cut -d: -f2)\nPOST_BODY=$(echo \"$POST_RESPONSE\" | sed '/HTTP_STATUS/d')\n\necho \"Response Status: $HTTP_STATUS\"\necho \"Response Body:\"\necho \"$POST_BODY\" | jq . 2&gt;/dev/null || echo \"$POST_BODY\"\necho \"\"\n\nif [ \"$HTTP_STATUS\" == \"201\" ] || [ \"$HTTP_STATUS\" == \"200\" ]; then\n    echo \" POST Transaction Created Successfully!\"\n    # Extract transaction ID from the self URI\n    TRANSACTION_ID=$(echo \"$POST_BODY\" | jq -r '.self' | grep -oP '/transactions/\\K[^/]+$')\n    echo \"Transaction ID: $TRANSACTION_ID\"\nelse\n    echo \" POST Transaction Failed!\"\n    exit 1\nfi\n\necho \"\"\necho \"==========================================\"\necho \"\"\n\n# Step 3: Upload PFD Data (PUT)\necho \"[Step 3] Uploading PFD Data...\"\necho \"Endpoint: PUT ${NEF_BASE_URL}/3gpp-pfd-management/v1/${AF_ID}/transactions/${TRANSACTION_ID}\"\necho \"\"\n\nPUT_RESPONSE=$(curl -s -w \"\\nHTTP_STATUS:%{http_code}\" -X PUT \\\n  \"${NEF_BASE_URL}/3gpp-pfd-management/v1/${AF_ID}/transactions/${TRANSACTION_ID}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d \"{\n    \\\"pfdDatas\\\": {\n      \\\"$APP_ID\\\": {\n        \\\"externalAppId\\\": \\\"$APP_ID\\\",\n        \\\"pfds\\\": {\n          \\\"pfd001\\\": {\n            \\\"pfdId\\\": \\\"pfd001\\\",\n            \\\"flowDescriptions\\\": [\n              \\\"permit in ip from 192.168.1.0/24 to any\\\",\n              \\\"permit out ip from any to 10.0.0.0/8\\\"\n            ],\n            \\\"urls\\\": [\n              \\\"https://example.com/app\\\"\n            ],\n            \\\"domainNames\\\": [\n              \\\"example.com\\\"\n            ]\n          },\n          \\\"pfd002\\\": {\n            \\\"pfdId\\\": \\\"pfd002\\\",\n            \\\"flowDescriptions\\\": [\n              \\\"permit in ip from 172.16.0.0/12 to any\\\"\n            ]\n          }\n        }\n      }\n    }\n  }\")\n\nHTTP_STATUS=$(echo \"$PUT_RESPONSE\" | grep \"HTTP_STATUS\" | cut -d: -f2)\nPUT_BODY=$(echo \"$PUT_RESPONSE\" | sed '/HTTP_STATUS/d')\n\necho \"Response Status: $HTTP_STATUS\"\necho \"Response Body:\"\necho \"$PUT_BODY\" | jq . 2&gt;/dev/null || echo \"$PUT_BODY\"\necho \"\"\n\nif [ \"$HTTP_STATUS\" == \"200\" ] || [ \"$HTTP_STATUS\" == \"204\" ]; then\n    echo \" PUT Data Uploaded Successfully!\"\nelse\n    echo \" PUT Data Upload Failed!\"\nfi\n\necho \"\"\necho \"==========================================\"\necho \"Experiment Completed!\"\necho \"==========================================\"\necho \"\"\nLOG_DIR=$(ls -td /home/ubuntu25/free5gc/log/*/ 2&gt;/dev/null | head -1)\nLOG_FILE=\"${LOG_DIR}free5gc.log\"\necho \"Please check the following logs:\"\necho \"  - Log File: ${LOG_FILE}\"\necho \"  - You can use: tail -100 ${LOG_FILE} | grep -E 'NEF|UDR'\"\necho \"\"\necho \"To verify data in MongoDB:\"\necho \"  mongosh --eval \\\"use free5gc; db.getCollection('applicationData.pfds').find({applicationId: '$APP_ID'}).pretty();\\\"\"\necho \"\"\n</code></pre> <p>Usage: <pre><code>chmod +x /af_pfd_test.sh\n/af_pfd_test.sh\n</code></pre></p>"},{"location":"blog/20251119/20251119/#54-executing-the-experiment","title":"5.4 Executing the Experiment","text":""},{"location":"blog/20251119/20251119/#541-preparation-phase","title":"5.4.1 Preparation Phase","text":"<pre><code># 1. Ensure free5GC is running\nps aux | grep -E \"nef|udr|nrf\" | grep -v grep\n\n# 2. Ensure MongoDB is running\nps aux | grep mongod | grep -v grep\n\n# 3. Start log monitoring (open new terminal windows)\n# Terminal 2:\n/monitor_nef.sh &gt; /tmp/nef_monitor.log 2&gt;&amp;1 &amp;\n\n# Note: PCF monitoring is not needed in this experiment (PCF is not involved in PFD Management workflow)\n# For subsequent traffic influence experiments, optionally use:\n# /monitor_pcf.sh &gt; /tmp/pcf_monitor.log 2&gt;&amp;1 &amp;\n</code></pre>"},{"location":"blog/20251119/20251119/#542-executing-tests","title":"5.4.2 Executing Tests","text":"<pre><code># Terminal 1: Execute test script\n/af_pfd_test.sh\n</code></pre> <p>Expected Output: <pre><code>==========================================\nAF PFD Management Experiment\n==========================================\nApp ID: app_1761902997\n[Step 2] Creating PFD Transaction...\nEndpoint: POST http://127.0.0.5:8000/3gpp-pfd-management/v1/AF001/transactions\nResponse Status: 201\nResponse Body:\n{\n  \"self\": \"http://127.0.0.5:8000/3gpp-pfd-management/v1/AF001/transactions/6\",\n  \"pfdDatas\": {\n    \"app_1761902997\": {\n      \"externalAppId\": \"app_1761902997\",\n      \"self\": \"http://127.0.0.5:8000/3gpp-pfd-management/v1/AF001/transactions/6/applications/app_1761902997\",\n      \"pfds\": {\n        \"pfd001\": {\n          \"pfdId\": \"pfd001\",\n          \"flowDescriptions\": [\n            \"permit in ip from 192.168.1.0/24 to any\"\n          ]\n        }\n      }\n    }\n  }\n}\n POST Transaction Created Successfully!\nTransaction ID: 6\n==========================================\n[Step 3] Uploading PFD Data...\nEndpoint: PUT http://127.0.0.5:8000/3gpp-pfd-management/v1/AF001/transactions/6\nResponse Status: 200\nResponse Body:\n{\n  \"self\": \"http://127.0.0.5:8000/3gpp-pfd-management/v1/AF001/transactions/6\",\n  \"pfdDatas\": {\n    \"app_1761902997\": {\n      \"externalAppId\": \"app_1761902997\",\n      \"self\": \"http://127.0.0.5:8000/3gpp-pfd-management/v1/AF001/transactions/6/applications/app_1761902997\",\n      \"pfds\": {\n        \"pfd001\": {\n          \"pfdId\": \"pfd001\",\n          \"flowDescriptions\": [\n            \"permit in ip from 192.168.1.0/24 to any\",\n            \"permit out ip from any to 10.0.0.0/8\"\n          ],\n          \"urls\": [\n            \"https://example.com/app\"\n          ],\n          \"domainNames\": [\n            \"example.com\"\n          ]\n        },\n        \"pfd002\": {\n          \"pfdId\": \"pfd002\",\n          \"flowDescriptions\": [\n            \"permit in ip from 172.16.0.0/12 to any\"\n          ]\n        }\n      }\n    }\n  }\n}\n PUT Data Uploaded Successfully!\n==========================================\nExperiment Completed!\n==========================================\n</code></pre></p>"},{"location":"blog/20251119/20251119/#55-results-verification","title":"5.5 Results Verification","text":""},{"location":"blog/20251119/20251119/#551-nrf-service-discovery-verification","title":"5.5.1 NRF Service Discovery Verification","text":"<p>Before NEF processes PFD Management requests, NEF first queries NRF for UDR service endpoints. This is a core mechanism of 5G SBA architecture.</p> <pre><code># View NEF and NRF interaction logs\nLOG_FILE=$(ls -t /home/ubuntu25/free5gc/log/*/free5gc.log 2&gt;/dev/null | head -1)\ntail -100 \"$LOG_FILE\" | grep -E \"NEF.*Discovery|NEF.*Nnrf|SearchNFInstances.*UDR\"\n</code></pre> <p>Key Log Examples: <pre><code>time=\"...\" level=\"info\" msg=\"SearchNFInstances with nfType[UDR]\" CAT=\"Nnrf\" NF=\"NEF\"\ntime=\"...\" level=\"debug\" msg=\"URI from NRF: http://127.0.0.4:8000\" NF=\"NEF\"\n</code></pre></p> <p>These logs prove that NEF doesn't hardcode UDR's URL but dynamically discovers UDR's <code>nudr-dr</code> service endpoint through NRF.</p>"},{"location":"blog/20251119/20251119/#552-nef-log-verification","title":"5.5.2 NEF Log Verification","text":"<pre><code># View NEF logs for processing POST requests\n# Automatically get the latest log file\nLOG_FILE=$(ls -t /home/ubuntu25/free5gc/log/*/free5gc.log 2&gt;/dev/null | head -1)\ntail -100 \"$LOG_FILE\" | grep -A 5 \"PostPFDManagementTransactions\"\n</code></pre> <p>Key Logs: <pre><code>time=\"2025-10-31T09:29:57.449161053Z\" level=\"info\" msg=\"PostPFDManagementTransactions - scsAsID[AF001]\" CAT=\"PFDMng\" NF=\"NEF\"\ntime=\"2025-10-31T09:29:57.449259200Z\" level=\"info\" msg=\"New pfd transcation\" AFID=\"AF:AF001\" CAT=\"CTX\" NF=\"NEF\" PfdTRID=\"PFDT:6\"\ntime=\"2025-10-31T09:29:57.449273884Z\" level=\"info\" msg=\"appID[app_1761902997] is added\" AFID=\"AF:AF001\" CAT=\"CTX\" NF=\"NEF\" PfdTRID=\"PFDT:6\"\ntime=\"2025-10-31T09:29:57.453961420Z\" level=\"info\" msg=\"PFD Management Transaction is added\" AFID=\"AF:AF001\" CAT=\"CTX\" NF=\"NEF\" PfdTRID=\"PFDT:6\"\ntime=\"2025-10-31T09:29:57.454032294Z\" level=\"info\" msg=\"AF is added\" AFID=\"AF:AF001\" CAT=\"CTX\" NF=\"NEF\"\ntime=\"2025-10-31T09:29:57.454071110Z\" level=\"info\" msg=\"| 201 |       127.0.0.1 | POST    | /3gpp-pfd-management/v1/AF001/transactions | \" CAT=\"GIN\" NF=\"NEF\"\n</code></pre></p> <pre><code># View NEF logs for processing PUT requests\n# Automatically get the latest log file\nLOG_FILE=$(ls -t /home/ubuntu25/free5gc/log/*/free5gc.log 2&gt;/dev/null | head -1)\ntail -100 \"$LOG_FILE\" | grep -A 3 \"PutIndividualPFDManagementTransaction\"\n</code></pre> <p>Key Logs: <pre><code>time=\"2025-10-31T09:29:57.466704798Z\" level=\"info\" msg=\"PutIndividualPFDManagementTransaction - scsAsID[AF001], transID[6]\" CAT=\"PFDMng\" NF=\"NEF\"\ntime=\"2025-10-31T09:29:57.466762809Z\" level=\"info\" msg=\"appID[app_1761902997] is added\" AFID=\"AF:AF001\" CAT=\"CTX\" NF=\"NEF\" PfdTRID=\"PFDT:6\"\ntime=\"2025-10-31T09:29:57.472831410Z\" level=\"info\" msg=\"| 200 |       127.0.0.1 | PUT     | /3gpp-pfd-management/v1/AF001/transactions/6 | \" CAT=\"GIN\" NF=\"NEF\"\n</code></pre></p>"},{"location":"blog/20251119/20251119/#553-udr-log-verification","title":"5.5.3 UDR Log Verification","text":"<pre><code># View UDR logs for processing PFD storage requests\n# Automatically get the latest log file\nLOG_FILE=$(ls -t /home/ubuntu25/free5gc/log/*/free5gc.log 2&gt;/dev/null | head -1)\ntail -100 \"$LOG_FILE\" | grep -E \"UDR.*application-data/pfds\"\n</code></pre> <p>Key Logs: <pre><code>time=\"2025-10-31T09:29:57.453494418Z\" level=\"info\" msg=\"| 201 |       127.0.0.1 | PUT     | /nudr-dr/v1/application-data/pfds/app_1761902997 | \" CAT=\"GIN\" NF=\"UDR\"\ntime=\"2025-10-31T09:29:57.472671073Z\" level=\"info\" msg=\"| 200 |       127.0.0.1 | PUT     | /nudr-dr/v1/application-data/pfds/app_1761902997 | \" CAT=\"GIN\" NF=\"UDR\"\n</code></pre></p> <p>Explanation: The first PUT returns 201 Created (new resource), the second PUT returns 200 OK (updated existing resource), compliant with REST PUT semantics.</p>"},{"location":"blog/20251119/20251119/#554-mongodb-data-verification","title":"5.5.4 MongoDB Data Verification","text":"<pre><code># Connect to MongoDB and query PFD data\nmongosh --eval \"\n  use free5gc;\n  db.getCollection('applicationData.pfds').find(\n    {applicationId: 'app_1761902997'}\n  ).pretty();\n\"\n</code></pre> <p>Expected Output: <pre><code>{\n  _id: ObjectId(\"67237f2d8c8a9f0001234567\"),\n  applicationId: 'app_1761902997',\n  pfds: [\n    {\n      pfdId: 'pfd001',\n      flowDescriptions: [\n        'permit in ip from 192.168.1.0/24 to any',\n        'permit out ip from any to 10.0.0.0/8'\n      ],\n      urls: [ 'https://example.com/app' ],\n      domainNames: [ 'example.com' ]\n    },\n    {\n      pfdId: 'pfd002',\n      flowDescriptions: [ 'permit in ip from 172.16.0.0/12 to any' ]\n    }\n  ]\n}\n</code></pre></p>"},{"location":"blog/20251119/20251119/#555-api-interoperability-verification","title":"5.5.5 API Interoperability Verification","text":"<pre><code># Test GET operation: Query PFD Transaction\ncurl -X GET http://127.0.0.5:8000/3gpp-pfd-management/v1/AF001/transactions/6 | jq .\n</code></pre> <p>Expected Response: 200 OK, containing complete PFD data</p> <pre><code># Test GET operation: Query specific application's PFD\ncurl -X GET \"http://127.0.0.5:8000/3gpp-pfd-management/v1/AF001/transactions/6/applications/app_1761902997\" | jq .\n</code></pre> <p>Expected Response: 200 OK, containing that application's PFD data</p>"},{"location":"blog/20251119/20251119/#556-delete-operation-complete-verification","title":"5.5.6 DELETE Operation Complete Verification","text":"<p>This section verifies the completeness of PFD Transaction deletion operations, including data consistency across NEF, UDR, and MongoDB.</p> <pre><code># Step 1: Delete PFD Transaction\necho \"=== Step 1: Delete Transaction ===\"\ncurl -v -X DELETE http://127.0.0.5:8000/3gpp-pfd-management/v1/AF001/transactions/6\n</code></pre> <p>Expected Response: 204 No Content</p> <pre><code># Step 2: Check NEF logs\necho \"=== Step 2: Check NEF deletion logs ===\"\nLOG_FILE=$(ls -t /home/ubuntu25/free5gc/log/*/free5gc.log 2&gt;/dev/null | head -1)\ntail -50 \"$LOG_FILE\" | grep -E \"DELETE.*transactions/6\"\n</code></pre> <p>Expected Logs: <pre><code>time=\"...\" level=\"info\" msg=\"| 204 |  127.0.0.1 | DELETE  | /3gpp-pfd-management/v1/AF001/transactions/6 | \" CAT=\"GIN\" NF=\"NEF\"\n</code></pre></p> <pre><code># Step 3: Check if UDR executed DELETE operation\necho \"=== Step 3: Check UDR deletion logs ===\"\ntail -50 \"$LOG_FILE\" | grep -E \"DELETE.*application-data/pfds/app_1761902997\"\n</code></pre> <p>Expected Logs: <pre><code>time=\"...\" level=\"info\" msg=\"| 204 |  127.0.0.1 | DELETE  | /nudr-dr/v1/application-data/pfds/app_1761902997 | \" CAT=\"GIN\" NF=\"UDR\"\n</code></pre></p> <pre><code># Step 4: Verify data has been deleted from MongoDB\necho \"=== Step 4: Verify MongoDB data cleanup ===\"\nmongosh --eval \"\n  use free5gc;\n  const count = db.getCollection('applicationData.pfds').countDocuments(\n    {applicationId: 'app_1761902997'}\n  );\n  print('Records found: ' + count);\n  if (count === 0) {\n    print(' DELETE operation successful: MongoDB data cleaned');\n  } else {\n    print(' DELETE operation failed: MongoDB still has residual data');\n  }\n\"\n</code></pre> <p>Expected Output: <pre><code>Records found: 0\n DELETE operation successful: MongoDB data cleaned\n</code></pre></p> <p>Verification Explanation:</p> <ul> <li>After NEF receives a DELETE request, it sends a corresponding DELETE request to UDR</li> <li>UDR deletes the corresponding <code>applicationData.pfds</code> record from MongoDB</li> <li>The entire deletion workflow ensures data consistency between NEF Transaction and UDR/MongoDB</li> </ul> <p>Note: In MongoDB 5.0+, <code>.count()</code> has been deprecated; <code>.countDocuments()</code> method should be used instead.</p>"},{"location":"blog/20251119/20251119/#56-test-execution-summary","title":"5.6 Test Execution Summary","text":""},{"location":"blog/20251119/20251119/#561-test-results-confirmation","title":"5.6.1 Test Results Confirmation","text":"<p>Actual Test Output: <pre><code>==========================================\nAF PFD Management Experiment\n==========================================\nApp ID: app_1761922382\n[Step 2] Creating PFD Transaction...\nResponse Status: 201\n POST Transaction Created Successfully!\nTransaction ID: 17\n[Step 3] Uploading PFD Data...\nResponse Status: 200\n PUT Data Uploaded Successfully!\n==========================================\n</code></pre></p>"},{"location":"blog/20251119/20251119/#57-performance-testing","title":"5.7 Performance Testing","text":"<p>Important Note: The following performance test results are based on a single-machine loopback (127.0.0.x) environment, without TLS or OAuth2 verification enabled, and without connection to actual RAN/UE or generation of real user traffic. This test is only for verifying the basic response time of NEF\u2194UDR\u2194MongoDB and cannot be directly used as a production environment SLA reference.</p>"},{"location":"blog/20251119/20251119/#571-single-operation-latency-test","title":"5.7.1 Single Operation Latency Test","text":"<pre><code># Test POST operation latency\ntime curl -s -X POST http://127.0.0.5:8000/3gpp-pfd-management/v1/AF001/transactions \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"pfdDatas\":{\"test_app\":{\"externalAppId\":\"test_app\",\"pfds\":{\"pfd1\":{\"pfdId\":\"pfd1\",\"flowDescriptions\":[\"permit in ip from any to any\"]}}}}}' \\\n  &gt; /dev/null\n</code></pre> <p>Measured Results: <pre><code>real    0m0.015s\nuser    0m0.003s\nsys     0m0.003s\n</code></pre></p> <p>Analysis: POST operation average latency is approximately 15ms, as expected</p>"},{"location":"blog/20251119/20251119/#572-consecutive-operations-test","title":"5.7.2 Consecutive Operations Test","text":"<pre><code># Test creating 10 Transactions consecutively\nfor i in {1..10}; do\n  APP_ID=\"perf_test_$i\"\n  curl -s -X POST http://127.0.0.5:8000/3gpp-pfd-management/v1/AF001/transactions \\\n    -H \"Content-Type: application/json\" \\\n    -d \"{\\\"pfdDatas\\\":{\\\"$APP_ID\\\":{\\\"externalAppId\\\":\\\"$APP_ID\\\",\\\"pfds\\\":{\\\"pfd1\\\":{\\\"pfdId\\\":\\\"pfd1\\\",\\\"flowDescriptions\\\":[\\\"permit in ip from any to any\\\"]}}}}}\" \\\n    | jq -r '.self'\ndone\n</code></pre> <p>Results: All 10 requests succeeded, average response time 20ms</p>"},{"location":"blog/20251119/20251119/#58-script-improvements","title":"5.8 Script Improvements","text":"<p>During actual testing, the following improvements were made to the original scripts:</p>"},{"location":"blog/20251119/20251119/#581-dynamic-log-path-detection","title":"5.8.1 Dynamic Log Path Detection","text":"<p>The original script used hardcoded log paths, unsuitable for different execution times. The improved script automatically detects the latest log directory:</p> <pre><code># Before improvement\nLOG_FILE=\"/free5gc/log/20251031_090404/free5gc.log\"\n\n# After improvement\nLOG_DIR=$(ls -td /home/ubuntu25/free5gc/log/*/ 2&gt;/dev/null | head -1)\nLOG_FILE=\"${LOG_DIR}free5gc.log\"\n</code></pre> <p>Advantages:</p> <ul> <li>No need to manually modify log paths</li> <li>Automatically uses the latest log file</li> <li>Improves script reusability</li> </ul>"},{"location":"blog/20251119/20251119/#582-enhanced-output-messages","title":"5.8.2 Enhanced Output Messages","text":"<p>More detailed verification instructions were added at the end of the test script:</p> <pre><code>echo \"To verify data in MongoDB:\"\necho \"  mongosh --eval \\\"use free5gc; db.getCollection('applicationData.pfds').find({applicationId: '$APP_ID'}).pretty();\\\"\"\n</code></pre> <p>This allows users to immediately verify whether data is correctly stored.</p>"},{"location":"blog/20251119/20251119/#6-conclusion","title":"6. Conclusion","text":""},{"location":"blog/20251119/20251119/#61-summary-of-experimental-results","title":"6.1 Summary of Experimental Results","text":"<p>This experiment successfully implemented complete testing and verification of NEF PFD Management functionality in free5GC, achieving the following important results:</p>"},{"location":"blog/20251119/20251119/#611-functional-verification","title":"6.1.1 Functional Verification","text":"<ul> <li>Verified that NEF's PFD Management API complies with 3GPP TS 29.522 standards</li> <li>Confirmed correct data interaction workflow between NEF and UDR</li> <li>Verified PFD data persistence mechanism in MongoDB</li> <li>Tested complete CRUD operations (Create, Read, Update, Delete)</li> </ul>"},{"location":"blog/20251119/20251119/#612-bug-fixes-and-improvements","title":"6.1.2 Bug Fixes and Improvements","text":"<ul> <li>Bug #1: Fixed NEF's lack of automatic AF creation mechanism</li> <li>Bug #2: Fixed UDR response handling logic error</li> <li>Bug #3: Resolved API version mismatch between NEF and UDR</li> </ul> <p>These three bug fixes make free5GC's NEF functionality more complete and user-friendly, improving overall system stability.</p>"},{"location":"blog/20251119/20251119/#references","title":"References","text":"<ul> <li>3GPP TS 23.501</li> <li>3GPP TS 29.522</li> <li>3GPP TS 29.519 </li> <li>3GPP TS 29.507</li> <li>3GPP TS 29.510</li> <li>References to implementation:<ul> <li>nef/internal/sbi/processor/pfd.go</li> <li>udr/internal/sbi/processor/default.go</li> <li>udr/pkg/factory/config.go</li> </ul> </li> </ul>"},{"location":"blog/20251119/20251119/#about","title":"About","text":"<p>Hello! I'm Yu-Chen Chan, and I've recently started exploring 5G technology and engaging with the free5GC community. I hope you find this blog post useful, and don't hesitate to reach out if you spot any mistakes or have recommendations for improvement.</p>"},{"location":"blog/20251119/20251119/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: Yu-Chen, Chan</li> </ul>"},{"location":"blog/20251126/20251126/","title":"Implementing GTP-driven Automatic Scheduling Optimization with eBPF-based Scheduler","text":"<p>Note</p> <p>Author: Meng-Han, Hsieh Date: 2025/11/26</p>"},{"location":"blog/20251126/20251126/#abstract","title":"Abstract","text":"<p>This article demonstrates how to use eBPF (Extended Berkeley Packet Filter) to trace GTP packet processing in the kernel (via gtp5g-tracer), and combine it with Gthulhu \u2014 a Linux eBPF-based Scheduler (sched_ext) \u2014 to automatically adjust scheduling strategies for end-to-end UE (User Equipment) latency optimization.</p> <p>Key achievements delivered in this work:</p> <ul> <li>Automatically identify gNodeB, UE related process ID</li> <li>Dynamically adjust related process priority and CPU time slices</li> <li>Reduce UE ping latency</li> </ul>"},{"location":"blog/20251126/20251126/#background","title":"Background","text":""},{"location":"blog/20251126/20251126/#performance-challenges-in-5g-upf","title":"Performance Challenges in 5G UPF","text":"<p>In 5G networks, the UPF handles all user plane traffic, including tasks like GTP encapsulation/decapsulation and routing. UPF usually faces several performance challenges:</p> <ol> <li> <p>Multi-process CPU Competition:</p> <ul> <li>gNodeB processes (e.g. nr-gnb)</li> <li>UE simulators (e.g. nr-ue) generate test traffic</li> <li>GTP5G kernel module processes packets</li> <li>Other system services compete for CPU resources</li> </ul> </li> <li> <p>Limitations of Linux CFS Scheduler:</p> <ul> <li>CFS (Completely Fair Scheduler) pursues fairness</li> <li>Lacks application-level awareness \u2014 can't automatically prioritize critical 5GC processes based on traffic</li> </ul> </li> <li> <p>Manual Optimization Difficulties:</p> <ul> <li>PIDs change dynamically (container/process restarts)</li> <li>Requires continuous monitoring and adjustment</li> </ul> </li> </ol>"},{"location":"blog/20251126/20251126/#solution","title":"Solution","text":"<p>Combining eBPF observability + eBPF-based scheduler (sched_ext) programmability to build an automated process scheduling optimization system. Instead of modifying network traffic directly, I trace the <code>gtp5g</code> module to identify <code>nr-ue</code> and <code>nr-gnb</code> related processes and provide them higher CPU priority during high system load:</p> <pre><code>%%{init: { 'themeVariables': { 'fontSize': '24px', 'fontFamily': 'Inter, Arial, sans-serif' } } }%%\nflowchart LR\n  subgraph Host[5G Core Host]\n    direction LR\n    UE[\"UE\"] --&gt; gNodeB[\"gNodeB\"] --&gt; UPF[\"UPF (GTP5G)\"] --&gt; Internet[\"Internet\"]\n  end\n\n  subgraph Tracing[\"Kernel eBPF Tracing\"]\n    direction TB\n    gtp5g_tracer[\"gtp5g-tracer\"]\n    trace_pipe[\"trace_pipe\"]\n    gtp5g_tracer --&gt; trace_pipe\n  end\n\n  subgraph Operator[\"User-space Operator\"]\n    direction TB\n    operator[\"gtp5g_operator\\n(Go service)\\nParse &amp; Detect\"]\n    operator --&gt; gthulhu_api[\"Gthulhu API\"]\n    gthulhu_api_note[\"K8s service - Strategy Management\"]\n    gthulhu_api -.-&gt; gthulhu_api_note\n  end\n\n  gtp5g_tracer --&gt;|events| operator\n  gthulhu_api --&gt;|Update Strategies| gthulhu_sched[\"Gthulhu Scheduler\\n(sched_ext, eBPF-based)\"]\n  gthulhu_sched --&gt;|Apply| UPF\n\n  classDef component fill:#f8f9fa,stroke:#333,stroke-width:1px\n  class gtp5g_tracer,trace_pipe,operator,gthulhu_api,gthulhu_sched component\n\n  %% end mermaid</code></pre>"},{"location":"blog/20251126/20251126/#architecture","title":"Architecture","text":""},{"location":"blog/20251126/20251126/#system-components","title":"System Components","text":""},{"location":"blog/20251126/20251126/#1-gtp5g-tracer-ebpf-tracer","title":"1. gtp5g-tracer (eBPF Tracer)","text":"<p>Function: Trace critical functions in GTP5G kernel module</p> <p>Implementation: <pre><code>// gtp5g_tracer_kern.c\nSEC(\"fentry/gtp5g_encap_recv\")\nint BPF_PROG(gtp5g_encap_recv_entry, struct sk_buff *skb, \n             struct net_device *dev) {\n    u32 pid = bpf_get_current_pid_tgid() &gt;&gt; 32;\n    u32 tgid = bpf_get_current_pid_tgid();\n\n    bpf_printk(\"fentry/gtp5g_encap_recv: PID=%d, TGID=%d\", pid, tgid);\n    return 0;\n}\n\nSEC(\"fexit/gtp5g_encap_recv\")\nint BPF_PROG(gtp5g_encap_recv_exit, struct sk_buff *skb, \n             struct net_device *dev, int ret) {\n    bpf_printk(\"fexit/gtp5g_encap_recv: ret=%d\", ret);\n    return 0;\n}\n</code></pre></p> <p>Traced Functions:</p> <ul> <li><code>gtp5g_encap_recv()</code>: GTP encapsulation receive</li> <li><code>gtp5g_handle_skb_ipv4()</code>: IPv4 packet handling</li> <li><code>gtp5g_xmit_skb_ipv4()</code>: IPv4 packet transmission</li> </ul> <p>Output (<code>/sys/kernel/debug/tracing/trace_pipe</code>): <pre><code>nr-gnb-365189 [003] d..31 21039.948599: bpf_trace_printk: fentry/gtp5g_encap_recv: PID=365189, TGID=365162\nnr-ue-365012  [004] d..31 22353.878390: bpf_trace_printk: stop: pid=365012 (nr-ue) cpu=4\n</code></pre></p>"},{"location":"blog/20251126/20251126/#2-gtp5g_operator-go-service","title":"2. gtp5g_operator (Go Service)","text":"<p>Function: Parse trace_pipe, identify critical process IDs, and send scheduling strategies</p> <p>Core Modules:</p> <p>2.1 Trace Parser (<code>pkg/parser/trace_parser.go</code>)</p> <pre><code>type TraceParser struct {\n    nrGnbRegex *regexp.Regexp\n    nrUeRegex  *regexp.Regexp\n}\n\nfunc (p *TraceParser) ParsePIDFromLine(line string) (int, bool) {\n    // Priority matching:\n    // 1. TGID= (thread group ID)\n    // 2. nr-gnb-&lt;PID&gt; / nr-ue-&lt;PID&gt;\n    // 3. pid=&lt;num&gt; (procname)\n    // 4. PID= field\n}\n</code></pre> <p>2.2 JWT Auth Client (<code>pkg/auth/client.go</code>)</p> <pre><code>type Client struct {\n    token       string\n    tokenExpiry time.Time\n    mu          sync.RWMutex\n}\n\n// Automatic token management:\n// - Acquire on first request\n// - Auto-refresh 5 minutes before expiry\n// - Thread-safe\n</code></pre> <p>2.3 API Client (<code>pkg/api/client.go</code>)</p> <pre><code>type SchedulingStrategy struct {\n    PID           int    `json:\"pid\"`\n    Priority      bool   `json:\"priority\"`\n    ExecutionTime uint64 `json:\"execution_time\"`  // nanoseconds\n}\n\nfunc (c *Client) SendStrategies(ctx context.Context, \n                                pids map[int]bool, \n                                priority bool, \n                                executionTime uint64)\n</code></pre> <p>Workflow: <pre><code>1. tail -f /sys/kernel/debug/tracing/trace_pipe\n2. Regex matching to extract PIDs (nr-gnb, nr-ue)\n3. POST to Gthulhu API every second\n4. Periodically get JWT token authentication\n</code></pre></p>"},{"location":"blog/20251126/20251126/#3-gthulhu-scheduler-ebpf-based-scheduler-sched_ext","title":"3. Gthulhu Scheduler (eBPF-based Scheduler / sched_ext)","text":"<p>Function: Programmable scheduler based on Linux sched_ext</p> <p>Key Features:</p> <ul> <li>Receive strategy updates via API</li> <li>Dynamically adjust process priority</li> <li>Custom CPU time slice allocation</li> </ul> <p>Strategy Parameters: <pre><code>{\n  \"strategies\": [\n    {\n      \"pid\": 365162,           // gNodeB main process\n      \"priority\": true,        // Boost priority\n      \"execution_time\": 20000000  // 20ms time slice\n    }\n  ]\n}\n</code></pre></p>"},{"location":"blog/20251126/20251126/#data-flow","title":"Data Flow","text":"<p>To clearly demonstrate the data flow, I divide the process into three phases: Traffic Tracing, Analysis &amp; Decision, and Scheduling Optimization.</p> <p> <pre><code>%%{init: { 'themeVariables': { 'fontSize': '12px', 'fontFamily': 'Inter, Arial, sans-serif' } } }%%\nflowchart TD\n    subgraph Phase1[\"1. Traffic Tracing (Kernel Space)\"]\n        UE[UE Device] --&gt;|GTP Packets| GTP[GTP5G Module]\n        GTP --&gt;|fentry Trigger| Tracer[eBPF Tracer]\n        Tracer --&gt;|Write Event| Pipe[trace_pipe]\n    end\n\n    subgraph Phase2[\"2. Analysis &amp; Decision (User Space)\"]\n        Pipe --&gt;|Read| Operator[gtp5g_operator]\n        Operator --&gt;|Parse PID| Operator\n        Operator --&gt;|HTTP POST| API[Gthulhu API]\n    end\n\n    subgraph Phase3[\"3. Scheduling Optimization (Scheduler)\"]\n        API --&gt;|Update Map| Scheduler[Gthulhu Scheduler]\n        Scheduler --&gt;|Boost Priority| GTP\n    end\n\n    classDef phase fill:#f9f9f9,stroke:#333,stroke-width:1px;\n    class Phase1,Phase2,Phase3 phase;</code></pre> <p></p> <p>Process Detail:</p> <ol> <li>Traffic Generation: UE sends packets, processed by the <code>GTP5G Module</code> in the Kernel.</li> <li>Event Capture: <code>gtp5g-tracer</code> intercepts key functions via eBPF hooks and writes PID information to <code>trace_pipe</code>.</li> <li>Data Analysis: <code>gtp5g_operator</code> reads the pipe in real-time, filtering for key processes (nr-gnb/nr-ue).</li> <li>Strategy Dispatch: The Operator sends the identified PIDs to the <code>Gthulhu API</code>.</li> <li>Execution: <code>Gthulhu Scheduler</code> receives the strategy and immediately adjusts the CPU priority and time slice for that PID.</li> </ol>"},{"location":"blog/20251126/20251126/#implementation-details","title":"Implementation Details","text":""},{"location":"blog/20251126/20251126/#environment-setup","title":"Environment Setup","text":""},{"location":"blog/20251126/20251126/#system-requirements","title":"System Requirements","text":"<ul> <li>OS: Ubuntu 25.04 (kernel 6.12+)</li> <li>Kubernetes: microk8s or other K8s distributions</li> <li>free5GC: free5GC-helm v4.2.0</li> <li>Go: v1.24.2</li> <li>gtp5g: v0.9.15</li> <li>gtp5g-tracer: x</li> </ul>"},{"location":"blog/20251126/20251126/#step-1-gtp5g-tracer-build-run","title":"Step 1: gtp5g-tracer (build &amp; run)","text":"<p>1. Make gtp5g functions visible for fentry/fexit:</p> <p>If functions are declared <code>static inline</code> the symbol may not be visible to the tracer. Convert to a visible symbol where needed (example):</p> <pre><code>// gtp5g/src/gtpu/gtpu.c\n- static inline int gtp5g_encap_recv(struct sk_buff *skb, struct net_device *dev)\n+ __visible noinline int gtp5g_encap_recv(struct sk_buff *skb, struct net_device *dev)\n{\n  // ... function body\n}\n</code></pre> <p>2. Build &amp; run the tracer</p> <pre><code>cp /sys/kernel/btf/vmlinux /usr/lib/modules/$(uname -r)/build/\ncd &lt;GTP5G&gt;\nmake clean &amp;&amp; make\nsudo make install\ncd &lt;GTP5G-TRACER&gt;\nmake dep\nmake \n</code></pre> <p>3. Quick verification (development, should have ue traffic):</p> <pre><code>sudo cat /sys/kernel/debug/tracing/trace_pipe | grep gtp5g\n# example output:\n# nr-gnb-365189 ... bpf_trace_printk: fentry/gtp5g_encap_recv: PID=365189, TGID=365162\n# nr-ue-365012  ... bpf_trace_printk: stop: pid=365012 (nr-ue) cpu=4\n</code></pre>"},{"location":"blog/20251126/20251126/#step-2-build-gthulhu","title":"Step 2: Build Gthulhu","text":"<ul> <li> <p>Gthulhu (API + Scheduler): Deploying Gthulhu with Kubernetes</p> </li> <li> <p>gtp5g_operator: build the operator binary and make sure it can authenticate against the Gthulhu API</p> </li> </ul> <pre><code>cd ~/Gthulhu/gtp5g_operator\ngo build -o gtp5g_operator\n</code></pre> <p>The operator expects configuration for the API endpoint and the Kubernetes JWT public key; see <code>./start_operator.sh</code> for example environment variables.</p>"},{"location":"blog/20251126/20251126/#deployment-guide","title":"Deployment Guide","text":"<pre><code>Host (Ubuntu 25.04)\n\u251c\u2500\u2500 gtp5g-tracer (running in background)\n\u2502   \u2514\u2500\u2500 Output to /sys/kernel/debug/tracing/trace_pipe\n\u2502\n\u251c\u2500\u2500 Kubernetes Cluster (microk8s)\n\u2502   \u251c\u2500\u2500 gthulhu-api (Pod)\n\u2502   \u2502   \u251c\u2500\u2500 :8080 (API Server)\n\u2502   \u2502   \u2514\u2500\u2500 /app/jwt_public_key.pem\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 gthulhu-scheduler (Pod)\n\u2502       \u2514\u2500\u2500 eBPF-based Scheduler (sched_ext)\n\u2502\n\u2514\u2500\u2500 gtp5g_operator (running on host)\n    \u251c\u2500\u2500 Read trace_pipe\n    \u251c\u2500\u2500 Port-forward \u2192 :8081 \u2192 K8s :8080\n    \u2514\u2500\u2500 Send strategies to Gthulhu API\n</code></pre>"},{"location":"blog/20251126/20251126/#startup-sequence","title":"Startup Sequence","text":"<ol> <li> <p>Start free5GC-helm and UERANSIM <pre><code># Install free5GC charts\ncd free5gc-helm/charts\nhelm install -n free5gc free5gc-helm ./free5gc/ \n\n#Install UERANSIM chart\ncd free5gc-helm/charts\nhelm install -n free5gc ueransim ./ueransim/ \n</code></pre></p> </li> <li> <p>Start gtp5g-tracer <pre><code>cd ~/gtp5g-tracer\nsudo ./main\n</code></pre></p> </li> <li> <p>Start Gthulhu (K8s) <pre><code>cd Gthulhu/chart\nhelm install gthulhu gthulhu\n</code></pre></p> </li> <li> <p>Setup Port-Forward <pre><code>POD_NAME=gthulhu-api-xxxxx\nsudo kubectl port-forward $POD_NAME 8081:8080\n</code></pre></p> </li> <li> <p>Start gtp5g_operator <pre><code>cd ~/Gthulhu/gtp5g_operator/\nsudo go run main.go\n</code></pre></p> </li> </ol>"},{"location":"blog/20251126/20251126/#performance-testing","title":"Performance Testing","text":""},{"location":"blog/20251126/20251126/#test-methodology","title":"Test Methodology","text":""},{"location":"blog/20251126/20251126/#baseline-unoptimized","title":"Baseline (Unoptimized)","text":"<ol> <li>Stop gtp5g_operator</li> <li>Clear Gthulhu strategies</li> <li>UE ping test (Run a short host CPU stress, e.g. <code>stress-ng -c 20 --timeout 120s --metrics-brief</code>):</li> </ol> <pre><code># Inside UE POD\nping -I uesimtun0 N6_IP -c 20\n</code></pre>"},{"location":"blog/20251126/20251126/#optimized","title":"Optimized","text":"<ol> <li>Start gtp5g_operator</li> <li>Confirm strategies are applied</li> <li>UE ping test (same command, same CPU stress)</li> </ol>"},{"location":"blog/20251126/20251126/#test-results","title":"Test Results","text":"<p> Metric Baseline Optimized Improvement Avg Latency 88.98 ms 2.079 ms 97.66% Min Latency 35.47 ms 0.679 ms 98.08% Max Latency 130.95 ms 8.45 ms 93.55% <p></p> <p> Figure 1: Baseline - without gtp5g-operator</p> <p> Figure 2: Optimized - automatic apply schduling strategies</p>"},{"location":"blog/20251126/20251126/#conclusion","title":"Conclusion","text":"<p>Combining kernel-level eBPF tracing of gtp5g with an eBPF-based scheduler (Gthulhu) provides an efficient, non-invasive way to detect and prioritize critical 5GC processes \u2014 Reducing substantial UE latency under CPU contention. While this approach is promising, it requires BTF/function visibility and safe, well-tested strategies to avoid negative trade-offs.</p>"},{"location":"blog/20251126/20251126/#references","title":"References","text":"<ul> <li>GTP5G-Tracer: Detailed Project Explanation</li> <li>30 \u7bc7\u6587\u5e36\u4f60\u7528 eBPF \u8207 Golang \u6253\u9020 Linux Scheduler \u7cfb\u5217 </li> </ul>"},{"location":"blog/20251126/20251126/#about","title":"About","text":"<p>Hello! I'm Meng-Han Hsieh, and I've recently started exploring 5G technology and engaging with the free5GC community. I hope you find this blog post useful, and don't hesitate to reach out if you have recommendations for improvement.</p>"},{"location":"blog/20251126/20251126/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: Meng-Han, Hsieh</li> </ul>"},{"location":"blog/20251202/20251202/","title":"Introduction to BSF","text":"<p>Note</p> <p>Author: Chieh-Cheng, Kuo Date: 2025/12/03</p>"},{"location":"blog/20251202/20251202/#introduction","title":"Introduction","text":""},{"location":"blog/20251202/20251202/#1-what-is-bsf","title":"1. What Is BSF?","text":"<p>Binding Support Function (BSF) is a service-based network function defined in the 5G System Architecture, responsible for storing and providing binding information between</p> <ul> <li>PDU session (Packet Data Unit) and PCF (Policy Control Function)</li> <li>UE (User Equipment) and PCF</li> <li>MBS session (Multicast/Broadcast Services), and PCF. </li> </ul> <p>BSF allows PCF to register, update and remove a binding information, and allows PCF to discover binding information. In practice, the BSF becomes a real-time directory of active PCF assignments. When an application functions (AF) or network function (NF) needs to apply policy changes, the BSF ensures that the request is routed to the correct PCF instance.</p>"},{"location":"blog/20251202/20251202/#2-why-is-bsf-needed","title":"2. Why Is BSF Needed?","text":"<p>In the 5G Core, policy control is one of the most dynamic and distributed functions. With the shift to a Service-Based Architecture, network functions (NFs) are no longer monolithic and static as in legacy systems. Instead, they operate as cloud-native microservices that can scale in and out, get relocated, or fail independently. This flexibility creates a new challenge: How do different NFs, AFs know which Policy Control Function (PCF) is responsible for a specific UE or session? <p>The Binding Support Function (BSF) is the 5GC network function designed to solve this problem. It maintains authoritative mappings\u2014called bindings\u2014that associate UEs, sessions, or service groups with the correct PCF instance. </p> <p>AF interact with BSF</p>"},{"location":"blog/20251202/20251202/#bsf-workflow","title":"BSF Workflow","text":"<p>The BSF operates through a relatively simple but crucial workflow involving these major processes:</p> <ol> <li>PCF registers binding information with the BSF</li> <li>AF / NF query BSF to obtain the correct PCF instance</li> <li>AF / NF subscription</li> </ol> <p>These processes run continuously during network operation to ensure accurate and updated bindings.</p>"},{"location":"blog/20251202/20251202/#1-pcf-registers-binding-information","title":"1. PCF Registers Binding Information","text":"<p>Required information for binding When the PCF performs a POST (binding creation), it should provide some important information:</p> <ul> <li>SUPI or GPSI</li> <li>PCF instance ID</li> <li>DNN and S-NSSAI</li> <li>UE address</li> <li>Binding level information (NF instance or NF set)</li> </ul> <p>The binding may be created for a specific PDU Session (SM Policy Control), UE as a whole (AM Policy Authorization), or a MBS Session, however, these bindings are stored independently.</p> <p>bindLevel and PCF Set The BSF allows two types of binding targets:</p> <ul> <li>NF_INSTANCE \u2192 direct PCF instance mapping</li> <li>NF_SET \u2192 binding to a PCF Set, allowing failover and load distribution</li> </ul> <p>SamePcf Logic If a binding already exists for a given (SUPI, GPSI, DNN, S-NSSAI, or MBS Session ID), the BSF may:</p> <ul> <li>Enforce that subsequent PCF must be the same instance</li> <li>Reject conflicting registrations</li> </ul> <p>This prevents policy inconsistency.</p> <p>Accept binding information Upon the reception of an HTTP POST request, the BSF shall:</p> <ul> <li>create new binding information</li> <li>assign a bindingId</li> <li>store the binding information</li> </ul>"},{"location":"blog/20251202/20251202/#2-af-nf-requests-binding-information","title":"2. AF / NF Requests Binding Information","text":"<p>Since application functions or network functions do not inherently know which PCF is serving which UE, they need to send a request for binding information to the BSF before interacting with the PCF.</p> <p>Inputs Required When Querying BSF</p> <p>For PDU-session: UE IPv4/IPv6 address (mandatory). For UE binding retrieval: SUPI or GPSI (Optional: DNN, S-NSSAI) For MBS-session: MBS session identifier</p> <p>Upon acceptance, BSF will then return binding information.</p>"},{"location":"blog/20251202/20251202/#3-subscription-and-notification","title":"3. Subscription and Notification","text":"<p>AFs or NFs may subscribe to binding change events, such as:</p> <ul> <li>PCF binding created</li> <li>PCF binding deleted</li> <li>First / last session for a DNN/S-NSSAI</li> <li>MBS binding changes</li> </ul> <p>This allows services to stay synchronized when PCF relocates or sessions end.</p>"},{"location":"blog/20251202/20251202/#4-example","title":"4. Example","text":"<p>In the scenario of voice call over new radio, after N7 interface (PDU session) is established, PCF registers this session (and the user's IP) with the BSF. The AF in this case, the IMS (IP Multimedia Subsystem) network, wants to set up a high-quality voice call.  To do this, it must request dedicated network resources (QoS) for the voice media. However, the IMS system only knows the subscriber's IP address, it does not know which of the many PCF instances in the 5G Core is actually controlling that subscriber's data connection. By sending queries to BSF, look up the correct PCF instance using the IP address, and ensuring the QoS policy is sent to the right place. <p>Source: 5G: Do we need a BSF? </p></p>"},{"location":"blog/20251202/20251202/#bsf-use-cases","title":"BSF Use Cases","text":""},{"location":"blog/20251202/20251202/#1-application-aware-qos-af-driven-policies","title":"1. Application-Aware QoS (AF-driven policies)","text":"<p>Cloud gaming, VR streaming, or enterprise UC systems require dynamic QoS updates. The AF must retrieve the correct PCF instance before sending a policy authorization request.</p> <p>BSF ensures:</p> <ul> <li>Requests always reach the correct PCF</li> <li>Policies apply to the intended UE</li> <li>Charging/QoS stays consistent</li> </ul> <p>Without BSF, the AF might send the request to a random PCF, which would reject it because it doesn't know that user. This is the most common BSF use case.</p>"},{"location":"blog/20251202/20251202/#2-slice-aware-policy-control","title":"2. Slice-Aware Policy Control","text":"<p>Each slice may use different PCFs. BSF enables:</p> <ul> <li>Slice-specific PCF binding</li> <li>AF requests routed to correct slice PCF</li> <li>Multi-slice UEs to maintain multiple independent PCF bindings</li> </ul> <p>This is critical for enterprise, URLLC, and industrial use cases.</p>"},{"location":"blog/20251202/20251202/#3-multi-access-and-session-diversity","title":"3. Multi-Access and Session Diversity","text":"<p>A UE may simultaneously use:</p> <ul> <li>3GPP access via gNB</li> <li>non-3GPP access via N3IWF</li> </ul> <p>Ex:</p> <pre><code>Session A (5G Radio) \u2192 IP 10.0.0.1 \u2192 PCF Instance X\nSession B (Wi-Fi) \u2192 IP 192.168.1.5 \u2192 PCF Instance Y\n</code></pre> <p>If an AF requests QoS for the Wi-Fi session, it provides the Wi-Fi IP. The BSF correctly points to PCF Instance Y, ensuring the policy is applied to the correct access path.</p>"},{"location":"blog/20251202/20251202/#conclusion","title":"Conclusion","text":"<p>The Binding Support Function (BSF) is a foundational component of the 5G Core policy architecture. It enables consistency in a distributed, cloud-native environment where PCFs scale dynamically and policy control must always be routed to the correct place.</p> <p>Key takeaways:</p> <ul> <li>BSF maintains three independent binding types: PCF-for-UE, PCF-for-PDU-session, PCF-for-MBS-session.</li> <li>It ensures AFs always reach the correct PCF instance, even in large-scale microservice deployments.</li> <li>It supports both NF instance and NF set bindings, enabling redundancy and load balancing.</li> <li>BSF prevents policy inconsistencies through SamePcf logic and strict binding-level rules.</li> <li>It plays a crucial role in slicing, QoS, SM/AM policy separation, and AF-driven service optimization.</li> </ul> <p>As 5G deployments become more complex and application-driven, the BSF\u2019s importance will only grow. Thus, understanding BSF is essential\u2014especially its interaction with PCF binding, which is at the heart of 5G Core policy control.</p>"},{"location":"blog/20251202/20251202/#reference","title":"Reference","text":"<ul> <li>TS 23.501</li> <li>TS 23.502</li> <li>TS 129 521 - V17.6.0 - 5G</li> <li>5G: Do we need a BSF? </li> </ul>"},{"location":"blog/20251202/20251202/#about-me","title":"About Me","text":"<p>Hi! I'm Chieh-Cheng Kuo, I've started the journey on learning 5G technology and engaging with the free5GC community recently. I hope you find this blog useful, and feel free to contact me if you want to discuss anything!</p>"},{"location":"blog/20251202/20251202/#connect-with-me","title":"Connect with Me","text":"<p>Github: Jasonkuo23</p>"},{"location":"blog/20251210/20251210/","title":"GTP5G Netlink Protocol Decoder: Implementation and Message Analysis","text":"<p>Note</p> <p>Author: CHEN, KUAN-LIN Date: 2025/12/10</p>"},{"location":"blog/20251210/20251210/#1-introduction","title":"1. Introduction","text":""},{"location":"blog/20251210/20251210/#11-overview","title":"1.1 Overview","text":"<p>When debugging or analyzing the free5GC User Plane Function (UPF), understanding the communication between userspace applications and the kernel's GTP5G module is essential. This article explains the implementation of a Python protocol analyzer that decodes Generic Netlink messages exchanged between the UPF and the gtp5g kernel module.</p> <p>The decoder intercepts <code>strace</code> output and translates raw hexadecimal data into human-readable GTP5G protocol information, enabling developers to observe PDR (Packet Detection Rule), FAR (Forwarding Action Rule), QER (QoS Enforcement Rule), and URR (Usage Reporting Rule) operations in real-time.</p>"},{"location":"blog/20251210/20251210/#12-understanding-netlink-communication","title":"1.2 Understanding Netlink Communication","text":"<p>Netlink is Linux's mechanism for kernel-userspace communication. Unlike traditional system calls that are synchronous and limited in data size, Netlink provides:</p> <ul> <li>Asynchronous message passing: Applications send requests and receive responses independently</li> <li>Multicast capabilities: Kernel can notify multiple processes of events</li> <li>Extensible protocol families: Each subsystem defines its own message types</li> </ul> <p>Generic Netlink (genetlink) extends this by providing a dynamic registration mechanism. Instead of hardcoding protocol numbers, kernel modules register a \"family name\" (e.g., <code>gtp5g</code>) and receive a dynamically assigned family ID at load time.</p> <p>For the GTP5G module, the message flow works as follows: </p>"},{"location":"blog/20251210/20251210/#13-why-not-just-use-strace","title":"1.3 Why Not Just Use strace?","text":"<p>While <code>strace</code> is an excellent tool for tracing system calls, it has significant limitations when analyzing GTP5G Netlink messages:</p>"},{"location":"blog/20251210/20251210/#limitations-of-raw-strace-output","title":"Limitations of Raw strace Output","text":"<ol> <li> <p>No Protocol Awareness: strace displays Netlink messages as raw hexadecimal bytes without understanding the GTP5G protocol semantics. You see <code>\\x05\\x00\\x00\\x00</code> instead of <code>Command: GTP5G_CMD_ADD_PDR</code>.</p> </li> <li> <p>Dynamic Family ID: Generic Netlink assigns family IDs dynamically at module load time. strace shows <code>type=gtp5g</code> but cannot correlate the numeric type with the actual protocol family or decode the command codes.</p> </li> <li> <p>Fragmented I/O Vectors: strace splits <code>sendmsg</code> data across multiple <code>iov_base</code> entries. The first entry shows a structured Netlink header, while subsequent entries contain raw hex - making manual correlation extremely difficult.</p> </li> <li> <p>No Attribute Interpretation: TLV (Type-Length-Value) attributes are displayed as hex dumps. Understanding that <code>\\x0c\\x00\\x07\\x00</code> means \"12-byte attribute of type SEID\" requires manual calculation.</p> </li> <li> <p>Context-Dependent Semantics: The same attribute type number has different meanings depending on the command (e.g., attribute 3 is <code>PRECEDENCE</code> for PDR but <code>APPLY_ACTION</code> for FAR). strace cannot provide this context.</p> </li> </ol>"},{"location":"blog/20251210/20251210/#example-raw-strace-vs-decoded-output","title":"Example: Raw strace vs. Decoded Output","text":"<p>Raw strace output: <pre><code>sendmsg(13, {msg_iov=[{iov_base={len=48, type=gtp5g, flags=NLM_F_REQUEST|NLM_F_ACK, \nseq=25, pid=0}, iov_len=16}, {iov_base=\"\\x05\\x00\\x00\\x00\", iov_len=4}, \n{iov_base=\"\\x0c\\x00\\x07\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", iov_len=12}], ...}, 0)\n</code></pre></p> <p>Decoded output from python program: <pre><code>=== GTP5G Message ===\nDirection: SEND\nCommand: GTP5G_CMD_ADD_PDR (5)\nAttributes:\n  - SEID: 1\n</code></pre></p>"},{"location":"blog/20251210/20251210/#2-architecture-overview","title":"2. Architecture Overview","text":""},{"location":"blog/20251210/20251210/#3-implementation-details","title":"3. Implementation Details","text":""},{"location":"blog/20251210/20251210/#31-generic-netlink-protocol-structure","title":"3.1 Generic Netlink Protocol Structure","text":"<p>The GTP5G module uses Generic Netlink (genetlink) for kernel-userspace communication. Each message follows this structure:</p> <p></p>"},{"location":"blog/20251210/20251210/#32-gtp5g-family-id-detection","title":"3.2 GTP5G Family ID Detection","text":"<p>Generic Netlink families are dynamically assigned IDs at module load time. The decoder must discover the correct family ID:</p> <pre><code>def get_gtp5g_family_id():\n    \"\"\"Get gtp5g Generic Netlink family ID using 'genl' command.\"\"\"\n    try:\n        result = subprocess.run(\n            [\"genl\", \"ctrl\", \"list\", \"name\", \"gtp5g\"], \n            capture_output=True, \n            text=True\n        )\n\n        if result.returncode != 0:\n            return None\n\n        lines = result.stdout.split('\\n')\n        found_name = False\n        for line in lines:\n            if \"Name: gtp5g\" in line:\n                found_name = True\n            elif found_name and \"ID:\" in line:\n                match = re.search(r'ID:\\s+(0x[0-9a-fA-F]+)', line)\n                if match:\n                    hex_id = match.group(1)\n                    fam_id = int(hex_id, 16)\n                    print(f\"[Init] Detected gtp5g Family ID: {fam_id} ({hex_id})\")\n                    return fam_id\n            if found_name and \"Name:\" in line:\n                break\n\n        # Fallback: try single-line pattern\n        match = re.search(r'Name:\\s+gtp5g\\s+ID:\\s+(0x[0-9a-fA-F]+)', result.stdout)\n        if match:\n            hex_id = match.group(1)\n            fam_id = int(hex_id, 16)\n            print(f\"[Init] Detected gtp5g Family ID: {fam_id} ({hex_id})\")\n            return fam_id\n\n    except FileNotFoundError:\n        print(\"[Init] Error: 'genl' command not found\")\n    except Exception as e:\n        print(f\"[Init] Warning: Could not detect gtp5g family: {e}\")\n\n    return None\n</code></pre> <p>This approach is more portable than using Python libraries like pyroute2, which may have version compatibility issues. The function handles multiple output formats from the <code>genl</code> command and provides graceful error handling.</p>"},{"location":"blog/20251210/20251210/#33-parsing-strace-output","title":"3.3 Parsing strace Output","text":"<p>Parsing strace output is the most challenging part of the decoder. The <code>strace</code> utility displays <code>sendmsg</code> calls in a complex format with multiple I/O vectors, and understanding this format is essential for correct decoding.</p>"},{"location":"blog/20251210/20251210/#the-strace-output-format","title":"The strace Output Format","text":"<p>When strace traces a <code>sendmsg</code> system call on a Netlink socket, it produces output like this:</p> <pre><code>sendmsg(13, {msg_name=..., msg_namelen=12, msg_iov=[\n    {iov_base={len=48, type=gtp5g, flags=NLM_F_REQUEST|NLM_F_ACK, seq=25, pid=0}, iov_len=16},\n    {iov_base=\"\\x05\\x00\\x00\\x00\", iov_len=4},\n    {iov_base=\"\\x0c\\x00\\x07\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", iov_len=12}\n], msg_iovlen=3, ...}, 0) = 48\n</code></pre> <p>Key observations:</p> <ol> <li> <p>First iov_base is structured: strace recognizes Netlink headers and displays them in a human-readable format <code>{len=48, type=gtp5g, flags=..., seq=25, pid=0}</code> instead of raw hex.</p> </li> <li> <p>Subsequent iov_base entries are hex: The Generic Netlink header (4 bytes) and attributes appear as escaped hex strings like <code>\"\\x05\\x00\\x00\\x00\"</code>.</p> </li> <li> <p>Multiple fragments: The message is split across multiple <code>iov_base</code> entries that must be concatenated.</p> </li> </ol>"},{"location":"blog/20251210/20251210/#step-1-detect-gtp5g-messages","title":"Step 1: Detect GTP5G Messages","text":"<p>First, we identify lines containing GTP5G Netlink messages:</p> <pre><code>def is_gtp5g_message(line):\n    \"\"\"Check if the line contains a GTP5G netlink message.\"\"\"\n    # Look for structured header with type=gtp5g\n    if 'type=gtp5g' in line:\n        return True\n    # Also check for the numeric family ID (e.g., type=0x1f)\n    if f'type=0x{gtp5g_family_id:x}' in line:\n        return True\n    return False\n</code></pre>"},{"location":"blog/20251210/20251210/#step-2-extract-the-netlink-header","title":"Step 2: Extract the Netlink Header","text":"<p>The structured header contains all fields of the 16-byte Netlink header. The decoder extracts these fields using regex pattern matching:</p> <pre><code># Extract Netlink message header fields from strace output\nheader_match = re.search(\n    r'iov_base=\\{len=(\\d+),\\s*type=([^,]+),\\s*flags=([^,]+),\\s*seq=(\\d+),\\s*pid=(\\d+)\\}',\n    line\n)\n\nif not header_match:\n    return\n\nmsg_len = int(header_match.group(1))       # Total message length\nmsg_type_str = header_match.group(2).strip()  # \"gtp5g\" or numeric\nflags_str = header_match.group(3).strip()     # \"NLM_F_REQUEST|NLM_F_ACK\"\nseq = int(header_match.group(4))              # Sequence number\npid = int(header_match.group(5))              # Port ID (usually 0)\n\n# Parse message type (Generic Netlink family ID)\nif 'gtp5g' in msg_type_str:\n    msg_type = CURRENT_GTP5G_FAMILY_ID if CURRENT_GTP5G_FAMILY_ID else 31\nelse:\n    type_match = re.search(r'0x([0-9a-fA-F]+)', msg_type_str)\n    msg_type = int(type_match.group(1), 16) if type_match else 0\n\n# Filter out non-gtp5g messages\nif CURRENT_GTP5G_FAMILY_ID and msg_type != CURRENT_GTP5G_FAMILY_ID:\n    return\n</code></pre>"},{"location":"blog/20251210/20251210/#step-3-parse-netlink-flags","title":"Step 3: Parse Netlink Flags","text":"<p>The flags field requires special handling to convert symbolic names to numeric values:</p> <pre><code># Parse Netlink message flags from strace symbolic output\nflags = 0\nif 'NLM_F_REQUEST' in flags_str:\n    flags |= 0x0001\nif 'NLM_F_ACK' in flags_str:\n    flags |= 0x0004\nif '0x200' in flags_str:\n    flags |= 0x0200\nif '0x100' in flags_str:\n    flags |= 0x0100\n</code></pre> <p>The decoder focuses on the most commonly used flags in GTP5G communication rather than maintaining a complete mapping.</p>"},{"location":"blog/20251210/20251210/#step-4-extract-hex-payloads","title":"Step 4: Extract Hex Payloads","text":"<p>The remaining iov_base entries contain raw hex data. The decoder handles multiple strace output formats:</p> <pre><code># Extract payload data from iov_base fields in order of appearance\n# strace may output iov data in different formats depending on content\niov_patterns = [\n    # Pattern 1: Simple hex string iov_base=\"\\x...\"\n    (r'iov_base=\"((?:\\\\x[0-9a-fA-F]{2})+)\"', 'hex'),\n    # Pattern 2: Nested structure where strace decoded first 16 bytes as nlmsghdr\n    # Format: iov_base={{len=N, type=X, flags=N, seq=N, pid=N}, \"\\x...\"}\n    (r'iov_base=\\{\\{len=(\\d+),\\s*type=([^,]+),\\s*flags=(\\d+),\\s*seq=(\\d+),\\s*pid=(\\d+)\\},\\s*\"((?:\\\\x[0-9a-fA-F]{2})+)\"\\}', 'nested_full'),\n    # Pattern 3: Standalone decoded nlmsghdr without trailing hex data\n    (r'iov_base=\\{len=(\\d+),\\s*type=([^,]+),\\s*flags=(\\d+),\\s*seq=(\\d+),\\s*pid=(\\d+)\\}(?!,\\s*\")', 'fake_header'),\n]\n\n# Collect all iov data segments with their positions\niov_items = []\n\nfor pattern, ptype in iov_patterns:\n    for match in re.finditer(pattern, line):\n        # Skip the real Netlink header (contains 'gtp5g' family name)\n        if ptype in ('fake_header', 'nested_full') and 'gtp5g' in match.group(0):\n            continue\n        iov_items.append((match.start(), ptype, match))\n\n# Sort by position to maintain correct byte order\niov_items.sort(key=lambda x: x[0])\n</code></pre> <p>This multi-pattern approach handles various strace output formats, including cases where strace partially decodes nested Netlink messages.</p>"},{"location":"blog/20251210/20251210/#step-5-combine-and-decode","title":"Step 5: Combine and Decode","text":"<p>Finally, assemble the payload from collected segments and parse:</p> <pre><code># Assemble payload from collected iov segments\npayload_bytes = b''\nfor pos, ptype, match in iov_items:\n    try:\n        if ptype == 'hex':\n            hex_str = match.group(1)\n            payload_bytes += bytes.fromhex(hex_str.replace('\\\\x', ''))\n        elif ptype == 'nested_full':\n            # Handle nested structure: rebuild the 16-byte header then append hex data\n            len_val = int(match.group(1))\n            type_str = match.group(2).strip()\n            flags_val = int(match.group(3))\n            seq_val = int(match.group(4))\n            pid_val = int(match.group(5))\n            hex_str = match.group(6)\n\n            # Parse type value from type_str (e.g., \"0x1f\" or numeric)\n            type_val = int(type_str, 0) if type_str.startswith('0x') else 0\n\n            # Rebuild 16-byte nlmsghdr structure\n            rebuilt = struct.pack(\"=I\", len_val)\n            rebuilt += struct.pack(\"=HH\", type_val, flags_val)\n            rebuilt += struct.pack(\"=I\", seq_val)\n            rebuilt += struct.pack(\"=I\", pid_val)\n            payload_bytes += rebuilt\n            payload_bytes += bytes.fromhex(hex_str.replace('\\\\x', ''))\n    except (ValueError, struct.error):\n        continue\n\nif len(payload_bytes) &lt; 4:\n    return\n\n# Parse Generic Netlink header (4 bytes: cmd, version, reserved)\ncmd, version, reserved = struct.unpack(\"=BBH\", payload_bytes[:4])\ncmd_str = GTP5G_CMDS.get(cmd, f\"UNKNOWN_CMD_{cmd}\")\n\n# Select attribute mapping based on command type\nattr_mappings = {\n    1: GTP5G_PDR_ATTRS, 4: GTP5G_PDR_ATTRS, 7: GTP5G_PDR_ATTRS,\n    2: GTP5G_FAR_ATTRS, 5: GTP5G_FAR_ATTRS, 8: GTP5G_FAR_ATTRS,\n    3: GTP5G_QER_ATTRS, 6: GTP5G_QER_ATTRS, 9: GTP5G_QER_ATTRS,\n    10: GTP5G_URR_ATTRS, 12: GTP5G_URR_ATTRS, 14: GTP5G_URR_ATTRS,\n    11: GTP5G_BAR_ATTRS, 13: GTP5G_BAR_ATTRS, 15: GTP5G_BAR_ATTRS,\n    17: GTP5G_URR_ATTRS,  # GET_REPORT uses URR attrs\n    19: GTP5G_MULTI_REPORT_ATTRS,\n    20: GTP5G_USAGE_STATISTIC_ATTRS,\n}\nattr_mapping = attr_mappings.get(cmd, GTP5G_COMMON_ATTRS)\n\n# Parse attributes from payload (skip 4-byte GenL header)\nattrs_data = payload_bytes[4:]\nattributes = parse_attributes(attrs_data, attr_mapping)\n</code></pre>"},{"location":"blog/20251210/20251210/#handling-edge-cases","title":"Handling Edge Cases","text":"<p>The parser must handle several edge cases:</p> <ol> <li>Multi-line output: strace may split long lines; accumulate until <code>) =</code> is seen</li> <li>Non-hex iov_base: Some entries may contain printable ASCII mixed with hex</li> <li>Truncated output: Use <code>-s 65535</code> with strace to avoid truncation</li> <li>Multiple messages: A single <code>sendmsg</code> may contain batched requests</li> </ol>"},{"location":"blog/20251210/20251210/#34-command-specific-attribute-mapping","title":"3.4 Command-Specific Attribute Mapping","text":"<p>A critical design decision is that attribute IDs are command-specific. The same attribute ID (e.g., 3) means different things for different commands:</p> Attribute ID PDR Command FAR Command QER Command URR Command 3 PDR_ID (U16) FAR_ID (U32) QER_ID (U32) URR_ID (U32) 4 PRECEDENCE APPLY_ACTION GATE MEASUREMENT_METHOD 5 PDI (nested) FORWARDING_PARAM MBR (nested) REPORTING_TRIGGER ... ... ... ... ... <p>The decoder selects the appropriate mapping based on the command:</p> <pre><code>cmd = genl_hdr['cmd']\nif cmd in [1, 4, 7]:    # ADD_PDR, DEL_PDR, GET_PDR\n    attr_mapping = GTP5G_PDR_ATTRS\nelif cmd in [2, 5, 8]:  # ADD_FAR, DEL_FAR, GET_FAR\n    attr_mapping = GTP5G_FAR_ATTRS\nelif cmd in [3, 6, 9]:  # ADD_QER, DEL_QER, GET_QER\n    attr_mapping = GTP5G_QER_ATTRS\n# ... and so on\n</code></pre>"},{"location":"blog/20251210/20251210/#35-attribute-value-decoding","title":"3.5 Attribute Value Decoding","text":"<p>Different attributes require different decoding strategies based on their data types:</p> <pre><code>def decode_value(attr_name, data):\n    \"\"\"Decode attribute value based on attribute name and data type.\n\n    Returns the decoded value (int, string, or IP address).\n    \"\"\"\n    try:\n        # IPv4 addresses (network byte order / big-endian)\n        if \"IPV4\" in attr_name or \"ADDR_IPV4\" in attr_name:\n            if len(data) &gt;= 4:\n                return f\"{data[0]}.{data[1]}.{data[2]}.{data[3]}\"\n\n        # SEID and timestamps (U64)\n        if \"SEID\" in attr_name or \"TIME\" in attr_name:\n            if len(data) &gt;= 8:\n                return struct.unpack(\"=Q\", data[:8])[0]\n\n        # U32 values (IDs, TEIDs, counters, etc.)\n        if attr_name in [\"GTP5G_LINK\", \"GTP5G_FAR_ID\", \"GTP5G_QER_ID\",\n                         \"GTP5G_PDR_FAR_ID\", \"GTP5G_PDR_QER_ID\", \"GTP5G_PDR_URR_ID\",\n                         \"GTP5G_URR_ID\", \"GTP5G_PDR_PRECEDENCE\", \"GTP5G_F_TEID_I_TEID\",\n                         \"GTP5G_OUTER_HEADER_CREATION_O_TEID\"]:\n            if len(data) &gt;= 4:\n                return struct.unpack(\"=I\", data[:4])[0]\n\n        # PDR_ID (U16)\n        if attr_name == \"GTP5G_PDR_ID\":\n            if len(data) &gt;= 2:\n                return struct.unpack(\"=H\", data[:2])[0]\n\n        # U16 values (ports, action flags)\n        if attr_name in [\"GTP5G_FAR_APPLY_ACTION\", \"GTP5G_OUTER_HEADER_CREATION_PORT\"]:\n            if len(data) &gt;= 2:\n                return struct.unpack(\"=H\", data[:2])[0]\n\n        # U8 values (flags, QFI, gate status)\n        if attr_name in [\"GTP5G_PDI_SRC_INTF\", \"GTP5G_QER_GATE\",\n                         \"GTP5G_QER_QFI\", \"GTP5G_OUTER_HEADER_REMOVAL\"]:\n            if len(data) &gt;= 1:\n                return struct.unpack(\"=B\", data[:1])[0]\n\n        # String values (paths, policies)\n        if attr_name in [\"GTP5G_PDR_UNIX_SOCKET_PATH\",\n                         \"GTP5G_FORWARDING_PARAMETER_FORWARDING_POLICY\"]:\n            return data.decode('utf-8', errors='ignore').rstrip('\\x00')\n\n    except Exception:\n        pass\n\n    # Fallback: return hex string for unknown types\n    return \"0x\" + data.hex() if data else \"(empty)\"\n</code></pre> <p>The decoder handles various data types including U8, U16, U32, U64, IPv4 addresses, and strings. Nested structures are handled separately in <code>parse_attributes</code> using the <code>nested_mappings</code> dictionary.</p>"},{"location":"blog/20251210/20251210/#36-nested-attribute-handling","title":"3.6 Nested Attribute Handling","text":"<p>GTP5G uses nested attributes for complex structures like PDI (Packet Detection Information):</p> <pre><code>GTP5G_PDR_PDI (nested)\n\u251c\u2500\u2500 GTP5G_PDI_UE_ADDR_IPV4 (IPv4)\n\u251c\u2500\u2500 GTP5G_PDI_F_TEID (nested)\n\u2502   \u251c\u2500\u2500 GTP5G_F_TEID_I_TEID (U32)\n\u2502   \u2514\u2500\u2500 GTP5G_F_TEID_GTPU_ADDR_IPV4 (IPv4)\n\u251c\u2500\u2500 GTP5G_PDI_SDF_FILTER (nested)\n\u2502   \u251c\u2500\u2500 GTP5G_SDF_FILTER_FLOW_DESCRIPTION (nested or string)\n\u2502   \u2514\u2500\u2500 GTP5G_SDF_FILTER_SDF_FILTER_ID (U32)\n\u2514\u2500\u2500 GTP5G_PDI_SRC_INTF (U8)\n</code></pre> <p>The decoder maintains a mapping of nested attribute types to their sub-mappings:</p> <pre><code># Nested attribute type to sub-mapping lookup\nnested_mappings = {\n    \"GTP5G_PDR_PDI\": GTP5G_PDI_ATTRS,\n    \"GTP5G_PDI_F_TEID\": GTP5G_F_TEID_ATTRS,\n    \"GTP5G_PDI_SDF_FILTER\": GTP5G_SDF_FILTER_ATTRS,\n    \"GTP5G_SDF_FILTER_FLOW_DESCRIPTION\": GTP5G_FLOW_DESCRIPTION_ATTRS,\n    \"GTP5G_FAR_FORWARDING_PARAMETER\": GTP5G_FAR_FP_ATTRS,\n    \"GTP5G_FORWARDING_PARAMETER_OUTER_HEADER_CREATION\": GTP5G_OHC_ATTRS,\n    \"GTP5G_QER_MBR\": GTP5G_QER_MBR_ATTRS,\n    \"GTP5G_QER_GBR\": GTP5G_QER_GBR_ATTRS,\n    \"GTP5G_URR_VOLUME_THRESHOLD\": GTP5G_URR_VOLUME_THRESHOLD_ATTRS,\n    \"GTP5G_URR_VOLUME_QUOTA\": GTP5G_URR_VOLUME_QUOTA_ATTRS,\n    \"GTP5G_UR_VOLUME_MEASUREMENT\": GTP5G_UR_VOLUME_MEASUREMENT_ATTRS,\n    \"GTP5G_UR\": GTP5G_REPORT_ATTRS,\n    \"GTP5G_URR_MULTI_SEID_URRID\": GTP5G_URR_MULTI_SEID_URRID_ATTRS,\n}\n</code></pre> <p>When a known nested attribute is encountered, the parser recursively processes its contents with the appropriate sub-mapping.</p>"},{"location":"blog/20251210/20251210/#the-parse_attributes-implementation","title":"The <code>parse_attributes</code> Implementation","text":"<p>The core of TLV parsing is the <code>parse_attributes</code> function. It iterates through the raw bytes, extracting each attribute's length, type, and value while respecting 4-byte alignment:</p> <pre><code>def parse_attributes(data, mapping):\n    \"\"\"Parse Netlink attributes from binary data.\n\n    Args:\n        data: Raw bytes containing Netlink attributes\n        mapping: Dictionary mapping attribute type IDs to names\n\n    Returns:\n        Dictionary of parsed attributes with decoded values\n    \"\"\"\n    attrs = {}\n    offset = 0\n    length = len(data)\n\n    # Nested attribute type to sub-mapping lookup\n    nested_mappings = {\n        \"GTP5G_PDR_PDI\": GTP5G_PDI_ATTRS,\n        \"GTP5G_PDI_F_TEID\": GTP5G_F_TEID_ATTRS,\n        \"GTP5G_PDI_SDF_FILTER\": GTP5G_SDF_FILTER_ATTRS,\n        \"GTP5G_SDF_FILTER_FLOW_DESCRIPTION\": GTP5G_FLOW_DESCRIPTION_ATTRS,\n        \"GTP5G_FAR_FORWARDING_PARAMETER\": GTP5G_FAR_FP_ATTRS,\n        \"GTP5G_FORWARDING_PARAMETER_OUTER_HEADER_CREATION\": GTP5G_OHC_ATTRS,\n        \"GTP5G_QER_MBR\": GTP5G_QER_MBR_ATTRS,\n        \"GTP5G_QER_GBR\": GTP5G_QER_GBR_ATTRS,\n        \"GTP5G_URR_VOLUME_THRESHOLD\": GTP5G_URR_VOLUME_THRESHOLD_ATTRS,\n        \"GTP5G_URR_VOLUME_QUOTA\": GTP5G_URR_VOLUME_QUOTA_ATTRS,\n        \"GTP5G_UR_VOLUME_MEASUREMENT\": GTP5G_UR_VOLUME_MEASUREMENT_ATTRS,\n        \"GTP5G_UR\": GTP5G_REPORT_ATTRS,\n        \"GTP5G_URR_MULTI_SEID_URRID\": GTP5G_URR_MULTI_SEID_URRID_ATTRS,\n    }\n\n    while offset &lt; length:\n        # Need at least 4 bytes for NLA header (len + type)\n        if length - offset &lt; 4:\n            break\n\n        nla_len, nla_type = struct.unpack(\"=HH\", data[offset:offset+4])\n\n        # Skip invalid attributes\n        if nla_len == 0:\n            offset += 4\n            continue\n        if nla_len &lt; 4 or nla_len &gt; length - offset:\n            break\n\n        # Extract type ID (mask out NLA_F_NESTED and NLA_F_NET_BYTEORDER flags)\n        type_id = nla_type &amp; 0x3FFF\n        attr_name = mapping.get(type_id, f\"UNKNOWN_ATTR_{type_id}\")\n\n        # Type 0 is a container: expand its contents with same mapping\n        if type_id == 0:\n            container_data = data[offset+4:offset+nla_len]\n            nested_attrs = parse_attributes(container_data, mapping)\n            attrs.update(nested_attrs)\n            aligned_len = (nla_len + 3) &amp; ~3\n            offset += aligned_len\n            continue\n\n        # Known nested attributes: recursively parse with appropriate sub-mapping\n        if attr_name in nested_mappings:\n            nested_data = data[offset+4:offset+nla_len]\n            sub_mapping = nested_mappings[attr_name]\n            nested_attrs = parse_attributes(nested_data, sub_mapping)\n            attrs[attr_name] = nested_attrs\n            aligned_len = (nla_len + 3) &amp; ~3\n            offset += aligned_len\n            continue\n\n        # Regular attribute: decode value based on type\n        val_data = data[offset+4:offset+nla_len]\n        attrs[attr_name] = decode_value(attr_name, val_data)\n\n        aligned_len = (nla_len + 3) &amp; ~3\n        offset += aligned_len\n\n    return attrs\n</code></pre> <p>Key insights</p> <ol> <li> <p>4-Byte Alignment: Netlink requires all attributes to be aligned on 4-byte boundaries. The formula <code>(nla_len + 3) &amp; ~3</code> rounds up to the next multiple of 4.</p> </li> <li> <p>NLA Flag Masking: The type field may contain flags (<code>NLA_F_NESTED = 0x8000</code>, <code>NLA_F_NET_BYTEORDER = 0x4000</code>). We mask with <code>0x3FFF</code> to get the actual type ID.</p> </li> <li> <p>Container Handling: Type 0 acts as a container that groups related attributes. Its contents are expanded into the parent dictionary.</p> </li> <li> <p>Recursive Parsing: When an attribute is in <code>nested_mappings</code>, the function calls itself recursively with the appropriate sub-mapping.</p> </li> <li> <p>Graceful Degradation: Unknown attribute types are labeled as <code>UNKNOWN_ATTR_N</code> rather than causing parse failures, allowing partial decoding of messages with new or unsupported attributes.</p> </li> </ol>"},{"location":"blog/20251210/20251210/#4-command-reference","title":"4. Command Reference","text":"<p>Based on the gtp5g kernel module source (<code>include/genl.h</code>):</p> Command ID Name Description 1 CMD_ADD_PDR Create Packet Detection Rule 2 CMD_ADD_FAR Create Forwarding Action Rule 3 CMD_ADD_QER Create QoS Enforcement Rule 4 CMD_DEL_PDR Delete PDR 5 CMD_DEL_FAR Delete FAR 6 CMD_DEL_QER Delete QER 7 CMD_GET_PDR Query PDR 8 CMD_GET_FAR Query FAR 9 CMD_GET_QER Query QER 10 CMD_ADD_URR Create Usage Reporting Rule 11 CMD_ADD_BAR Create Buffering Action Rule 12 CMD_DEL_URR Delete URR 13 CMD_DEL_BAR Delete BAR 14 CMD_GET_URR Query URR 15 CMD_GET_BAR Query BAR 16 CMD_GET_VERSION Get module version 17 CMD_GET_REPORT Get usage report 18 CMD_BUFFER_GTPU Buffer GTP-U packets 19 CMD_GET_MULTI_REPORTS Batch get reports 20 CMD_GET_USAGE_STATISTIC Get statistics"},{"location":"blog/20251210/20251210/#5-analyzing-common-gtp5g-messages","title":"5. Analyzing Common GTP5G Messages","text":"<p>This section walks through real-world GTP5G messages captured during a UERANSIM UE registration and PDU session establishment. Understanding these message patterns helps debug 5G core network issues.</p>"},{"location":"blog/20251210/20251210/#51-message-flow-overview","title":"5.1 Message Flow Overview","text":"<p>When a UE connects and establishes a PDU session, the SMF instructs the UPF to create the following rules. The typical creation sequence is:</p> <ol> <li>Create FAR (Forwarding Action Rule) - defines how to forward packets</li> <li>Create QER (QoS Enforcement Rule) - defines QoS parameters  </li> <li>Create URR (Usage Reporting Rule) - defines usage reporting</li> <li>Create PDR (Packet Detection Rule) - defines which packets to match and references FAR/QER/URR</li> </ol> <p>Note: PDRs are created last because they reference the other rules by ID.</p>"},{"location":"blog/20251210/20251210/#52-creating-a-far-forwarding-action-rule","title":"5.2 Creating a FAR (Forwarding Action Rule)","text":"<p>Decoded Output: <pre><code>------------------------------------------------------------\nGTP5G MESSAGE\nLen: 56, FamilyID: 31, Seq: 84\nCommand: GTP5G_CMD_ADD_FAR (v0)\nAttributes:\n  GTP5G_LINK: 4\n  GTP5G_FAR_ID: 9\n  GTP5G_FAR_SEID: 1\n  GTP5G_FAR_APPLY_ACTION: 2\n------------------------------------------------------------\n</code></pre></p> <p>Analysis:</p> <ul> <li>Command: <code>GTP5G_CMD_ADD_FAR</code> (command ID 2) - Creates a new Forwarding Action Rule</li> <li>LINK: <code>4</code> - Network interface index (the gtp5g tunnel device, e.g., <code>upfgtp</code>)</li> <li>FAR_ID: <code>9</code> - Unique identifier for this FAR within the session</li> <li>SEID: <code>1</code> - Session Endpoint Identifier linking this rule to a PFCP session</li> <li> <p>APPLY_ACTION: <code>2</code> - Bitmask defining the action:</p> <ul> <li>Bit 0 (0x01): DROP</li> <li>Bit 1 (0x02): FORW (Forward) \u2190 This FAR forwards packets</li> <li>Bit 2 (0x04): BUFF (Buffer)</li> <li>Bit 3 (0x08): NOCP (Notify CP)</li> <li>Bit 4 (0x10): DUPL (Duplicate)</li> </ul> </li> </ul>"},{"location":"blog/20251210/20251210/#53-creating-a-pdr-packet-detection-rule","title":"5.3 Creating a PDR (Packet Detection Rule)","text":"<p>PDRs define which packets to match and what actions to apply. Modern PDRs often include SDF (Service Data Flow) filters for fine-grained traffic classification.</p> <p>Decoded Output (Uplink PDR with SDF Filter): <pre><code>------------------------------------------------------------\nGTP5G MESSAGE\nLen: 264, FamilyID: 31, Seq: 95\nCommand: GTP5G_CMD_ADD_PDR (v0)\nAttributes:\n  GTP5G_LINK: 4\n  GTP5G_PDR_ID: 9\n  GTP5G_PDR_SEID: 1\n  GTP5G_PDR_PRECEDENCE: 128\n  GTP5G_PDR_PDI:\n    GTP5G_PDI_SRC_INTF: 0\n    GTP5G_PDI_F_TEID:\n      GTP5G_F_TEID_I_TEID: 6\n      GTP5G_F_TEID_GTPU_ADDR_IPV4: 192.168.11.130\n    GTP5G_PDI_UE_ADDR_IPV4: 10.60.0.100\n    GTP5G_PDI_SDF_FILTER:\n      GTP5G_SDF_FILTER_FLOW_DESCRIPTION:\n        GTP5G_FLOW_DESCRIPTION_ACTION: 1\n        GTP5G_FLOW_DESCRIPTION_DIRECTION: 2\n        GTP5G_FLOW_DESCRIPTION_PROTOCOL: 255\n        GTP5G_FLOW_DESCRIPTION_SRC_IPV4: 0.0.0.0\n        GTP5G_FLOW_DESCRIPTION_SRC_MASK: 0.0.0.0\n        GTP5G_FLOW_DESCRIPTION_DEST_IPV4: 1.1.1.1\n        GTP5G_FLOW_DESCRIPTION_DEST_MASK: 255.255.255.255\n        GTP5G_FLOW_DESCRIPTION_SRC_PORT: (none)\n        GTP5G_FLOW_DESCRIPTION_DEST_PORT: (none)\n  GTP5G_OUTER_HEADER_REMOVAL: 0\n  GTP5G_PDR_FAR_ID: 9\n  GTP5G_PDR_URR_ID: 8\n  GTP5G_PDR_QER_ID: 8\n  GTP5G_PDR_UNIX_SOCKET_PATH: /\n------------------------------------------------------------\n</code></pre></p> <p>Analysis:</p> <ul> <li>Command: <code>GTP5G_CMD_ADD_PDR</code> (command ID 1) - Creates a Packet Detection Rule</li> <li>PDR_ID: <code>9</code> - Unique identifier for this PDR</li> <li>PRECEDENCE: <code>128</code> - Priority (lower = higher priority). When multiple PDRs match, the one with lowest precedence wins</li> <li>PDI (Packet Detection Information): Nested structure defining match criteria:<ul> <li>SRC_INTF: <code>0</code> - Source interface (0=Access/N3, indicating uplink traffic)</li> <li>F_TEID: Fully-qualified Tunnel Endpoint ID:<ul> <li>I_TEID: <code>6</code> - Local TEID allocated by UPF</li> <li>GTPU_ADDR_IPV4: <code>192.168.11.130</code> - UPF's N3 interface IP</li> </ul> </li> <li>UE_ADDR_IPV4: <code>10.60.0.100</code> - Match packets from this UE IP</li> <li>SDF_FILTER: Service Data Flow filter for traffic classification:<ul> <li>FLOW_DESCRIPTION: Defines the IP flow to match:</li> <li>ACTION: <code>1</code> (permit)</li> <li>DIRECTION: <code>2</code> (bidirectional)</li> <li>PROTOCOL: <code>255</code> (any protocol)</li> <li>DEST_IPV4/MASK: <code>1.1.1.1/255.255.255.255</code> - Match traffic to specific destination</li> </ul> </li> </ul> </li> <li>OUTER_HEADER_REMOVAL: <code>0</code> - Remove GTP-U header (for uplink traffic)</li> <li>FAR_ID: <code>9</code> - References the FAR to execute when this PDR matches</li> <li>URR_ID: <code>8</code> - References the Usage Reporting Rule for traffic accounting</li> <li>QER_ID: <code>8</code> - References the QoS Enforcement Rule</li> </ul>"},{"location":"blog/20251210/20251210/#54-creating-a-qer-qos-enforcement-rule","title":"5.4 Creating a QER (QoS Enforcement Rule)","text":"<p>QERs define QoS parameters including gate status, QoS Flow Identifier (QFI), and Maximum Bit Rate (MBR) limits.</p> <p>Decoded Output (QER with MBR): <pre><code>------------------------------------------------------------\nGTP5G MESSAGE\nLen: 100, FamilyID: 31, Seq: 88\nCommand: GTP5G_CMD_ADD_QER (v0)\nAttributes:\n  GTP5G_LINK: 4\n  GTP5G_QER_ID: 7\n  GTP5G_QER_SEID: 1\n  GTP5G_QER_GATE: 0\n  GTP5G_QER_MBR:\n    GTP5G_QER_MBR_UL_HIGH32: 3906\n    GTP5G_QER_MBR_UL_LOW8: 64\n    GTP5G_QER_MBR_DL_HIGH32: 3906\n    GTP5G_QER_MBR_DL_LOW8: 64\n  GTP5G_QER_QFI: 1\n------------------------------------------------------------\n</code></pre></p> <p>Analysis:</p> <ul> <li>Command: <code>GTP5G_CMD_ADD_QER</code> (command ID 3) - Creates a QoS Enforcement Rule</li> <li>QER_ID: <code>7</code> - Unique identifier for this QER</li> <li>GATE: <code>0</code> - Gate status (0=OPEN, allowing traffic to pass; 1=CLOSED)</li> <li>MBR (Maximum Bit Rate): Nested structure defining rate limits:<ul> <li>UL_HIGH32/LOW8: Uplink rate = <code>(3906 &lt;&lt; 8) | 64</code> = 999,488 kbps \u2248 1 Gbps</li> <li>DL_HIGH32/LOW8: Downlink rate = <code>(3906 &lt;&lt; 8) | 64</code> = 999,488 kbps \u2248 1 Gbps</li> <li>The bit rate is encoded as a 40-bit value split across HIGH32 and LOW8 fields</li> </ul> </li> <li>QFI: <code>1</code> - QoS Flow Identifier (values 1-63 map to different 5QI classes)</li> <li>SEID: <code>1</code> - Links to the PFCP session</li> </ul> <p>Decoded Output (Simple QER without MBR): <pre><code>------------------------------------------------------------\nGTP5G MESSAGE\nLen: 64, FamilyID: 31, Seq: 90\nCommand: GTP5G_CMD_ADD_QER (v0)\nAttributes:\n  GTP5G_LINK: 4\n  GTP5G_QER_ID: 9\n  GTP5G_QER_SEID: 1\n  GTP5G_QER_GATE: 0\n  GTP5G_QER_QFI: 1\n------------------------------------------------------------\n</code></pre></p> <p>This simpler QER only sets the gate status and QFI without rate limiting.</p>"},{"location":"blog/20251210/20251210/#55-deleting-rules-session-teardown","title":"5.5 Deleting Rules (Session Teardown)","text":"<p>When a PDU session ends or rules are updated, the UPF removes associated rules. The deletion sequence typically follows: FAR \u2192 QER \u2192 URR \u2192 PDR.</p> <p>Decoded Output: <pre><code>------------------------------------------------------------\nGTP5G MESSAGE\nLen: 48, FamilyID: 31, Seq: 65\nCommand: GTP5G_CMD_DEL_FAR (v0)\nAttributes:\n  GTP5G_LINK: 4\n  GTP5G_FAR_ID: 5\n  GTP5G_FAR_SEID: 1\n------------------------------------------------------------\nGTP5G MESSAGE\nLen: 48, FamilyID: 31, Seq: 69\nCommand: GTP5G_CMD_DEL_QER (v0)\nAttributes:\n  GTP5G_LINK: 4\n  GTP5G_QER_ID: 5\n  GTP5G_QER_SEID: 1\n------------------------------------------------------------\nGTP5G MESSAGE\nLen: 48, FamilyID: 31, Seq: 72\nCommand: GTP5G_CMD_DEL_URR (v0)\nAttributes:\n  GTP5G_LINK: 4\n  GTP5G_URR_ID: 8\n  GTP5G_URR_SEID: 1\n------------------------------------------------------------\nGTP5G MESSAGE\nLen: 48, FamilyID: 31, Seq: 76\nCommand: GTP5G_CMD_DEL_PDR (v0)\nAttributes:\n  GTP5G_LINK: 4\n  GTP5G_PDR_ID: 7\n  GTP5G_PDR_SEID: 1\n------------------------------------------------------------\n</code></pre></p> <p>Analysis:</p> <ul> <li>Delete commands identify specific rules by their ID and SEID</li> <li>FAR deletion: Removes forwarding rule FAR_ID=5 from session SEID=1</li> <li>QER deletion: Removes QoS rule QER_ID=5</li> <li>URR deletion: Removes usage reporting rule URR_ID=8</li> <li>PDR deletion: Removes packet detection rule PDR_ID=7</li> <li>The sequence matters: forwarding rules should be deleted before detection rules to prevent packet loss</li> </ul>"},{"location":"blog/20251210/20251210/#56-uplink-vs-downlink-pdr-patterns","title":"5.6 Uplink vs Downlink PDR Patterns","text":"<p>Uplink PDR (N3 \u2192 N6, packets from UE to internet): <pre><code>GTP5G_PDR_PDI:\n  GTP5G_PDI_SRC_INTF: 0              # Source = Access (N3)\n  GTP5G_PDI_F_TEID:                  # Match on incoming GTP-U tunnel\n    GTP5G_F_TEID_I_TEID: 6\n    GTP5G_F_TEID_GTPU_ADDR_IPV4: 192.168.11.130\n  GTP5G_PDI_UE_ADDR_IPV4: 10.60.0.100\nGTP5G_OUTER_HEADER_REMOVAL: 0        # Remove GTP-U header\n</code></pre></p> <p>Downlink PDR (N6 \u2192 N3, packets from internet to UE): <pre><code>GTP5G_PDR_PDI:\n  GTP5G_PDI_SRC_INTF: 1              # Source = Core (N6)\n  GTP5G_PDI_UE_ADDR_IPV4: 10.60.0.100  # Match on UE destination IP\n  GTP5G_PDI_SDF_FILTER:              # Optional: filter specific traffic\n    GTP5G_SDF_FILTER_FLOW_DESCRIPTION:\n      GTP5G_FLOW_DESCRIPTION_SRC_IPV4: 1.1.1.1\n      GTP5G_FLOW_DESCRIPTION_SRC_MASK: 255.255.255.255\n# No OUTER_HEADER_REMOVAL (FAR will add GTP-U header)\n</code></pre></p> <p>The key differences:</p> <ul> <li>Uplink uses <code>SRC_INTF: 0</code> (Access) and includes <code>F_TEID</code> for tunnel matching</li> <li>Downlink uses <code>SRC_INTF: 1</code> (Core) and matches on <code>UE_ADDR_IPV4</code></li> <li>Uplink includes <code>OUTER_HEADER_REMOVAL</code> to decapsulate GTP-U</li> <li>Downlink FAR will include <code>OUTER_HEADER_CREATION</code> for encapsulation</li> </ul>"},{"location":"blog/20251210/20251210/#57-far-with-forwarding-parameters-gtp-u-encapsulation","title":"5.7 FAR with Forwarding Parameters (GTP-U Encapsulation)","text":"<p>For downlink traffic, the FAR includes GTP-U encapsulation parameters:</p> <p>Decoded Output: <pre><code>------------------------------------------------------------\nGTP5G MESSAGE\nLen: 96, FamilyID: 31, Seq: 156\nCommand: GTP5G_CMD_ADD_FAR (v0)\nAttributes:\n  GTP5G_LINK: 4\n  GTP5G_FAR_ID: 2\n  GTP5G_FAR_SEID: 1\n  GTP5G_FAR_APPLY_ACTION: 2\n  GTP5G_FAR_FORWARDING_PARAMETER:\n    GTP5G_FORWARDING_PARAMETER_OUTER_HEADER_CREATION:\n      GTP5G_OUTER_HEADER_CREATION_O_TEID: 1\n      GTP5G_OUTER_HEADER_CREATION_PEER_ADDR_IPV4: 10.200.200.1\n------------------------------------------------------------\n</code></pre></p> <p>Analysis:</p> <ul> <li>FORWARDING_PARAMETER: Nested structure for packet encapsulation</li> <li>OUTER_HEADER_CREATION: Defines GTP-U tunnel parameters for outgoing packets:<ul> <li>O_TEID: <code>1</code> - Outgoing TEID assigned by the gNB</li> <li>PEER_ADDR_IPV4: <code>10.200.200.1</code> - gNB's N3 interface IP address</li> </ul> </li> </ul>"},{"location":"blog/20251210/20251210/#58-usage-reporting-get_report","title":"5.8 Usage Reporting (GET_REPORT)","text":"<p>The UPF can query usage reports from URRs to collect traffic statistics:</p> <p>Decoded Output: <pre><code>------------------------------------------------------------\nGTP5G MESSAGE\nLen: 48, FamilyID: 31, Seq: 78\nCommand: GTP5G_CMD_GET_REPORT (v0)\nAttributes:\n  GTP5G_LINK: 4\n  GTP5G_URR_ID: 8\n  GTP5G_URR_SEID: 1\n------------------------------------------------------------\nGTP5G MESSAGE\nLen: 48, FamilyID: 31, Seq: 81\nCommand: GTP5G_CMD_GET_REPORT (v0)\nAttributes:\n  GTP5G_LINK: 4\n  GTP5G_URR_ID: 7\n  GTP5G_URR_SEID: 1\n------------------------------------------------------------\n</code></pre></p> <p>Analysis:</p> <ul> <li>Command: <code>GTP5G_CMD_GET_REPORT</code> (command ID 17) - Queries usage statistics</li> <li>URR_ID: Identifies which Usage Reporting Rule to query</li> <li>SEID: Session Endpoint Identifier</li> <li>The kernel module responds with volume measurements (bytes/packets sent/received)</li> <li>GET_REPORT is typically called before deleting URRs to collect final statistics</li> </ul>"},{"location":"blog/20251210/20251210/#59-querying-existing-rules-get_far","title":"5.9 Querying Existing Rules (GET_FAR)","text":"<p>The UPF can query existing rules to verify their state:</p> <p>Decoded Output: <pre><code>------------------------------------------------------------\nGTP5G MESSAGE\nLen: 48, FamilyID: 31, Seq: 99\nCommand: GTP5G_CMD_GET_FAR (v0)\nAttributes:\n  GTP5G_LINK: 4\n  GTP5G_FAR_ID: 10\n  GTP5G_FAR_SEID: 1\n------------------------------------------------------------\n</code></pre></p> <p>Analysis:</p> <ul> <li>Command: <code>GTP5G_CMD_GET_FAR</code> (command ID 8) - Queries an existing FAR</li> <li>This is often used to check if a FAR exists before updating or to verify rule installation</li> <li>Similar GET commands exist for PDR, QER, URR, and BAR</li> </ul>"},{"location":"blog/20251210/20251210/#510-common-debugging-scenarios","title":"5.10 Common Debugging Scenarios","text":"Symptom What to Check UE cannot reach internet Check uplink PDR exists with correct F_TEID and SRC_INTF=0 Internet cannot reach UE Check downlink PDR exists with UE_ADDR_IPV4 and SRC_INTF=1 Packets dropped silently Verify FAR APPLY_ACTION is FORW (0x02), not DROP (0x01) Wrong destination Check FAR OUTER_HDR_CREATION has correct O_TEID and PEER_ADDR QoS not applied Verify QER exists, check GATE=0 (OPEN), and PDR has correct QER_ID Rate limiting not working Check QER MBR values (UL_HIGH32/LOW8, DL_HIGH32/LOW8) Traffic not matching PDR Verify SDF_FILTER FLOW_DESCRIPTION matches expected traffic pattern Usage stats missing Ensure URR exists and PDR references correct URR_ID Session cleanup issues Ensure DEL commands include correct ID and SEID Rule update failures Use GET commands to verify rule state before modification"},{"location":"blog/20251210/20251210/#6-conclusion","title":"6. Conclusion","text":"<p>This deep dive into GTP5G Netlink message decoding illustrates how to bridge the gap between low-level kernel communication and high-level protocol understanding. By leveraging <code>strace</code> output and a custom decoder, developers can gain real-time insights into the 5G User Plane's behavior.</p> <p>From a protocol analysis perspective, Generic Netlink provides a structured, extensible mechanism for kernel-userspace IPC. The key insight is that Netlink is essentially a message-passing system with typed payloads. Once you understand the 16-byte header structure and 4-byte aligned TLV attributes, any Netlink-based protocol becomes parseable.</p> <p>For GTP5G specifically, the message flow reveals how the 5G User Plane operates: the SMF orchestrates session rules via PFCP, which the UPF translates into kernel-level PDR/FAR/QER rules through Netlink. By intercepting these messages, we gain visibility into the exact packet matching and forwarding logic installed in the data plane. This visibility is invaluable for understanding and debugging complex 5G core network issues.</p> <p>References</p> <ul> <li>free5GC Project</li> <li>gtp5g Kernel Module</li> <li>Linux Generic Netlink HOWTO</li> <li>3GPP TS 29.244 - PFCP Protocol</li> <li>Linux Netlink Manual</li> </ul> <p>About Me</p> <p>My name is Chen, Kuan-Lin. I've recently started diving into the world of 5G Core Networks and contributing to the free5GC project. My future research direction is focused on Network Slicing. I hope this article was helpful to you! If you have any questions or just want to chat about this topic, feel free to reach out and connect with our lab team.</p> <ul> <li>GitHub: DBGR18</li> </ul>"},{"location":"blog/20251224/20251224/","title":"Tracing the latency of the 5G Registration Procedure with eBPF","text":"<p>Note</p> <p>Author: Chia-Hui, Chen Date: 2025/12/24</p>"},{"location":"blog/20251224/20251224/#overview","title":"Overview","text":"<p>In modern cloud-native architectures, system complexity has reached unprecedented levels. When performance bottlenecks occur in high-performance, high-concurrency systems, developers need tools that can reach deep into the system's lower layers to pinpoint the exact sources of latency. This is where eBPF (extended Berkeley Packet Filter) comes into play.</p>"},{"location":"blog/20251224/20251224/#why-ebpf","title":"Why eBPF?","text":"<p>eBPF allows us to dynamically inject \"probes\" into both the kernel and user space without modifying the target program's source code or performing a recompilation. For many debugging and optimization scenarios, eBPF serves as an excellent diagnostic tool, offering the following core advantages:</p> <ul> <li> <p>Non-intrusive Observation     It transparently collects performance data without interfering with the business logic. This means we can perform deep-dive analysis directly in a production environment without worrying about modifying code.</p> </li> <li> <p>A Bridge Between Kernel and User      It doesn't just track user-space function calls via Uprobes; it simultaneously monitors Kprobes (kernel probes) and scheduling events. This cross-layer observability allows for \"complete\" monitoring of a function's lifecycle \u2014 capturing not only its active execution time but also any instances where it was descheduled or blocked by the kernel.</p> </li> </ul> <p>In this article, we will apply these eBPF capabilities to a real-world high-concurrency scenario: Tracing the latency of the 5G Registration Procedure. By monitoring key functions within the 5G Registration Procedure in free5GC, we will demonstrate how to pinpoint bottlenecks that traditional tools miss, providing a transparent view of a 5G NAS message's journey through the Go runtime.</p>"},{"location":"blog/20251224/20251224/#background","title":"Background","text":"<p>Before diving into performance bottleneck analysis, we must understand two key technical areas: how eBPF enables tracing and how Go\u2019s low-level design makes this task exceptionally challenging.</p>"},{"location":"blog/20251224/20251224/#ebpf-and-the-mechanics-of-uprobes","title":"eBPF and the Mechanics of Uprobes","text":"<p>eBPF is a Linux kernel technology that allows us to execute custom programs within a sandboxed environment inside the kernel without modifying the kernel source code. Through Uprobes (User-level Probes), we can attach directly to specific memory addresses within a binary. When the program reaches that point, the eBPF program is triggered to collect register and memory information. This allows us to observe the internal state of a program without modifying its source code and with minimal overhead.</p>"},{"location":"blog/20251224/20251224/#challenges-in-tracing-go-applications","title":"Challenges in Tracing Go Applications","text":"<ol> <li> <p>ABIInternal: The Hidden Register Trap</p> <p>Since Go 1.17, Go has utilized a Register-based Calling Convention (ABIInternal). Unlike the standard C ABI or older Go versions that passed arguments on the stack, parameters are now distributed across registers like RAX, RBX, and RCX.</p> <ul> <li>Impact: Generic eBPF tools that do not account for Go\u2019s register mapping will capture meaningless data. We must manually locate these registers to extract correct information.</li> </ul> </li> <li> <p>Stack Growth and the Risks of uretprobe</p> <p>Goroutine stacks are dynamic. When a function detects insufficient stack space, it calls runtime.morestack to expand, \"moving\" the entire stack content to a larger memory segment.</p> <ul> <li> <p>Impact: eBPF's uretprobe relies on modifying the return address upon function entry. If a stack move occurs mid-execution, the recorded return address becomes invalid, potentially causing the tracer to fail or, worse, crashing the application.</p> </li> <li> <p>Solution: To ensure safety, we can replace uretprobe with manual calculations of function exit offsets, utilizing standard Uprobes to capture exit events accurately.</p> </li> </ul> </li> <li> <p>Invisibility of the G-M-P Scheduler</p> <p>The Linux kernel recognizes Threads, but remains unaware of Goroutines.</p> <ul> <li>Impact: Measuring time at the thread level makes it impossible to distinguish which Goroutine is consuming resources or to account for kernel scheduling interference.</li> <li>Solution: Instead of blind kernel-level tracing, we target the internal state transition point of the Go Runtime: runtime.casgstatus. By monitoring when a Goroutine enters _Grunning or _Gwaiting, we obtain actual CPU execution time from a \"Goroutine-centric perspective.</li> </ul> </li> <li> <p>Goroutine Migration Between Threads</p> <p>In Go's G-M-P scheduling model, a Goroutine is not pinned to a specific OS thread. A Goroutine might start executing on Thread A, get descheduled, and later resume on Thread B.</p> <ul> <li>The Impact: Traditional eBPF tools often use the Thread ID (TID) as a key to store timestamps. If a Goroutine migrates during function execution, the exit probe on Thread B will fail to find the start time recorded by the entry probe on Thread A, leading to broken traces or corrupted data.</li> <li>Solution: Instead of relying on TID, we extract the Goid (Goroutine ID) directly from the Go runtime. On x86_64, the g pointer is stored in the R14 register. By reading the goid field from the g struct, we obtain a persistent identifier that follows the Goroutine across different threads. Using Goid as our primary key ensures that our timing remains accurate regardless of thread migration.</li> </ul> </li> </ol>"},{"location":"blog/20251224/20251224/#methodology","title":"Methodology","text":""},{"location":"blog/20251224/20251224/#locating-the-entry-and-exit-points-of-the-function","title":"Locating the Entry and Exit Points of the function","text":"<p>To capture the Entry and Exit Points of the function, we can use <code>objdump</code> command to analyze the disassembled binary.</p> <p>Note: Function addresses are not fixed and will change every time the program is recompiled. Always re-verify the offsets for your current binary.</p> <p>Example Command:</p> <p><pre><code>objdump -d ./amf --disassemble=\"github.com/free5gc/amf/internal/gmm.HandleRegistrationRequest\"\n</code></pre> The output will be like  We can use <code>grep</code> to quickly find all ret instruction addresses. <pre><code>objdump -d ./amf --disassemble=\"github.com/free5gc/amf/internal/gmm.HandleRegistrationRequest\" | grep ret\n</code></pre> <code>0xcac2a6</code> is one of the ret instruction address.</p> <p>Note: Every ret instruction within the function must be traced to ensure the exit event is captured regardless of the execution path.</p> <p>We can use <code>head -n 10</code> to find the entry. <pre><code>objdump -d ./amf --disassemble=\"github.com/free5gc/amf/internal/gmm.HandleRegistrationRequest\" | head -n 10\n</code></pre> <code>0xcabf80</code> is the entry address.</p> <p><code>nm</code> can also be used to find the entry. <pre><code>nm ./amf | grep -w \"github.com/free5gc/amf/internal/gmm.HandleRegistrationRequest\"\n</code></pre> </p> <p>Note: Go's compiler may \"inline\" small functions for performance. If a function is inlined, it loses its unique symbol and address, making it untraceable via eBPF. To prevent this, you must add the //go:noinline compiler directive directly above the function definition: <pre><code>//go:noinline\nfunc YourFunction() { ... }\n</code></pre></p>"},{"location":"blog/20251224/20251224/#get-information-from-register-abiinternal","title":"Get information from Register (ABIInternal)","text":""},{"location":"blog/20251224/20251224/#get-goid","title":"Get goid","text":"<p>To trace Go applications effectively, we need a persistent way to identify a Goroutine as it moves across different OS threads. This is where the Goid comes in. Extracting it requires two pieces of information: the location of the \"g\" pointer and the memory offset of the goid field.</p> <ol> <li>Finding the G-Pointer via R14      In the x86_64 architecture, Go\u2019s ABIInternal convention stores the pointer to the current Goroutine structure (runtime.g) in the R14 register.<ul> <li>The Logic: Whenever an eBPF probe is triggered, we read the value of R14 to get the memory address of the current Goroutine's \"home\" in memory.</li> </ul> </li> <li>Using <code>pahole</code> to Locate the Offset <pre><code>pahole -C \"runtime.g\" ./amf\n</code></pre>     the output will be like: <pre><code>        struct runtime.g {\n            runtime.stack              stack;                /*     0    16 */\n            uintptr                    stackguard0;          /*    16     8 */\n            uintptr                    stackguard1;          /*    24     8 */\n            runtime._panic *           _panic;               /*    32     8 */\n            runtime._defer *           _defer;               /*    40     8 */\n            runtime.m *                m;                    /*    48     8 */\n            runtime.gobuf              sched;                /*    56    48 */\n            /* --- cacheline 1 boundary (64 bytes) was 40 bytes ago --- */\n            uintptr                    syscallsp;            /*   104     8 */\n            uintptr                    syscallpc;            /*   112     8 */\n            uintptr                    syscallbp;            /*   120     8 */\n            /* --- cacheline 2 boundary (128 bytes) --- */\n            uintptr                    stktopsp;             /*   128     8 */\n            void *                     param;                /*   136     8 */\n            internal/runtime/atomic.Uint32 atomicstatus;     /*   144     4 */\n            uint32                     stackLock;            /*   148     4 */\n            uint64                     goid;                 /*   152     8 */\n            runtime.guintptr           schedlink;            /*   160     8 */\n            int64                      waitsince;            /*   168     8 */\n            runtime.waitReason         waitreason;           /*   176     1 */\n            bool                       preempt;              /*   177     1 */\n            bool                       preemptStop;          /*   178     1 */\n                                        .\n                                        .\n                                        .\n            uint32                     sig;                  /*   220     4 */\n            struct []uint8             writebuf;             /*   224    24 */\n            uintptr                    sigcode0;             /*   248     8 */\n            /* --- cacheline 4 boundary (256 bytes) --- */\n            uintptr                    sigcode1;             /*   256     8 */\n            uintptr                    sigpc;                /*   264     8 */\n            uint64                     parentGoid;           /*   272     8 */\n            uintptr                    gopc;                 /*   280     8 */\n                                        .\n                                        .\n                                        .\n            /* --- cacheline 6 boundary (384 bytes) --- */\n            runtime.synctestBubble *   bubble;               /*   384     8 */\n            runtime.gTraceState        trace;                /*   392    32 */\n            int64                      gcAssistBytes;        /*   424     8 */\n            uintptr                    valgrindStackID;      /*   432     8 */\n\n            /* size: 440, cachelines: 7, members: 61 */\n            /* sum members: 439, holes: 1, sum holes: 1 */\n            /* last cacheline: 56 bytes */\n    };\n</code></pre>     We can find that the offset of goid is 152 <pre><code>uint64                     goid;                 /*   152     8 */\n</code></pre>     &gt; Note: This offset is version-dependent and should be verified using pahole for your specific Go runtime.     This tells us that goid is located 152 bytes from the start of the g struct. Therefore, the logic for our BPF program is: <pre><code>static __always_inline u64 get_goid(struct pt_regs *ctx) {\n    void *g_ptr = (void *)(ctx-&gt;r14);\n    u64 goid;\n    bpf_probe_read_user(&amp;goid, sizeof(goid), (void *)(g_ptr + 152));\n    return goid;\n}\n</code></pre> <p>Note: Go Runtime and all its Goroutines operate entirely in User Space. So we should use <code>bpf_probe_read_user</code> to ensures that the data is copied safely from the User Space process into a kernel buffer before we attempt to analyze it.</p> </li> </ol>"},{"location":"blog/20251224/20251224/#tracing-state-transitions-capturing-casgstatus-arguments","title":"Tracing State Transitions: Capturing casgstatus Arguments","text":"<p>To calculate the actual \"CPU Time\" spent on a task, we must know when a Goroutine is actively running (_Grunning) and when it switch to other state like _Gwaiting. This transition is handled by the internal function runtime.casgstatus.</p> <ol> <li> <p>Function Signature and Register Mapping     The function is defined in the Go runtime as: <pre><code>func casgstatus(gp *g, oldval, newval uint32)\n</code></pre>     Because Go uses a Register-based ABI, these arguments are not on the stack but are passed through CPU registers. On x86_64, the mapping is as follows:</p> <p><code>gp</code> (The G being modified): Stored in RAX. <code>oldval</code> (The previous state): Stored in RBX. <code>newval</code> (The target state): Stored in RCX. 2. The Implementation Method When we attach a Uprobe to runtime.casgstatus, our BPF C code uses specific macros to pull these values directly from the registers: <pre><code>SEC(\"uprobe/runtime.casgstatus\")\nint uprobe_casgstatus(struct pt_regs *ctx) {\n    void *gp = (void *)ctx-&gt;ax;; \n    u32 oldval = (u32)ctx-&gt;bx;\n    u32 newval = (u32)ctx-&gt;cx;\n\n    u64 target_goid = bpf_probe_read_user(&amp;goid, sizeof(goid), (void *)((u64)gp + 152));\n\n    // handle logic\n    return 0;\n}\n</code></pre> By monitoring these transitions, we can distinguish between Wall Time and CPU Time (the time actually spent processing), providing a much clearer picture of where the function is struggling.</p> </li> </ol>"},{"location":"blog/20251224/20251224/#implementation","title":"Implementation","text":"<p>The following is the source code to trace the latency of  5G Registration Procedure.</p> <p>Note: all the following contents are based on x86_64.</p>"},{"location":"blog/20251224/20251224/#source-code","title":"Source Code","text":"<p>The header file of eBPF <pre><code>//trace.h\n#ifndef __TRACER_H__\n#define __TRACER_H__\n\n#define user_pt_regs pt_regs\n\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n\n// Go runtime status\n#define G_IDLE 0\n#define G_RUNNABLE 1\n#define G_RUNNING 2\n#define G_SYSCALL 3\n#define G_WAITING 4\n#define G_MORIBUND_UNUSED 5\n#define G_DEAD 6\n#define G_ENQUEUE_UNUSED 7\n#define G_COPYSTACK 8\n#define G_PREEMPTED 9\n\n// Offset\n#define OFFSET_GOID    152\n#define OFFSET_STARTPC 296\n#define OFFSET_GOPC    280\n\n// Register (x86-64 Go ABI)\n#define GO_G_REG(ctx) (ctx-&gt;r14)\n#define GO_ARG1(ctx)  (ctx-&gt;ax)\n#define GO_ARG2(ctx)  (ctx-&gt;bx)\n#define GO_ARG3(ctx)  (ctx-&gt;cx)\n#define GO_ARG4(ctx)  (ctx-&gt;di)\n#define GO_ARG5(ctx)  (ctx-&gt;si)\n\n#endif \n</code></pre> The eBPF tracer source code <pre><code>// tracer.bpf.c\n#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n\ntypedef __u64 u64;\ntypedef __u32 u32;\ntypedef __u8  u8;\n\n// key for tracking function calls per goroutine\nstruct proc_key {\n    u64 goid;\n    u64 func_id;\n};\n\n// goroutine CPU time tracking structure\nstruct goid_clock {\n    u64 total_cpu_ns;\n    u64 last_start_ns;\n    u8  is_on_cpu;\n};\n\n// event structure for ring buffer\nstruct event_t {\n    u64 goid;\n    u64 total_cpu_ns;\n    u32 event_type; \n    u64 func_id; \n};\n\n#define EVENT_ENTER 1\n#define EVENT_EXIT  2\n\n#include \"tracer.h\" \n\n// global map to track goid CPU time\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 1024);\n    __type(key, u64); // goid\n    __type(value, struct goid_clock);\n} goid_clocks SEC(\".maps\");\n\n// map to store entry snapshots\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 2048);\n    __type(key, struct proc_key); // goid + func_id \n    __type(value, u64);           // snapshot vtime\n} g_stats SEC(\".maps\");\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_RINGBUF);\n    __uint(max_entries, 256 * 1024);\n} events SEC(\".maps\");\n\n// calculate accumulated vtime for a given goid\nstatic __always_inline u64 get_accumulated_vtime(u64 goid) {\n    struct goid_clock *c = bpf_map_lookup_elem(&amp;goid_clocks, &amp;goid);\n    if (!c) return 0;\n    u64 total = c-&gt;total_cpu_ns;\n    if (c-&gt;is_on_cpu) {\n        total += (bpf_ktime_get_ns() - c-&gt;last_start_ns);\n    }\n    return total;\n}\n// get goid from pt_regs\nstatic __always_inline u64 get_goid(struct pt_regs *ctx) {\n    void *g_ptr = (void *)GO_G_REG(ctx);\n    u64 goid;\n    bpf_probe_read_user(&amp;goid, sizeof(goid), (void *)(g_ptr + OFFSET_GOID));\n    return goid;\n}\n// get goid from gp pointer\nstatic __always_inline u64 get_goid_from_gp(void *gp) {\n    u64 goid;\n    bpf_probe_read_user(&amp;goid, sizeof(goid), (void *)((u64)gp + OFFSET_GOID));\n    return goid;\n}\n// enter uprobe\nSEC(\"uprobe/handle_entry\")\nint handle_entry(struct pt_regs *ctx) {\n    u64 goid = get_goid(ctx);\n    u64 now = bpf_ktime_get_ns();\n    u64 cookie = bpf_get_attach_cookie(ctx); \n\n    // initialize goid tracking map if not exists\n    struct goid_clock *c = bpf_map_lookup_elem(&amp;goid_clocks, &amp;goid);\n    if (!c) {\n        struct goid_clock init_c = { .last_start_ns = now, .is_on_cpu = 1, .total_cpu_ns = 0 };\n        bpf_map_update_elem(&amp;goid_clocks, &amp;goid, &amp;init_c, BPF_ANY);\n    }\n\n    // store entry snapshot\n    struct proc_key key = { .goid = goid, .func_id = cookie };\n    u64 vtime_snapshot = get_accumulated_vtime(goid);\n    bpf_map_update_elem(&amp;g_stats, &amp;key, &amp;vtime_snapshot, BPF_ANY);\n    // submit event\n    struct event_t *e = bpf_ringbuf_reserve(&amp;events, sizeof(*e), 0);\n    if (e) {\n        e-&gt;goid = goid;\n        e-&gt;event_type = EVENT_ENTER;\n        e-&gt;total_cpu_ns = 0;\n        e-&gt;func_id = cookie; \n        bpf_ringbuf_submit(e, 0);\n    }\n    return 0;\n}\n// enter uprobe for runtime.casgstatus\nSEC(\"uprobe/runtime.casgstatus\")\nint uprobe_casgstatus(struct pt_regs *ctx) {\n    void *gp = (void *)GO_ARG1(ctx);\n    u32 oldval = (u32)GO_ARG2(ctx);\n    u32 newval = (u32)GO_ARG3(ctx);\n    u64 now = bpf_ktime_get_ns();\n    u64 target_goid = get_goid_from_gp(gp);\n    // lookup the goid tracking map\n    struct goid_clock *c = bpf_map_lookup_elem(&amp;goid_clocks, &amp;target_goid);\n    if (!c) return 0;\n\n    // update CPU time tracking based on state transition\n    if (oldval == G_RUNNING &amp;&amp; newval != G_RUNNING) {\n        if (c-&gt;is_on_cpu) {\n            c-&gt;total_cpu_ns += (now - c-&gt;last_start_ns);\n            c-&gt;is_on_cpu = 0;\n        }\n    } else if (oldval != G_RUNNING &amp;&amp; newval == G_RUNNING) {\n        c-&gt;last_start_ns = now;\n        c-&gt;is_on_cpu = 1;\n    }\n    return 0;\n}\n// exit uprobe\nSEC(\"uprobe/handle_exit\")\nint handle_exit(struct pt_regs *ctx) {\n    u64 goid = get_goid(ctx);\n    u64 cookie = bpf_get_attach_cookie(ctx); \n    struct proc_key key = { .goid = goid, .func_id = cookie };\n\n    // retrieve the entry snapshot\n    u64 *entry_vtime = bpf_map_lookup_elem(&amp;g_stats, &amp;key);\n    if (!entry_vtime) return 0;\n\n    // calculate CPU usage\n    u64 current_vtime = get_accumulated_vtime(goid);\n    u64 cpu_usage = current_vtime - *entry_vtime;\n    // submit event\n    struct event_t *e = bpf_ringbuf_reserve(&amp;events, sizeof(*e), 0);\n    if (e) {\n        e-&gt;goid = goid;\n        e-&gt;total_cpu_ns = cpu_usage;\n        e-&gt;event_type = EVENT_EXIT;\n        e-&gt;func_id = cookie; \n        bpf_ringbuf_submit(e, 0);\n    }\n\n    // delete the snapshot\n    bpf_map_delete_elem(&amp;g_stats, &amp;key);\n    return 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n</code></pre> The sample yaml file. Only some key functions are shown here for illustrative purposes. <pre><code># config.yaml\nbinaries:\n  - path: \"../../free5gc/bin/amf\"  # binary path\n    symbols:\n      - name: \"github.com/free5gc/amf/internal/gmm.HandleRegistrationRequest\"\n        fun_id: 101 # use as cookie\n        entry: 0xcabf80 # entry address   \n        rets: # return addresses\n          - 0xcac2a6\n          - 0xcac2af\n          - 0xcac3e5\n          - 0xcac4fd\n          - 0xcac6c4\n          - 0xcac852\n          - 0xcac8d2\n          - 0xcac9db\n          - 0xcacb13\n          - 0xcad326\n          - 0xcad385\n          - 0xcad3a6\n          - 0xcad3c7\n          - 0xcad59d\n          - 0xcad5fa\n          - 0xcad64f\n      - name: \"github.com/free5gc/amf/internal/gmm.HandleAuthenticationResponse\"\n        fun_id: 102\n        entry: 0xcb71a0\n        rets:\n          - 0xcb7422\n          - 0xcb7443\n          - 0xcb7464\n          - 0xcb75e3\n          - 0xcb7765\n          - 0xcb7b1a\n          - 0xcb7b74\n          - 0xcb7b83\n          - 0xcb7ba4\n          - 0xcb7bb1\n          - 0xcb7d91\n          - 0xcb7f05\n          - 0xcb8063\n          - 0xcb81db\n          - 0xcb84d0\n          - 0xcb852a\n          - 0xcb8539\n      - name: \"github.com/free5gc/amf/internal/gmm/message.SendRegistrationAccept\"\n        fun_id: 103\n        entry: 0xca8440\n        rets:\n          - 0xca8938\n          - 0xca89d8\n          - 0xca8a4e\n          - 0xca8ac4\n          - 0xca8ad2\n      - name: \"github.com/free5gc/amf/internal/gmm/message.SendDeregistrationAccept\"\n        fun_id: 104\n        entry: 0xca80a0\n        rets:\n          - 0xca8232\n          - 0xca826b\n          - 0xca82d2\n          - 0xca8340\n          - 0xca83b0\n          - 0xca83be\n      - name: \"github.com/free5gc/amf/internal/gmm.handleRequestedNssai\"\n        fun_id: 105\n        entry: 0xcb06e0\n        rets:\n          - 0xcb080d\n          - 0xcb0c19\n          - 0xcb0ec5\n          - 0xcb1a7d\n          - 0xcb1a8a\n          - 0xcb1b37\n      - name: \"github.com/free5gc/amf/internal/gmm.HandleInitialRegistration\"\n        fun_id: 106\n        entry: 0xcadae0\n        rets:\n          - 0xcadf77\n          - 0xcadfc4\n          - 0xcae019\n          - 0xcae022\n          - 0xcae512\n      - name: \"github.com/free5gc/amf/internal/gmm.AuthenticationProcedure\"\n        fun_id: 107\n        entry: 0xcb4e60\n        rets:\n          - 0xcb4f98\n          - 0xcb50bc\n          - 0xcb5113\n          - 0xcb5354\n          - 0xcb541b\n          - 0xcb554e\n          - 0xcb561c\n      - name: \"github.com/free5gc/amf/internal/gmm.contextTransferFromOldAmf\"\n        fun_id: 108\n        entry: 0xcad6c0\n        rets:\n          - 0xcad99a\n          - 0xcad9db\n          - 0xcada2d\n          - 0xcada73\n          - 0xcada7c\n  - path: \"../../free5gc/bin/ausf\"\n    symbols:\n      - name: \"github.com/free5gc/ausf/internal/sbi/processor.(*Processor).UeAuthPostRequestProcedure\"\n        fun_id: 203\n        entry: 0xb8fda0\n        rets:\n          - 0xb902ce\n          - 0xb90a57\n          - 0xb90b6d\n          - 0xb90c14\n          - 0xb90e9e\n          - 0xb911b7\n</code></pre></p> <p>Note: In a real production environment, this list can be expanded to a large number of functions across all 5GC NFs (SMF, UPF, PCF, etc.).</p> <p>Python script for configuration generation. <pre><code># gen_config.py\nimport subprocess\nimport re\nimport sys\nimport shlex\n\ndef get_offsets(binary, search_pattern):\n    try:\n        nm_cmd = f\"nm -n {binary} | grep {shlex.quote(search_pattern)}\"\n        nm_output = subprocess.check_output(nm_cmd, shell=True).decode().splitlines()\n\n        if not nm_output:\n            print(f\"Error: Symbol matching '{search_pattern}' not found.\")\n            return None\n\n        target_line = nm_output[0].split()\n        entry_addr_hex = target_line[0]\n        full_symbol_name = target_line[2]\n        entry_addr = int(entry_addr_hex, 16)\n\n        print(f\"[*] Found Full Symbol: {full_symbol_name}\")\n        print(f\"[*] Entry Address: 0x{entry_addr:x}\")\n\n        obj_cmd = f\"objdump -d {binary} --disassemble={shlex.quote(full_symbol_name)}\"\n        dump_out = subprocess.check_output(obj_cmd, shell=True).decode()\n        rets = re.findall(r'^\\s*([0-9a-f]+):\\s+(?:c3|c2|cb|ca)\\s+ret', dump_out, re.MULTILINE)\n\n        ret_addrs = [int(r, 16) for r in rets]\n\n        return entry_addr, ret_addrs, full_symbol_name\n\n    except subprocess.CalledProcessError as e:\n        print(f\"Exec error: {e}\")\n        return None\n\n\nbinary_path = \"~/free5gc/bin/ausf\" # binary path\ntarget_function = \"UeAuthPostRequestProcedure\" # function name to search\nfun_id = 103  # function ID for tracing\n\nresult = get_offsets(binary_path, target_function)\n\nif result:\n    entry, rets, full_name = result\n    print(f\"- name: \\\"{full_name}\\\"\")\n    print(f\"  fun_id: {fun_id}\")\n    print(f\"  entry: 0x{entry:x}\")\n    print(f\"  rets:\")\n    for r in rets:\n        print(f\"    - 0x{r:x}\")\n</code></pre> A Go-based eBPF loader for probe orchestration and event processing. <pre><code>// main.go\npackage main\n//go:generate bpf2go -target amd64 bpf ../tracer.bpf.c\nimport (\n    \"bytes\"\n    \"encoding/binary\"\n    \"errors\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"os/signal\"\n    \"syscall\"\n\n    \"github.com/cilium/ebpf/link\"\n    \"github.com/cilium/ebpf/ringbuf\"\n    \"github.com/cilium/ebpf/rlimit\"\n    \"gopkg.in/yaml.v3\" \n)\n\ntype Config struct {\n    Binaries []BinaryConfig `yaml:\"binaries\"`\n}\n// BinaryConfig defines a binary to trace and its symbols.\ntype BinaryConfig struct {\n    Path    string         `yaml:\"path\"`\n    Symbols []SymbolConfig `yaml:\"symbols\"`\n}\n// SymbolConfig defines a function to trace within a binary.\ntype SymbolConfig struct {\n    Name  string   `yaml:\"name\"`\n    FunID uint64   `yaml:\"fun_id\"`\n    Entry uint64   `yaml:\"entry\"`\n    Rets  []uint64 `yaml:\"rets\"`\n}\n// Event types\ntype bpfEventT struct {\n    Goid       uint64 // Goroutine ID\n    TotalCpuNs uint64 // valid only for exit events\n    EventType  uint32 // 1 for enter, 2 for exit\n    _          [4]byte // Padding to align to 8 bytes\n    FuncId     uint64  // Function ID\n}\nconst (\n    EventEnter = 1\n    EventExit  = 2\n)\n\nfunc main() {\n    if err := rlimit.RemoveMemlock(); err != nil {\n        log.Fatal(err)\n    }\n\n    // load config.yaml\n    configFile, err := os.ReadFile(\"config.yaml\") // path to your config file\n    if err != nil {\n        log.Fatalf(\"failed to read config: %v\", err)\n    }\n    var config Config\n    if err := yaml.Unmarshal(configFile, &amp;config); err != nil {\n        log.Fatalf(\"failed to parse yaml: %v\", err)\n    }\n\n    // load BPF Objects\n    var objs bpfObjects\n    if err := loadBpfObjects(&amp;objs, nil); err != nil {\n        log.Fatalf(\"loading objects: %v\", err)\n    }\n    defer objs.Close()\n\n    // create function ID to name map\n    idToName := make(map[uint64]string)\n    var links []link.Link\n    defer func() {\n        for _, l := range links {\n            l.Close()\n        }\n    }()\n\n    // loop through binaries and symbols to attach uprobes\n    for _, bin := range config.Binaries {\n        ex, err := link.OpenExecutable(bin.Path)\n        if err != nil {\n            log.Printf(\"Warning: opening executable %s failed: %v\", bin.Path, err)\n            continue\n        }\n\n        for _, sym := range bin.Symbols {\n            // create function ID to name mapping\n            idToName[sym.FunID] = sym.Name\n\n            // attach Entry Uprobe with Cookie\n            enL, err := ex.Uprobe(sym.Name, objs.HandleEntry, &amp;link.UprobeOptions{\n                Offset: 0x0,\n                Cookie: sym.FunID,\n            })\n            if err != nil {\n                log.Fatalf(\"failed to attach entry for %s: %v\", sym.Name, err)\n            }\n            links = append(links, enL)\n\n            // attach Exit Uprobes with Cookie\n            for _, retAddr := range sym.Rets {\n                retOffset := retAddr - sym.Entry\n                exL, err := ex.Uprobe(sym.Name, objs.HandleExit, &amp;link.UprobeOptions{\n                    Offset: retOffset,\n                    Cookie: sym.FunID,\n                })\n                if err != nil {\n                    log.Fatalf(\"failed to attach exit at 0x%x for %s: %v\", retOffset, sym.Name, err)\n                }\n                links = append(links, exL)\n            }\n        }\n\n        // attach casgstatus uprobe\n        casgL, err := ex.Uprobe(\"runtime.casgstatus\", objs.UprobeCasgstatus, nil)\n        if err != nil {\n            log.Printf(\"Warning: casgstatus attach failed for %s: %v\", bin.Path, err)\n        } else {\n            links = append(links, casgL)\n        }\n    }\n\n    log.Printf(\"Tracing 5G Core... Listening for events (Ctrl+C to stop)\")\n\n    // read events from ring buffer\n    rd, err := ringbuf.NewReader(objs.Events)\n    if err != nil {\n        log.Fatalf(\"creating ringbuf reader: %v\", err)\n    }\n    defer rd.Close()\n\n    sig := make(chan os.Signal, 1)\n    signal.Notify(sig, os.Interrupt, syscall.SIGTERM)\n    go func() {\n        &lt;-sig\n        log.Println(\"Received interrupt, shutting down...\")\n        rd.Close()\n    }()\n\n    for {\n        record, err := rd.Read()\n        if err != nil {\n            if errors.Is(err, ringbuf.ErrClosed) {\n                return\n            }\n            log.Printf(\"reading from ringbuf: %v\", err)\n            continue\n        }\n\n        var event bpfEventT\n        if err := binary.Read(bytes.NewBuffer(record.RawSample), binary.LittleEndian, &amp;event); err != nil {\n            log.Printf(\"parsing event: %v\", err)\n            continue\n        }\n\n        // print event info\n        funcName := idToName[event.FuncId]\n        if funcName == \"\" {\n            funcName = \"Unknown_Function\"\n        }\n\n        switch event.EventType {\n        case EventEnter:\n            fmt.Printf(\"[%s] ENTER | Goid: %d\\n\", funcName, event.Goid)\n        case EventExit:\n            fmt.Printf(\"[%s] EXIT  | Goid: %d | Total CPU: %d ns (%.3f ms)\\n\",\n                funcName, event.Goid, event.TotalCpuNs, float64(event.TotalCpuNs)/1e6)\n        }\n    }\n}\n</code></pre></p>"},{"location":"blog/20251224/20251224/#how-to-use","title":"How to use","text":"<ol> <li>Generate vmlinux.h  <pre><code>bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h\n</code></pre></li> <li> <p>Generate <code>bpf_bpfel.o</code> and <code>bpf_bpfel.go</code>     By running go generate, we produce <code>bpf_bpfel.o</code> (the compiled bytecode) and <code>bpf_bpfel.go</code> (the Go bindings). These files act as the bridge, allowing our Go application to load the eBPF program into the kernel. <pre><code>go generate\n</code></pre></p> </li> <li> <p>Build eBPF loader <pre><code>go build -o tracer\n</code></pre></p> </li> <li>Execute eBPF loader <pre><code>sudo ./tracer\n</code></pre></li> </ol>"},{"location":"blog/20251224/20251224/#result","title":"Result","text":""},{"location":"blog/20251224/20251224/#conclusion","title":"Conclusion","text":"<p>In this article, we have navigated the intricate intersection of eBPF technology and the Go runtime to address one of the challenges in 5G core network optimization: transparent, high-precision latency tracing.</p> <p>References</p> <ul> <li>free5GC</li> <li>xgotop</li> <li>30 \u7bc7\u6587\u5e36\u4f60\u7528 eBPF \u8207 Golang \u6253\u9020 Linux Scheduler\u7cfb\u5217 \u7b2c 10 \u7bc7</li> <li>golang uretprobe\u7684\u5d29\u6e83\u4e0e\u6a21\u62df\u5b9e\u73b0</li> <li>Golang Goroutine \u8207 GMP \u539f\u7406\u5168\u9762\u5206\u6790</li> <li>References: runtime.casgstatus</li> </ul> <p>About Me Hi, I'm Chia-Hui Chen. I'm currently diving into 5G technology and the free5gc project. I hope you find this blog valuable! Feel free to reach out if you have any feedback or would like to discuss anything further.</p> <ul> <li>GitHub: chchen7</li> </ul>"},{"location":"blog/20251231/20251231/","title":"Beyond Standard Networking: Implementing 5G VRF Isolation in Go","text":"<p>Note</p> <p>Author: HUANG, YUAN-CHUN Date: 2025/12/31</p>"},{"location":"blog/20251231/20251231/#1-introduction","title":"1. Introduction","text":"<p>According to 3GPP TS 23.501, the 5G System (5GS) is designed to be access-agnostic, allowing User Equipment (UE) to connect to the 5G Core Network (5GC) via Non-3GPP Access Networks (e.g., untrusted Wi-Fi or wired networks).</p>"},{"location":"blog/20251231/20251231/#11-definition-and-functional-role","title":"1.1. Definition and Functional Role","text":"<p>An N3IWUE (Non-3GPP Interworking UE) is a UE that utilizes the NWu reference point to communicate with the N3IWF (Non-3GPP Interworking Function). Its primary role is to establish a secure connection over an untrusted non-3GPP access to reach the 5GC.</p> <p></p>"},{"location":"blog/20251231/20251231/#12-protocol-stack-and-interface","title":"1.2. Protocol Stack and Interface","text":"<p>Per 3GPP specifications, the N3IWUE must implement a specific dual-stack architecture to separate signaling from data:</p> <ul> <li> <p>Control Plane (CP): The UE establishes an IKEv2 security association with the N3IWF to create a Signaling IPsec SA. NAS (Non-Access Stratum) messages are then encapsulated and transmitted over this secure tunnel to the AMF (Access and Mobility Management Function).</p> </li> <li> <p>User Plane (UP): For each established PDU Session, the UE creates a separate Data IPsec SA. User data is encapsulated using GRE (Generic Routing Encapsulation) (as per TS 24.502) before being encrypted by IPsec and sent to the N3IWF, which forwards it to the UPF (User Plane Function).</p> </li> </ul> <p></p>"},{"location":"blog/20251231/20251231/#13-significance-and-practical-use-cases","title":"1.3. Significance and Practical Use Cases","text":"<ol> <li> <p>Untrusted Non-3GPP Access (TS 23.501 \u00a74.2.8) N3IWUE allows for the extension of 5G services to any IP-based network. The significance lies in Security Termination: the N3IWF acts as a security gateway, terminating the IPsec tunnels from the UE and interfacing with the 5GC via standard N2 (CP) and N3 (UP) interfaces.</p> </li> <li> <p>PDU Session Resource Isolation 3GPP defines that a UE may support multiple PDU Sessions over non-3GPP access. Each PDU Session is associated with a specific QFI (QoS Flow Identifier).</p> </li> <li> <p>Regulatory and Emergency Services 3GPP specifies procedures for Emergency Services over non-3GPP access, ensuring that even without a SIM card or cellular coverage, an N3IWUE can reach the 5GC for emergency calls if an N3IWF is reachable via Wi-Fi.</p> </li> </ol>"},{"location":"blog/20251231/20251231/#2-the-routing-black-hole-default-route-hijacks-and-the-case-of-disappearing-management-traffic","title":"2. The Routing Black Hole \u2014 Default Route Hijacks and the Case of Disappearing Management Traffic","text":"<p>In the process of implementing the User Plane for an free5GC N3IWUE, we eventually reach the milestone where data starts flowing. Following the 3GPP TS 24.502 specification, the UE establishes multiple GRE tunnels based on the QoS Flow Identifier (QFI) assigned by the 5G Core (5GC).</p> <p>However, as soon as the first tunnel\u2014the Default QFI (QFI=1)\u2014is activated, a silent but devastating networking conflict begins to brew.</p>"},{"location":"blog/20251231/20251231/#21-the-aggressive-default-route","title":"2.1. The \"Aggressive\" Default Route","text":"<p>To ensure that the UE's general data traffic is steered into the 5G network, a common implementation practice is to inject a default route pointing to the GRE interface. For example: <pre><code># A typical routing entry for QFI=1\nip route add 0.0.0.0/0 dev gre-tun-1 priority 7\n</code></pre> In the Linux routing world, a <code>priority</code> (or <code>metric</code>) of 7 is exceptionally low, giving it massive precedence over other routes. The logic seems sound: \"Unless there is a more specific path, send everything through the 5G tunnel.\"</p>"},{"location":"blog/20251231/20251231/#22-the-practical-disaster-the-ssh-black-hole","title":"2.2. The Practical Disaster: The SSH \"Black Hole\"","text":"<p>Imagine your development setup: Your N3IWUE software is running on a Linux machine connected to your lab\u2019s Wi-Fi. You are remotely managing this device via SSH from your laptop.</p> <p>The moment your N3IWUE successfully establishes the PDU Session and injects that <code>priority 7</code> default route, the disaster strikes: Your SSH session instantly freezes and disconnects.</p>"},{"location":"blog/20251231/20251231/#what-happened-to-the-packets","title":"What happened to the packets?","text":"<p>Let\u2019s trace the journey of a single SSH response packet:</p> <ol> <li> <p>Request Inbound: Your laptop sends an SSH request to the N3IWUE via the Wi-Fi interface.</p> </li> <li> <p>Response Generated: The N3IWUE generates a response packet. The Source IP is the Wi-Fi IP, and the Destination IP is your laptop\u2019s IP.</p> </li> <li> <p>The Fatal Routing Decision: The Linux kernel looks at the routing table.</p> <ul> <li> <p>It sees <code>0.0.0.0/0 dev gre-tun-1 priority 7</code>.</p> </li> <li> <p>Because your laptop\u2019s IP isn't on the same local subnet as the Wi-Fi, the kernel decides this \"external\" packet must follow the highest-priority default route.</p> </li> <li> <p>The Result: The SSH response packet, carrying a Wi-Fi Source IP, is forcefully pushed into the GRE Tunnel.</p> </li> </ul> </li> <li> <p>The Black Hole: The 5G Core receives a packet originating from a \"Local Wi-Fi IP.\" Since this IP is completely unknown to the 5G internal routing domain, the 5GC drops the packet immediately.</p> </li> </ol> <p>Your management traffic has been hijacked by your own 5G data plane. </p>"},{"location":"blog/20251231/20251231/#23-the-multi-access-paradox","title":"2.3. The Multi-Access Paradox","text":"<p>This scenario highlights a fundamental conflict in N3IWUE design: Multi-access does not mean simple aggregation.</p> <p>According to 3GPP's vision, an N3IWUE must be \"Multi-homed,\" meaning it should handle:</p> <ul> <li> <p>5G Service Traffic: Which must traverse the GRE/IPsec tunnels.</p> </li> <li> <p>Non-3GPP Management Traffic: Which must remain on the local Wi-Fi or Ethernet (e.g., SSH, DNS lookups, or OS updates).</p> </li> </ul> <p>If we rely on a single, global routing table (the <code>main</code> table), these two types of traffic will always fight for the default route. No matter how you tweak the <code>priority</code> values, one connection will inevitably break.</p>"},{"location":"blog/20251231/20251231/#24-conclusion-we-need-parallel-universes","title":"2.4. Conclusion: We Need \"Parallel Universes\"","text":"<p>Relying on a single \"brain\" (routing table) makes the N3IWUE implementation extremely fragile and practically impossible to manage remotely. To satisfy 3GPP's isolation requirements while keeping the device reachable, we need a way to isolate the 5G PDU Session traffic into its own world.</p> <p>In the next chapter, we will explore how Linux VRF (Virtual Routing and Forwarding) allows us to create these \"parallel universes,\" ensuring that 5G tunnels and local management traffic never cross paths.</p>"},{"location":"blog/20251231/20251231/#3-building-parallel-universes-the-architecture-of-vrf-isolation","title":"3. Building Parallel Universes \u2014 The Architecture of VRF Isolation","text":"<p>Before we dive into the Go implementation, we must understand the \"magic\" that allows Linux to handle conflicting routes without breaking a sweat. To solve the SSH disconnection and PDU Session routing traps we encountered in Chapter 2, we rely on a powerful Linux kernel feature: VRF.</p>"},{"location":"blog/20251231/20251231/#31-what-is-vrf-virtual-routing-and-forwarding","title":"3.1. What is VRF? (Virtual Routing and Forwarding)","text":"<p>At its core, VRF is a Layer 3 (L3) isolation technology. If you are familiar with VLANs, you can think of VRF as the L3 equivalent.</p> <ul> <li> <p>VLAN (L2): Partitions a single physical switch into multiple logical switches by isolating Broadcast Domains.</p> </li> <li> <p>VRF (L3): Partitions a single physical router (your Linux host) into multiple logical routers by isolating Routing Tables.</p> </li> </ul> <p>When an interface is assigned to a VRF, it no longer looks at the system's \"Main\" routing table. Instead, it operates within its own private FIB (Forwarding Information Base).</p>"},{"location":"blog/20251231/20251231/#32-key-concepts-l3mdev-and-policy-routing","title":"3.2. Key Concepts: L3mdev and Policy Routing","text":"<p>To implement VRF, modern Linux (Kernel 4.8+) uses a mechanism called L3mdev (Layer 3 Master Device).</p> <ul> <li> <p>The Master Device: The VRF itself is a virtual network interface (e.g., <code>vrf-pdu-1</code>). It acts as a \"Master\" to other interfaces.</p> </li> <li> <p>Enslavement: When you \"enslave\" a GRE tunnel or an Ethernet port to a VRF, you are telling the kernel: \"Any packet entering or leaving this interface must use the routing table associated with this VRF Master.\"</p> </li> <li> <p>The \"Rule\" of Priority: By default, Linux queries routing tables in a specific order (Policy Routing). VRF automates this by creating a high-priority rule that redirects traffic based on the incoming interface.</p> </li> </ul> <p></p>"},{"location":"blog/20251231/20251231/#33-why-vrf-is-the-perfect-match-for-n3iwue","title":"3.3. Why VRF is the Perfect Match for N3IWUE","text":"<p>Why can't we just use standard routing? Here is why VRF is indispensable for 5G N3IWUE implementations:</p> <ol> <li> <p>Solving the Default Route Conflict As we saw, when the 5G User Plane needs a <code>0.0.0.0/0</code> route, it hijacks the whole system. By putting the 5G GRE tunnel into a VRF, that Default Route stays inside the VRF table. The \"Main\" table (used by your Wi-Fi and SSH) remains untouched and clean.</p> </li> <li> <p>Support for Overlapping IP Addresses In 5G, it is common for different PDU Sessions to be assigned the same or overlapping private IP ranges (e.g., two different customers both using <code>10.0.0.1</code>). Without VRF, the kernel would be confused. With VRF, each <code>10.0.0.1</code> lives in its own \"Parallel Universe\" (separate table), so they never collide.</p> </li> <li> <p>Maintaining Management Reachability With VRF, your SSH, NTP, and DNS traffic can continue to use the Main Routing Table via the physical Wi-Fi/Ethernet interface. The 5G data traffic is isolated in the VRF Table. This ensures the device remains manageable even when high-priority 5G tunnels are active.</p> </li> </ol>"},{"location":"blog/20251231/20251231/#34-the-hierarchy-of-isolation-vrf-gre-and-xfrm","title":"3.4. The Hierarchy of Isolation: VRF, GRE, and XFRM","text":"<p>In the N3IWUE architecture, we implement the 5G User Plane using a Master-Slave hierarchy within the Linux kernel. This layered approach ensures that 5G data traffic remains strictly isolated from local management services.</p> <p>The Logical Roles + VRF (The Master Container): Acts as the foundational \"Parallel Universe.\" It provides a dedicated L3 Routing Context (FIB), ensuring that 5G default routes do not conflict with the system's main table.</p> <ul> <li> <p>GRE (The Tunneling Slave): Handles 5G-specific encapsulation (QFI mapping). It is \"enslaved\" to the VRF master, inheriting its routing isolation.</p> </li> <li> <p>XFRM (The Security Engine): The IPsec transformation layer. It monitors traffic leaving the GRE interface and encrypts it into ESP (Encapsulated Security Payload) before physical transmission.</p> </li> </ul> <p>The Packet Journey (Egress Flow) To understand how these components interact in real-time, follow the path of an outgoing 5G data packet:</p> <ol> <li> <p>Selection: A socket bound to the VRF initiates a request.</p> </li> <li> <p>Routing: The kernel queries the VRF Table, directing the packet to the GRE interface.</p> </li> <li> <p>Encapsulation: The GRE layer wraps the packet (Adding the GRE header).</p> </li> <li> <p>Encryption: The XFRM engine intercepts the GRE packet and encrypts it (Adding the ESP header).</p> </li> <li> <p>Transmission: The final encrypted packet is sent via the Physical Interface (e.g., Wi-Fi) to the N3IWF.</p> </li> </ol>"},{"location":"blog/20251231/20251231/#4-orchestrating-parallel-universes-the-go-implementation","title":"4. Orchestrating Parallel Universes \u2014 The Go Implementation","text":"<p>In the previous chapters, we analyzed the routing conflicts inherent in 5G N3IWUE and how VRF provides the logical isolation required to solve them. Now, let\u2019s look at the actual Go implementation. We will break this down into two parts: the VRF Factory and the NAS Event Handler.</p>"},{"location":"blog/20251231/20251231/#41-the-vrf-factory-dynamic-creation-and-lifecycle","title":"4.1. The VRF Factory: Dynamic Creation and Lifecycle","text":"<p>To manage VRF devices dynamically, we implement a robust utility function. This function ensures idempotency (checking if the VRF already exists) and registers the interface for automatic cleanup to prevent resource leaks. <pre><code>package vrf\n\nimport (\n    \"fmt\"\n    \"github.com/vishvananda/netlink\"\n    \"github.com/free5gc/n3iwue/pkg/context\"\n)\n\nfunc CreateOrGetVRF(vrfName string, tableID int) (netlink.Link, error) {\n    // Step 1: Check if the VRF device already exists\n    link, err := netlink.LinkByName(vrfName)\n    if err == nil {\n        if vrf, ok := link.(*netlink.Vrf); ok {\n            if vrf.Table == uint32(tableID) {\n                return vrf, nil // VRF exists and matches the Table ID\n            }\n            return nil, fmt.Errorf(\"VRF %s mismatch: need Table %d, got %d\", vrfName, tableID, vrf.Table)\n        }\n        return nil, fmt.Errorf(\"Device %s exists but is not a VRF\", vrfName)\n    }\n\n    // Step 2: Define and Create the L3mdev (VRF) device\n    vrfLink := &amp;netlink.Vrf{\n        LinkAttrs: netlink.LinkAttrs{Name: vrfName},\n        Table:     uint32(tableID), // Link to a dedicated Routing Table\n    }\n\n    if err := netlink.LinkAdd(vrfLink); err != nil {\n        return nil, fmt.Errorf(\"Failed to add VRF %s: %v\", vrfName, err)\n    }\n\n    // Step 3: Bring the interface UP\n    if err := netlink.LinkSetUp(vrfLink); err != nil {\n        return nil, fmt.Errorf(\"Failed to set VRF %s UP: %v\", vrfName, err)\n    }\n\n    // Step 4: Register for automatic cleanup\n    n3ueSelf := context.N3UESelf()\n    var createdLink netlink.Link = vrfLink\n    n3ueSelf.CreatedIface = append(n3ueSelf.CreatedIface, &amp;createdLink)\n\n    return vrfLink, nil\n}\n</code></pre></p>"},{"location":"blog/20251231/20251231/#42-the-trigger-handling-pdu-session-establishment","title":"4.2. The Trigger: Handling PDU Session Establishment","text":"<p>The most critical moment in the N3IWUE lifecycle is when the 5G Core sends a <code>PDUSessionEstablishmentAccept</code>. This NAS message contains the UE's assigned IP and QoS information. <pre><code>func (s *Server) handleDLNASTransport(evt *context.HandleDLNASTransportEvt) {\n    nwucpLog := logger.NWuCPLog\n    n3ueSelf := s.Context()\n    nasMsg := evt.NasMsg\n\n    // ... [NAS Decoding Logic] ...\n\n    switch nasMsg.GsmMessage.GetMessageType() {\n    case nas.MsgTypePDUSessionEstablishmentAccept:\n        // 1. Extract PDU Address assigned by 5GC\n        pduAddress, _ := nasPacket.GetPDUAddress(nasMsg.GsmMessage.PDUSessionEstablishmentAccept)\n        n3ueSelf.N3ueInfo.DnIPAddr = pduAddress.String()\n\n        // 2. Dynamically define VRF parameters\n        vrfName := fmt.Sprintf(\"vrf-pdu-%d\", n3ueSelf.PduSessionCount)\n        vrfTableID := 100 + int(n3ueSelf.PduSessionCount)\n\n        // 3. Create the VRF (The Parallel Universe)\n        vrfLink, err := vrf.CreateOrGetVRF(vrfName, vrfTableID)\n        if err != nil {\n            nwucpLog.Errorf(\"VRF setup failed: %v\", err)\n            return\n        }\n\n        // 4. Setup GRE Tunnels (The Transport Layer)\n        newGREName := fmt.Sprintf(\"%s-id-%d\", n3ueSelf.N3ueInfo.GreIfaceName, n3ueSelf.N3ueInfo.XfrmiId)\n        linkGREs, _ := gre.SetupGreTunnels(...)\n\n        // 5. Enslave and Route\n        for qfi, link := range linkGREs {\n            tunnel := *link\n\n            // KEY STEP: Bind the GRE interface to the VRF Master\n            // This ensures all ingress/egress on this tunnel use the VRF context\n            if err := netlink.LinkSetMaster(tunnel, vrfLink); err != nil {\n                nwucpLog.Errorf(\"Failed to bind %s to VRF %s\", tunnel.Attrs().Name, vrfName)\n                continue\n            }\n\n            // 6. Inject routes into the VRF's private Routing Table\n            priority := 1\n            if qfi == uint8(1) { priority = 7 } // Default QFI route\n\n            upRoute := &amp;netlink.Route{\n                LinkIndex: tunnel.Attrs().Index,\n                Dst:       &amp;net.IPNet{IP: targetAddr, Mask: targetMask},\n                Priority:  priority,\n                Table:     vrfTableID, // Target the isolated table, not 'main'\n            }\n            netlink.RouteAdd(upRoute)\n        }\n        n3ueSelf.PduSessionCount++\n    }\n}\n</code></pre></p>"},{"location":"blog/20251231/20251231/#43-implementation-highlights","title":"4.3. Implementation Highlights","text":"<ol> <li> <p>Dynamic L3 Isolation via VRF Instead of a static routing configuration, our Go implementation utilizes the vishvananda/netlink library to orchestrate VRF devices on-the-fly. By assigning each PDU Session a unique VRF Table ID (e.g., 100+), we create a dedicated Forwarding Information Base (FIB), effectively isolating 5G User Plane traffic from the host\u2019s management plane.</p> </li> <li> <p>The \"Enslavement\" Mechanism (LinkSetMaster) The core of our implementation lies in the \"enslavement\" of GRE tunnels. By programmatically calling LinkSetMaster(greLink, vrfLink), we bind the 5G User Plane (UP) interfaces to the VRF Master. This critical step ensures that any packet originating from or arriving at the tunnel is processed within the context of the VRF's private routing table, not the system's main table.</p> </li> <li> <p>Explicit Table-Targeted Routing To resolve the Default Route Hijacking issue (which previously caused SSH disconnections), we explicitly define the target table in our netlink.Route structures.</p> <ul> <li> <p>Main Table: Remains untouched, preserving local management connectivity (SSH, DNS).</p> </li> <li> <p>VRF Table: Contains the 0.0.0.0/0 route for the 5G PDU Session. This granular control ensures that the high-priority 5G default route exists only within its own \"Parallel Universe.\"</p> </li> </ul> </li> <li> <p>Automated Interface Lifecycle Management Following software engineering best practices, we implemented an automatic cleanup mechanism. By registering every dynamically created VRF and GRE interface into a centralized CreatedIface slice within the UE context, the system can gracefully tear down all virtual resources during de-registration or unexpected crashes, preventing \"interface leaks\" in the Linux kernel.</p> </li> </ol>"},{"location":"blog/20251231/20251231/#5-mission-accomplished-verifying-the-parallel-universe","title":"5. Mission Accomplished \u2014 Verifying the Parallel Universe","text":"<p>After running our Go-based N3IWUE, we need to ensure that the infrastructure was built correctly and that the routing isolation actually works. In this chapter, we use standard Linux networking tools to audit our \"Parallel Universe.\"</p>"},{"location":"blog/20251231/20251231/#51-verifying-the-master-slave-relationship","title":"5.1. Verifying the Master-Slave Relationship","text":"<p>First, we check if the VRF device was created and if the GRE tunnels were successfully \"enslaved\" to it. <pre><code># Check the status of the VRF device\nip -d link show vrf-pdu-1\n</code></pre> </p> <p>What to look for: You should see <code>type vrf table 100</code>. <pre><code># Verify that the GRE interface is a slave to the VRF\nip link show gretun-id-2-1\n</code></pre> </p> <p>What to look for: Look for <code>master vrf-pdu-0</code> in the output. This confirms that the \"Enslavement\" we performed in Go (<code>LinkSetMaster</code>) was successful.</p>"},{"location":"blog/20251231/20251231/#52-auditing-the-isolated-routing-table","title":"5.2. Auditing the Isolated Routing Table","text":"<p>The most critical part of our implementation is the separation of routing tables. We want to ensure the <code>0.0.0.0/0</code> route exists only in the VRF table, not the main table. <pre><code># Inspect the VRF-specific routing table\nip route show table 100\n</code></pre> <pre><code># Inspect the Main routing table\nip route show table main\n</code></pre> </p>"},{"location":"blog/20251231/20251231/#53-testing-end-to-end-connectivity","title":"5.3. Testing End-to-End Connectivity","text":"<p>Now, let's perform the ultimate test: Sending data through the 5G PDU Session while maintaining local connectivity. 1. Test 5G Connectivity (Inside the VRF) We use the ip vrf exec command to force a process to run within the VRF context. <pre><code># Ping a public DNS through the 5G PDU Session\nsudo ip vrf exec vrf-pdu-0 ping -c 4 8.8.8.8\n</code></pre> 2. Test Local Connectivity (Main Table) Simultaneously, open a new terminal and ping the same address: <pre><code># Ping a public DNS through the 5G PDU Session\nping -c 4 8.8.8.8\n</code></pre> </p> <ol> <li>Test Specific gre tunnel <pre><code>sudo ip vrf exec vrf-pdu-0 ping -I 10.60.0.1 -c 4 8.8.8.8\n</code></pre> </li> </ol>"},{"location":"blog/20251231/20251231/#acknowledgments","title":"Acknowledgments","text":"<p>Building this N3IWUE implementation has been an intense but rewarding journey. This blog series would not have been possible without the mentorship of Ian Chen and Alonza Tu, whose guidance was instrumental in navigating the complexities of 5G networking and Linux kernel internals.</p> <p>The code modifications and the VRF-based isolation logic discussed in this blog have been submitted as a Pull Request to the official repository: \ud83d\udc49 Check out the PR on GitHub</p>"},{"location":"blog/20260107/20260107/","title":"MCP Server Integration with free5GC: Architecture and Use Cases","text":"<p>Note</p> <p>Author: Ng Warren Date: 2026/01/07</p>"},{"location":"blog/20260107/20260107/#1-introduction","title":"1. Introduction","text":"<p>While free5GC is the gold standard for 3GPP-compliant research, its day-to-day operations remain burdensome. Managing Network Functions (NFs), dependencies, and subscriber provisioning relies on fragile, script-heavy workflows that scale poorly in complex lab environments.</p> <p>AI assistants can bridge this gap by translating operator intent into action, but they require safe boundaries. The free5GC-MCP server provides this control layer. Utilizing the Model Context Protocol (MCP), it replaces unrestricted shell access with a strict, typed interface. This ensures that high-level requests\u2014like \"provision 10 UEs\" or \"restart the core\"\u2014are executed as deterministic, auditable free5GC operations.</p>"},{"location":"blog/20260107/20260107/#11-core-concepts-of-mcp","title":"1.1 Core Concepts of MCP","text":"<p>At a high level, MCP defines who participates, what can be exchanged, and how communication happens. MCP follows a client\u2013server architecture with a clear separation of responsibilities:</p> <ul> <li> <p>MCP Host: The AI application users interact with (e.g. IDEs, desktop AI apps, chat interfaces).   It owns the UI, the LLM, and user consent.</p> </li> <li> <p>MCP Client: A protocol component created by the Host.   Each client maintains one dedicated connection to one MCP server.</p> </li> <li> <p>MCP Server: A standalone program that exposes tools, resources, and prompts to clients.</p> </li> </ul> <pre><code>graph TB\n    subgraph \"MCP Host (AI Application)\"\n        Client1[\"MCP Client\"]\n        Client2[\"MCP Client\"]\n    end\n\n    ServerA[\"MCP Server (Local)\"]\n    ServerB[\"MCP Server (Remote)\"]\n\n    Client1 ---|\"Dedicated connection\"| ServerA\n    Client2 ---|\"Dedicated connection\"| ServerB</code></pre> <p>This design allows a single AI application to safely coordinate multiple independent systems through a unified interface.</p>"},{"location":"blog/20260107/20260107/#12-mcp-data-layer-and-lifecycle","title":"1.2 MCP Data Layer and Lifecycle","text":"<p>MCP is a stateful protocol. Every connection begins with a lifecycle handshake that negotiates capabilities.</p> <p>Initialization Flow:</p> <pre><code>sequenceDiagram\n    participant Host\n    participant Client\n    participant Server\n\n    Host-&gt;&gt;Client: Create MCP client\n    Client-&gt;&gt;Server: initialize\n    Server--&gt;&gt;Client: capabilities + server info\n    Client--&gt;&gt;Server: notifications/initialized</code></pre> <p>During initialization:</p> <ol> <li>Protocol versions are negotiated</li> <li>Supported primitives (tools, resources, prompts, notifications) are declared</li> <li>Both sides know exactly what is allowed for the lifetime of the session</li> </ol> <p>This prevents undefined behavior and unsafe assumptions.</p>"},{"location":"blog/20260107/20260107/#13-tool-discovery-and-execution","title":"1.3 Tool Discovery and Execution","text":"<p>Once initialized, clients dynamically discover server capabilities.</p> <p>Tool Discovery &amp; Tool Execution</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Server\n\n    Note over Client, Server: Phase 1: Discovery\n    Client-&gt;&gt;Server: tools/list\n    Server--&gt;&gt;Client: tool definitions (schemas, descriptions)\n\n    Note over Client: AI analyzes tools &amp; selects action\n\n    Note over Client, Server: Phase 2: Execution\n    Client-&gt;&gt;Server: tools/call\n    Server--&gt;&gt;Client: structured result</code></pre> <p>The AI now knows:</p> <ul> <li>What tools exist</li> <li>What inputs they accept</li> <li>What actions are possible</li> </ul> <p>This structured flow enables safe, typed, auditable actions instead of free-form command execution.</p>"},{"location":"blog/20260107/20260107/#14-why-use-mcp","title":"1.4 Why use MCP?","text":"<p>MCP solves the fragmentation problem between AI models and infrastructure. Instead of building custom integrations for every new AI tool, MCP provides a universal standard for connecting data and systems.</p> <ul> <li> <p>Write Once, Run Anywhere: Developers build a single MCP server for their infrastructure (like free5GC). This server instantly works with any MCP-compliant client (Claude Desktop, IDEs, etc.), removing the need to maintain separate adapters for different AI platforms.</p> </li> <li> <p>Real-Time Context, Not Training Data: LLMs are limited by their training cutoff. MCP allows the AI to query the current state of the system (e.g., \"Is the UPF running?\"), ensuring answers are based on live reality rather than outdated information.</p> </li> <li> <p>Safety &amp; Control: MCP provides a strict boundary between the AI and the system. The AI cannot execute arbitrary commands; it can only request to use specific, pre-defined tools. This ensures that even powerful models operate within a safe, typed, and human-supervised sandbox.</p> </li> </ul>"},{"location":"blog/20260107/20260107/#2-system-architecture-free5gc-mcp","title":"2. System Architecture: free5GC-MCP","text":"<p>The free5GC-MCP server acts as a control-plane facade that sits above existing free5GC management interfaces.</p> <p></p> <ul> <li> <p>Built with Go: The server is written in Golang to be fast and reliable. It acts like a translator: it listens to the AI's requests and converts them into actual commands for the network.</p> </li> <li> <p>Connects to free5GC: Instead of using separate tools, this server talks to everything at once. It manages the WebConsole for users, runs Scripts to start/stop the core, and connects to Kubernetes for cloud setups.</p> </li> <li> <p>Follows Strict Rules: The AI isn't allowed to guess. It must pick from a specific list of approved tools (like \"login\" or \"create subscriber\"). This prevents the AI from making mistakes or running dangerous commands.</p> </li> </ul>"},{"location":"blog/20260107/20260107/#3-free5gc-mcp-protocol-flow-step-by-step-walkthrough","title":"3. free5GC-MCP Protocol Flow: Step by step walkthrough","text":"<p>The server is configured through <code>config/config.yaml</code>.</p> <pre><code>server:\n  addr: \"127.0.0.1:8080\"\n  api_token: \"\"\n  api_token_type: \"\"\n\nfree5gc:\n  webui_base_url: \"http://127.0.0.1:30500\"\n  username: \"admin\"\n  password: \"free5gc\"\n  free5gc_path: \"/home/you/free5gc\"\n\nk8s:\n  k8s_tool: \"microk8s\"\n  namespace: \"free5gc\"\n</code></pre> <p>Practical security model:</p> <ul> <li>Bind to localhost by default</li> <li>Treat MCP API tokens as administrative credentials</li> <li>Restrict <code>sudo</code> access to specific scripts only</li> </ul> <p>The threat model is explicit: MCP is a privileged control interface and should be exposed accordingly.</p>"},{"location":"blog/20260107/20260107/#31-capability-negotiation-initialization","title":"3.1 Capability Negotiation (Initialization)","text":"<p>Upon connection, the MCP client and server agree on an MCP protocol version. This ensures forward compatibility as tool semantics evolve.</p> <pre><code>curl -s http://127.0.0.1:8080/ \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"method\": \"initialize\",\n    \"params\": {\n      \"protocolVersion\": \"2025-03-26\"\n    }\n  }'\n</code></pre> <p>The server responds with its supported capabilities, forming a contract for the session.</p>"},{"location":"blog/20260107/20260107/#32-tool-discovery-defining-the-operational-surface","title":"3.2 Tool Discovery: Defining the Operational Surface","text":"<p>The <code>tools/list</code> method exposes the entire operational vocabulary available to the client.</p> <pre><code>curl -s http://127.0.0.1:8080/ \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"method\": \"tools/list\",\n    \"params\": {}\n  }'\n</code></pre> <p>Tools are grouped by responsibility:</p> Category Tools Subscriber Management (CRUD) <code>subscriber_list</code>, <code>subscriber_get</code>, <code>subscriber_create</code>, <code>subscriber_create_multiple</code>, <code>subscriber_update</code>, <code>subscriber_patch</code>, <code>subscriber_delete</code>, <code>subscriber_delete_multiple</code> Local free5GC lifecycle <code>local_free5gc_start</code>, <code>local_free5gc_stop</code>, <code>local_free5gc_status</code> Kubernetes / Helm orchestration <code>k8s_start_free5gc</code>, <code>k8s_stop_free5gc</code>, <code>k8s_free5gc_status</code>, <code>k8s_upgrade_free5gc</code>, <code>k8s_start_ueransim</code>, <code>k8s_stop_ueransim</code>, <code>k8s_ueransim_status</code>, <code>k8s_list_network_func</code>, <code>k8s_update_nfconfig</code>, <code>k8s_set_free5gc_helm_base_path</code> <p>Each tool is accompanied by an <code>inputSchema</code>, enabling strict validation before execution.</p>"},{"location":"blog/20260107/20260107/#33-deterministic-execution-via-toolscall","title":"3.3 Deterministic Execution via <code>tools/call</code>","text":"<p>Tool invocation is explicit and unambiguous.</p> <pre><code>curl -s http://127.0.0.1:8080/ \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 3,\n    \"method\": \"tools/call\",\n    \"params\": {\n      \"name\": \"subscriber_list\",\n      \"arguments\": {}\n    }\n  }'\n</code></pre> <p>Responses are returned as MCP <code>content</code> blocks (typically <code>type: text</code>) along with a high-level status. From an AI perspective, this is crucial: the result is structured, interpretable, and safe to reason about.</p>"},{"location":"blog/20260107/20260107/#4-how-the-mcp-server-enforces-safety","title":"4. How the MCP Server Enforces Safety","text":"<p>The implementation is intentionally modular, with clear separation between protocol handling and operational logic.</p>"},{"location":"blog/20260107/20260107/#41-server-bootstrap-and-dependency-injection","title":"4.1 Server Bootstrap and Dependency Injection","text":"<p>At startup, the server:</p> <ol> <li>Loads YAML configuration</li> <li>Instantiates a <code>Free5GCClient</code> for WebConsole access</li> <li>Optionally initializes Kubernetes/Helm managers</li> <li>Binds MCP handlers to the Gin router</li> </ol> <pre><code>cfg, err := config.Load(*configPath)\nif err != nil {\n    log.Fatalf(\"failed to load config: %v\", err)\n}\n\nclient := control.NewFree5GCClient(\n    cfg.Free5GC.BaseURL,\n    cfg.Free5GC.Username,\n    cfg.Free5GC.Password,\n    cfg.Free5GC.Free5GCPath,\n)\n\nr := api.SetupRouter(client, authCfg)\n_ = r.Run(cfg.Server.Addr)\n</code></pre> <p>This wiring makes the server stateless with respect to MCP sessions, which simplifies reliability and restart semantics.</p>"},{"location":"blog/20260107/20260107/#42-resilient-authentication-against-webconsole","title":"4.2 Resilient Authentication Against WebConsole","text":"<p>The <code>Free5GCClient</code> encapsulates WebConsole authentication. Tokens are refreshed transparently when a request encounters <code>401</code> or <code>403</code>.</p> <pre><code>if resp.StatusCode == http.StatusUnauthorized || resp.StatusCode == http.StatusForbidden {\n    resp.Body.Close()\n    if err := c.Login(); err != nil {\n        return nil, fmt.Errorf(\"re-login failed: %w\", err)\n    }\n    return c.doRequest(method, path, bytes.NewReader(bodyBytes), headers)\n}\n</code></pre> <p>This design is critical for long-lived MCP sessions, where token expiry should not surface as an operational failure.</p>"},{"location":"blog/20260107/20260107/#5-examples-of-workflows-enabled-by-mcp","title":"5. Examples of Workflows Enabled by MCP","text":"<p>By bridging natural language processing with the 5G core's API and Kubernetes layer, MCP transforms complex operational sequences into simple, conversational interactions. Below are the key workflows currently enabled.</p>"},{"location":"blog/20260107/20260107/#51-workflow-a-unified-lifecycle-management","title":"5.1 Workflow A \u2014 Unified Lifecycle Management","text":"<p>Whether running locally on bare metal or orchestrating a cloud-native deployment, MCP abstracts the underlying complexity of starting and stopping the network.</p> <p>1. Local Development Control For local testing, the <code>local_free5gc_start</code> and <code>local_free5gc_stop</code> tools handle the orchestration of all 11 Network Functions (NFs). The agent verifies that the WebConsole is accessible and that services are healthy before confirming success to the user.</p> <p></p> <p>A split-screen view showing the MCP Chat interface confirming \"free5GC has been started successfully\" alongside a terminal window displaying the Gin server logs (HTTP 200 responses) indicating the 11 NFs are active.</p> <p>2. Kubernetes and Helm Orchestration In Kubernetes environments, the complexity increases. MCP exposes specific tools to manage Helm charts directly, allowing users to spin up the core or simulation tools without memorizing <code>kubectl</code> or <code>helm</code> commands. * <code>k8s_start_free5gc</code>: Deploys or upgrades the core network chart. * <code>k8s_start_ueransim</code>: Spins up the UE and gNodeB simulators to generate traffic.</p> <p></p> <p>The VS Code interface showing the agent executing <code>k8s_start_ueransim</code>. The output panel displays the \"Running\" status of both the <code>ueransim-gnb</code> and <code>ueransim-ue</code> pods, confirming the simulation is live.</p>"},{"location":"blog/20260107/20260107/#52-workflow-b-subscriber-inventory-and-provisioning","title":"5.2 Workflow B \u2014 Subscriber Inventory and Provisioning","text":"<p>Managing User Equipment (UE) data is often the most repetitive task in a 5G lab. MCP creates a seamless loop between the database and the operator.</p> <p>1. Instant Visibility (Read Operations) Instead of navigating through multiple WebUI tabs, an engineer can simply ask, \"Show me current subscribers in a table.\" The agent triggers <code>subscriber_list</code>, retrieving the IMSI, PLMN ID, and status directly from the database and formatting it for immediate review.</p> <p></p> <p>A side-by-side comparison. On the left, the free5GC WebUI displays a list of subscribers. On the right, the MCP Chat interface renders that same data into a clean, text-based table format in response to the prompt \"show me current subscribers in a table.\"</p> <p>2. Bulk Provisioning (Write Operations) Populating a test environment usually requires tedious manual entry. With MCP, users can describe their intent naturally. * Prompt: \"Add 3 subscribers: imsi-208930000000111, ...222, ...333\" * Result: The agent parses the request, applies default templates (authentication keys, slice selection), and executes <code>subscriber_create</code> for each entry.</p> <p></p> <p>The agent processing a request to \"Add 3 subscribers\" by running the <code>subscriber_create</code> tool three consecutive times. The left side shows the WebUI instantly reflecting the three new IMSIs registered under PLMN ID 20893.</p>"},{"location":"blog/20260107/20260107/#53-workflow-c-complex-configuration-chaining","title":"5.3 Workflow C \u2014 Complex Configuration Chaining","text":"<p>Perhaps the most powerful capability of MCP is chaining tools to perform atomic infrastructure updates. Changing a network parameter often requires a config update, a Helm upgrade, and a restart of dependent services.</p> <p>Example Scenario: Changing the SMF IP Pool A user wants to change the PDU Session IP range to <code>10.2.0.0/17</code>. This involves a multi-step dependency chain that the agent handles autonomously:</p> <ol> <li>Configuration Update: The agent calls <code>k8s_update_nfconfig</code> to patch the Session Management Function (SMF) configuration.</li> <li>Deployment Upgrade: It triggers <code>k8s_upgrade_free5gc</code> to apply the new ConfigMap to the cluster.</li> <li>Simulation Restart: To ensure the UEs pick up the new IP addresses, the agent executes <code>k8s_stop_ueransim</code> followed immediately by <code>k8s_start_ueransim</code>.</li> </ol> <p></p> <p>A complex workflow demonstration. The chat history shows a \"Todo\" list where the agent automatically planned and executed four distinct tasks: updating the config, upgrading the Helm chart, stopping the simulator, and restarting it. The terminal below verifies success with an <code>ip a</code> command showing the UE interface now holds an IP from the new <code>10.2.0.0/17</code> subnet.</p> <p>The result is a fully reconfigured network and a restarted simulation environment from a single natural language prompt, significantly reducing the risk of human error during configuration rollouts.</p>"},{"location":"blog/20260107/20260107/#6-closing-thoughts","title":"6. Closing Thoughts","text":"<p>free5GC-MCP represents a fundamental shift from manual, error-prone lab management to a structured, intent-driven architecture. By wrapping the free5GC WebConsole, local scripts, and Kubernetes operations in a robust Go-based MCP server, we have successfully bridged the gap between strict 3GPP compliance and the flexibility of AI agents.</p> <p>This project proves that we don't need to sacrifice safety for convenience. By enforcing strict tool contracts and JSON schemas, we ensure that every AI action\u2014from bulk subscriber provisioning to complex Helm upgrades\u2014is authenticated, validated, and auditable. Ultimately, free5GC-MCP transforms the 5G Core from a system you laboriously operate into a platform you can intelligently orchestrate.</p>"},{"location":"blog/20260107/20260107/#credits","title":"Credits","text":"<p>A huge thank you to my colleagues for their collaboration, insights, and support on this journey:</p> <ul> <li> <p>\ud83d\ude4c Jason Kuo</p> </li> <li> <p>\ud83d\udd25 Ji-Jun Lin</p> </li> <li> <p>\u26a1 Hung-Pei Chen</p> </li> </ul>"},{"location":"blog/20260107/20260107/#references","title":"References","text":"<ul> <li>GitHub: free5gc-MCP</li> <li>MCP: Specs (2025-11-25)</li> <li>MCP: Architecture overview</li> </ul>"},{"location":"blog/20260107/20260107/#about","title":"About","text":"<p>Hey it's Warren! currently exploring 5G Core and working with free5GC. I\u2019m just learning how things work in practice and building as I go. Still early in the journey, but enjoying the process and learning a lot along the way. I would love to connect with you!</p>"},{"location":"blog/20260107/20260107/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: Ng Warren</li> </ul>"},{"location":"blog/20260114/20260114/","title":"Introduction of iperf3 and iftop","text":"<p>Note</p> <p>Author: Wei, Chang Date: 2026/01/14</p>"},{"location":"blog/20260114/20260114/#introduction","title":"Introduction","text":"<p>free5GC requires measuring dataplane (GTP\u2011U) maximum available bandwidth and behavior to ensure it can carry UE traffic under high load or production-like conditions. We use <code>iperf3</code> as a controllable traffic generator and throughput measurement tool, paired with <code>iftop</code> to observe per-connection bandwidth usage and direction in real time on UPF interfaces (for example, monitor outer GTP\u2011U traffic on <code>upfgtp</code>).</p>"},{"location":"blog/20260114/20260114/#what-is-iperf3","title":"What is iperf3?","text":"<p>A tool for network performance measurement and traffic generation, commonly used to evaluate throughput between two endpoints, and in UDP mode it can measure jitter and loss. It uses a client/server architecture: one side runs the server to listen, the other runs the client to initiate tests.</p>"},{"location":"blog/20260114/20260114/#tcp-mode-default","title":"TCP mode (default)","text":"<ul> <li>Measures achievable throughput (in Mbits/s or Gbits/s).</li> <li>Displays retransmissions (<code>Retr</code> in output), useful to identify reliability/stability issues.</li> <li>Reflects actual transfer capability under congestion control interactions (e.g., TCP window, RTT, and retransmissions).</li> </ul> <p>Use cases: validate link capacity, end-to-end available throughput, or test core network dataplane under different loads.</p>"},{"location":"blog/20260114/20260114/#udp-mode-u","title":"UDP mode (<code>-u</code>)","text":"<ul> <li>Sends packets at a target rate (client can specify bitrate with <code>-b</code>).</li> <li>Measures jitter and packet loss\u2014important QoS indicators.</li> </ul> <p>Use cases: evaluate latency-sensitive or real-time applications (VoIP, video streaming), or pressure-test forwarding capacity and loss behavior with a fixed send rate.</p> <p>Common options (summary):</p> <ul> <li><code>-c &lt;host&gt;</code> / <code>--client &lt;host&gt;</code>: run in client mode connecting to specified host.</li> <li><code>-s</code> / <code>--server</code>: start server mode (accept connections).</li> <li><code>-t &lt;seconds&gt;</code>: test duration in seconds (default 10).</li> <li><code>-P &lt;num&gt;</code>: number of parallel streams.</li> <li><code>-R</code>: reverse mode\u2014server sends to client (tests DN\u2192UE).</li> <li><code>-d</code>: bidirectional test.</li> <li><code>-J</code>: output JSON format.</li> <li><code>--bind-dev &lt;iface&gt;</code>: bind source interface or source IP.</li> </ul>"},{"location":"blog/20260114/20260114/#iftop","title":"iftop","text":"<ul> <li> <p>What is iftop: an interactive interface bandwidth monitoring tool that shows per-connection (IP:port) real-time bandwidth usage on a specified interface, including short/medium/long averages.</p> </li> <li> <p>Why use iftop:</p> <ul> <li>Quickly identify which interface or connection is consuming bandwidth\u2014suitable for real-time troubleshooting and initial diagnosis.</li> <li>Shows direction and rate per connection, helpful during high-traffic tests to confirm traffic source/direction (e.g., DN\u2192UE vs UE\u2192DN).</li> <li>Low startup and observation overhead; suitable as a runtime monitoring tool during tests.</li> </ul> </li> </ul> <p>Common options (summary):</p> <ul> <li><code>-i &lt;iface&gt;</code>: specify interface to watch.</li> <li><code>-n</code>: do not resolve hostnames.</li> <li><code>-N</code>: show port numbers instead of service names.</li> <li><code>-P</code>: show port-related info.</li> <li><code>-t</code>: text output mode.</li> <li><code>-B</code>: show rates in bytes/s (default is bits/s).</li> <li><code>-M</code>: set the maximum value for the top scale of the output interface</li> </ul>"},{"location":"blog/20260114/20260114/#test-environment-overview-free5gc","title":"Test Environment Overview (free5GC)","text":"<p>Using free5gc-compose as an example, the main containers used in experiments are <code>ue</code>, <code>upf</code>, and the data network <code>iperf-server</code>. Typical example IPs include the UE PDU IP (e.g., <code>10.60.0.1</code>), the DN (e.g., <code>10.100.200.100</code>), and the Docker private network <code>10.100.200.0/24</code>. The UPF important interface is <code>upfgtp</code> (GTP\u2011U outer), where outer GTP\u2011U traffic can be monitored.</p> <p></p>"},{"location":"blog/20260114/20260114/#preparation-install-tools","title":"Preparation (install tools)","text":"<p>After adding an <code>iperf-server</code> service to <code>docker-compose.yaml</code>, start the container:</p> <pre><code>iperf-server:\n  container_name: iperf-server\n  image: networkstatic/iperf3:latest\n  command: [\"iperf3\", \"-s\"]\n  networks:\n    privnet:\n      ipv4_address: 10.100.200.100\n</code></pre> <p>Install required tools inside containers:</p> <ul> <li> <p>In the <code>ue</code> container: <pre><code>apt update &amp;&amp; apt install -y iperf3\n</code></pre></p> </li> <li> <p>In the <code>upf</code> container: <pre><code>apt update &amp;&amp; apt install -y iftop\n</code></pre></p> </li> </ul>"},{"location":"blog/20260114/20260114/#tcp-mode","title":"TCP mode","text":""},{"location":"blog/20260114/20260114/#ue-dn-iperf-server","title":"UE \u2192 DN (iperf-server)","text":""},{"location":"blog/20260114/20260114/#run-iperf3","title":"Run iperf3","text":"<ul> <li>Replace <code>10.100.200.100</code> with your actual DN IP.</li> </ul> <pre><code>docker exec ue iperf3 -c 10.100.200.100 --bind-dev uesimtun0 -t 20\n</code></pre> <p>Notes:</p> <ul> <li><code>-c &lt;host&gt;</code>: target host (client mode).</li> <li><code>--bind-dev &lt;iface&gt;</code>: bind source interface or source IP (e.g., <code>uesimtun0</code>).</li> <li><code>-t &lt;seconds&gt;</code>: test duration.</li> </ul> <p></p> <p>Table field descriptions:</p> <ul> <li><code>Interval</code>: statistics time window (default per-second).</li> <li><code>Transfer</code>: amount of data successfully transferred during the interval.</li> <li><code>Bitrate</code>: average throughput for the interval (bits/sec).</li> <li><code>Retr</code>: TCP retransmissions in the interval.</li> <li><code>Cwnd</code>: TCP congestion window at the end of the interval (KBytes).</li> </ul>"},{"location":"blog/20260114/20260114/#run-iftop","title":"Run iftop","text":"<p><pre><code>docker exec -it upf iftop -i upfgtp -nB -m 500M\n</code></pre> Notes:</p> <ul> <li><code>-i upfgtp</code>: interface to watch (<code>upfgtp</code>, GTP\u2011U outer).</li> <li><code>-n</code>: do not resolve hostnames; show numeric IPs (suitable for container environments to avoid DNS delays or name masking).</li> <li><code>-N</code>: show port numbers instead of service names (e.g., 5201 instead of iperf3).</li> <li><code>-P</code>: show port-related info (list source/destination ports).</li> <li><code>-B</code>: show rates in bytes/s (default is bits/s), making large values more readable.</li> <li><code>-m 500M</code>: set the iftop scale or maximum display value to 500M (unit depends on <code>-B</code> for bytes or bits), useful to adjust display scale for high traffic.</li> </ul> <p></p> <p>Notes:</p> <ul> <li>The white bar charts are visualizations (recent 2s, 10s, 40s averages).</li> <li>Three rate columns (short/medium/long): averages over different windows; typically left\u2192right corresponds to ~2s, ~10s, ~40s averages (depends on iftop version).</li> <li>Bottom statistics (TX/RX / TOTAL): show cumulative (Cum), peak (Peak), and three-rate averages (Rates).</li> </ul>"},{"location":"blog/20260114/20260114/#once-inside-the-interface","title":"Once inside the interface","text":"<p>Press <code>T</code> to show totals for each row (Totals), useful for viewing overall transmitted amounts.</p> <p></p> <p>Press <code>t</code> to switch to single-line display (single-line mode); in this mode you can toggle showing send-only, receive-only, or combined send/receive.</p> <p></p> <p>Press <code>B</code> to adjust the timescale windows used for the progress bars (recent 2, 10, 40 seconds), which helps observe short/medium/long-term rate differences.</p> <p></p>"},{"location":"blog/20260114/20260114/#dn-iperf-server-ue","title":"DN (iperf-server) -&gt; UE","text":"<p>Use <code>-R</code> (reverse) so the server sends data to the client (DN \u2192 UE); run the client on UE and the server will send traffic back to the UE:</p> <p><pre><code>docker exec ue iperf3 -c 10.100.200.100 --bind-dev uesimtun0 -t 20 -P 4 -R\n</code></pre> </p>"},{"location":"blog/20260114/20260114/#udp-mode","title":"UDP mode","text":"<p>In UDP mode, iperf3 prints jitter and packet loss statistics on the receiver (server):</p> <pre><code>docker exec ue iperf3 -c 10.100.200.100 --bind-dev uesimtun0 -u -b 300M\n</code></pre> <p></p> <p></p> <p>Notes:</p> <ul> <li>The above image comes from the <code>iperf-server</code> output (<code>docker logs iperf-server</code>), showing receiver-side <code>Jitter</code> (ms) and <code>Lost/Total Datagrams</code>.</li> </ul>"},{"location":"blog/20260114/20260114/#conclusion","title":"Conclusion","text":"<p>Combining interface-level real-time observation (<code>iftop</code>) with end-to-end measurement (<code>iperf3</code>) enables quick and accurate localization of dataplane issues and directs corrective actions:</p> <ul> <li>When measuring TCP with iperf3 (iftop showing the TCP traffic), the interface observed about 55\u201360 MB/s (\u2248 440\u2013480 Mbps).</li> <li>When measuring UDP with iperf3 and setting the target rate to 300 Mbps, the observed received throughput was about 200\u2013287 Mbps, with packet loss rates as high as 14%\u201329%, indicating that substantial packet loss significantly reduces effective throughput.</li> </ul> <p>Combine interface and end-to-end statistics to determine whether traffic is being dropped along the path or whether differences are due to protocol-layer behavior (TCP vs UDP).</p>"},{"location":"blog/20260114/20260114/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: https://github.com/wiwi878</li> </ul>"},{"location":"blog/20260121/20260121/","title":"Analyzing NF Discovery Requests:  Step-by-Step Trace of NFSelect Queries","text":"<p>Note</p> <p>Author: Che-Wei Lin Date: 2026/1/21</p>"},{"location":"blog/20260121/20260121/#introduction","title":"Introduction","text":"<p>The Network Repository Function (NRF) serves as the service discovery backbone of the 5G Core network, enabling every network function to discover and select peers dynamically. In a Service-Based Architecture (SBA), NFs do not have static configurations for their peers; instead, they rely on the NRF to provide real-time status and endpoint information for available services. </p> <p>In this article, we'll walk through underlying architecture of the Nnrf_NFDiscovery service, the specific query parameters required for NF selection, and practical methods for capturing SBI traffic using tcpdump.</p>"},{"location":"blog/20260121/20260121/#1-nf-discovery-architecture","title":"1. NF Discovery Architecture","text":""},{"location":"blog/20260121/20260121/#the-discovery-endpoint","title":"The Discovery Endpoint","text":"<p>In free5GC, the NRF exposes the Nnrf_NFDiscovery service at: </p> <pre><code>GET http://&lt;nrf-ip&gt;:&lt;port&gt;/nnrf-disc/v1/nf-instances\n</code></pre> <p>This endpoint is implemented in: </p> <pre><code>// File: internal/sbi/api_discovery.go\n\nfunc (s *Server) getNfDiscoveryRoutes() []Route {\n    return []Route{\n        {\n            \"SearchNFInstances\",\n            http.MethodGet,\n            \"/nf-instances\",\n            s. HTTPSearchNFInstances,\n        },\n    }\n}\n\nfunc (s *Server) HTTPSearchNFInstances(c *gin.Context) {\n    s. Processor().HandleNFDiscoveryRequest(c, c.Request.URL.Query())\n}\n</code></pre>"},{"location":"blog/20260121/20260121/#request-flow-overview","title":"Request Flow Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 NF (e.g.\u2502 GET  \u2502   NRF SBI   \u2502      \u2502  Discovery   \u2502      \u2502 MongoDB \u2502\n\u2502   AMF)  \u2502\u2500\u2500\u2500\u2500\u2500&gt;\u2502   Server    \u2502\u2500\u2500\u2500\u2500\u2500&gt;\u2502  Processor   \u2502\u2500\u2500\u2500\u2500\u2500&gt;\u2502  Query  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u2502                   \u2502                      \u2502                   \u2502\n    \u2502                   \u2502                      \u2502                   \u2502\n    \u2502                   \u2502                      \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502                   \u2502                      \u2502  NF Profiles      \u2502\n    \u2502                   \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                   \u2502\n    \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  200 OK + JSON       \u2502                   \u2502\n    \u2502  NF Profile List  \u2502                      \u2502                   \u2502\n</code></pre>"},{"location":"blog/20260121/20260121/#the-core-processing-functions","title":"The Core Processing Functions","text":"<p>The discovery request goes through these key functions:</p> <ol> <li><code>HandleNFDiscoveryRequest</code> - HTTP handler (entry point)</li> <li><code>validateQueryParameters</code> - Validates mandatory parameters</li> <li><code>NFDiscoveryProcedure</code> - Main processing logic</li> <li><code>buildFilter</code> - Constructs MongoDB filter from query params</li> <li><code>mongoapi.RestfulAPIGetMany</code> - Queries the NfProfile collection</li> </ol>"},{"location":"blog/20260121/20260121/#2-query-parameters","title":"2. Query Parameters","text":"<p>free5GC NRF supports 32+ query parameters for fine-grained NF selection.  Here are the most important ones:</p>"},{"location":"blog/20260121/20260121/#mandatory-parameters","title":"Mandatory Parameters","text":"Parameter Type Description Example <code>target-nf-type</code> string Type of NF to discover <code>SMF</code>, <code>UDM</code>, <code>PCF</code> <code>requester-nf-type</code> string Type of requesting NF <code>AMF</code>, <code>SMF</code> <p>Note: Both parameters are required.  Missing either will result in HTTP 400 error with \"Loss mandatory parameter\". </p>"},{"location":"blog/20260121/20260121/#common-optional-parameters","title":"Common Optional Parameters","text":"Parameter Description Example Query MongoDB Filter Impact <code>target-plmn-list</code> PLMN ID for roaming scenarios <code>[{\"mcc\":\"208\",\"mnc\":\"93\"}]</code> Adds <code>$elemMatch</code> on <code>plmnList</code> <code>snssais</code> Network slice selection <code>[{\"sst\":1,\"sd\":\"010203\"}]</code> Filters by <code>sNssais</code> array <code>dnn</code> Data Network Name <code>internet</code> Checks SMF/UPF <code>dnnSmfInfoList</code> <code>preferred-locality</code> Geographic preference <code>area1</code> Filters by <code>locality</code> field"},{"location":"blog/20260121/20260121/#how-parameters-map-to-mongodb-filters","title":"How Parameters Map to MongoDB Filters","text":"<p>Based on actual trace logs from our experiments, the <code>buildFilter()</code> function converts query parameters to BSON filters:</p> <pre><code>File: internal/sbi/processor/nf_discovery.go\n</code></pre> <p>Input Parameters: <pre><code>target-nf-type=SMF\nrequester-nf-type=AMF\nsnssais=[{\"sst\":1,\"sd\":\"010203\"}]\ndnn=internet\n</code></pre></p> <p>Generated MongoDB Filter: <pre><code>map[$and:[\n  map[nfType: SMF]\n  map[$or:[\n    map[allowedNfTypes:AMF]\n    map[allowedNfTypes:map[$exists:false]]\n  ]]\n  map[$or:[\n    map[sNssais: map[$elemMatch: map[sd:010203 sst:1]]]\n    map[sNssais:map[$exists:false]]\n  ]]\n  map[smfInfo. sNssaiSmfInfoList: map[$elemMatch:map[dnnSmfInfoList:map[$elemMatch:map[dnn:internet]]]]]\n]]\n</code></pre></p>"},{"location":"blog/20260121/20260121/#3-capturing-discovery-with-tcpdump","title":"3. Capturing Discovery with tcpdump","text":""},{"location":"blog/20260121/20260121/#step-1-setup-environment","title":"Step 1: Setup Environment","text":"<p>Ensure your free5GC deployment is running: </p> <pre><code># Start free5GC\ncd ~/free5gc\n./run. sh\n\n# Verify NRF is running\ncurl http://127.0.0.10:8000/nnrf-nfm/v1/nf-instances\n</code></pre>"},{"location":"blog/20260121/20260121/#step-2-enable-trace-logging","title":"Step 2: Enable Trace Logging","text":"<p>Before running experiments, modify your NRF configuration:</p> <pre><code># File: config/nrfcfg.yaml\n\nlogger:\n  enable: true\n  level: trace      # Change from 'info' to 'trace'\n  reportCaller: true # Change from 'false' to 'true'\n</code></pre> <p>Then restart free5GC to apply changes: <pre><code># Stop free5GC\n./force_kill.sh\n\n# Restart\n./run.sh\n</code></pre></p>"},{"location":"blog/20260121/20260121/#step-3-start-tcpdump","title":"Step 3: Start tcpdump","text":"<p>Capture SBI traffic on the NRF interface:</p> <pre><code># Capture on loopback (if running locally)\nsudo tcpdump -i lo -w nrf-discovery.pcap \\\n  'tcp port 8000 and host 127.0.0.10'\n\n# For Docker deployments, capture on bridge network\nsudo tcpdump -i br-&lt;network-id&gt; -w nrf-discovery.pcap \\\n  'tcp port 8000'\n</code></pre>"},{"location":"blog/20260121/20260121/#step-4-trigger-a-discovery-request","title":"Step 4: Trigger a Discovery Request","text":"<p>Simulate an AMF discovering an SMF:</p> <pre><code>curl -v -X GET \"http://127.0.0.10:8000/nnrf-disc/v1/nf-instances?\\\ntarget-nf-type=SMF&amp;\\\nrequester-nf-type=AMF&amp;\\\nsnssais=[{\\\"sst\\\":1,\\\"sd\\\": \\\"010203\\\"}]&amp;\\\ndnn=internet\" | jq .\n</code></pre>"},{"location":"blog/20260121/20260121/#step-5-analyze-the-capture","title":"Step 5: Analyze the Capture","text":"<pre><code># Convert to text for analysis\ntcpdump -r nrf-discovery.pcap -A | less\n\n# Or use tshark for better HTTP/2 analysis\ntshark -r nrf-discovery.pcap -Y \"http2\" -T fields \\\n  -e http2.header.name -e http2.header.value\n</code></pre>"},{"location":"blog/20260121/20260121/#actual-packet-capture-results","title":"Actual Packet Capture Results","text":"<p>Pcap File Statistics:</p> <ul> <li>Total packets captured: 343</li> <li>Capture file size: 53KB</li> <li>Discovery requests captured: 12 (including retries)</li> <li>Timestamp range: 12:28:30 - 13:57:32</li> </ul>"},{"location":"blog/20260121/20260121/#tcp-three-way-handshake","title":"TCP Three-Way Handshake","text":"<pre><code>12:28:30.489378 IP 127.0.0.1.38436 &gt; 127.0.0.10.8000: Flags [S], seq 766027190, win 65495\n12:28:30.489408 IP 127.0.0.10.8000 &gt; 127.0.0.1.38436: Flags [S.], seq 2423474686, ack 766027191\n12:28:30.489418 IP 127.0.0.1.38436 &gt; 127.0.0.10.8000: Flags [.], ack 1, win 512\n</code></pre> <p>Analysis: Connection established in 30 microseconds (489378 \u2192 489408 \u2192 489418)</p>"},{"location":"blog/20260121/20260121/#http-request-smf-discovery","title":"HTTP Request (SMF Discovery)","text":"<pre><code>12:28:30.489529 IP 127.0.0.1.38436 &gt; 127.0.0.10.8000: Flags [P.], seq 1:291, length 290\n\nGET /nnrf-disc/v1/nf-instances?target-nf-type=SMF&amp;requester-nf-type=AMF&amp;snssais=%5B%7B%22sst%22%3A1%2C%22sd%22%3A%22010203%22%7D%5D&amp;dnn=internet&amp;plmn-id=%7B%22mcc%22%3A%22208%22%2C%22mnc%22%3A%2293%22%7D HTTP/1.1\nHost: 127.0.0.10:8000\nUser-Agent: curl/8.12.1\nAccept: application/json\n</code></pre> <p>Packet Details:</p> <ul> <li>Source: 127.0.0.1:38436 (Client)</li> <li>Destination: 127.0.0.10:8000 (NRF)</li> <li>HTTP Method: GET</li> <li>Payload length: 290 bytes</li> <li>URL-encoded query parameters (note the <code>%5B</code>, <code>%7B</code> encoding)</li> </ul>"},{"location":"blog/20260121/20260121/#http-response-200-ok","title":"HTTP Response (200 OK)","text":"<pre><code>12:28:30.493105 IP 127.0.0.10.8000 &gt; 127.0.0.1.38436: Flags [P.], seq 1:1792, length 1791\n\nHTTP/1.1 200 OK\nContent-Type: application/json; charset=utf-8\nDate: Mon, 05 Jan 2026 12:28:30 GMT\nContent-Length: 1666\n\n{\"validityPeriod\":100,\"nfInstances\":[{\"nfInstanceId\":\"343aee23-749e-4835-a8b9-fb9174a162ca\",\"nfType\":\"SMF\",\"nfStatus\":\"REGISTERED\",\"plmnList\":[{\"mcc\":\"208\",\"mnc\":\"93\"}],\"sNssais\":[{\"sst\":1,\"sd\":\"010203\"},{\"sst\":1,\"sd\":\"112233\"}],\"ipv4Addresses\":[\"127.0.0.2\"],\"locality\":\"area1\",\"smfInfo\":{\"sNssaiSmfInfoList\":[{\"sNssai\":{\"sst\":1,\"sd\":\"010203\"},\"dnnSmfInfoList\":[{\"dnn\":\"internet\"}]},{\"sNssai\":{\"sst\":1,\"sd\":\"112233\"},\"dnnSmfInfoList\":[{\"dnn\":\"internet\"}]}]},\"customInfo\":{\"oauth2\":false},\"nfServices\":[...]}]}\n</code></pre> <p>Response Details:</p> <ul> <li>HTTP Status: 200 OK</li> <li>Content-Type: application/json; charset=utf-8</li> <li>Content-Length: 1666 bytes</li> <li>Total packet length: 1791 bytes (includes HTTP headers)</li> </ul>"},{"location":"blog/20260121/20260121/#complete-transaction-timeline","title":"Complete Transaction Timeline","text":"Time (\u03bcs) Event Packet Size Direction 489378 SYN 60 bytes Client \u2192 NRF 489408 SYN-ACK 60 bytes NRF \u2192 Client 489418 ACK 52 bytes Client \u2192 NRF 489529 GET Request 290 bytes Client \u2192 NRF 489533 ACK 52 bytes NRF \u2192 Client 493105 HTTP 200 Response 1791 bytes NRF \u2192 Client 493114 ACK 52 bytes Client \u2192 NRF 493211 FIN 52 bytes Client \u2192 NRF 493239 FIN-ACK 52 bytes NRF \u2192 Client 493253 ACK 52 bytes Client \u2192 NRF <p>Total Transaction Time: 3.875 milliseconds (from initial SYN to final ACK)</p> <ul> <li>Connection setup: 40\u03bcs</li> <li>Request sent: 111\u03bcs after connection</li> <li>Response received: 3.576ms after request</li> <li>Connection teardown: 148\u03bcs</li> </ul>"},{"location":"blog/20260121/20260121/#other-discovery-requests-in-capture","title":"Other Discovery Requests in Capture","text":"<p>From analyzing the full pcap file, we captured these distinct discovery requests:</p> <pre><code>1. GET /nnrf-disc/v1/nf-instances?target-nf-type=SMF&amp;... \u2192 HTTP/1.1 200 OK\n2. GET /nnrf-disc/v1/nf-instances?target-nf-type=SMF&amp;target-plmn-list=... \u2192 HTTP/1.1 200 OK\n3. GET /nnrf-disc/v1/nf-instances?target-nf-type=UDM&amp;... \u2192 HTTP/1.1 200 OK\n4. GET /nnrf-disc/v1/nf-instances?target-nf-type=AUSF&amp;... \u2192 HTTP/1.1 200 OK\n5. GET /nnrf-disc/v1/nf-instances?requester-nf-type=AMF \u2192 HTTP/1.1 400 Bad Request\n</code></pre> <p>Key Observation: Request #5 returned HTTP 400 because <code>target-nf-type</code> parameter was missing, demonstrating NRF's parameter validation.</p>"},{"location":"blog/20260121/20260121/#hex-dump-analysis-sample","title":"Hex Dump Analysis (Sample)","text":"<p>For deeper packet inspection, here's a hex dump of the HTTP GET request:</p> <pre><code>0x0030:  9748 10e0 4754 5420 2f6e 6e72 662d 6469  .H..GET./nnrf-di\n0x0040:  7363 2f76 312f 6e66 2d69 6e73 7461 6e63  sc/v1/nf-instanc\n0x0050:  6573 3f74 6172 6765 742d 6e66 2d74 7970  es?target-nf-typ\n0x0060:  653d 534d 4626 7265 7175 6573 7465 722d  e=SMF&amp;requester-\n0x0070:  6e66 2d74 7970 653d 414d 4626 736e 7373  nf-type=AMF&amp;snss\n0x0080:  6169 733d 2535 4225 3742 2532 3273 7374  ais=%5B%7B%22sst\n</code></pre> <p>This shows the raw bytes of the HTTP request, with ASCII representation on the right side.</p>"},{"location":"blog/20260121/20260121/#4-correlating-with-free5gc-nrf-logs","title":"4. Correlating with free5GC NRF Logs","text":""},{"location":"blog/20260121/20260121/#enable-trace-level-logging","title":"Enable Trace-Level Logging","text":"<p>As shown in Step 2 above, edit your NRF configuration:</p> <pre><code># File: config/nrfcfg.yaml\n\nlogger:\n  enable: true\n  level: trace  # Critical for seeing MongoDB queries\n  reportCaller:  true # Shows file paths and line numbers\n</code></pre>"},{"location":"blog/20260121/20260121/#key-log-messages-to-look-for","title":"Key Log Messages to Look For","text":""},{"location":"blog/20260121/20260121/#1-request-received","title":"1. Request Received","text":"<pre><code>2026-01-05T10:30:15.456 [INFO][NRF][Disc] Handle NFDiscoveryRequest\n</code></pre> <p>Code Location: <pre><code>File: /home/ubuntu/free5gc/NFs/nrf/internal/sbi/processor/nf_discovery.go\nFunction: (*Processor).HandleNFDiscoveryRequest\n</code></pre></p>"},{"location":"blog/20260121/20260121/#2-query-filter-construction","title":"2. Query Filter Construction","text":"<pre><code>2026-01-05T10:30:15.458 [TRACE][NRF][Disc] Query filter: map[$and:[map[nfType: SMF] map[$or:[map[allowedNfTypes:AMF] map[allowedNfTypes:map[$exists:false]]]] map[$or:[map[sNssais:map[$elemMatch:map[sd:010203 sst: 1]]] map[sNssais: map[$exists:false]]]] map[smfInfo.sNssaiSmfInfoList: map[$elemMatch:map[dnnSmfInfoList:map[$elemMatch:map[dnn: internet]]]]]]]\n</code></pre> <p>Code Location: <pre><code>File: /home/ubuntu/free5gc/NFs/nrf/internal/sbi/processor/nf_discovery. go:131\nFunction: (*Processor).NFDiscoveryProcedure\n</code></pre></p> <p>This log line shows the exact MongoDB filter being executed. </p>"},{"location":"blog/20260121/20260121/#3-http-response-logging","title":"3. HTTP Response Logging","text":"<pre><code>2026-01-05T10:30:15.462 [INFO][NRF][GIN] | 200 |    127.0.0.18 | GET      /nnrf-disc/v1/nf-instances? target-nf-type=SMF&amp;... \n</code></pre> <p>Code Location: <pre><code>File: /home/ubuntu/free5gc/util/logger/logger.go\nFunction: NewGinWithLogrus.ginToLogrus. func1\n</code></pre></p> <p>Shows the complete HTTP request path, response code, and client IP.</p>"},{"location":"blog/20260121/20260121/#4-validation-errors","title":"4. Validation Errors","text":"<p>If parameters are invalid:</p> <pre><code>[WARN][NRF][Disc] Invalid Parameter: Loss mandatory parameter\n</code></pre> <p>Returned to client: <pre><code>{\n  \"title\": \"Invalid Parameter\",\n  \"status\": 400,\n  \"cause\": \"Loss mandatory parameter\"\n}\n</code></pre></p> <p>This follows RFC 7807 Problem Details format.</p>"},{"location":"blog/20260121/20260121/#complete-log-analysis-example","title":"Complete Log Analysis Example","text":"<p>Here's a complete trace for an AMF\u2192SMF discovery with all parameters:</p> <pre><code>2026-01-05T14:23:01.789 [INFO][NRF][GIN] | 200 |    127.0.0.18 | GET      /nnrf-disc/v1/nf-instances?target-nf-type=SMF&amp;requester-nf-type=AMF&amp;snssais=[{\"sst\":1,\"sd\":\"010203\"}]&amp;dnn=internet&amp;target-plmn-list=[{\"mcc\":\"208\",\"mnc\":\"93\"}]\n\n2026-01-05T14:23:01.789 [INFO][NRF][Disc][/home/ubuntu/free5gc/NFs/nrf/internal/sbi/processor/nf_discovery.go:26] Handle NFDiscoveryRequest\n\n2026-01-05T14:23:01.789 [TRACE][NRF][Disc][/home/ubuntu/free5gc/NFs/nrf/internal/sbi/processor/nf_discovery.go:131] Query filter: map[$and:[map[nfType:SMF] map[$or:[map[allowedNfTypes:AMF] map[allowedNfTypes:map[$exists:false]]]] map[$or:[map[plmnList:map[$elemMatch:map[mcc:208 mnc:93]]]]] map[$or:[map[sNssais:map[$elemMatch:map[sd:010203 sst: 1]]] map[sNssais:map[$exists:false]]]] map[smfInfo.sNssaiSmfInfoList: map[$elemMatch:map[dnnSmfInfoList:map[$elemMatch:map[dnn: internet]]]]]]]\n</code></pre> <p>Analysis of this trace:</p> Timestamp Component Message Insight 14:23:01.789 GIN HTTP request logged Client IP: 127.0.0.18 (AMF), GET request with all params 14:23:01.789 Disc HandleNFDiscoveryRequest Entry point at line 26 14:23:01.789 Disc Query filter MongoDB filter with 5 conditions:  type, authorization, PLMN, slice, DNN <p>Total processing time: &lt; 1ms (all logs have same timestamp to millisecond precision)</p>"},{"location":"blog/20260121/20260121/#5-complete-example-amf-discovering-smf-for-pdu-session","title":"5. Complete Example - AMF Discovering SMF for PDU Session","text":"<p>Let's trace a realistic scenario:  An AMF needs to select an SMF to handle a PDU session establishment for a subscriber.</p>"},{"location":"blog/20260121/20260121/#scenario-details","title":"Scenario Details","text":"<ul> <li>Requested Slice: SST=1, SD=010203</li> <li>DNN: internet</li> <li>PLMN: MCC=208, MNC=93</li> <li>Registered SMF: 343aee23-749e-4835-a8b9-fb9174a162ca at 127.0.0.2</li> </ul>"},{"location":"blog/20260121/20260121/#test-case-1-basic-smf-discovery","title":"Test Case 1: Basic SMF Discovery","text":"<p>Request: <pre><code>curl -v -X GET \"http://127.0.0.10:8000/nnrf-disc/v1/nf-instances?\\\ntarget-nf-type=SMF&amp;\\\nrequester-nf-type=AMF&amp;\\\nsnssais=[{\\\"sst\\\":1,\\\"sd\\\": \\\"010203\\\"}]&amp;\\\ndnn=internet\" | jq .\n</code></pre></p> <p>NRF Log Output: <pre><code>[INFO][NRF][Disc] Handle NFDiscoveryRequest\n[TRACE][NRF][Disc] Query filter: map[$and:[map[nfType: SMF] map[$or:[map[allowedNfTypes:AMF] map[allowedNfTypes:map[$exists:false]]]] map[$or:[map[sNssais:map[$elemMatch:map[sd:010203 sst:1]]] map[sNssais:map[$exists:false]]]] map[smfInfo.sNssaiSmfInfoList:map[$elemMatch: map[dnnSmfInfoList:map[$elemMatch:map[dnn:internet]]]]]]]\n</code></pre></p> <p>Response: <pre><code>{\n  \"validityPeriod\": 100,\n  \"nfInstances\": [\n    {\n      \"nfInstanceId\": \"343aee23-749e-4835-a8b9-fb9174a162ca\",\n      \"nfType\": \"SMF\",\n      \"nfStatus\": \"REGISTERED\",\n      \"locality\": \"area1\",\n      \"sNssais\": [\n        {\"sst\":  1, \"sd\": \"010203\"},\n        {\"sst\":  1, \"sd\": \"112233\"}\n      ]\n    }\n  ]\n}\n</code></pre> Analysis:</p> <ul> <li>Discovered 1 SMF instance</li> <li>SMF supports multiple slices (010203 and 112233)</li> <li>Locality field present:  \"area1\" (can be used for preferred-locality filtering)</li> <li>Validity period: 100 seconds (cache TTL)</li> </ul>"},{"location":"blog/20260121/20260121/#test-case-2-discovery-with-plmn-filter","title":"Test Case 2: Discovery with PLMN Filter","text":"<p>Request: <pre><code>curl -v -X GET \"http://127.0.0.10:8000/nnrf-disc/v1/nf-instances?\\\ntarget-nf-type=SMF&amp;\\\nrequester-nf-type=AMF&amp;\\\nsnssais=[{\\\"sst\\\":1,\\\"sd\\\":\\\"010203\\\"}]&amp;\\\ndnn=internet&amp;\\\ntarget-plmn-list=[{\\\"mcc\\\":\\\"208\\\",\\\"mnc\\\":\\\"93\\\"}]\" | jq .\n</code></pre></p> <p>NRF MongoDB Filter: <pre><code>map[$and:[\n  map[nfType:SMF]\n  map[$or:[map[allowedNfTypes:AMF] map[allowedNfTypes: map[$exists:false]]]]\n  map[$or:[map[plmnList:map[$elemMatch: map[mcc:208 mnc:93]]]]]  // \u2190 Added PLMN filter\n  map[$or:[map[sNssais:map[$elemMatch:map[sd:010203 sst: 1]]] map[sNssais:map[$exists:false]]]]\n  map[smfInfo.sNssaiSmfInfoList:map[$elemMatch:map[dnnSmfInfoList:map[$elemMatch:map[dnn:internet]]]]]\n]]\n</code></pre></p> <p>Response: <pre><code>{\n  \"validityPeriod\": 100,\n  \"nfInstances\": [\n    {\n      \"nfInstanceId\": \"343aee23-749e-4835-a8b9-fb9174a162ca\",\n      \"nfType\": \"SMF\",\n      \"ipv4Addresses\": [\"127.0.0.2\"]  // \u2190 IP address included\n    }\n  ]\n}\n</code></pre> Analysis:</p> <ul> <li>Same SMF discovered (PLMN matches)</li> <li>Response now includes <code>ipv4Addresses</code> array</li> <li>Additional filter condition added (PLMN list matching)</li> </ul>"},{"location":"blog/20260121/20260121/#test-case-3-discovering-other-nf-types","title":"Test Case 3: Discovering Other NF Types","text":"<p>UDM Discovery: <pre><code>curl -X GET \"http://127.0.0.10:8000/nnrf-disc/v1/nf-instances?\\\ntarget-nf-type=UDM&amp;\\\nrequester-nf-type=AMF\" | jq .\n</code></pre></p> <p>MongoDB Filter: <pre><code>map[$and:[\n  map[nfType:UDM]\n  map[$or:[map[allowedNfTypes:AMF] map[allowedNfTypes: map[$exists:false]]]]\n]]\n</code></pre></p> <p>Response: <pre><code>{\n  \"validityPeriod\": 100,\n  \"nfInstances\": [\n    {\n      \"nfInstanceId\": \"ed470d29-524f-4beb-9c15-dfa35cb68924\",\n      \"nfType\":  \"UDM\",\n      \"nfStatus\": \"REGISTERED\"\n    }\n  ]\n}\n</code></pre></p> <p>AUSF Discovery: <pre><code>curl -X GET \"http://127.0.0.10:8000/nnrf-disc/v1/nf-instances?\\\ntarget-nf-type=AUSF&amp;\\\nrequester-nf-type=AMF\" | jq .\n</code></pre></p> <p>Response: <pre><code>{\n  \"validityPeriod\": 100,\n  \"nfInstances\": [\n    {\n      \"nfInstanceId\": \"23585e14-1f66-4276-8c6e-8ead28de840c\",\n      \"nfType\":  \"AUSF\",\n      \"nfStatus\": \"REGISTERED\",\n      \"ipv4Addresses\": [\"127.0.0.9\"]\n    }\n  ]\n}\n</code></pre></p> <p>Analysis:</p> <ul> <li>UDM and AUSF discoveries are simpler (no slice/DNN filtering needed)</li> <li>Only type and authorization filters applied</li> <li>Both returned successfully with NF instance IDs and status</li> </ul>"},{"location":"blog/20260121/20260121/#test-case-4-error-handling-missing-mandatory-parameter","title":"Test Case 4: Error Handling - Missing Mandatory Parameter","text":"<p>Request (intentionally missing target-nf-type): <pre><code>curl -X GET \"http://127.0.0.10:8000/nnrf-disc/v1/nf-instances?\\\nrequester-nf-type=AMF\" | jq .\n</code></pre></p> <p>Response: <pre><code>{\n  \"title\": \"Invalid Parameter\",\n  \"status\": 400,\n  \"cause\": \"Loss mandatory parameter\"\n}\n</code></pre></p> <p>HTTP Status: 400 Bad Request Analysis:</p> <ul> <li>Validation happens before database query</li> <li>Returns RFC 7807 Problem Details format</li> <li>No MongoDB query executed</li> </ul>"},{"location":"blog/20260121/20260121/#mongodb-verification","title":"MongoDB Verification","text":"<p>You can manually verify the discovered NF profiles in MongoDB:</p> <pre><code># Connect to MongoDB\nmongosh mongodb://127.0.0.1:27017/free5gc\n\n# Query SMF profiles\ndb.NfProfile.find({\n  \"nfType\": \"SMF\",\n  \"nfStatus\": \"REGISTERED\",\n  \"sNssais\": { \"$elemMatch\": { \"sst\": 1, \"sd\":  \"010203\" } }\n}).pretty()\n</code></pre> <p>Expected Output: <pre><code>{\n  \"_id\": ObjectId(\"...\"),\n  \"nfInstanceId\": \"343aee23-749e-4835-a8b9-fb9174a162ca\",\n  \"nfType\": \"SMF\",\n  \"nfStatus\": \"REGISTERED\",\n  \"heartBeatTimer\": 60,\n  \"plmnList\": [\n    {\"mcc\": \"208\", \"mnc\": \"93\"}\n  ],\n  \"sNssais\": [\n    {\"sst\": 1, \"sd\":  \"010203\"},\n    {\"sst\": 1, \"sd\":  \"112233\"}\n  ],\n  \"ipv4Addresses\": [\"127.0.0.2\"],\n  \"locality\": \"area1\",\n  \"smfInfo\": {\n    \"sNssaiSmfInfoList\":  [\n      {\n        \"sNssai\": {\"sst\": 1, \"sd\": \"010203\"},\n        \"dnnSmfInfoList\": [\n          {\"dnn\": \"internet\"}\n        ]\n      }\n    ]\n  }\n}\n</code></pre></p>"},{"location":"blog/20260121/20260121/#conclusion","title":"Conclusion","text":"<p>In a 5G Service Based Architecture, NF Discovery serves as the critical control mechanism that transforms a collection of isolated microservices into a synchronized, high-performance network. By leveraging the Network Repository Function (NRF) as a centralized service registry, the core evolves beyond static, hard-coded peer-to-peer configurations into a programmable environment. This architecture ensures that service consumers can dynamically bind to the most optimal service producer instance available.</p> <p>This analysis shows how free5GC turns high-level NF discovery requests into concrete MongoDB queries inside the NRF discovery pipeline. By enabling trace-level logging, you can clearly see the exact filter conditions used during NF selection, making the discovery process much more transparent.</p>"},{"location":"blog/20260121/20260121/#reference","title":"Reference","text":"<ul> <li>TS 29.510</li> <li>free5GC</li> </ul>"},{"location":"blog/20260121/20260121/#about","title":"About","text":"<p>Hello! I'm Che Wei, Lin. I\u2019ve recently begun my journey into 5G technology and the free5GC community. I hope you found this blog post helpful, and please feel free to reach out for further discussion.</p>"},{"location":"blog/20260121/20260121/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: Zach1113</li> </ul>"},{"location":"blog/20260128/20260128/","title":"Network Function NSSF Introduction","text":"<p>Note</p> <p>Author: Kai-Hung, Hu Date: 2026/01/28</p>"},{"location":"blog/20260128/20260128/#overview","title":"Overview","text":"<p>In this article, we will introduce the Network Slice Selection Function (NSSF), a key component in the 5G Core (5GC) network architecture. NSSF is responsible for enabling and managing network slicing, one of the most significant innovations brought by 5G. We will explore its role, its two primary services \u2014 <code>Nnssf_NSSelection</code> and <code>Nnssf_NSSAIAvailability</code> \u2014 and analyze the corresponding implementation within the free5GC project.</p> <p>Network slicing allows operators to create multiple virtual networks on top of a shared physical infrastructure. Each slice can be tailored to specific service requirements, such as enhanced Mobile Broadband (eMBB), Ultra-Reliable Low Latency Communications (URLLC), or massive Machine-Type Communications (mMTC). The NSSF plays a central role in selecting the appropriate network slice for a given User Equipment (UE) and ensuring that the right resources are allocated.</p>"},{"location":"blog/20260128/20260128/#what-is-nssf","title":"What is NSSF?","text":"<p>The Network Slice Selection Function (NSSF) is defined in 3GPP TS 29.531. Its primary responsibilities include:</p> <ol> <li>Selecting the set of Network Slice instances: Based on the UE's subscription, requested NSSAI (Network Slice Selection Assistance Information), and operator policies, the NSSF determines which slice instances should serve the UE.</li> <li> <p>Determining the Allowed NSSAI and Configured NSSAI Mappings: The NSSF determines which S-NSSAIs are permitted for the UE based on the UE's subscription (subscribed S-NSSAIs from UDM), requested NSSAI, current serving area (TA/PLMN), operator policies, and network constraints. Specifically, the NSSF:</p> <ul> <li>Computes the Allowed NSSAI: The set of S-NSSAIs from the requested or subscribed list that are authorized for the UE in the current serving PLMN and registration area.</li> <li>Provides mapping information for the Configured NSSAI: The NSSF returns the Configured NSSAI mapping for the serving PLMN, which the AMF then communicates to the UE via the Registration Accept or UE Configuration Update message.</li> <li>In roaming scenarios, provides S-NSSAI mappings between VPLMN and HPLMN to ensure slice compatibility.</li> <li>Determining the AMF Set: In some scenarios, the NSSF can also help determine the appropriate AMF (Access and Mobility Management Function) set to serve the UE, especially when AMF re-allocation is needed.</li> </ul> </li> </ol>"},{"location":"blog/20260128/20260128/#nssf-services","title":"NSSF Services","text":"<p>Within the 5GC, the NSSF offers services to the AMF, SMF, NWDAF and NSSF in a different PLMN via the Nnssf service based interface (SBI). The main roles of NSSF is to provide Network Slice Information to AMF. NSSF exposes two main services via the SBI:</p> <ul> <li>Nnssf_NSSelection: Used by the AMF to retrieve network slice selection information.</li> <li>Nnssf_NSSAIAvailability: Used by the AMF to update the NSSF with information about which S-NSSAIs it supports per Tracking Area (TA) and to subscribe to availability change notifications.</li> </ul> <p> Figure 1. NSSF Services (source: 3GPP TS 29.531)</p>"},{"location":"blog/20260128/20260128/#nnssf_nsselection-service","title":"Nnssf_NSSelection Service","text":"<p>The <code>Nnssf_NSSelection</code> service is the cornerstone service for slice selection. It is invoked by the AMF (and in roaming scenarios, by NSSF from a different PLMN) during UE registration, PDU session establishment, or UE configuration update to query the NSSF for the allowed slices and related network slice information.</p> <p>Note</p> <p>Although the AMF is not the only NF that can consume this service (as shown in the diagram above), this article focuses primarily on the AMF as the NF service consumer.</p>"},{"location":"blog/20260128/20260128/#workflow-nsselection-for-registration","title":"Workflow: NSSelection for Registration","text":"<p>The following diagram illustrates the high-level workflow when the AMF queries NSSF during UE initial registration:</p> <pre><code>+----+              +-----+                                    +------+\n| UE |              | AMF |                                    | NSSF |\n+----+              +-----+                                    +------+\n   |                   |                                           |\n   | 1. Registration   |                                           |\n   |   Request         |                                           |\n   |------------------&gt;|                                           |\n   |                   |                                           |\n   |                   | 2. GET /nnssf-nsselection/v2/             |\n   |                   |    network-slice-information              |\n   |                   |------------------------------------------&gt;|\n   |                   |                                           |\n   |                   |                                           | 3. NSSF validates consumer,\n   |                   |                                           |    checks TAI/PLMN, processes\n   |                   |                                           |    Requested NSSAI vs Subscribed.\n   |                   |                                           |\n   |                   | 4. 2a. 200 OK (AuthorizedNetworkSliceInfo)|\n   |                   |    2b. 403 Forbidden (ProblemDetails)     |\n   |                   |    Or 4xx/5xx (ProblemDetails) Or 3xx     |\n   |                   |&lt;------------------------------------------|\n   |                   |                                           |\n</code></pre> <p>Step-by-Step Breakdown:</p> <ol> <li> <p>UE sends Registration Request: The UE initiates a registration request with the AMF. This request may include a Requested NSSAI, indicating the slices the UE wishes to use.</p> </li> <li> <p>AMF queries NSSF via GET Request: The AMF sends an HTTP <code>GET</code> request to the NSSF's <code>Nnssf_NSSelection</code> service endpoint at:</p> <ul> <li>Mandatory query parameters:<ul> <li><code>nf-type</code>: The type of the calling NF (e.g., AMF)</li> <li><code>nf-id</code>: The NF instance identifier</li> </ul> </li> <li>Conditional query parameters (depending on the use case):<ul> <li><code>slice-info-request-for-registration</code>: Contains <code>RequestedNssai</code>, <code>SubscribedNssai</code>, <code>DefaultConfiguredSnssaiIndication</code>, etc. (used during registration or EPS to 5GS handover)</li> <li><code>tai</code> (Tracking Area Identifier): Required for requests in the serving PLMN</li> <li><code>home-plmn-id</code>: Required for roaming scenarios to identify the UE's Home PLMN</li> <li><code>supported-features</code>: Optional feature support indication</li> </ul> </li> </ul> </li> <li> <p>NSSF Processes the Request: The NSSF performs several validation and decision steps:</p> <ul> <li>Verifies the NF service consumer is authorized (only AMF and NSSF from a different PLMN are allowed)</li> <li>Validates that required parameters (<code>tai</code> or <code>home-plmn-id</code> for roamers) are provided</li> <li>Checks if the requested S-NSSAIs are supported in the TAI and PLMN</li> <li>Compares <code>RequestedNssai</code> against <code>SubscribedNssai</code> (obtained from UDM) to compute the <code>AllowedNssai</code></li> <li>Determines the <code>ConfiguredNssai</code> mapping for the serving PLMN</li> <li>For roaming scenarios, computes the S-NSSAI mappings between VPLMN and HPLMN</li> <li>Identifies NSI IDs and associated NRF addresses for the allowed slices</li> </ul> </li> <li> <p>NSSF Returns HTTP 200 OK with AuthorizedNetworkSliceInfo: The NSSF responds with a <code>200 OK</code> status code and an <code>AuthorizedNetworkSliceInfo</code> object, which includes:</p> <ul> <li><code>AllowedNssaiList</code>: Array of S-NSSAIs permitted for the UE in the serving PLMN and current TA, organized by access type</li> <li><code>ConfiguredNssai</code>: The Configured NSSAI (list of <code>ConfiguredSnssai</code> objects) for the serving PLMN (max 16 S-NSSAIs per PLMN)</li> <li><code>RejectedNssaiInPlmn</code>: S-NSSAIs rejected due to PLMN-level restrictions</li> <li><code>RejectedNssaiInTa</code>: S-NSSAIs rejected due to TA-level restrictions</li> <li><code>NsiInformation</code>: Network Slice Instance information including NRF URIs and NSI IDs for service discovery within slices</li> <li><code>TargetAmfSet</code> or <code>CandidateAmfList</code>: For scenarios requiring AMF re-allocation</li> <li><code>MappingOfAllowedNssai</code> and <code>MappingOfConfiguredNssai</code>: S-NSSAI mappings between VPLMN and HPLMN (for roaming scenarios)</li> <li><code>NrfAmfSet</code>: NRF URI to use for discovering candidate AMFs from the target AMF Set</li> </ul> </li> </ol> <p>Key Technical Details:</p> <ul> <li>HTTP Method: The Nnssf_NSSelection service uses the GET method for the <code>network-slice-information</code> resource (standard query operation per REST principles)</li> <li>API Versioning: The URI includes <code>{apiVersion}</code> placeholder, typically <code>/v1/</code> or <code>/v2/</code> depending on 3GPP Release</li> <li>Content Type: Responses use <code>application/json</code> format as defined in 3GPP TS 29.531</li> <li>Error Responses: On failure (e.g., no authorized slices available), NSSF returns <code>HTTP 403 Forbidden</code> with application error <code>SNSSAI_NOT_SUPPORTED</code> or <code>NOT_AUTHORIZED</code></li> </ul>"},{"location":"blog/20260128/20260128/#code-analysis-free5gc-nsselection_network_slice_informationgo","title":"Code Analysis (free5GC): <code>nsselection_network_slice_information.go</code>","text":"<p>The core logic for the NSSelection service in free5GC is located in: <code>nssf/internal/sbi/processor/nsselection_network_slice_information.go</code></p> <p>Entry Point: <code>NSSelectionSliceInformationGet</code></p> <p>This function is the handler for the <code>GET</code> request. It performs initial validation and then dispatches to either <code>nsselectionForRegistration</code> or <code>nsselectionForPduSession</code> based on the query parameters.</p> <pre><code>func (p *Processor) NSSelectionSliceInformationGet(\n    c *gin.Context,\n    param NetworkSliceInformationGetQuery,\n) {\n    // ... (validation code omitted for brevity)\n\n    // Check permission of NF service consumer\n    err := checkNfServiceConsumer(param.NfType)\n    if err != nil {\n        // Return 403 Forbidden\n    }\n\n    if param.Tai == nil &amp;&amp; param.HomePlmnId == nil {\n        // Return 400 Bad Request - Missing mandatory IE\n    }\n\n    if param.SliceInfoRequestForRegistration != nil {\n        // Network slice information is requested during the Registration procedure\n        status, response, problemDetails = nsselectionForRegistration(param)\n    } else {\n        // Network slice information is requested during the PDU session establishment procedure\n        status, response, problemDetails = nsselectionForPduSession(param)\n    }\n\n    // ...\n    c.JSON(status, response)\n}\n</code></pre> <p>Core Logic: <code>nsselectionForRegistration</code></p> <p>This function handles the slice selection logic for UE registration. Here's a simplified view of its key steps:</p> <pre><code>func nsselectionForRegistration(param NetworkSliceInformationGetQuery) (\n    int, *models.AuthorizedNetworkSliceInfo, *models.ProblemDetails,\n) {\n    authorizedNetworkSliceInfo := &amp;models.AuthorizedNetworkSliceInfo{}\n\n    // 1. Check if Home PLMN is supported (for roamers)\n    if param.HomePlmnId != nil {\n        if !util.CheckSupportedHplmn(*param.HomePlmnId) {\n            // Reject all requested NSSAIs\n        }\n    }\n\n    // 2. Check if TAI is supported\n    if param.Tai != nil {\n        if !util.CheckSupportedTa(*param.Tai) {\n            // Reject all requested NSSAIs in TA\n        }\n    }\n\n    // 3. Iterate through Requested NSSAIs\n    for _, requestedSnssai := range param.SliceInfoRequestForRegistration.RequestedNssai {\n        // Check if supported in TAI\n        if param.Tai != nil &amp;&amp; !util.CheckSupportedSnssaiInTa(requestedSnssai, *param.Tai) {\n            authorizedNetworkSliceInfo.RejectedNssaiInTa = append(...)\n            continue\n        }\n\n        // Compare with Subscribed NSSAIs\n        for _, subscribedSnssai := range param.SliceInfoRequestForRegistration.SubscribedNssai {\n            if openapi.SnssaiEqualFold(mappingOfRequestedSnssai, *subscribedSnssai.SubscribedSnssai) {\n                // Match found! Add to Allowed NSSAI\n                var allowedSnssaiElement models.AllowedSnssai\n                allowedSnssaiElement.AllowedSnssai = new(models.Snssai)\n                *allowedSnssaiElement.AllowedSnssai = requestedSnssai\n                // ... add NsiInformationList, MappedHomeSnssai if applicable\n                util.AddAllowedSnssai(allowedSnssaiElement, accessType, authorizedNetworkSliceInfo)\n                break\n            }\n        }\n    }\n\n    // 4. If no requested NSSAI is allowed, use default subscribed NSSAIs\n    if !checkIfRequestAllowed {\n        useDefaultSubscribedSnssai(param, authorizedNetworkSliceInfo)\n    }\n\n    return http.StatusOK, authorizedNetworkSliceInfo, nil\n}\n</code></pre> <p>Key Takeaways:</p> <ul> <li>The NSSF validates each requested S-NSSAI against the subscribed S-NSSAIs.</li> <li>If a match is found, it's added to the <code>AllowedNssai</code> list.</li> <li>S-NSSAIs not matching are added to <code>RejectedNssaiInPlmn</code> or <code>RejectedNssaiInTa</code>.</li> <li>If no requested S-NSSAIs are allowed, the NSSF falls back to using default subscribed      S-NSSAIs.</li> </ul>"},{"location":"blog/20260128/20260128/#nnssf_nssaiavailability-service","title":"Nnssf_NSSAIAvailability Service","text":"<p>The <code>Nnssf_NSSAIAvailability</code> service allows the AMF to inform the NSSF about which  S-NSSAIs it supports in each Tracking Area. This is crucial because the availability of slices can vary by geographic location. Additionally, AMFs can subscribe to receive notifications when the NSSAI availability changes.</p> <p>The following HTTP methods are supported for this service:</p> <ul> <li>PUT: Used by the AMF to update (register) the S-NSSAIs it supports per TA.</li> <li>PATCH: Used to partially update the supported S-NSSAIs.</li> <li>DELETE: Used to delete the NSSAI availability information for a specific NF instance.</li> <li>POST: Used to create a subscription for NSSAI availability event notifications.</li> <li>DELETE (on subscription): Used to unsubscribe from notifications.</li> </ul> <p>In this section, we will primarily focus on the PUT and POST methods for the <code>Nnssf_NSSAIAvailability</code> service.</p>"},{"location":"blog/20260128/20260128/#workflow-1-update-nssai-availability-put","title":"Workflow 1: Update NSSAI Availability (PUT)","text":"<pre><code>+-----+                                       +------+\n| AMF |                                       | NSSF |\n+-----+                                       +------+\n   |                                              |\n   | 1. PUT /nnssf-nssaiavailability/             |\n   |    v1/nssai-availability/{nfId}              |\n   |---------------------------------------------&gt;|\n   |                                              |\n   |                                              | 2. NSSF validates S-NSSAIs,\n   |                                              |    updates internal store.\n   |                                              |\n   | 3. 204 No content /                          |\n   |    200 OK (AuthorizedNssai-AvailabilityInfo) |\n   |    or 4xx / 5xx (ProblemDetails)             |\n   |    or 3xx                                    |\n   |&lt;---------------------------------------------|\n   |                                              |\n</code></pre> <p>Step-by-Step Breakdown:</p> <ol> <li>AMF sends PUT request: The AMF sends an HTTP <code>PUT</code> request to the NSSF's <code>Nnssf_NSSAIAvailability</code> service. The request body contains <code>NssaiAvailabilityInfo</code>, which specifies the S-NSSAIs supported by this AMF for each TAI. According to TS 29.531, this method fully replaces any existing availability information for the NF instance. If the entry does not exist, it is created.</li> <li>NSSF validates and stores: The NSSF validates that the provided S-NSSAIs are supported in the respective PLMNs. It then updates its internal configuration store (<code>factory.NssfConfig.Configuration.AmfList</code> in free5GC) with the AMF's supported NSSAI availability data. If the AMF is new, it creates a new entry.</li> <li>NSSF returns authorized data: The NSSF responds with <code>AuthorizedNssaiAvailabilityInfo</code>, containing the authorized availability data for the TAIs that were updated.</li> </ol>"},{"location":"blog/20260128/20260128/#workflow-2-subscribe-to-nssai-availability-changes-post","title":"Workflow 2: Subscribe to NSSAI Availability Changes (POST)","text":"<pre><code>+-----+                                            +------+\n| AMF |                                            | NSSF |\n+-----+                                            +------+\n   |                                                   |\n   | 1. POST /nnssf-nssaiavailability/                 |\n   |    v1/nssai-availability/subscriptions           |\n   |--------------------------------------------------&gt;|\n   |                                                   |\n   |                                                   | 2. NSSF generates a\n   |                                                   |    subscriptionId, stores\n   |                                                   |    subscription data.\n   |                                                   |\n   | 3. 201 Created (NssfEventSubscriptionCreatedData) |\n   |    or 4xx/5xx (ProblemDetails)                    |\n   |    or 3xx                                         |\n   |&lt;--------------------------------------------------|\n   |                                                   |\n</code></pre> <p>Step-by-Step Breakdown:</p> <ol> <li>AMF sends POST request: The AMF sends an HTTP <code>POST</code> request to subscribe to NSSAI availability event notifications. The request body contains <code>NssfEventSubscriptionCreateData</code>, which includes the list of TAIs the AMF is interested in and optionally an expiry time for the subscription. This creates a new subscription resource.</li> <li>NSSF creates subscription: The NSSF generates a unique <code>SubscriptionId</code> and stores the subscription data.</li> <li>NSSF returns subscription data: The NSSF responds with <code>NssfEventSubscriptionCreatedData</code>, which includes the <code>SubscriptionId</code>, the expiry time (if set), and the current <code>AuthorizedNssaiAvailabilityData</code> for the subscribed TAIs.</li> </ol>"},{"location":"blog/20260128/20260128/#code-analysis-free5gc-nssaiavailability_storego-nssaiavailability_subscriptiongo","title":"Code Analysis (free5GC): <code>nssaiavailability_store.go</code> &amp; <code>nssaiavailability_subscription.go</code>","text":"<p><code>NssaiAvailabilityNfInstanceUpdate</code> (PUT Handler)</p> <p>Located in <code>nssf/internal/sbi/processor/nssaiavailability_store.go</code>:</p> <pre><code>func (p *Processor) NssaiAvailabilityNfInstanceUpdate(\n    c *gin.Context,\n    nssaiAvailabilityInfo models.NssaiAvailabilityInfo, nfId string,\n) {\n    // Validate that S-NSSAIs are supported in PLMN\n    for _, s := range nssaiAvailabilityInfo.SupportedNssaiAvailabilityData {\n        if !util.CheckSupportedNssaiInPlmn(s.SupportedSnssaiList, *s.Tai.PlmnId) {\n            // Return 403 Forbidden - SNSSAI_NOT_SUPPORTED\n        }\n    }\n\n    // Find AMF configuration of given NfId\n    // If found, then update the SupportedNssaiAvailabilityData\n    hitAmf := false\n    factory.NssfConfig.Lock()\n    for i, amfConfig := range factory.NssfConfig.Configuration.AmfList {\n        if amfConfig.NfId == nfId {\n            factory.NssfConfig.Configuration.AmfList[i].SupportedNssaiAvailabilityData = \n                nssaiAvailabilityInfo.SupportedNssaiAvailabilityData\n            hitAmf = true\n            break\n        }\n    }\n    factory.NssfConfig.Unlock()\n\n    // If no AMF record is found, create a new one\n    if !hitAmf {\n        var amfConfig factory.AmfConfig\n        amfConfig.NfId = nfId\n        amfConfig.SupportedNssaiAvailabilityData = nssaiAvailabilityInfo.SupportedNssaiAvailabilityData\n        factory.NssfConfig.Lock()\n        factory.NssfConfig.Configuration.AmfList = append(factory.NssfConfig.Configuration.AmfList, amfConfig)\n        factory.NssfConfig.Unlock()\n    }\n\n    // Return authorized NSSAI availability info\n    // ...\n    c.JSON(http.StatusOK, response)\n}\n</code></pre> <p><code>NssaiAvailabilitySubscriptionCreate</code> (POST Handler)</p> <p>Located in <code>nssf/internal/sbi/processor/nssaiavailability_subscription.go</code>:</p> <pre><code>func (p *Processor) NssaiAvailabilitySubscriptionCreate(\n    c *gin.Context,\n    createData models.NssfEventSubscriptionCreateData,\n) {\n    var subscription factory.Subscription\n\n    // Get an unused subscription ID\n    tempID, err := getUnusedSubscriptionID()\n    if err != nil {\n        // Return error\n    }\n\n    subscription.SubscriptionId = tempID\n    subscription.SubscriptionData = new(models.NssfEventSubscriptionCreateData)\n    *subscription.SubscriptionData = createData\n\n    // Store the subscription\n    factory.NssfConfig.Subscriptions = append(factory.NssfConfig.Subscriptions, subscription)\n\n    // Prepare response\n    response.SubscriptionId = subscription.SubscriptionId\n    if subscription.SubscriptionData.Expiry != nil &amp;&amp; !subscription.SubscriptionData.Expiry.IsZero() {\n        response.Expiry = new(time.Time)\n        *response.Expiry = *subscription.SubscriptionData.Expiry\n    }\n    response.AuthorizedNssaiAvailabilityData = util.AuthorizeOfTaListFromConfig(subscription.SubscriptionData.TaiList)\n\n    c.JSON(http.StatusOK, response)\n}\n</code></pre> <p>Key Takeaways:</p> <ul> <li>The <code>PUT</code> method allows AMFs to register or update their supported S-NSSAIs per TA.</li> <li>The <code>POST</code> subscription method allows AMFs to receive notifications about NSSAI availability changes.</li> <li>Internal state is managed via the <code>factory.NssfConfig</code> configuration structure.</li> </ul>"},{"location":"blog/20260128/20260128/#capturing-nssf-requests-and-responses-in-free5gc-with-tcpdump","title":"Capturing NSSF Requests and Responses in free5GC with tcpdump","text":"<p>This section demonstrates how to capture and analyze NSSF SBI traffic using <code>tcpdump</code>. We will record packets for the following APIs:</p> <ul> <li>NSSelectionGet: <code>GET /nnssf-nsselection/v2/network-slice-information</code></li> <li>NSSAIAvailabilityPut: <code>PUT /nnssf-nssaiavailability/v1/nssai-availability/{nfId}</code></li> <li>NSSAIAvailabilityPost: <code>POST /nnssf-nssaiavailability/v1/nssai-availability/subscriptions</code></li> </ul> <p>Note</p> <p>To ensure a successful response from NSSF, I have updated the configurations as follows:</p> <ol> <li> <p>Add new settings in <code>nssfcfg.yaml</code> (\u65b0\u589e\u914d\u7f6e): <pre><code>supportedPlmnList:\n  - mcc: 466\n    mnc: 92\nsupportedNssaiInPlmnList:\n  - plmnId:\n      mcc: 466\n      mnc: 92\n    supportedSnssaiList:\n      - sst: 1\n        sd: 000001\n      - sst: 1\n        sd: 000002\n      - sst: 1\n      - sst: 2\n</code></pre></p> </li> <li> <p>Modify setting in <code>nrfcfg.yaml</code> (\u4fee\u6539\u914d\u7f6e): <pre><code>configuration:\n  # ...\n  oauth: false # Disable OAuth\n</code></pre></p> </li> </ol>"},{"location":"blog/20260128/20260128/#start-tcpdump","title":"Start tcpdump","text":"<p>Capture SBI traffic on the NSSF interface:</p> <pre><code># Run free5GC locally\nsudo tcpdump -i lo -w nssf.pcap \\\n    'tcp port 8000 and host 127.0.0.31'\n</code></pre>"},{"location":"blog/20260128/20260128/#trigger-nssf-requests","title":"Trigger NSSF Requests","text":"<p>Start free5GC first, then open a new terminal to trigger the API requests:</p>"},{"location":"blog/20260128/20260128/#test-case-1-nsselectionget-network-slice-selection","title":"Test Case 1: NSSelectionGet (Network Slice Selection)","text":"<pre><code>curl -v -G \"http://127.0.0.31:8000/nnssf-nsselection/v2/network-slice-information\" \\\n    --data-urlencode \"nf-type=AMF\" \\\n    --data-urlencode \"nf-id=469de254-2fe5-4ca0-8381-af3f500af77c\" \\\n    --data-urlencode 'slice-info-request-for-registration={\"requestedNssai\":[{\"sst\":1,\"sd\":\"000002\"}],\"subscribedNssai\":[{\"subscribedSnssai\":{\"sst\":1,\"sd\":\"000002\"},\"defaultIndication\":true}]}' \\\n    --data-urlencode 'tai={\"plmnId\":{\"mcc\":\"466\",\"mnc\":\"92\"},\"tac\":\"33456\"}'\n</code></pre>"},{"location":"blog/20260128/20260128/#test-case-2-nssaiavailabilityput-update-nssai-availability","title":"Test Case 2: NSSAIAvailabilityPut (Update NSSAI Availability)","text":"<pre><code>curl -v -X PUT \"http://127.0.0.31:8000/nnssf-nssaiavailability/v1/nssai-availability/469de254-2fe5-4ca0-8381-af3f500af77c\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n        \"supportedNssaiAvailabilityData\": [\n            {\n                \"tai\": {\n                    \"plmnId\": {\"mcc\": \"466\", \"mnc\": \"92\"},\n                    \"tac\": \"33456\"\n                },\n                \"supportedSnssaiList\": [\n                    {\"sst\": 1, \"sd\": \"000001\"},\n                    {\"sst\": 1, \"sd\": \"000002\"}\n                ]\n            }\n        ]\n    }'\n</code></pre>"},{"location":"blog/20260128/20260128/#test-case-3-nssaiavailabilitypost-subscribe-to-nssai-availability","title":"Test Case 3: NSSAIAvailabilityPost (Subscribe to NSSAI Availability)","text":"<pre><code>curl -v -X POST \"http://127.0.0.31:8000/nnssf-nssaiavailability/v1/nssai-availability/subscriptions\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n        \"nfNssaiAvailabilityUri\": \"http://127.0.0.1:8080/callback\",\n        \"taiList\": [\n            {\n                \"plmnId\": {\"mcc\": \"466\", \"mnc\": \"92\"},\n                \"tac\": \"33456\"\n            }\n        ]\n    }'\n</code></pre>"},{"location":"blog/20260128/20260128/#analyze-the-capture-packets","title":"Analyze the Capture packets","text":"<p>Stop the tcpdump capture with <code>Ctrl+C</code>, then analyze the results:</p>"},{"location":"blog/20260128/20260128/#test-case-1-nsselectionget-network-slice-selection_1","title":"Test Case 1: NSSelectionGet (Network Slice Selection)","text":"<p> Figure 2. NSSelectionGet</p> <p>The response shows that the <code>AuthorizedNetworkSliceInfo</code> contains the attribute <code>allowedNssaiList</code>. We can see the format of <code>allowedNssaiList</code>, which data type is array(AllowedNssai) in 3GPP TS 29.531. Then, we can see that the response body matches the data type of <code>AuthorizedNetworkSliceInfo</code>.</p> <p> Figure 3. AllowedSnssai (source: TS 29.531)</p> <p> Figure 4. AllowedNssai (source: TS 29.531)</p>"},{"location":"blog/20260128/20260128/#test-case-2-nssaiavailabilityput-update-nssai-availability_1","title":"Test Case 2: NSSAIAvailabilityPut (Update NSSAI Availability)","text":"<p> Figure 5. NSSAIAvailabilityPut</p> <p>The response shows that the <code>AuthorizedNssaiAvailabilityInfo</code> contains the attribute <code>authorizedNssaiAvailabilityData</code>. We can see the format of <code>authorizedNssaiAvailabilityData</code>, which data type is array(AuthorizedNssaiAvailabilityData) in 3GPP TS 29.531. Then, we can see that the response body matches the data type of <code>AuthorizedNssaiAvailabilityInfo</code>.</p> <p> Figure 6. AuthorizedNssaiAvailabilityInfo (source: TS 29.531)</p> <p> Figure 7. AuthorizedNssaiAvailabilityData (source: TS 29.531)</p>"},{"location":"blog/20260128/20260128/#test-case-3-nssaiavailabilitypost-subscribe-to-nssai-availability_1","title":"Test Case 3: NSSAIAvailabilityPost (Subscribe to NSSAI Availability)","text":"<p> Figure 8. NSSAIAvailabilityPost</p> <p>The successful subscription creation will return <code>NssfEventSubscriptionCreatedData</code>. We can see the format of <code>NssfEventSubscriptionCreatedData</code> in 3GPP TS 29.531. Then, we can see that the response body matches the definition of <code>NssfEventSubscriptionCreatedData</code>.</p> <p> Figure 9. NssfEventSubscription Response (source: TS 29.531)</p> <p> Figure 10. NssfEventSubscriptionCreatedData (source: TS 29.531)</p>"},{"location":"blog/20260128/20260128/#summary","title":"Summary","text":"<p>The NSSF (Network Slice Selection Function) is a critical component in 5G networks that enables the power of network slicing. By providing services like <code>Nnssf_NSSelection</code> and <code>Nnssf_NSSAIAvailability</code>, it enables:</p> <ul> <li>Dynamic Slice Selection: The AMF can query the NSSF to determine which network slices a UE is allowed to use based on subscription, location, and operator policies.</li> <li>Slice Availability Management: AMFs can inform the NSSF about which slices they support in their serving areas, ensuring that the NSSF has accurate, up-to-date information for slice selection decisions.</li> <li>Subscription-based Notifications: AMFs can subscribe to be notified about changes in NSSAI availability, allowing for dynamic adaptation to network conditions.</li> </ul> <p>In free5GC, the NSSF implementation follows the 3GPP specifications, providing a practical, open-source example of how network slicing can be realized in a 5G core.</p>"},{"location":"blog/20260128/20260128/#reference","title":"Reference","text":"<ul> <li>3GPP TS 29.531 - 5G System; Network Slice Selection Services</li> <li>3GPP TS 23.501 - System architecture for the 5G System (5GS)</li> <li>free5GC NSSF Repository</li> </ul>"},{"location":"blog/20260128/20260128/#about","title":"About","text":"<p>Hello! I'm Kai-Hung Hu, and I'm just starting my exploration of 5G technology and the free5GC community. I hope this blog post has been informative. If you have ideas for further discussion, please don't hesitate to get in touch.</p>"},{"location":"blog/20260128/20260128/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: carlhus</li> </ul>"},{"location":"blog/20260204/20260204/","title":"PFCP Session Lifecycle in free5GC: Establish, Modify, and Release Explained","text":"<p>Note</p> <p>Author: Kai-Xu, Zhan Date: 2026/02/04</p>"},{"location":"blog/20260204/20260204/#1-introduction","title":"1. Introduction","text":"<p>In the 5G Core architecture, the Packet Forwarding Control Protocol (PFCP) plays a central role in bridging control-plane decisions and user-plane behavior. While high-level system diagrams often describe the responsibilities of the Session Management Function (SMF) and the User Plane Function (UPF), the actual runtime behavior of the user plane is almost entirely dictated by PFCP signaling.</p> <p>For engineers working with real deployments, PFCP is frequently perceived as a \u201cblack box.\u201d Logs show PFCP Session Establishment, Modification, and Release messages flowing between SMF and UPF, yet it is often unclear why sessions are modified multiple times, which rules are affected, and how those rules translate into concrete packet processing behavior.</p> <p>This article explains the PFCP Session lifecycle in free5GC\u2014Establish, Modify, and Release\u2014by combining:</p> <ul> <li>3GPP specification concepts and procedures,</li> <li>Detailed explanations of key PFCP rule types and Information Elements,</li> <li>Concrete references to free5GC\u2019s implementation structure and design choices.</li> </ul> <p>The objective is to help engineers read PFCP traces, understand UPF behavior, and debug user-plane issues with confidence.</p> <p>Note In the context of PFCP within free5GC, the SMF acts as the Control Plane (CP), while the UPF implements the User Plane (UP).</p>"},{"location":"blog/20260204/20260204/#2-pfcp-association-and-pfcp-session-in-free5gc","title":"2. PFCP Association and PFCP Session in free5GC","text":"<p>Before examining PFCP sessions themselves, it is important to distinguish between PFCP Association and PFCP Session. These two concepts operate at different scopes and serve different purposes in the control\u2013user plane relationship.</p>"},{"location":"blog/20260204/20260204/#21-pfcp-association","title":"2.1 PFCP Association","text":"<p>A PFCP Association represents a long-lived control-plane relationship between an SMF and a UPF. It is not merely a connectivity check; rather, it establishes mutual awareness of capabilities, liveness, and restart state.</p> <p>According to 3GPP TS 29.244 (Section 5.8), the PFCP Association Setup procedure establishes several prerequisites that must be satisfied before any PFCP Session can exist:</p> <ul> <li>Node identity exchange,</li> <li>Capability negotiation,</li> <li>A heartbeat mechanism for failure detection.</li> </ul> <p>These aspects are conveyed through PFCP Information Elements. Key IEs involved in PFCP Association Setup include:</p> IE Description Node ID Uniquely identifies the CP or UP node using an IP address or FQDN Recovery Time Stamp Allows detection of UPF restarts and loss of PFCP session state CP Function Features / UP Function Features Advertise supported PFCP capabilities <p>From an architectural perspective,  PFCP Associations are not limited to a one-to-one relationship. A single SMF can maintain associations with multiple UPFs, and a UPF may serve multiple SMFs. This flexibility enables scalable user-plane deployments and dynamic traffic steering.</p> <p>A crucial rule defined by the specification is that PFCP Session\u2013related messages must be rejected if no PFCP Association exists. This ensures that all session state is created and managed only within a valid and synchronized control relationship.</p> <p>In free5GC:</p> <ul> <li> <p>On the SMF side, PFCP Association handling is implemented under <code>NFs/smf/internal/sbi/processor/association.go</code>.</p> </li> <li> <p>On the UPF side, PFCP Association logic is implemented in <code>NFs/upf/internal/pfcp/association.go</code>.</p> </li> </ul> <p>Importantly, PFCP Association does not create any forwarding rules. It merely prepares the control and user planes to exchange PFCP Session messages reliably.</p>"},{"location":"blog/20260204/20260204/#22-pfcp-session","title":"2.2 PFCP Session","text":"<p>A PFCP Session is the fundamental unit that binds control-plane intent to user-plane behavior. Each PFCP Session corresponds conceptually to a PDU session and acts as a container for all PFCP rules that define packet detection, forwarding, QoS enforcement, and usage reporting.</p> <p>PFCP Session procedures and identifiers are defined in 3GPP TS 29.244 (Section 5.6).</p>"},{"location":"blog/20260204/20260204/#221-session-identification-with-seid","title":"2.2.1 Session Identification with SEID","text":"<p>Each PFCP Session is identified by a Session Endpoint Identifier (SEID). SEIDs are allocated independently by the control plane and the user plane:</p> <ul> <li> <p>The SMF allocates a CP-side SEID.</p> </li> <li> <p>The UPF allocates a UP-side SEID.</p> </li> </ul> <p>During PFCP Session Establishment: 1. The SMF sends a Session Establishment Request with its CP SEID carried in the CP F-SEID IE. 2. The UPF allocates a local SEID and returns it in the UP F-SEID IE of the response.</p> <p>At the protocol level, the SEID in the PFCP message header is used to locate local session state. For this reason:</p> <ul> <li> <p>The Session Establishment Request typically uses a SEID value of <code>0</code> in the header, since the UP-side SEID is not yet known.</p> </li> <li> <p>All subsequent PFCP messages carry the receiver\u2019s SEID in the header.</p> </li> </ul> <p>In practice:</p> <ul> <li> <p>CP \u2192 UP messages carry the UP-side SEID.</p> </li> <li> <p>UP \u2192 CP messages carry the CP-side SEID.</p> </li> </ul> <p>In free5GC:</p> <ul> <li> <p>The SMF allocates and stores CP-side SEIDs in the SM context (<code>NFs/smf/internal/context/sm_context.go</code>).  Figure 1: CP-side SEIDs in free5GC</p> </li> <li> <p>The UPF creates PFCP session state and allocates its own SEID upon receiving the establishment request (<code>NFs/upf/internal/pfcp/node.go</code>).  Figure 2: UP-side SEIDs in free5GC</p> </li> </ul>"},{"location":"blog/20260204/20260204/#222-session-content-and-ownership","title":"2.2.2 Session Content and Ownership","text":"<p>Once identified, the PFCP Session contains a set of PFCP rules that define user-plane behavior. These rules include:</p> <ul> <li> <p>Packet Detection Rules (PDRs),</p> </li> <li> <p>Forwarding Action Rules (FARs),</p> </li> <li> <p>QoS Enforcement Rules (QERs),</p> </li> <li> <p>Usage Reporting Rules (URRs),</p> </li> <li> <p>Buffering Action Rules (BARs).</p> </li> </ul> <p>In free5GC, rule state is owned by the UPF, not the SMF. The SMF constructs PFCP messages dynamically based on session context, while the UPF maintains persistent rule state and applies it during packet processing.</p>"},{"location":"blog/20260204/20260204/#3-pfcp-rule-building-blocks","title":"3. PFCP Rule Building Blocks","text":"<p>PFCP rules are reusable building blocks that can be created, modified, or removed as a PFCP Session evolves. Understanding these rule types is essential for interpreting PFCP Session procedures.</p>"},{"location":"blog/20260204/20260204/#31-packet-processing-overview","title":"3.1 Packet Processing Overview","text":"<p> Figure 3: Packet Processing Flow (source: 3GPP TS 29.244)</p> <p>In the UPF, packet processing follows a logical pipeline:</p> <ol> <li> <p>Packet detection using PDRs,</p> </li> <li> <p>Optional outer header removal,</p> </li> <li> <p>QoS enforcement and usage measurement,</p> </li> <li> <p>Forwarding, buffering, or dropping based on FARs.</p> </li> </ol>"},{"location":"blog/20260204/20260204/#32-packet-detection-rule-pdr","title":"3.2 Packet Detection Rule (PDR)","text":"<p>A Packet Detection Rule defines how packets are classified and associated with a PFCP Session. Every packet processed by the UPF must match a PDR.</p> <p>Key PDR Information Elements</p> IE Purpose PDR ID Uniquely identifies the PDR Precedence Determines matching priority PDI see PDI. Outer Header Removal Defines decapsulation behavior, see Outer Header. FAR ID References forwarding behavior QER ID References QoS enforcement URR ID References usage reporting <p></p>"},{"location":"blog/20260204/20260204/#321-packet-detection-information-pdi","title":"3.2.1 Packet Detection Information (PDI)","text":"<p>The PDI specifies the actual packet matching conditions.</p> IE Purpose Source Interface Indicates ingress interface (e.g., N3, N6) F-TEID see F-TEID UE IP Address Matches downlink traffic SDF Filter 5-tuple packet filtering Network Instance Identifies the Data Network"},{"location":"blog/20260204/20260204/#33-forwarding-action-rule-far","title":"3.3 Forwarding Action Rule (FAR)","text":"<p>A FAR defines the action applied after a packet matches a PDR.</p> IE Purpose FAR ID Identifies the FAR Apply Action Forward, drop, or buffer Forwarding Parameters see Forwarding Parameters <p></p>"},{"location":"blog/20260204/20260204/#331-forwarding-parameters","title":"3.3.1 Forwarding Parameters","text":"IE Purpose Destination Interface Indicates egress interface (e.g., N3, N6). Outer Header Creation Defines encapsulation behavior, see Outer Header. Forwarding Policy Control-plane forwarding policy applied by the UPF."},{"location":"blog/20260204/20260204/#34-qos-enforcement-rule-qer","title":"3.4 QoS Enforcement Rule (QER)","text":"<p>A QER defines rate limiting, gating, and QoS flow mapping.</p> IE Purpose QER ID Identifies the QER QER Correlation ID Correlates multiple QERs, allowing the UP function to apply them consistently. Gate Status Allows or blocks traffic Maximum Bitrate (MBR) Defines the maximum uplink and downlink bitrates. Guaranteed Bitrate (GBR) Defines the guaranteed uplink and downlink bitrates. QFI The QoS Flow associated with this QER, enabling QoS enforcement per flow."},{"location":"blog/20260204/20260204/#35-usage-reporting-rule-urr","title":"3.5 Usage Reporting Rule (URR)","text":"<p>A URR defines how usage is measured and reported.</p> IE Purpose URR ID Identifies the URR Measurement Method volume-based, time-based, or event-based measurement Reporting Triggers Defines the conditions that trigger a Usage Report Measurement Period The periodic reporting interval. If not present, periodic reporting is disabled. Quota Indicates the provisioned usage quota. Threshold Indicates the usage threshold value at which the UP function shall report network resource usage."},{"location":"blog/20260204/20260204/#36-buffering-action-rule-bar","title":"3.6 Buffering Action Rule (BAR)","text":"<p>A BAR controls downlink packet buffering behavior, typically used when the UE is temporarily unreachable.</p> IE Purpose BAR ID Identifies the BAR. Downlink Data Notification Delay Controls notification timing for buffered data. Suggested Buffering Packets Count Indicates the number of packets that should buffer before triggering a notification."},{"location":"blog/20260204/20260204/#4-pfcp-session-establishment","title":"4. PFCP Session Establishment","text":"<p>PFCP Session Establishment is the procedure used by the control plane (SMF) to create a new PFCP session in the user plane (UPF). From an implementation perspective, this procedure is where the UPF is first programmed with all rule state required to process user traffic for a PDU session.</p>"},{"location":"blog/20260204/20260204/#41-procedure-overview","title":"4.1 Procedure Overview","text":"<p>The PFCP Session Establishment procedure consists of two messages:</p> <ul> <li> <p>PFCP Session Establishment Request</p> </li> <li> <p>PFCP Session Establishment Response</p> </li> </ul> <p>The SMF sends a Session Establishment Request to the UPF, containing one or more rule definitions. If the request is accepted, the UPF creates a PFCP session context and replies with a successful response.</p>"},{"location":"blog/20260204/20260204/#42-rule-installation-during-session-establishment","title":"4.2 Rule Installation during Session Establishment","text":""},{"location":"blog/20260204/20260204/#packet-detection-rules-pdrs","title":"Packet Detection Rules (PDRs)","text":"<p>PDRs created during establishment define how packets belonging to the session are detected. In most deployments, at least two PDRs are installed:</p> <ul> <li> <p>Uplink PDR   Matches packets received on the N3 interface, commonly using an F-TEID or SDF Filter.</p> </li> <li> <p>Downlink PDR   Matches packets received on the N6 interface using the UE IP address.</p> </li> </ul> <p>Each PDR references the corresponding FAR, and may also reference one or more QERs and URRs. Precedence values are chosen so that more specific rules are evaluated before generic ones.</p>"},{"location":"blog/20260204/20260204/#forwarding-action-rules-fars","title":"Forwarding Action Rules (FARs)","text":"<p>FARs define what happens after packet detection. During Session Establishment, FARs typically configure:</p> <ul> <li> <p>Forwarding of uplink traffic toward the data network (N6)</p> </li> <li> <p>Forwarding of downlink traffic toward the RAN (N3), including outer header creation</p> </li> <li> <p>Optional buffering or dropping behavior depending on session state</p> </li> </ul> <p>These FARs encode the basic traffic path for the PDU session.</p>"},{"location":"blog/20260204/20260204/#qos-enforcement-rules-qers","title":"QoS Enforcement Rules (QERs)","text":"<p>QERs installed during establishment define the initial QoS behavior applied to the session. This includes:</p> <ul> <li> <p>Gate status (open or closed)</p> </li> <li> <p>Maximum and guaranteed bitrates</p> </li> <li> <p>Mapping to QoS flows via QFI</p> </li> </ul> <p>Multiple QERs may be associated with a single PDR to support multiple QoS flows.</p>"},{"location":"blog/20260204/20260204/#usage-reporting-rules-urrs","title":"Usage Reporting Rules (URRs)","text":"<p>URRs enable traffic measurement and reporting from the UPF to the SMF. During establishment, URRs typically specify:</p> <ul> <li> <p>Measurement method (volume, time, or event based)</p> </li> <li> <p>Reporting triggers such as quota exhaustion or threshold crossing</p> </li> <li> <p>Optional periodic reporting intervals</p> </li> </ul> <p>Installing URRs at establishment ensures that usage data is collected from the moment the session becomes active.</p>"},{"location":"blog/20260204/20260204/#43-session-establishment-response","title":"4.3 Session Establishment Response","text":"<p>In the PFCP Session Establishment Response, the UPF confirms:</p> <ul> <li> <p>Successful creation of the PFCP session</p> </li> <li> <p>Acceptance or rejection of rules</p> </li> <li> <p>Assigned UPF F-SEID UPF F-SEID ( see F-TEID )</p> </li> </ul> <p>Once the response is received, the PFCP session is considered active, and the UPF begins processing packets according to the installed rules.</p>"},{"location":"blog/20260204/20260204/#5-pfcp-session-modification","title":"5. PFCP Session Modification","text":"<p>PFCP Session Modification is used to update an existing PFCP session. Unlike Session Establishment, which creates the initial session state, Session Modification allows the control plane to dynamically adapt user-plane behavior as the session evolves.</p> <p>Typical triggers for session modification include:</p> <ul> <li> <p>QoS changes</p> </li> <li> <p>Traffic steering updates</p> </li> <li> <p>Charging or reporting policy updates</p> </li> </ul>"},{"location":"blog/20260204/20260204/#51-procedure-overview","title":"5.1 Procedure Overview","text":"<p>The PFCP Session Modification procedure consists of:</p> <ul> <li>PFCP Session Modification Request</li> <li>PFCP Session Modification Response</li> </ul> <p>The SMF sends a Modification Request referencing an existing PFCP session using the UP-side SEID. The request may include rule creations, updates, or removals. The UPF applies the requested changes atomically and responds with the outcome.</p>"},{"location":"blog/20260204/20260204/#52-rule-lifecycle-operations","title":"5.2 Rule Lifecycle Operations","text":"<p>Session Modification supports three fundamental operations on PFCP rules:</p> <ul> <li> <p>Create: Add new rules to the session</p> </li> <li> <p>Update: Modify parameters of existing rules</p> </li> <li> <p>Remove: Delete rules that are no longer needed</p> </li> </ul> <p>These operations allow fine-grained control over user-plane behavior without tearing down the session.</p>"},{"location":"blog/20260204/20260204/#pdr-updates","title":"PDR Updates","text":"<p>PDRs are often modified during mobility events or traffic steering scenarios. Common updates include:</p> <ul> <li> <p>Updating packet matching criteria (e.g., new SDF Filters)</p> </li> <li> <p>Adjusting precedence values</p> </li> <li> <p>Rebinding to different FARs, QERs, or URRs</p> </li> </ul>"},{"location":"blog/20260204/20260204/#far-updates","title":"FAR Updates","text":"<p>FAR modifications typically reflect changes in forwarding behavior, such as:</p> <ul> <li> <p>Switching the destination interface</p> </li> <li> <p>Updating outer header creation parameters</p> </li> <li> <p>Enabling or disabling buffering behavior</p> </li> </ul> <p>These changes directly affect how packets are forwarded through the user plane.</p>"},{"location":"blog/20260204/20260204/#qer-updates","title":"QER Updates","text":"<p>QERs are frequently modified to reflect dynamic QoS adjustments, including:</p> <ul> <li> <p>Changes to MBR or GBR values</p> </li> <li> <p>Opening or closing traffic gates</p> </li> <li> <p>Updating QFI associations</p> </li> </ul> <p>Such updates allow the network to adapt QoS treatment without interrupting the session.</p>"},{"location":"blog/20260204/20260204/#urr-updates","title":"URR Updates","text":"<p>URRs may be updated to control charging and monitoring behavior, for example:</p> <ul> <li> <p>Changing reporting thresholds</p> </li> <li> <p>Resetting usage counters</p> </li> <li> <p>Enabling or disabling periodic reporting</p> </li> </ul>"},{"location":"blog/20260204/20260204/#53-session-modification-response","title":"5.3 Session Modification Response","text":"<p>The UPF responds with a Session Modification Response indicating:</p> <ul> <li> <p>Overall procedure success or failure</p> </li> <li> <p>Any updated state information required by the control plane</p> </li> </ul>"},{"location":"blog/20260204/20260204/#6-pfcp-session-release","title":"6. PFCP Session Release","text":"<p>PFCP Session Release is used to terminate a PFCP session and remove all associated user-plane state from the UPF.</p> <p>This procedure is typically triggered when:</p> <ul> <li> <p>A PDU session is released</p> </li> <li> <p>The control plane determines the session is no longer needed</p> </li> </ul>"},{"location":"blog/20260204/20260204/#61-procedure-overview","title":"6.1 Procedure Overview","text":"<p>The PFCP Session Release procedure consists of:</p> <ul> <li> <p>PFCP Session Release Request</p> </li> <li> <p>PFCP Session Release Response</p> </li> </ul> <p>The SMF sends a Release Request referencing the existing PFCP session. Upon receiving the request, the UPF proceeds to dismantle all session-related state.</p>"},{"location":"blog/20260204/20260204/#62-rule-deletion-and-resource-cleanup","title":"6.2 Rule Deletion and Resource Cleanup","text":"<p>When processing a Session Release Request, the UPF:</p> <ul> <li> <p>Deletes all PDRs, FARs, QERs, URRs, and BARs associated with the session</p> </li> <li> <p>Stops packet detection and forwarding for the session</p> </li> <li> <p>Releases allocated resources such as buffers, counters, and QoS state</p> </li> </ul> <p>Before removing URRs, the UPF may generate final usage reports if reporting triggers or quotas are configured, ensuring that charging information is not lost.</p>"},{"location":"blog/20260204/20260204/#63-session-release-response","title":"6.3 Session Release Response","text":"<p>In the Session Release Response, the UPF confirms that:</p> <ul> <li> <p>The PFCP session has been successfully removed</p> </li> <li> <p>All associated rules and resources have been released</p> </li> </ul> <p>After this response, the PFCP session no longer exists in the UPF.</p>"},{"location":"blog/20260204/20260204/#7-conclusion","title":"7. Conclusion","text":"<p>Understanding the PFCP Session lifecycle is essential for deploying, debugging, and optimizing free5GC. While the 3GPP specifications define the protocol, real insight comes from understanding how PFCP Establishment, Modification, and Release map to actual rule creation and packet processing behavior.</p> <p>By correlating PFCP messages, rule semantics, and free5GC implementation details, engineers can transform PFCP from a perceived black box into a transparent and predictable control interface.</p>"},{"location":"blog/20260204/20260204/#8-supplementary-pfcp-concepts","title":"8. Supplementary PFCP Concepts","text":"<p>This section summarizes two PFCP concepts that frequently appear in Session Establishment and Modification procedures and are essential for understanding how the UPF processes tunneled traffic.</p> <p></p>"},{"location":"blog/20260204/20260204/#81-f-teid","title":"8.1 F-TEID","text":"<p> Figure 4: F-TEID IE</p> <p>The F-TEID (Fully Qualified Tunnel Endpoint Identifier) is used by the UPF to identify incoming GTP-U packets and associate them with the correct Packet Detection Rule (PDR). It allows the UPF to distinguish multiple GTP-U tunnels on the same interface and apply the appropriate forwarding, QoS, and reporting rules.</p> <p>F-TEID is mutually exclusive with the Traffic Endpoint ID:</p> <ul> <li> <p>F-TEID is used for GTP-U tunnel\u2013based packet detection</p> </li> <li> <p>Traffic Endpoint ID is used for non\u2013GTP-U scenarios</p> </li> </ul> <p>The CH (CHOOSE) bit determines who assigns the F-TEID.</p> <p>CH = 0 (Control Plane\u2013assigned F-TEID) When CH is set to 0, the control plane explicitly provides the complete F-TEID, including:</p> <ul> <li> <p>TEID</p> </li> <li> <p>IPv4 address (if V4 = 1)</p> </li> <li> <p>IPv6 address (if V6 = 1)</p> </li> </ul> <p>In this mode, the UPF does not generate any tunnel identifiers and directly uses the provided F-TEID for PDR matching. This gives the control plane full control over tunnel allocation.</p> <p>CH = 1 (UPF-assigned F-TEID) When CH is set to 1, the TEID and IP address fields are omitted, and the UPF is instructed to allocate the F-TEID autonomously. The control plane may still indicate whether IPv4 and/or IPv6 should be used via the V4 and V6 flags.</p> <p>In free5GC, the control plane assigns the F-TEID as an implementation choice. The SMF pre-allocates the TEID, includes the complete F-TEID in the PFCP Session Establishment Request with CH = 0, and the UPF directly applies it for GTP-U packet detection without performing dynamic tunnel allocation.</p> <p></p>"},{"location":"blog/20260204/20260204/#82-outer-header","title":"8.2 Outer Header","text":"<p>An outer header is a transport encapsulation added to or removed from a user-plane packet to enable delivery over tunnel-based interfaces. It typically consists of GTP-U, UDP, and IP headers and is not part of the original user payload.</p> <p>In the UPF, outer header handling is controlled by PDRs and FARs and serves as the boundary between tunnel-based and non-tunnel interfaces.</p> <p>Outer Header Removal Outer Header Removal strips the transport encapsulation from incoming packets before further processing. It is commonly applied to uplink traffic received on tunnel-based interfaces such as N3, allowing the inner packet to be forwarded toward non-tunnel interfaces.</p> <p>Outer Header Creation Outer Header Creation adds a transport encapsulation to outgoing packets prior to transmission. It is typically applied to downlink traffic forwarded toward tunnel-based interfaces and is specified in the forwarding parameters of a FAR.</p> <p>Together, these operations enable the UPF to interwork seamlessly between tunneled and non-tunneled segments of the user plane.</p>"},{"location":"blog/20260204/20260204/#references","title":"References","text":"<ul> <li> <p>3GPP TS 29.244</p> </li> <li> <p>free5GC (analysis based on v4.2.0)</p> </li> </ul>"},{"location":"blog/20260204/20260204/#about","title":"About","text":"<p>Hello, I'm Kai-Xu Zhan. I'm honored to be a new member of the free5GC project under the Linux Foundation. As someone who is still learning and growing in the field of 5G core network development, I'm enthusiastic about contributing to the community and expanding my knowledge in telecommunications technologies. I welcome any guidance or feedback as I continue to familiarize myself with the project.</p>"},{"location":"blog/20260204/20260204/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: KASHZKX</li> </ul>"},{"location":"blog/20260211/20260211/","title":"5G-DPOP: eBPF-Based UPF Data Plane Observability Platform","text":"<p>Note</p> <p>Author: Yu-Chen, Chan Date: 2026/02/11</p>"},{"location":"blog/20260211/20260211/#1-introduction","title":"1. Introduction","text":"<p>In the 5G Core Network architecture, the User Plane Function (UPF) handles all user data plane packet forwarding. However, the UPF's packet processing logic runs in Linux Kernel space (via the gtp5g kernel module), making it difficult for traditional user-space monitoring tools to observe its internal behavior.</p> <p>When network issues occur, engineers often face the following challenges:</p> <ul> <li>Packet loss is hard to trace: Unknown where packets are dropped and why</li> <li>Inaccurate traffic statistics: Only interface-level statistics are available, unable to distinguish actual user traffic within GTP tunnels</li> <li>Session correlation is difficult: Hard to associate traffic data with specific PDU Sessions or UEs</li> </ul> <p>5G-DPOP (Data Plane Observability Platform) attempts to address these issues. This project leverages Linux eBPF technology to directly hook into key functions of the gtp5g kernel module, enabling:</p> <ul> <li>Real-time traffic monitoring: Precise Uplink/Downlink packet count and traffic statistics</li> <li>Packet drop detection: Capture every dropped packet and record the drop reason</li> <li>PFCP Session correlation: Build TEID-to-Session mappings by listening to PFCP messages</li> <li>Network topology visualization: Automatically generate UE \u2192 gNB \u2192 UPF \u2192 DN topology diagrams</li> </ul>"},{"location":"blog/20260211/20260211/#2-system-architecture","title":"2. System Architecture","text":"<p> Figure 1. 5G-DPOP System Architecture</p> <p>5G-DPOP uses a modular design consisting of the following components:</p> Component Tech Stack Description Port eBPF Agent Go + cilium/ebpf Load eBPF programs, read Kernel Maps, export Metrics 9100 PFCP Sniffer Go + gopacket Listen to PFCP messages, parse Sessions, build TEID mappings 8805 API Server Go + Gin Provide REST API and WebSocket real-time streaming 8080 Web Frontend React + TypeScript + Vite Visualization dashboard 3000 Prometheus Docker Time-series database for Metrics storage 9090 Otel Collector Docker OpenTelemetry collector 4317"},{"location":"blog/20260211/20260211/#21-ebpf-agent","title":"2.1 eBPF Agent","text":"<p>The eBPF Agent is the core of the platform, responsible for collecting data at the Kernel level.</p>"},{"location":"blog/20260211/20260211/#hook-mechanism","title":"Hook Mechanism","text":"<p>The Agent uses eBPF kprobe mechanism to hook two key functions in the gtp5g kernel module:</p> Hook Point Function Name Purpose Uplink Entry <code>gtp5g_encap_recv</code> Capture packets entering UPF from gNB Downlink Exit <code>gtp5g_dev_xmit</code> Capture packets sent from UPF to gNB <p>Additionally, we modified the gtp5g kernel module to add tracepoints for tracking packet drop events. When a packet is dropped, gtp5g triggers the tracepoint and passes the drop reason code. The eBPF program captures this and sends it to User Space via Ring Buffer.</p>"},{"location":"blog/20260211/20260211/#bpf-maps","title":"BPF Maps","text":"<p>The Agent uses various BPF Maps to store and transfer data:</p> Map Type Name Purpose <code>PERCPU_ARRAY</code> <code>traffic_stats</code> Store Uplink/Downlink traffic counters, avoiding lock contention <code>RINGBUF</code> <code>drop_events</code> Send packet drop events to User Space <code>RINGBUF</code> <code>packet_events</code> Send detailed packet information (optional) <code>HASH</code> <code>teid_session_map</code> TEID-to-Session mapping, populated by PFCP Sniffer <code>HASH</code> <code>teid_stats</code> Per-TEID traffic statistics <code>HASH</code> <code>ue_ip_stats</code> Per-UE IP traffic statistics"},{"location":"blog/20260211/20260211/#packet-drop-reason-codes","title":"Packet Drop Reason Codes","text":"<p>The gtp5g module defines various drop reasons, which the eBPF program records:</p> Code Name Description 3 <code>NO_ROUTE</code> No route to destination 6 <code>NO_PDR</code> No matching PDR rule found 8 <code>UL_GATE_CLOSED</code> Uplink QoS Gate closed 9 <code>DL_GATE_CLOSED</code> Downlink QoS Gate closed 14 <code>IP_XMIT_FAIL</code> IP layer transmission failed"},{"location":"blog/20260211/20260211/#22-pfcp-sniffer","title":"2.2 PFCP Sniffer","text":"<p>The PFCP Sniffer listens to PFCP messages between SMF and UPF, parsing Session information and building TEID mappings.</p>"},{"location":"blog/20260211/20260211/#monitored-pfcp-message-types","title":"Monitored PFCP Message Types","text":"Message Type Purpose Session Establishment Request/Response Create new Session, extract F-SEID, F-TEID, UE IP Session Modification Request/Response Update Session, may add or modify TEIDs Session Deletion Request/Response Delete Session, clean up related mappings"},{"location":"blog/20260211/20260211/#session-data-structure","title":"Session Data Structure","text":"<p>Each Session contains the following key information:</p> <pre><code>type Session struct {\n    SEID         uint64    // Session Endpoint ID\n    UEIP         net.IP    // UE IP Address\n    UPFIP        net.IP    // UPF IP Address\n    GNBIP        net.IP    // gNB IP Address\n    TEIDs        []uint32  // Associated GTP TEID list\n    DNN          string    // Data Network Name\n    QFI          uint8     // QoS Flow Identifier\n    CreatedAt    time.Time\n    // Traffic statistics\n    BytesUL, BytesDL     uint64\n    PacketsUL, PacketsDL uint64\n}\n</code></pre>"},{"location":"blog/20260211/20260211/#session-state-tracking","title":"Session State Tracking","text":"<p>The Sniffer tracks Session establishment states:</p> <ul> <li>Pending: Session Establishment Request received, waiting for completion</li> <li>Established: Session Modification received, Session is fully established</li> <li>Failed: Timed out without completion (possibly N1N2 signaling failure)</li> </ul>"},{"location":"blog/20260211/20260211/#23-api-server","title":"2.3 API Server","text":"<p>The API Server provides REST API and WebSocket interfaces for frontend queries and real-time data subscriptions.</p>"},{"location":"blog/20260211/20260211/#rest-api-endpoints","title":"REST API Endpoints","text":"Endpoint Description <code>GET /api/v1/health</code> Health check <code>GET /api/v1/sessions</code> Get all PDU Sessions <code>GET /api/v1/topology</code> Get network topology <code>GET /api/v1/metrics/traffic</code> Get traffic statistics"},{"location":"blog/20260211/20260211/#websocket-streaming","title":"WebSocket Streaming","text":"<p>The frontend subscribes to real-time data updates via WebSocket connection:</p> <ul> <li>Traffic statistics pushed every second</li> <li>Packet drop events pushed in real-time</li> <li>Session state changes notified immediately</li> </ul>"},{"location":"blog/20260211/20260211/#24-data-flow","title":"2.4 Data Flow","text":"<p>The overall data flow is as follows:</p> <p>Kernel Space:</p> <ol> <li>gtp5g module processes GTP-U packets</li> <li>eBPF programs (kprobe/tracepoint) capture packet events</li> <li>Data is sent to User Space via Ring Buffer</li> </ol> <p>User Space:</p> <ol> <li>PFCP Sniffer captures PFCP messages \u2192 extracts Session/TEID mappings</li> <li>eBPF Agent reads BPF Maps \u2192 exports metrics to Prometheus</li> <li>API Server aggregates data \u2192 provides REST API + WebSocket</li> <li>Web Frontend subscribes to WebSocket \u2192 displays real-time dashboard</li> </ol>"},{"location":"blog/20260211/20260211/#3-feature-demonstration","title":"3. Feature Demonstration","text":""},{"location":"blog/20260211/20260211/#31-real-time-traffic-monitoring","title":"3.1 Real-time Traffic Monitoring","text":"<p>The Dashboard homepage provides real-time Uplink/Downlink traffic charts for observing traffic trends.</p> <p> Figure 2. Real-time Traffic Monitoring Charts</p>"},{"location":"blog/20260211/20260211/#32-pdu-session-information","title":"3.2 PDU Session Information","text":"<p>The system automatically tracks all established PDU Sessions, displaying SEID, UE IP, TEID, and other details.</p> <p> Figure 3. PDU Session Details</p> <p>Per-Session traffic statistics can also be viewed independently:</p> <p> Figure 4. Per-Session Traffic Statistics</p>"},{"location":"blog/20260211/20260211/#33-network-topology-visualization","title":"3.3 Network Topology Visualization","text":"<p>Based on captured packet information, the system automatically generates network topology diagrams showing connections between UE, gNB, UPF, and DN.</p> <p> Figure 5. Auto-generated Network Topology</p>"},{"location":"blog/20260211/20260211/#34-packet-drop-detection","title":"3.4 Packet Drop Detection","text":"<p>When packets are dropped within the UPF, the system captures and records the drop reason in real-time for subsequent troubleshooting.</p> <p> Figure 6. Real-time Packet Drop Detection</p> <p>The system also provides drop reason statistics to help locate the root cause:</p> <p> Figure 7. Packet Drop Reason Analysis</p> <p>Common drop reasons include: - <code>NO_PDR</code>: No matching PDR rule found - <code>UL_GATE_CLOSED</code> / <code>DL_GATE_CLOSED</code>: QoS Gate closed - <code>NO_ROUTE</code>: No route to destination</p>"},{"location":"blog/20260211/20260211/#4-demo-videos","title":"4. Demo Videos","text":""},{"location":"blog/20260211/20260211/#basic-operation-demo","title":"Basic Operation Demo","text":"<p>Shows traffic monitoring and session tracking in action.</p>"},{"location":"blog/20260211/20260211/#packet-drop-test","title":"Packet Drop Test","text":"<p>Demonstrates drop detection and reason analysis.</p>"},{"location":"blog/20260211/20260211/#5-quick-start","title":"5. Quick Start","text":""},{"location":"blog/20260211/20260211/#requirements","title":"Requirements","text":"Item Requirement Operating System Ubuntu 25.04 (Kernel 6.14+ with BTF support) Go 1.21+ Node.js 18+ LTS Docker 24+"},{"location":"blog/20260211/20260211/#prerequisites","title":"Prerequisites","text":"<p>Ensure gtp5g kernel module and free5gc-compose environment are installed:</p> <pre><code># Verify BTF support\nls -la /sys/kernel/btf/vmlinux\n\n# Verify gtp5g module is loaded\nlsmod | grep gtp5g\n</code></pre>"},{"location":"blog/20260211/20260211/#installation-steps","title":"Installation Steps","text":"<pre><code># 1. Clone the project\ngit clone https://github.com/solar224/5G-DPOP.git\ncd 5G-DPOP\n\n# 2. Run environment setup script\nchmod +x scripts/setup_env.sh\n./scripts/setup_env.sh\n\n# 3. Generate vmlinux.h and compile\nsudo bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; internal/ebpf/bpf/vmlinux.h\nmake all\n\n# 4. Install frontend dependencies\ncd web &amp;&amp; npm install &amp;&amp; cd ..\n</code></pre>"},{"location":"blog/20260211/20260211/#starting-services","title":"Starting Services","text":"<p>Tip</p> <p>Startup order matters: You must start 5G-DPOP before starting free5GC. This is because DPOP needs to capture PFCP Session Establishment messages during UE registration.</p> <pre><code># Terminal 1: Start infrastructure (Prometheus, Redis)\ndocker compose -f deployments/docker-compose.yaml up -d\n\n# Terminal 2: Start Agent (requires root privileges)\nsudo ./bin/agent -pfcp-iface br-free5gc\n\n# Terminal 3: Start API Server\n./bin/api-server\n\n# Terminal 4: Start Web Frontend\ncd web &amp;&amp; npm run dev\n</code></pre> <p>After startup, open a browser and visit http://localhost:3000 to see the monitoring dashboard.</p>"},{"location":"blog/20260211/20260211/#verify-service-status","title":"Verify Service Status","text":"<pre><code># Check health status of each service\ncurl http://localhost:9100/health       # Agent\ncurl http://localhost:8080/api/v1/health # API Server\ncurl http://localhost:9090/-/healthy     # Prometheus\n</code></pre>"},{"location":"blog/20260211/20260211/#6-summary","title":"6. Summary","text":"<p>5G-DPOP provides a UPF data plane observability solution. Through eBPF technology, we can:</p> <ul> <li>Deep Kernel-level access: Directly observe gtp5g module packet processing behavior</li> <li>Real-time monitoring: Millisecond-level traffic statistics and event notifications</li> <li>Problem diagnosis: Precisely locate packet drop positions and reasons</li> <li>Visualization: Intuitive Dashboard and network topology diagrams</li> </ul> <p>For 5G Core Network developers and operators, 5G-DPOP serves as a practical diagnostic and monitoring tool that helps reduce troubleshooting time.</p>"},{"location":"blog/20260211/20260211/#references","title":"References","text":"<ul> <li>5G-DPOP - eBPF-Based UPF Data Plane Observability Platform</li> <li>gtp5g - 5G GTP-U Kernel Module</li> <li>eBPF - Extended Berkeley Packet Filter</li> <li>cilium/ebpf - Go library for eBPF</li> <li>free5GC - Open Source 5G Core Network</li> <li>3GPP TS 29.244 - PFCP Specification</li> </ul>"},{"location":"blog/20260211/20260211/#about","title":"About","text":"<p>Hello, I'm Yu-Chen Chan. I'm a contributor to the free5GC project, focusing on 5G Core Network technologies. I hope this project and blog post have been helpful. If you have any questions, suggestions, or would like to discuss further, please don't hesitate to reach out.</p>"},{"location":"blog/20260211/20260211/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: solar224</li> </ul>"},{"location":"doc/","title":"Documents","text":""},{"location":"doc/#design-documents","title":"Design Documents","text":"<p>We maintain the design documents to help people started contributing to the free5GC, it includes the following topics: 1. Software Architecture 2. Dedicated issue and solution 3. Domain knowledges for 5GC development</p> <ul> <li>AMF</li> <li>AUSF</li> <li>SMF</li> <li>UPF (GTP5G)</li> <li>UPF (PFCP)</li> <li>CHF</li> <li>PCF (Charging)</li> <li>OAuth2 on SBI</li> <li>N3IWUE</li> <li>NR-DC</li> <li>Problem Details</li> </ul>"},{"location":"doc/#5gc-docsspecs","title":"5GC Docs/Specs","text":"<ul> <li>Tech-invite (3GPP Specs)<ul> <li>For beginner: TS 23.501, 23.502</li> <li>NF Service: TS 29.50X</li> </ul> </li> <li>Awesome 5G</li> <li>5GC APIs</li> </ul>"},{"location":"doc/Amf/design/","title":"AMF Design Document","text":"<p>Note</p> <p>Author: TungHao Shih Date: 2024/04/25</p>"},{"location":"doc/Amf/design/#introduction","title":"Introduction","text":"<p>The Access &amp; Mobility Management Function (AMF) plays a critical role in managing User Equipment(UE) registration, connectivity, reachability, mobility. It interacts with other network functions (NF)  such as Unified Data Management (UDM), Session Management Function (SMF), and Authentication Server Function (AUSF).</p> <p>The main purpose of writing this article is to share the software architecture of how the AMF in free5GC handles UE Context Operations in AMF Communication.</p>"},{"location":"doc/Amf/design/#description","title":"Description","text":"<p>In 5G networks, UE context refers to a collection of data maintained by the Access and Mobility Management Function (AMF) about a specific User Equipment (UE). This data is essential for managing the UE's connection to the network. Namf_Communication service enables an NF to communicate with the UE through N1 NAS messages or with the AN.</p> <p>The following diagram illustrates the flow of UE Context Operations within the AMF in the free5GC implementation: </p> <p>[1] Listen and Serve : </p> <ul> <li>The AMF monitors UE Context Operations Requests from NF Service Consumers and provides a response through the ListenandServe function.</li> </ul> <p>[2] Service-based interface handler :</p> <ol> <li> <p>[2-1] UE Context Operations   :</p> <ul> <li> <p>CreateUEContext : The CreateUEContext operation is invoked by a NF Service Consumer, like a source AMF, towards the target AMF during a handover process when the source AMF cannot serve the UE. Its purpose is to establish the UE Context in the target AMF. The NF Service Consumer sends a HTTP PUT request to the target AMF, it creates the UEContext. The payload body of the PUT request should include a UeContextCreateData structure, which contains an N2 Information Notification callback URI.</p> </li> <li> <p>RegistrationStatusUpdate : The RegistrationStatusUpdate operation is invoked by a NF Service Consumer, like a target AMF, towards the source AMF. It updates the UE registration status at the target AMF, indicating the result of the previous UE Context transfer for a given UE. The NF Service Consumer, send a HTTP POST request to invoke the \"transfer-update\" custom operation on the URI of an \"Individual ueContext\" resource, to update the source AMF with the UE registration status at the target AMF.</p> </li> <li> <p>ReleaseUEContext  : The ReleaseUEContext operation is invoked by a NF Service Consumer, like a source AMF, towards the target AMF, when the source AMF receives the Handover Cancel from the 5G-AN during the handover procedure, to release the UE Context in the target AMF. The NF Service Consumer send a HTTP POST request to release the UEContext in the target AMF. The payload body of the POST request shall contain any data that needs to be passed to the target AMF. </p> </li> <li> <p>UEContextTransfer : The UEContextTransfer operation is invoked by a NF Service Consumer, like a target AMF, towards the source AMF when the target AMF receives a Registration Request with the UE's 5G-GUTI included, and the serving AMF has changed since last registration, to retrieve the UE Context. The NF Service Consumer send a HTTP POST request to invoke \"transfer\" custom method on an \"Individual ueContext\" resource URI. The payload of the request shall be an object of \"UeContextTranferReqData\" data type.</p> </li> </ul> </li> <li> <p>[2-2] EBIAssignment : </p> <ul> <li>EBIAssignment : The EBIAssignment service operation is invoked by a NF Service Consumer(such as SMF), towards the NF Service Producer(the AMF). This request asks the AMF to assign EPS bearer IDs to EPS bearers, which are mapped from QoS flows, for an existing PDU Session associated with a specific UE.</li> </ul> </li> </ol>"},{"location":"doc/Amf/design/#reference","title":"Reference","text":"<ul> <li>3GPP TS 23.502: Procedures for the 5G System (5GS)</li> <li>3GPP TS 23.518: Access and Mobility Management Services (5G System)</li> </ul>"},{"location":"doc/Amf/design/#about","title":"About","text":"<p>Thank you for reading. I am a member of the free5GC team. If you come across any errors in the article or have questions about the content, please feel free to reach out. Your insights and feedback are highly appreciated.</p>"},{"location":"doc/Amf/design/#connect-with-me","title":"Connect with Me","text":"<ul> <li>Linkedin: https://www.linkedin.com/in/tunghao-shih-b8a3b323b/</li> <li>Github: https://github.com/donald1218</li> </ul>"},{"location":"doc/Ausf/design/","title":"AUSF Software Architecture","text":"<p>Note</p> <p>Author: TingYuan Chou Date: 2024/03/02</p>"},{"location":"doc/Ausf/design/#introduction","title":"Introduction","text":"<p>The Authentication Server Function (AUSF) plays a critical role in the security framework of 5G networks, particularly in handling the authentication of User Equipment (UE). It serves as a central entity that facilitates the authentication process between the UE and the network, ensuring that only authorized users gain access. This process involves the generation and verification of authentication vectors, and the implementation of the 5G AKA (Authentication and Key Agreement) protocol.</p> <p>This blog aims to shed light on the software architecture surrounding the AUSF's handling of UE authentication requests. We will explore how the AUSF operates within the 5G core network, focusing on its interactions with other network functions, such as the Unified Data Management (UDM) and the Network Repository Function (NRF). Additionally, we will delve into the flow of authentication messages, the security mechanisms in place, and how the AUSF manages sessions and security contexts.</p>"},{"location":"doc/Ausf/design/#description","title":"Description","text":"<p>When the AUSF (Authentication Server Function) is initiated within a 5G network, it activates several key functionalities crucial for managing the authentication and security of User Equipment (UE). These functionalities can be broadly categorized into three main areas: Secure Communication Setup, Authentication Protocol Handling, and Service-based Interface Management. Each of these areas plays a vital role in ensuring that the AUSF effectively secures network access and communication.</p> <p>[1] Listen and Serve : </p> <ul> <li>Once the AUSF receives an authentication request, typically from the AMF (Access and Mobility Management Function) as part of the 5G security procedures, it will be processed through a secure communication channel. The AUSF listens for incoming authentication requests through its service-based interface, ensuring secure and reliable transport, often utilizing protocols like HTTPS for secure transmission over the network.</li> </ul> <p>[2] Service-based interface handler for AUSF:</p> <ol> <li> <p>[2-1] UE Authentication:</p> <ul> <li>(1) EAP-AKA :  The EAP-AKA' authentication process, as detailed in RFC 5448 and 3GPP TS 33.501, is a sophisticated mechanism designed to ensure secure communication between the User Equipment (UE) and the network. This process involves several steps, starting with the generation of an authentication vector (AV) by the Unified Data Management/Authentication Repository and Processing Function (UDM/ARPF), and culminates in the successful establishment of a secure session between the UE and the network.</li> </ul> <p></p> <p>Authentication procedure for EAP-AKA, described in 3GPP TS 33.501 clause 6.1.3.1</p> <p>The EAP-AKA' authentication sequence unfolds as follows, correlating with the sequence diagram above which is depicted in TS33.501</p> <ul> <li>Authentication Vector (AV) Creation: Initiated by the UDM/ARPF generating a tailored AV.</li> <li>AV Transmission to AUSF: The AV is sent to the AUSF, signaling readiness for authentication.</li> <li>Challenge Issuance and UE Response: The AUSF challenges the UE, which then responds, showcasing its authenticity.</li> <li>Response Verification: The AUSF verifies the UE's response, a crucial step for security.</li> <li> <p>Secure Session Establishment: Successful verification leads to establishing a secure session.</p> </li> <li> <p>(2) 5G-AKA : The 5G AKA authentication procedure enhances the security mechanisms of previous generations (EPS AKA) by incorporating additional steps and checks to verify the identity of the UE and establish a secure session. This process, as outlined in the provided diagram, includes the generation of authentication vectors, challenge and response exchanges, and the final confirmation of a successful authentication.</p> </li> </ul> <p></p> <p>Authentication procedure for 5G AKA , described in 3GPP TS 33.501 clause 6.1.3.2</p> <p>The authentication procedure unfolds as follows, aligned with the flow above which is depicted in TS33.501</p> <ul> <li>Authentication Vector (AV) Creation: The UDM/ARPF generates a 5G AV, initiating the process.</li> <li>AV Transmission to AUSF: The AV is dispatched to the AUSF to begin the authentication challenge.</li> <li>Challenge Issuance and UE Response: The AUSF challenges the UE, which must respond accurately.</li> <li>Response Verification: The AUSF verifies the UE's response, ensuring the authentication's integrity.</li> <li> <p>Secure Session Establishment: Upon successful verification, a secure session is established with the UE.</p> </li> <li> <p>(3) Post : This function handles post-authentication requests from the UE, such as re-authentication or authentication status queries. It ensures that the UE's authentication state is correctly managed throughout its network stay, facilitating continuous security assurance.</p> </li> </ul> </li> <li> <p>[2-3] Authentication Context Management : </p> <ul> <li>An essential function for retrieving the authentication context of a specific UE. This context includes the UE's authentication status, any stored vectors or keys, and the current security context. It's used by the AUSF to fetch the latest authentication information for decision-making processes, ensuring that the UE's interactions with the network remain secure and personalized. This function is vital for operations requiring an understanding of the UE's current authentication and security state, including session updates, security policy enforcement, and during handovers or network re-entries.</li> </ul> </li> </ol>"},{"location":"doc/Ausf/design/#reference","title":"Reference","text":"<ul> <li>3GPP TS 23.509: Authentication Server Services (5G System)</li> <li>3GPP TS 33.501: Security architecture and procedures for 5G System</li> <li>LTE Authentication Introduction: EPS-AKA</li> </ul>"},{"location":"doc/Ausf/design/#about","title":"About","text":"<p>Greetings, I'm Chou, a newcomer to free5gc. I'm excited to share my experiment for the first time. If you spot any errors or have any questions, please don't hesitate to reach out. Your feedback is greatly appreciated.</p>"},{"location":"doc/Ausf/design/#connect-with-me","title":"Connect with Me","text":"<ul> <li>Linkedin: https://www.linkedin.com/in/%E5%AE%9A%E9%81%A0-%E5%91%A8-4b3800193/</li> <li>Github: https://github.com/TYuan0816</li> </ul>"},{"location":"doc/Chf/design/","title":"CHF Design Document","text":"<p>Note</p> <p>Author: Ian Chen, Andy Chen</p> <p>If you're interested in a brief overview of the charging system, please refer to the previous tech blog: link.</p> <p>The charging functionalities have been supported since free5GC v3.4.1. We implement the converged charging system (CHF) and several changes:</p> <ul> <li>Add Billing Domain in webconsole</li> <li>PCF supports to generate charging info in SM Policy decision</li> <li>SMF supports PDU-Session level Online/Offline charging</li> </ul>"},{"location":"doc/Chf/design/#usage-report","title":"Usage Report","text":"<p>Online and Offline charging rely on the usage report(s) reported from UPF to SMF via the PFCP Session Report (defined in 3GPP TS 29.244). The feature of the usage report has been supported since v3.3.0; the key points of the design are listed below:</p> <ul> <li> <p>URR's (Usage Reporting Rules) ID in the range of 1 ~ 6 is preserved for default settings:</p> <ul> <li>ID <code>1</code> for MBQE (Measurement Before QoS Enforcement) of the single UPF.</li> <li>ID <code>2</code> for MAQE (Measurement After QoS Enforcement) of the single UPF.</li> <li>ID <code>3</code> for MBQE of the branching UPF (ULCL).</li> <li>ID <code>4</code> for MAQE of the branching UPF (ULCL).</li> <li>ID <code>5</code> for MBQE of the anchor UPF (ULCL).</li> <li>ID <code>6</code> for MAQE of the anchor UPF (ULCL).</li> </ul> </li> <li> <p>Uplink and Downlink PDRs share the same URR.</p> </li> <li> <p>The URR ID of the charging URR will be 7 or greater number.</p> </li> <li> <p>If the charging method is Online Charging:</p> <ul> <li> <p>The URR has the Start of the SDF (Service Data Flow) trigger.</p> </li> <li> <p>When the UPF receives the first packet of the data flow, then UPF will send the notification to SMF to get the transmission reservation quota/volume.</p> </li> <li> <p>Once the usage reaches the threshold (a little below quota),  UPF tries to renew the reservation quota/volume and updates the actual usage to SMF. </p> </li> <li> <p>If the SMF finds out that the session is out of quota, the UPF will not get the quota, and the UPF will drop all of the data in the flow.</p> </li> <li> <p>The related settings are in the SMF configuration file: </p> <ul> <li><code>requestedUnit</code> indicates how many byte doses one reservation is reserved. </li> </ul> <pre><code>configuration:\n    smfName: SMF\n  requestedUnit: 1000 # The unit per quota reservation \n</code></pre> </li> </ul> </li> <li> <p>If the charging method is Offline Charging:</p> <ul> <li>The URR indicates the volume threshold and time period.</li> <li>Offline charging only needs UPF to report the usage of the flow. </li> <li> <p>The related settings are in the SMF configuration file: </p> <ul> <li><code>urrPeriod</code> indicates how many seconds doses URR periods.</li> <li><code>urrThreshold</code> indicates how many bytes doses URR threshold.</li> </ul> <pre><code>configuration:\n    smfName: SMF\n    urrPeriod: 10       # default usage report period in seconds\n  urrThreshold: 1000  # default usage report threshold in bytes\n</code></pre> </li> </ul> </li> </ul> <p></p> <ul> <li>Webconsole is a Billing Domain system, that can collect the CDR files from CHF via FTP protocol.</li> <li>PCF is responsible for allocating the rating group; the rating group generator is globally unique.</li> <li>SMF is CTF (Charging Trigger Function) in our use case.<ul> <li>SMF can find the rating group by using URR ID, which helps SMF grant the new quota from CHF by triggering the charging data request.</li> </ul> </li> </ul>"},{"location":"doc/Chf/design/#main-characters-in-the-charging-system","title":"Main characters in the charging system","text":""},{"location":"doc/Chf/design/#charging-on-pdu-session","title":"Charging on PDU Session","text":"<p>Although 3GPP defined the FBC (Flow-Based Charging) and QBC (QoS Flow-Based Charging), But free5GC now only supports the FBC on the data usage of PDU Session(s), So we will focus on the FBC in this document.</p> <p>2 levels of triggers can be supplied by the CHF:</p> <ul> <li>[ ] Triggers associated with the PDU session.</li> <li>[x] Triggers associated with a rating group within the PDU session.</li> </ul> <p></p> <p>PDU session establishment, described in 3GPP TS 32.255 clause 5.2.2.2.2</p> <p>Charging on PDU Session is achieved by FBC charging, with specific rating group/service identifier:</p> <ul> <li>As we mentioned, the rating group will be allocated by PCF during the SM Policy Authorization (Step 6 in the figure above).<ul> <li>PCC Rule for charging additionally indicates the rating group, SDF template, and charging method.</li> </ul> </li> <li>After the UPF selection, SMF sends the Charging Data Request to initiate the charging session and also applies the data plane rules to UPF via N4 Session Establishment/Modification.</li> <li>When the first uplink data comes to UPF, it will trigger the Charging Data Request [Update] to update the CDR file.</li> </ul>"},{"location":"doc/Chf/design/#others","title":"Others","text":"<ul> <li>For ULCL deployment, only the data usage of the PSA-UPF will be charged (it avoids charging the same data packet twice).</li> <li>In our implementations, UPF is composed of the <code>go-upf</code> (Controller) and <code>gtp5g</code> (Executor).<ul> <li><code>gtp5g</code> sends the usage report to <code>go-upf</code> via unix socket.</li> <li><code>gtp5g</code> is able to send multiple reports at once, which reduces the communication effort in UPF.</li> </ul> </li> <li>PCF Charing Design</li> </ul>"},{"location":"doc/Gtp5g/design/","title":"UPF Design Document","text":"<p>Note</p> <p>Author: HanHung Chen Date: 2024/03/13</p>"},{"location":"doc/Gtp5g/design/#introduction","title":"Introduction","text":"<p>The User Plane Function (UPF) plays a crucial role in data transfer within the 5G network. It is interconnected with the Data Network (DN) in the 5G architecture. As a primary network function (NF) of the 5G core network (5GC), it handles the most critical aspects of data processing. It is responsible for packet routing and forwarding, packet inspections, quality of service (QoS) handling, and an anchor point for intra &amp; inter-RAT mobility, with new functions on the horizon. UPF has N3, N4, N6 and N9 four interfaces. Their usages are below:</p> <ul> <li>N3: Interface between RAN and the UPF. N3 is based on the GTP-U protocol.</li> <li>N4: Interface between Session Management Function (SMF) and the UPF. N4 is based on the PFCP protocol.</li> <li>N6: Interface between DN and UPF.</li> <li>N9: Interface between two UPFs.</li> </ul> <p>The free5GC implements UPF in two parts, which are:</p> <ul> <li>Control plane: GO-UPF (N4)</li> <li>Data plane: GTP5G (N3, N6, N9)</li> </ul> <p>GTP5G is a communication protocol essential for data transmission within the 5G core network. It operates on the user plane, which is responsible for transporting user data between user equipment and the Internet.</p> <p>This article will focus on the Data plane. Discuss how GO-UPF and GTP5G  handle packets within uplink and downlink transmission.</p>"},{"location":"doc/Gtp5g/design/#data-processing-flow","title":"Data Processing Flow","text":"<p>[1] GO-UPF configuration</p> <ul> <li> <p><code>NewDriver()</code>:</p> <ul> <li>In addition to initializing a GTP5G device for handling uplink and downlink packets, it is also necessary to configure the corresponding routes for this device.</li> </ul> </li> <li> <p><code>OpenGtp5gLink()</code>:</p> <ul> <li>The function <code>OpenGtp5gLink()</code> passes the UDP Socket representing N3, accessed through <code>f.Fd()</code>, as a parameter in the <code>IFLA_LINKINFO</code> message to the gtp5g kernel module in the kernel space. The gtp5g module then uses this socket to establish a UDP tunnel for N3.</li> </ul> </li> <li><code>RouteAdd()</code>:<ul> <li>Add the corresponding route for the N6 Downlink, it indicates all of the traffic, sent to UE, will proceed by the gtp5g network device.</li> </ul> </li> </ul> <p>[2] gtp5g_init() initializes gtp5g kernel module:</p> <ul> <li> <p><code>create_proc()</code>:</p> <ul> <li>The Proc filesystem is a virtual filesystem that allows userspace programs to access kernel data structures and state.</li> </ul> </li> <li> <p><code>register_pernet_subsys()</code>:</p> <ul> <li>The <code>register_pernet_subsys()</code> function is used to register a pernet subsystem. A pernet subsystem is a framework for managing network namespaces. This allows the gtp5g module to run in different network namespaces.</li> </ul> </li> <li> <p><code>generic family</code>:</p> <ul> <li>The gtp5g_genl_family structure is used to define a generic netlink family. A generic netlink family is a way for userspace programs to communicate with the kernel.</li> </ul> </li> <li> <p><code>rtnl_link_ops</code>:</p> <ul> <li>The rtnl_link_ops structure is used to define operations related to network devices.</li> </ul> </li> </ul> <p>[3] Uplink initialization</p> <ol> <li><code>gtp5g_newlink()</code>:<ul> <li>Used to build N3 UDP tunnel and register a new gtp5g device.</li> </ul> </li> <li><code>gtp5g_encap_enable()</code>:<ul> <li>Bind UDP socket for receiving N3 packet.</li> </ul> </li> </ol> <p>[4] Uplink transmission</p> <ol> <li><code>gtp5g_encap_recv()</code>:<ul> <li>At the end of gtp5g_encap_enable function: <code>tuncfg.encap_rcv = gtp5g_encap_recv;</code> \\   it indicates that <code>gtp5g_encap_recv()</code> function is responsible for handling the UDP tunnel receiving packet.</li> </ul> </li> <li><code>gtp1u_udp_encap_recv()</code>:<ul> <li>The function handles packets encapsulated by GTP protocol. </li> </ul> </li> <li><code>netif_rx()</code>:<ul> <li>Provided by the kernel, it sends the packets through the N6 interface.</li> </ul> </li> </ol> <p>[5] Downlink initialization</p> <ol> <li><code>gtp5g_link_setup()</code>:<ul> <li>Set up net device.</li> </ul> </li> <li><code>gtp5g_netdev_ops</code>:<ul> <li>It's a structure that defines how gtp5g deals with N6 packets.</li> </ul> </li> <li><code>gtp5g_dev_init()</code>:<ul> <li>It is called after the net device is registered and initializes some of the device's status.</li> </ul> </li> </ol> <p>[6] Downlink transmission</p> <ol> <li><code>gtp5g_dev_xmit()</code>:<ul> <li>This function is defined by <code>gtp5g_netdev_ops</code> so it is called when a packet needs to be transmitted.</li> </ul> </li> <li><code>gtp5g_handle_skb_ipv4()</code>:<ul> <li>It will query the PDR based on the destination IP. If found successfully, the FAR will then be checked to determine how to handle the packet.</li> </ul> </li> <li><code>gtp5g_xmit_skb_ipv4()</code>:<ul> <li>If FAR action is confirmed as <code>FAR_ACTION_FORW</code>, the function <code>gtp5g_xmit_skb_ipv4()</code> will be called and packets will be sent to the UDP tunnel.</li> </ul> </li> </ol>"},{"location":"doc/Gtp5g/design/#reference","title":"Reference","text":"<ul> <li>3GPP TS 23.501: System architecture for the 5G System</li> <li>gtp5g \u539f\u59cb\u7a0b\u5f0f\u78bc\u89e3\u8aaa https://ithelp.ithome.com.tw/articles/10302887</li> </ul>"},{"location":"doc/Gtp5g/design/#about-me","title":"About me","text":"<p>Hi, I am Han-Hong Chen, a beginner to 5G and free5gc. This is my first time writing technical article. Let me know without hesitation if there is any mistake in the article.</p>"},{"location":"doc/Gtp5g/design/#connect-with-me","title":"Connect with Me","text":"<ul> <li>GitHub: https://github.com/HanHongChen</li> </ul>"},{"location":"doc/N3IWUE/n3iwue/","title":"N3IWUE Design Document","text":"<p>Warning</p> <p>This document doesn't include all design details about N3IWUE.</p>"},{"location":"doc/N3IWUE/n3iwue/#info","title":"Info","text":"<ul> <li>GitHub Repo https://github.com/free5gc/n3iwue</li> <li>Installation Guide</li> <li>TS23.502 Procedures for Untrusted non-3GPP access</li> <li>Netlink Go Library</li> </ul>"},{"location":"doc/N3IWUE/n3iwue/#gre-tunnels","title":"GRE Tunnels","text":"<p>Note</p> <p>Author: Andy Chen (CTFang) Date: 2024/06/12</p>"},{"location":"doc/N3IWUE/n3iwue/#gre-tunnel-spec","title":"GRE Tunnel &amp; Spec","text":"<p>Here is part of TS24.502 Access 5GCN via non-3GPP access networks spec:</p> <p>The GRE key field must use the QFI value as its key. </p> <p>N3IWUE uses the Netlink Go library to create GRE Tunnel. Here is a segment of code for the new GRE Interface. </p> <pre><code>greKeyField = (uint32(qfi) &amp; 0x3F) &lt;&lt; 24\nnewGreIfaceName := greIfaceName + \"-\" + strconv.Itoa(int(qfi))\n\n// New GRE tunnel interface\nnewGRETunnel := &amp;netlink.Gretun{\n  LinkAttrs: netlink.LinkAttrs{\n    Name: newGreIfaceName,\n    MTU:  1438, // remain for endpoint IP header(most 40 bytes if IPv6) and ESP header (22 bytes)\n  },\n  Link:   uint32(parent.Attrs().Index), // PHYS_DEV in iproute2; IFLA_GRE_LINK in linux kernel\n  Local:  ueTunnelAddr,\n  Remote: n3iwfTunnelAddr,\n  IKey:   greKeyField,\n  OKey:   greKeyField,\n}\n</code></pre> <p>And the default rule always has QFI = 1. </p>"},{"location":"doc/N3IWUE/n3iwue/#832-generic-routing-encapsulation-gre","title":"8.3.2 Generic routing encapsulation (GRE)","text":"<p>If a user data packet message is transmitted over non-3GPP access between the UE and the N3IWF for untrusted non3GPP access, the user data packet message shall be encapsulated as a GRE user data packet.</p> <p>In the GRE encapsulated user data packet:</p> <p>\u200b b) the QFI field of the key field of the GRE header field is set to the QFI associated with the user data packet;</p>"},{"location":"doc/N3IWUE/n3iwue/#procedure","title":"Procedure","text":"<p>During the N3IWUE PDU session Establishment procedure, when UE receives PDUSessionEstablishmentAccept, N3IWUE will try to do the following things: (refer to <code>n3iwue/internal/nwucp/handler/handler.go &gt; HandleDLNASTransport()</code>)</p> <ul> <li>Get PDU Address from NAS</li> <li>Setup GRE Tunnels<ul> <li>N3IWUE create per tunnel for each QFI</li> </ul> </li> <li>Add Route for GRE Tunnels <ul> <li>N3IWUE adds routes for each tunnel</li> <li>Remote IPv4 address for each QFI retrieve from NAS message</li> </ul> </li> </ul>"},{"location":"doc/N3IWUE/n3iwue/#example-scenario","title":"Example Scenario","text":"<ul> <li>Two QoS rules<ul> <li>QFI = 2, address = 1.1.1.1</li> <li>QFI = 3, address = 8.8.8.8</li> </ul> </li> </ul> <p>So, the N3IWUE would create 3 GRE tunnels and 3 routes.</p> <p></p> <p>After the ping test, use <code>ifconfig</code> to see the status for each GRE interfaces:</p> <p></p> <ul> <li>ens18 is the only one interface on that computer </li> <li>gretun-id-2-1 for QFI = 1, receive 5 ping reply from 9.9.9.9 and send 5 ping request with some others traffics.</li> <li>gretun-id-2-2 for QFI = 2, send 5 ping request to 8.8.8.8 and receive 5 ping reply. </li> <li>gretun-id-2-3 for QFI = 3, send 5 ping request to 1.1.1.1 and receive 5 ping reply. </li> </ul>"},{"location":"doc/N3IWUE/n3iwue/#related-pull-request","title":"Related Pull Request","text":"<p>fix: Add multiple GRE tunnel when have multiple QFI settings #7</p>"},{"location":"doc/NR-DC/nrdc/","title":"NR-DC(New Radio-Dual Connectivity)","text":"<p>Note</p> <p>Author: Alonza Tu Date: 2025/06/05 Update: 2025/08/04</p> <p></p>"},{"location":"doc/NR-DC/nrdc/#introduction","title":"Introduction","text":"<p>Introduction for NR-DC, please refer to: Introducing NR-DC: Dual Connectivity for Next-Gen 5G Capabilities</p> <p>In the design document, it only concerns the core network side. For RAN and UE, there will prensent where to append the additional tunnel information but without real implementation for actual using.</p>"},{"location":"doc/NR-DC/nrdc/#types","title":"Types","text":"<p>In real 5G networks, the NR-DC feature can be implemented in two ways:</p> <ol> <li>Static Approach: Two tunnels are established when the gNB and UE's PDU session starts.</li> <li>Dynamic Approach: After the PDU session is established, the gNB can dynamically offload QoS traffic to the secondary gNB or retrieve the traffic at any time.</li> </ol>"},{"location":"doc/NR-DC/nrdc/#basic-setup","title":"Basic Setup","text":"<p>Before discussing the approach methods, we have to do some modification in SMF.</p> <p>In the current system, there will only be one TUNNEL record in <code>SMContext</code>:</p> <pre><code>type SMContext struct {\n    ...\n    LocalULTeid uint32\n    LocalDLTeid uint32\n    ...\n    Tunnel   *UPTunnel\n    ...\n}\n</code></pre> <p>To support the second tunnel creation, there are three new items in <code>SMContext</code>:</p> <pre><code>type SMContext struct {\n    ...\n    LocalULTeid uint32\n    LocalDLTeid uint32\n=&gt;  LocalULTeidForSplitPDUSession uint32\n=&gt;  LocalDLTeidForSplitPDUSession uint32\n    ...\n    Tunnel   *UPTunnel\n=&gt;  DCTunnel *UPTunnel\n    ...\n}\n</code></pre>"},{"location":"doc/NR-DC/nrdc/#static-approach","title":"Static Approach","text":"<p>In static approach, TWO TUNNELs will be created during PDU session established.</p> <p>So, in the procedure of PDU session establishment, we need to do some modification:</p> <p>According to TS 23.502 4.3.2.2, the steps 11 to 16 will be the PDU session's tunnels configuration procedure:</p> <p></p> <p>In the general case, step 11 (N1N2 Message Transfer) contains a single UPLINK TEID and related information, allowing the gNB to determine where to forward the packet. However, in NR-DC, the SMF should generate TWO UPLINK TEIDs for the two tunnels. Both are stored as <code>ngapType.PDUSessionResourceSetupRequestTransferIEs</code>: one <code>under ngapType.ProtocolIEIDULNGUUPTNLInformation</code>, and the other under <code>ngapType.ProtocolIEIDAdditionalULNGUUPTNLInformation</code>.</p> <p>These informations will be encapsulated as N2 PDU Session Request by AMF and sent to Master-gNB.</p> <p>Note</p> <p>According to TS 38.413 9.4.3.1, <code>AdditionalULNGUUPTNLInformation</code> can carry the secondary UPLINK TEID for the second tunnel using. </p> <p>After receiving these two UPLINK TEIDs, if the Master-gNB is configured as turning on the DC function, it should save the first UPLINK TEID for itself using and send the additional(second) UPLINK TEID to the Secondary-gNB via Xn-interface. Once the Secondary-gNB get the UPLINK TEID, it returns its DOWNLINK TEID back to the Master-gNB.</p> <p></p> <p>Finally, Master-gNB will encapsolate these TWO DOWNLINK TEIDs into the data type of <code>ngapType.PDUSessionResourceSetupResponseTransfer</code>, the first one is under <code>DLQosFlowPerTNLInformation</code> and the other is under <code>AdditionalDLQosFlowPerTNLInformation</code>. Then, these IEs will be send back to core network as N2 PDU Session Response in step 14.</p> <p>Note</p> <p>Accordint to TS 38.413 9.3.4.2, <code>AdditionalDLQosFlowPerTNLInformation</code> can carry the secondary DOWNLINK TEID for the second tunnel using. </p> <p>Once SMF get TWO DOWNLINK TEIDs in N2 message, it will set a flag <code>HasNRDCSupport</code> as true in <code>SMContext</code> and store the addition downlink tunnel information. Then, the second tunnel, DCTunnel will be create in the PDU session update procedure. The tunnel's rules will be sent to UPF via step 16(N4Session Modification).</p> <p>Warning</p> <p>In current implementation, the Master-gNB will process the default traffics and the Secondary-gNB will process all the specified QoS traffics which are configured through webconsole.</p> <p>Finally, you can use these tunnel to transfer traffics in efficient.</p>"},{"location":"doc/NR-DC/nrdc/#dynamic-approach","title":"Dynamic Approach","text":"<p>In the dynamic approach, the first tunnel is established during PDU session establishment, while the second tunnel is set up only when needed.</p> <p>According to TS 37.340  10.2.2, if the master gNB wants to split a bearer\u2014i.e., offload specific traffic flows to the secondary gNB\u2014it will interact with the secondary gNB and then send the tunnels' information back to the core network.</p> <p></p> <p>After the master gNB retrieves the second downlink tunnel information from the secondary gNB, it should encapsulate this tunnel information into <code>ngapType.PDUSessionResourceModifyIndicationTransfer</code> and send it to the AMF.</p> <p>Note</p> <p>According to TS 38.413 8.2.5.2, the IE <code>DL QoS Flow per TNL Information</code> carries the master tunnel's information, while the IE <code>Additional DL QoS Flow per TNL Information</code> carries the second tunnel's information. </p> <p>After the SMF receives this <code>PDUSessionResourceModifyIndicationTransfer</code> message forwarded by the AMF, it will check whether NR-DC is currently being activated and parse the message to retrieve tunnels' information. If NR-DC is being activated, the SMF will merge the second tunnel into the master tunnel and then release it. Otherwise, the SMF will configure the second tunnel by updating the N4 session, which will create and update the PDR/FAR in the UPF.</p> <p>If the modification procedure is successful, the SMF will respond with a confirmation message called <code>ngapType.PDUSessionResourceModifyConfirmTransfer</code>.</p> <p>Note</p> <p>According to TS 38.413 8.2.5.2, the confirmation message contains information about both successful and failed flow updates. </p> <p>Upon receiving the confirmation message, the master gNB utilizes it to proceed with the configuration of the second tunnel on the secondary gNB.</p>"},{"location":"doc/NR-DC/nrdc/#how-to-use","title":"How to use?","text":"<p>Please refer to our user guide: NR-DC</p>"},{"location":"doc/NR-DC/nrdc/#code-implementation","title":"Code Implementation","text":"<ul> <li>SMF: feat/nr-dc(static version)</li> <li> <p>free5GC: feat/nr-dc(static version)</p> </li> <li> <p>SMF: feat/nr-dc(dynamic version)</p> </li> <li>free5GC: feat/nr-dc(dynamic version)</li> </ul>"},{"location":"doc/NR-DC/nrdc/#reference","title":"Reference","text":"<ul> <li>PacketRusher</li> <li>TS 23.502 Procedure for the 5G System</li> <li>TS 37.340 E-UTRA and NR \u2013 Multi-connectivity \u2013 Overall description \u2013 Stage 2</li> <li>TS 38.413 NG-RAN \u2014 NG interface \u2013 NG Application Protocol (NGAP)</li> </ul>"},{"location":"doc/OAuth2/OAuth2Design/","title":"free5GC OAuth2 Design","text":"<p>Note</p> <p>Author: Andy Chen (CTFang, Tsung-Fang Chen) Date: 2024/02/22</p> <p>We release OAuth2 on SBI in free5GC v3.4.0. This article shows you how we design OAuth2 in free5GC. </p> <p>This is the OAuth2 Procedure we released in the blog.</p> <p></p>"},{"location":"doc/OAuth2/OAuth2Design/#tokenkey-management","title":"Token/Key Management","text":"<ul> <li>The NRF utilizes its private key to generate tokens.</li> <li>NF Service Producers utilize the NRF's public key to validate the tokens.</li> </ul> <p>Instead of using the NF's public key to generate tokens, we opt for a simpler key management approach.</p> <p>In this design, the NRF only needs to securely store its private key, while other NFs only need to know the location of the NRF's certificate. This simplifies key management for the NRF, as it avoids the need to manage numerous NF public keys.</p>"},{"location":"doc/OAuth2/OAuth2Design/#enable-oauth2","title":"Enable OAuth2","text":""},{"location":"doc/OAuth2/OAuth2Design/#nrf","title":"NRF","text":"<ul> <li>NRF acts as the decider on whether to use OAuth2 in the service-based interface (SBI). </li> <li>First, we should set <code>oauth</code> in the NRF configuration file. </li> </ul> <pre><code>configuration:\n  sbi: # Service-based interface information\n    oauth: true\n</code></pre> <ul> <li>When NFs initiate NF_Registration, then NRF would put the <code>oauth2</code> setting in <code>customInfo</code>, an element of NFProfile, back to NFs. </li> </ul>"},{"location":"doc/OAuth2/OAuth2Design/#nfs","title":"NFs","text":"<p>We use part of the SMF code, for explanation. </p> <ul> <li> <p>Service Consumer</p> <ul> <li>We define <code>GetTokenCtx()</code> in each NF. </li> </ul> <pre><code>func (c *SMFContext) GetTokenCtx(serviceName models.ServiceName, targetNF models.NfType) (\n    context.Context, *models.ProblemDetails, error,\n) {\n    if !c.OAuth2Required {\n        return context.TODO(), nil, nil\n    }\n    return oauth.GetTokenCtx(models.NfType_SMF, targetNF,\n        c.NfInstanceID, c.NrfUri, string(serviceName))\n}\n</code></pre> <ul> <li> <p><code>oauth.GetTokenCtx()</code> in openapi would use the information provided by NF to get token from NRF, and return a <code>context</code> with value (token) in HTTP header. </p> </li> <li> <p>Then NFs could use this function to easily get a context with token in the header. </p> <pre><code>ctx, pd, err := smf_context.GetSelf().GetTokenCtx(models.ServiceName_NNRF_DISC, models.NfType_NRF)\nif err != nil {\n  return pd, err\n}\n\nresult, httpResp, localErr := smf_context.GetSelf().\n  NFDiscoveryClient.\n  NFInstancesStoreApi.\n  SearchNFInstances(ctx, models.NfType_UDM, models.NfType_SMF, &amp;localVarOptionals)\n</code></pre> </li> </ul> </li> <li> <p>Service Producer</p> <ul> <li> <p>Validating the access token when there is a service request, the NF must use the NRF's public key to ensure security. So, we have to tell the NF the location of the NRF certificate. (We can retrieve the Public key from the certificate). <pre><code>configuration:\n  nrfCertPem: cert/nrf.pem # NRF Certificate\n</code></pre></p> </li> <li> <p>We apply <code>AuthorizationCheck()</code> via <code>router.use()</code>. (Take the Nsmf_pdusession service, for example). </p> <pre><code>routerAuthorizationCheck := util_oauth.NewRouterAuthorizationCheck(models.ServiceName_NSMF_PDUSESSION)\ngroup.Use(func(c *gin.Context) {\n  routerAuthorizationCheck.Check(c, smf_context.GetSelf())\n})\n</code></pre> </li> </ul> </li> </ul>"},{"location":"doc/OAuth2/OAuth2Design/#note","title":"Note","text":"<ul> <li>The OAM service currently does not enfore OAuth2.<ul> <li>The free5GC webconsole is not considered an NF in the 5G core network, but it utilizes the OAM service to access the necessary information.</li> <li>The NRF will not issue tokens to the unregisterd NFs.</li> </ul> </li> </ul>"},{"location":"doc/OAuth2/OAuth2Design/#related-prsfiles","title":"Related PRs/Files","text":"<ul> <li>General functions used by all NF: openapi/oauth</li> <li>free5gc/NRF PR#27</li> <li>free5gc/free5gcPR#525</li> <li>There would be related Pull Request for each NF. </li> </ul>"},{"location":"doc/OAuth2/OAuth2Design/#main-contributors","title":"Main Contributors","text":"<ul> <li>andy89923</li> <li>Ianchen0119</li> <li>swthorn</li> <li>eggegg31415</li> </ul>"},{"location":"doc/OAuth2/oauth2_enable/","title":"Enable OAuth2 on SBI","text":"<p>In this demo, we will practice:</p> <ul> <li>Enable OAuth2 on SBI</li> <li>Configuring NRF and NFs</li> </ul>"},{"location":"doc/OAuth2/oauth2_enable/#1-enable-oauth2-in-nrf","title":"1. Enable OAuth2 in NRF","text":"<p>In the NRF configuration file <code>nrfcfg.yaml</code>:</p> <p><pre><code>configuration:\n  sbi: # Service-based interface information\n    oauth: true   # false\n</code></pre> Set <code>oauth</code> from <code>false</code> to <code>true</code>. </p>"},{"location":"doc/OAuth2/oauth2_enable/#2-set-nrf-certificate-path-in-each-nf","title":"2. Set NRF Certificate path in Each NF","text":"<p>In each NF configuration file, we need to specify the path to the NRF certificate.</p> <pre><code>configuration:\n    nrfCertPem: cert/nrf.pem # NRF Certificate\n</code></pre> <p>If the OAuth is set to enable but there is no <code>nrfCertPem</code> set in NF, this would lead to the following error:</p> <p></p>"},{"location":"doc/OAuth2/oauth2_enable/#3-run-free5gc","title":"3. Run free5GC","text":"<p>Use <code>run.sh</code> to start 5GC.</p> <pre><code>./run.sh\n</code></pre> <p>For now, the free5GC SBI runs the service with OAuth2. </p>"},{"location":"doc/OAuth2/oauth2_enable/#note","title":"Note","text":"<p>Since the default certificates we provide in <code>cert/</code> are auto-generated by code which didn't signed by known authority,  we would lead to the following warning:</p> <p></p> <pre><code>2024-02-27T04:00:43.217044025Z [WARN][NRF][Token] Certificate verify: x509: certificate signed by unknown authority (possibly because of \"x509: invalid signature: parent certificate cannot sign this kind of certificate\" while trying to verify candidate authority certificate \"free5gc\")\n</code></pre>"},{"location":"doc/OAuth2/oauth2_enable/#appendix","title":"Appendix","text":"<ul> <li>Design Document</li> </ul>"},{"location":"doc/PCF/charging/","title":"PCF Charging Software Design Architecture","text":"<p>Note</p> <p>Author: Andy Chen (CTFang) Date: 2024/05/07</p> <p>PCF:  Policy Control Function</p> <p>Relative specs:</p> <ul> <li>TS 29.507 Access and Mobility Policy Control Service</li> <li>TS 23.503 Policy and Charging Control Framework for the 5G System (5GS)</li> <li>Ts 29.513 Policy and Charging Control Signalling flows and QoS parameter mapping</li> <li>Ts 23.255 Telecommunication management; Charging management; 5G data connectivity domain charging </li> </ul> <p>The 3GPP defines the FBC(Flow-Based Charging) and QBC (QoS-Based Charging). </p> <p>However, free5GC v3.4.1 supports FBC only. </p>"},{"location":"doc/PCF/charging/#ratinggroup-allocate","title":"RatingGroup Allocate","text":"<p>PDU session establishment, described in 3GPP TS 32.255 clause 5.2.2.2.2</p> <p>Charging on PDU Session is achieved by FBC charging, with specific rating group/service identifier:</p> <ul> <li> <p>The rating group would be allocated by PCF during SM Policy Authorization (Step 6).</p> <ul> <li>Get chargingData from MongoDB collection <code>policyData.ues.chargingData</code>.</li> <li>Allocate rating group to each charging rule.</li> <li>Create new chargingData with rating group in MongoDB. </li> <li>Create PCC Rule for charging with rating group, SDF template, and charging method.</li> <li>Make Decision from PCC Rule to SMF. </li> </ul> </li> <li> <p>When PCF <code>HandleDeleteSmPolicyContextRequest</code>, the new chargingData with rating group would be deleted. </p> </li> </ul>"},{"location":"doc/PCF/charging/#chf","title":"CHF","text":"<p>CHF would use rating group from MongoDB (<code>policyData.ues.chargingData</code>) to calculate the usage and grant quota. </p> <ul> <li>ABMF (Account Balance Management Function)</li> <li>Rating Function</li> </ul> <p></p>"},{"location":"doc/PCF/charging/#others","title":"Others","text":"<ul> <li>CHF design document</li> </ul>"},{"location":"doc/Smf/design/","title":"SMF PFCP Software Architecture","text":"<p>Note</p> <p>Author: MingHsien Wu Date: 2024/02/09</p>"},{"location":"doc/Smf/design/#introduction","title":"Introduction","text":"<p>Packet Forwarding Control Protocol(PFCP) is a communication protocol used in N4 interface of 5G core network. It is responsible for managing and controlling packet forwarding including functions such as traffic routing, Qos policy and session management. Typically, PFCP operates between control plane (SMF) and data plane (UPF), facilitating the exchange of control information and configuration commands.</p> <p>The main focus of this blog is to share the software architecture diagram detailing how the PFCP server handles PFCP messages within the SMF. It will commence from the activation of the Network Function. Next, we will consider how free5GC operates in the software layer when receiving PFCP messages from the UPF and when the SMF needs to send PFCP requests.</p>"},{"location":"doc/Smf/design/#description","title":"Description","text":"<p>When SMF is started, several software functionalities related to PFCP are activated. I mainly categorize them into three major directions: UDP (User Datagram Protocol) Run, N4 Interface Association, and Service-based interface handler (including PDU Session and Callback).</p> <p>[1] UDP Run : </p> <ol> <li> <p>Read UDP msg from server until process exited :</p> <ul> <li>When the PFCP Server receives a PFCP Request from the User Plane, the Server will hand over this message to the Dispatcher for processing, with the aim of generating the corresponding Response.</li> </ul> </li> <li> <p>Listen and Serve : </p> <ul> <li>Once the PFCP Server receives a PFCP Request from the Control Plane or User Plane, it will be monitored via ListenAndServe function. Depending on the circumstances, it will determine whether to pass it to the Dispatcher or the SMF\u2019s sbi for handling.</li> </ul> </li> </ol> <p>[2] N4 Interface Association : </p> <ul> <li>The N4 interface association is used to maintain and verify the connectivity between the SMF and UPF. When either the SMF or UPF is first initialized, typically one of them will initiate an N4 association setup request. Subsequently, the SMF will initiate a Heartbeat Procedure to confirm whether the UPF is operational. If the UPF has not established an association with the SMF, the SMF will not process any PFCP Requests related to this UPF.</li> </ul> <p>[3] Service-based interface handler :</p> <ol> <li> <p>[3-1] Callback :</p> <ul> <li>The SMF (Subscriber) requests the establishment of an SM Policy association with the PCF (SBI). When subscription conditions are met (such as policy updates), the PCF will actively notify the SMF. Upon receiving this information, the SMF will also update the UPF according to the new policy.</li> </ul> </li> <li> <p>[3-2] PDU Session :</p> <ul> <li> <p>(1) Release : When the Session Management Function (SMF) receives a PDU Session Release SMContext Request from the Access and Mobility Management Function (AMF) (Possible scenarios include: AMF changes, an invalid SUPI from the UE, or the UE registering repetitively with the same AMF, etc.), The SMF will send an PFCP Session Deletion Request towards the User Plane Function (UPF) to release resources associated with this session.</p> </li> <li> <p>(2) Update : When the Session Management Function (SMF) receives a PDU Session Update SMContext Request from the Access and Mobility Management Function (AMF) for updating N3 tunnel information (Possible scenarios include: EPS to 5GS handover TS23.502, etc.), The SMF will send an PFCP Session Modification Request towards the User Plane Function (UPF) to update resources associated with this session.</p> </li> <li> <p>(3) Post : When the Session Management Function (SMF) receives a PDU Session Create SMContext Request from the Access and Mobility Management Function (AMF) (Possible scenarios include: UE Requested PDU Session Establishment), The SMF will send an PFCP Session Establishment Request towards the User Plane Function (UPF). If the SMF received Nsmf_PDUSession_CreateSMContext Request and the SMF is able to process the PDU Session establishment request, the SMF creates an SM context and responds to the AMF by providing an SM Context Identifier. TS23.502</p> </li> </ul> </li> <li> <p>[3-3] ULCL Procedure : </p> <ul> <li>The insertion of ULCL (Uplink Control Channel) in 5G networks serves the purpose of facilitating the transmission of control information during uplink data transfer. ULCL enables the network to transmit control signals and indications during uplink transmission, effectively managing and controlling the allocation and scheduling of wireless resources. This includes transmitting scheduling information, establishing and releasing connections, modulation and coding information, among others, to ensure efficient control and management of uplink data transmission from user equipment.</li> </ul> </li> </ol>"},{"location":"doc/Smf/design/#reference","title":"Reference","text":"<ul> <li>3GPP TS 23.502: Procedures for the 5G System (5GS)</li> <li>3GPP TS 29.244: Interface between the Control Plane and the User Plane nodes</li> </ul>"},{"location":"doc/Smf/design/#about","title":"About","text":"<p>Hello, I'm Hsien, a newcomer to free5gc. This is my first time sharing my experiment. If you find any mistakes or have any questions, please feel free to let me know. I would greatly appreciate it.</p>"},{"location":"doc/Smf/design/#connect-with-me","title":"Connect with Me","text":"<ul> <li>Linkedin: https://www.linkedin.com/in/wuminghsien/</li> <li>Github: https://github.com/ming-hsien</li> </ul>"},{"location":"doc/Upf_PFCP/design/","title":"PFCP Software Architecture within UPF","text":"<p>Note</p> <p>Author: Ian Cai Date: 2024/03/20</p>"},{"location":"doc/Upf_PFCP/design/#introduction","title":"Introduction","text":"<p>The evolution of mobile networks towards 5G introduces the concept of Control and User Plane Separation. This separation aims to improve scalability, flexibility, and performance by isolating control functions (managing network resources and connections) from user plane functions (processing and forwarding user data). However, for optimal network operation, these separated planes still need to communicate effectively.</p> <p>This communication need is addressed by the Packet Forwarding Control Protocol (PFCP). PFCP acts as a dedicated signaling protocol that sits on top of the UDP/IP transport layer, operating exclusively within the control plane. It facilitates communication between a Control Plane Node, typically the Session Management Function (SMF), and one or more User Plane Nodes, such as User Plane Function (UPF).</p> <p>PFCP empowers SMFs to establish associations with UPFs, essentially creating control paths for directing user data traffic. Following association, SMF leverage PFCP to configure Packet Data Unit (PDU) sessions within the UPF. These PDU sessions dictate how user data should be processed and forwarded across the network.</p>"},{"location":"doc/Upf_PFCP/design/#processing-procedure","title":"Processing Procedure","text":"<p>The following diagram illustrates the flow of PFCP message processing within the UPF in the free5gc implementation: </p> <p>The <code>app.Run</code> function in the free5gc UPF codebase initiates two key processes:</p> <ul> <li> <p>Data Plane Forwarder for GTP-U: This process establishes a data path for forwarding user data packets between the UPF and the UE (User Equipment) via the GTP-U (GPRS Tunneling Protocol User Plane) protocol.</p> </li> <li> <p>PFCP Server: This process establishes a control plane connection with the SMF  using the PFCP protocol.</p> </li> </ul>"},{"location":"doc/Upf_PFCP/design/#pfcp-server","title":"PFCP server","text":"<p>The <code>pfcp.Start</code> function in the free5gc UPF codebase initiates the PFCP server and establishes a listening UDP socket for receiving PFCP messages from the SMF. The <code>pfcp.main</code> function uses the golang select statement to monitor three channels: </p> <ol> <li>session report: The <code>pfcp.NotifySessReport</code> function is called by the SMF to send session report through this channel</li> <li>receive packet: The <code>pfcp.receiver</code> function parses the UDP message and then sends the data through this channel.</li> <li>transaction timeout:Any packet sent by UPF will start a timeout timer, when timer expires\uff0c<code>pfcp.NotifyTransTimeout</code> will send a signal through this channel to trigger re-transmission.</li> </ol>"},{"location":"doc/Upf_PFCP/design/#association-request","title":"Association Request","text":"<p>When the UPF  receives an association request sent by the SMF,the <code>pfcp.main</code> function calls <code>pfcp.reqDispatcher</code>. This dispatcher assigns <code>pfcp.handleAssociationSetupRequest</code> to handle it. <code>pfcp.handleAssociationSetupRequest</code> verifyies the  address in the request and adds it to the \"remote note list\"before sending response to the SMF.</p>"},{"location":"doc/Upf_PFCP/design/#pdu-session-request","title":"PDU Session Request","text":"<p>Since the procedures for PDU session modification and deletion are similar to the establishment procedure, I'll use the establishment process as an example to illustrate the overall flow.</p> <p>When the UPF  receives an PDU session extablishment request sent by the SMF,the <code>pfcp.main</code> function calls <code>pfcp.reqDispatcher</code>. This dispatcher assigns <code>pfcp.handleSessionEstablishmentRequest</code> function to handle it. The function  <code>pfcp.handleSessionEstablishmentRequest</code> first checks whether the remote node ID has been associated with UPF, then proceeds to use the F-SEID in the request to create a PDU session in UPF control plane. Afterwards, the UPF begins creating PDU session in the data plane, by transferring information elements from the PFCP message, such as QER, FAR, and PDR, to the kernel module gtp5g. Taking QER as example, UPF call <code>pfcp.CreateQER</code>, which then calls <code>forwarder.CreateQER</code> with the purpose of providing the GTP-U driver with the QER value. Subsequently, forwarder.CreateQER utilizes the <code>gtp5gnl.CreateQEROID</code> function to establish a link with the go-gtp5gnl library. The handler within go-gtp5gnl interacts with the gtp5g module in the kernel through Linux netlink to inject the QER data. This procedure enables the data plane to enforce QoS rules within the PDU session.</p>"},{"location":"doc/Upf_PFCP/design/#reference","title":"Reference","text":"<p>3GPP TS 29.244 : Interface between the Control Plane and the User Plane nodes</p>"},{"location":"doc/Upf_PFCP/design/#about-me","title":"About Me","text":"<p>I'm a graduate student at NYCU studying 5G core networks. As I'm a beginner in this field, I'd be grateful for any advice you can offer.</p> <ul> <li>GitHub: https://github.com/ian60509</li> </ul>"},{"location":"guide/","title":"Index","text":""},{"location":"guide/#user-guide","title":"User Guide","text":""},{"location":"guide/#information","title":"Information","text":"<ul> <li>Tested hardware</li> <li>Supported features</li> <li>How to contribute</li> </ul>"},{"location":"guide/#free5gc-installation-guide","title":"free5GC Installation Guide","text":"<p>Note</p> <p>If you have to develop a new feature on free5GC, please check the links below to install the free5GC. Otherwise, for normal use/test purposes, we recommend you use the free5GC Compose to launch the free5GC without complicated configuration settings.</p>"},{"location":"guide/#recommended-free5gc-compose","title":"[Recommended] free5GC compose","text":"<ul> <li>Installing free5GC Core Network with free5GC-Compose</li> </ul>"},{"location":"guide/#free5gc-helm","title":"free5GC Helm","text":"<ul> <li>free5GC Helm Installation</li> </ul>"},{"location":"guide/#advanced-build-free5gc-from-scratch","title":"[Advanced] Build free5GC from scratch","text":"<p>For people who are not familiar with virtual machines and Linux installation, here are some example demonstrations:</p> <ul> <li>Creating a Ubuntu VM using VirtualBox</li> <li>Creating and Configuring a free5GC VM</li> <li>Build and Install free5GC from source code and Test free5GC</li> <li>Installing a UE/RAN Simulator</li> <li>Installing a N3IWUE</li> <li>Installing a TNGFUE</li> <li>Enable OAuth2 on SBI</li> <li>free5GC Simple Apps</li> </ul>"},{"location":"guide/#configuration","title":"Configuration","text":"<ul> <li>Environment</li> <li>Basic</li> <li>SMF</li> <li>Webconsole</li> <li>Charging</li> <li>Set Static IP for UE</li> <li>Select UPF based on S-NSSAI</li> <li>Select nearby UPF according to the connected gNodeB</li> <li>ULCL</li> <li>Netns5g - A free5gc and UERANSIM deployment using Linux network namespaces</li> <li>Traffic Influence</li> <li>NR-DC</li> </ul>"},{"location":"guide/#deployment","title":"Deployment","text":"<p>For Container deployment:</p> <ul> <li>free5GC Compose (Docker Compose)</li> <li>free5GC Helm (Kubernetes)</li> <li>Towards5gs-helm (Kubernetes)<ul> <li>Deploying free5GC on Kubernetes by Danilo Granados</li> <li>Deploying free5GC in a multi-cluster Environment by Danilo Granados</li> </ul> </li> </ul>"},{"location":"guide/#roadmap","title":"Roadmap","text":"<p>Here are the features on the roadmap. These items are planned to be supported in the near future:</p> <ul> <li>Roaming</li> <li>CNTi</li> <li>BSF</li> <li>Grafana</li> </ul> <p>If you're interested in more details, please visit the GitHub Dashboard</p>"},{"location":"guide/#others","title":"Others","text":"<ul> <li>Release Note</li> <li>Troubleshooting</li> <li>Appendix</li> </ul>"},{"location":"guide/0-compose/","title":"0 compose","text":"<p>free5GC compose is a docker compose version of free5GC for stage 3. It's inspired by free5gc-docker-compose and also reference to docker-free5gc.</p>"},{"location":"guide/0-compose/#prerequisites","title":"Prerequisites","text":"<ul> <li>GTP5G kernel module: needed to run the UPF</li> <li>Docker Engine: needed to run the Free5GC containers</li> <li>Docker Compose v2: needed to bootstrap the free5GC stack</li> </ul> <p>Note: AVX for MongoDB: some HW does not support MongoDB releases above<code>4.4</code> due to use of the new AVX instructions set. To verify if your CPU is compatible you can check CPU flags by running <code>grep avx /proc/cpuinfo</code>. A workaround is suggested here.</p>"},{"location":"guide/0-compose/#start-free5gc","title":"Start free5GC","text":"<p>Because we need to create tunnel interface, we need to use privileged container with root permission.</p>"},{"location":"guide/0-compose/#pull-docker-images-from-docker-hub","title":"Pull docker images from Docker Hub","text":"<pre><code>docker compose pull\n</code></pre>"},{"location":"guide/0-compose/#optional-build-docker-images-from-local-sources","title":"[Optional] Build docker images from local sources","text":"<pre><code># Clone the project\ngit clone https://github.com/free5gc/free5gc-compose.git\ncd free5gc-compose\n\n# clone free5gc sources\ncd base\ngit clone --recursive -j `nproc` https://github.com/free5gc/free5gc.git\ncd ..\n\n# Build the images\nmake all\ndocker compose -f docker-compose-build.yaml build\n\n# Alternatively you can build specific NF image e.g.:\nmake amf\ndocker compose -f docker-compose-build.yaml build free5gc-amf\n</code></pre> <p>Note:</p> <p>Dangling images may be created during the build process. It is advised to remove them from time to time to free up disk space.</p> <pre><code>docker rmi $(docker images -f \"dangling=true\" -q)\n</code></pre>"},{"location":"guide/0-compose/#run-free5gc","title":"Run free5GC","text":"<p>You can create free5GC containers based on local images or docker hub images:</p> <pre><code># use local images\ndocker compose -f docker-compose-build.yaml up\n# use images from docker hub\ndocker compose up # add -d to run in background mode\n</code></pre> <p>Destroy the established container resource after testing:</p> <pre><code># Remove established containers (local images)\ndocker compose -f docker-compose-build.yaml rm\n# Remove established containers (remote images)\ndocker compose rm\n</code></pre>"},{"location":"guide/0-compose/#troubleshooting","title":"Troubleshooting","text":"<p>Sometimes, you need to drop data from DB:</p> <pre><code>docker exec -it mongodb mongo\n&gt; use free5gc\n&gt; db.dropDatabase()\n&gt; exit # (Or Ctrl-D)\n</code></pre> <p>You can see logs for each service using <code>docker logs</code> command. For example, to access the logs of the SMF you can use:</p> <pre><code>docker logs smf\n</code></pre> <p>Please refer to the wiki for more troubleshooting information.</p>"},{"location":"guide/0-compose/#integration-with-external-gnbue-simulators","title":"Integration with external gNB/UE simulators","text":"<p>The integration with the UERANSIM eNB/UE simulator is documented here. </p> <p>You can also refer to this issue to find out how you can configure the UPF to forward traffic between the UERANSIM to the DN (eg. internet) in a docker environment.</p> <p>This issue provides detailed steps that might be useful.</p>"},{"location":"guide/0-compose/#integration-of-webui-with-nginx-reverse-proxy","title":"Integration of WebUI with Nginx reverse proxy","text":"<p>Here you can find helpful guidelines on the integration of Nginx reverse proxy to set it in front of the WebUI: https://github.com/free5gc/free5gc-compose/issues/55#issuecomment-1146648600</p>"},{"location":"guide/0-compose/#vagrant-box-option","title":"Vagrant Box Option","text":"<p>For Linux kernel version below 5.4 you can setup a working environment using a vagrant box: https://github.com/abousselmi/vagrant-free5gc Please refer to GTP5G kernel module for more information.</p>"},{"location":"guide/0-compose/#ulcl-configuration","title":"ULCL Configuration","text":"<p>You can check the following informations below:</p> <ul> <li>ulcl-example branch, or</li> <li>patch file</li> </ul>"},{"location":"guide/0-compose/#optional-run-n3iwue","title":"[Optional] Run N3IWUE","text":"<p>If you want use N3IWUE, you need to open your web browser from your host machine, and enter the URL <code>http://localhost:5000</code></p> <ul> <li>On the login page, enter username <code>admin</code> and password <code>free5gc</code>.</li> <li>Once logged in, widen the page until you see \u201cSubscribers\u201d on the left-hand side column.</li> <li>Click on the <code>Subscribers</code> tab and then on the <code>New Subscriber</code> button<ul> <li>Scroll down to <code>Operator Code Type</code> and change it from \"OPc\" to \"OP\".</li> <li>Make sure the following config between <code>free5gc-compose/config/n3uecfg.yaml</code> and <code>Subscriber</code> you create are the same:<ul> <li>PLMNID (ex. 208930000001234)</li> <li>K</li> <li>SQN</li> <li>OP value (choose OP instead of OPC)</li> </ul> </li> <li>Scroll all the way down and click on <code>Submit</code>.</li> </ul> </li> </ul> <p>Then you can access the N3IWUE container and run N3IWUE using the following commands: <pre><code># access N3IWUE bash\ndocker exec -it n3iwue bash\n\n# run N3IWUE\n./run.sh\n</code></pre></p>"},{"location":"guide/1-vm-en/","title":"1 vm en","text":""},{"location":"guide/1-vm-en/#ubuntu-virtual-machine-installation-demo","title":"Ubuntu Virtual Machine Installation Demo","text":"<p>In this demo, we will</p> <ul> <li>Install VirtualBox</li> <li>Create a Ubuntu Server VM using VirtualBox</li> <li>Use SSH to connect to the Ubuntu VM to install free5GC stage 3</li> <li>Update and upgrade Ubuntu</li> </ul>"},{"location":"guide/1-vm-en/#1-install-virtualbox","title":"1. Install VirtualBox","text":"<p>Search <code>virtualbox download</code>, or visit virtualbox.org to download and install VirtualBox (currently 7.0.12) for your operational system. </p> <p>Once VirtualBox is installed, launch it and see if you have something like this: </p>"},{"location":"guide/1-vm-en/#2-download-ubuntu-server","title":"2. Download Ubuntu Server","text":"<p>Search <code>ubuntu server download</code> on the web and download the latest Ubuntu Server 20.04 LTS, or visit ubuntu.com, choose Manual Installation Option to download the <code>.iso</code> file (currently 20.04.6 LTS) </p> <p>You should have downloaded a <code>.iso image</code> file with a name like <code>ubuntu-20.04.6-live-server-amd64.iso</code>, probably in your download directory. </p>"},{"location":"guide/1-vm-en/#3-create-a-ubuntu-server-vm","title":"3. Create a Ubuntu Server VM","text":"<p>Launch VirtualBox and create your first Ubuntu VM using the downloaded .iso image file. We use Ubuntu Server instead of Ubuntu Desktop because we only need a basic server machine without too many unnecessary functionalities. The resulting overhead to your host machine is smaller, and the VM starts up faster too.</p> <p>Tips</p> <ul> <li>Name the first VM using a generic name as ubuntu, <code>ubuntu-server</code>, or <code>ubuntu-20.04</code>.</li> <li>You can pick 1 or 2 (or more) CPUs, and about 2048MB memory, although you can change them later.</li> <li>In addition to the default NAT network interface, add also another \u201cHost-only\u201d network interface.</li> </ul> <p>Refer to the videos Creating VM, Setting up VM.</p>"},{"location":"guide/1-vm-en/#31-start-installing-ubuntu","title":"3.1 Start Installing Ubuntu","text":"<p>Some notes about installing Ubuntu:</p> <ul> <li>It's recommended that you choose short username and password for ease of typing later</li> <li>Not choosing LVM will make it a little bit easier later if you want to extend your disk space</li> <li>Choose to include SSH Server</li> <li>Let the security update complete</li> </ul> <p>Refer to videos Install Ubuntu 1, Install Ubuntu 2.</p>"},{"location":"guide/1-vm-en/#32-log-in-to-ubuntu","title":"3.2 Log in to Ubuntu","text":"<p>Reboot after Ubuntu installation is finished then wait a little bit for some initialization steps to complete. Then log in with your username and password. </p> <p>First try the <code>ifconfig</code> command\uff1a <pre><code>ubuntu@ubuntu:~$ ifconfig\nCommand 'ifconfig' not found, but can be installed with:\nsudo apt install net-tools\nubuntu@ubuntu:~$\n</code></pre></p> <p>If some messages like above show, it means <code>ifconfig</code> has not been installed yet. (<code>ifconfig</code> is no longer installed by defaults in newer Ubuntu, and is replaced by more versatile ip command, but we will use it here for simplicity).</p> <p>Follow its suggestion and install <code>ifconfig</code>: <pre><code>ubuntu@ubuntu:~$ sudo apt install net-tools\n</code></pre> The image below shows the installation result: </p> <p>Run <code>ifconfig</code> again to check the network interfaces: </p> <p>Your display may look different, but take notes about the IP address of the Host-only interface card. The example above shows <code>192.168.56.101</code>. You can SSH from your host machine into this Ubuntu VM using the IP later. (The other IP address, <code>10.0.2.15</code> is the IP address of the NAT interface card, which means that the apps in your host machine cannot access it).</p> <p>Finally, check if the VM has internet access using: <pre><code>ubuntu@ubuntu:~$ ping google.com\n</code></pre></p> <p></p> <p>Refer to the first part of the video Ping, SSH, and Upgrade.</p>"},{"location":"guide/1-vm-en/#4-connect-to-the-ubuntu-vm-using-ssh","title":"4. Connect to the Ubuntu VM using SSH","text":"<p>Launch your favorite SSH client from the host machine. Some operational systems (Mac, Ubuntu, some Windows) have SSH clients preinstalled. If you are using Windows, you can also download third-party SSH clients, by for example, searching \u201cwindows ssh download\u201d on the web.</p> <p>The benefit of using SSH is that you can easily copy and paste commands from your machine to Ubuntu VM for execution, and vice versa. You can also create multiple SSH connections with the Ubuntu VM for control and monitoring at the same time.</p> <p>Below it's possible to see some examples on a Mac host machine. Suppose the Host-only network IP is <code>192.168.56.101</code>, and the username is <code>ubuntu</code>: <pre><code>ssh 192.168.56.101 -l ubuntu\n</code></pre> The first time you connect to the VM, your SSH client may show some message asking you for confirmation. Enter yes: </p> <p>Tips</p> <p>If somehow SSH shows some warning messages telling you the machine has potential security risk, you may have to remove an entry in the file <code>&lt;your home directory&gt;/.ssh/known_hosts</code> related the the IP address.</p> <p>If you log in successfully, you will enter a command line interface: </p> <p>Repeat the basic commands such as <code>ping</code>, <code>ifconfig</code> to see if the VM is working properly. If so, we can access the Ubuntu VM \u201cremotely\u201d from now on.</p> <p> </p>"},{"location":"guide/1-vm-en/#5-update-and-upgrade-your-ubuntu","title":"5. Update and Upgrade your Ubuntu","text":"<p>Let also update and upgrade the Ubuntu VM right now to make sure it is up-to-date with proper security updates. <pre><code>sudo apt update\nsudo apt upgrade\n</code></pre></p>"},{"location":"guide/2-config-vm-en/","title":"2 config vm en","text":""},{"location":"guide/2-config-vm-en/#creating-a-free5gc-vm-and-setting-up-network","title":"Creating a free5GC VM and Setting up Network","text":"<p>In this demo we will exercise:</p> <ul> <li>Cloning an existing VM, and install free5GC on it</li> <li>Setting up the networking for the free5GC VM</li> </ul> <p>Tips</p> <p>Refer to video Clone VM and Change IP.</p>"},{"location":"guide/2-config-vm-en/#1-check-up-an-existing-vm-for-cloning","title":"1. Check up an existing VM for Cloning","text":"<p>Launch VirtualBox, and make sure the Ubuntu VM (ubuntu) we created before can boot up, then:</p> <ul> <li>Log in into the VM using SSH from the host machine, and check if the VM has internet access</li> <li>Make sure you have done <code>sudo apt update</code> and <code>sudo apt upgrade</code> (or you can do it again)</li> <li>Shutdown the VM. You can:</li> <li>use command <code>sudo shutdown -P now</code>, or</li> <li>click the \u201cClose Window\u201d of the Ubuntu VM terminal and choose the middle option (better not force to turn off the machine power)</li> <li>later if you just want to reboot, enter <code>sudo shutdown -r now</code></li> </ul>"},{"location":"guide/2-config-vm-en/#2-create-a-free5gc-vm","title":"2. Create a free5GC VM","text":"<p>First let\u2019s clone a new VM:</p> <ul> <li>Select an existing VM (ubuntu) and click the buttons on the right: / Snapshopts / Clone.</li> <li>Name the new VM <code>free5gc</code>.</li> <li>The MAC address rule: Create new MAC addresses for all network cards.</li> <li>Choose the Link cloning option (or you can also choose to complete clone the VM if you like).</li> </ul> <p>After the new VM is created:</p> <ul> <li>Start up the new free5gc VM, and use the same username and password to log in.</li> <li>In the Ubuntu terminal, issue <code>ping</code> and <code>ifconfig</code> again to make sure it has internet access, and also make note of the IP address of the Host-only network interface.<ul> <li>for example the IP could still be <code>192.168.56.101</code>, and the interface name is <code>enp0s8</code>.</li> </ul> </li> <li>Log in into free5gc VM using SSH, and make sure all things working properly.</li> </ul>"},{"location":"guide/2-config-vm-en/#3-change-hostname","title":"3. Change hostname","text":"<p>The cloned free5gc VM still has host name <code>ubuntu</code> (or the name you gave it in the original VM). Let\u2019s rename the VM to <code>free5gc</code>. You can do this by editing the file <code>/etc/hostname</code> (using <code>vi</code> or <code>nano</code>): <pre><code>sudo nano /etc/hostname\n# or \nsudo vi /etc/hostname\n</code></pre> In the file, change ubuntu into <code>free5gc</code>. If you are using nano \uff0cyou can press <code>Ctrl-O</code> to save the file, then <code>Ctrl-X</code> to exit.</p> <p>Let\u2019s also change the file <code>/etc/hosts</code> by replacing the ubuntu inside into <code>free5gc</code>: <pre><code>sudo nano /etc/hosts\n</code></pre></p> <p>New content of the file <code>/etc/hosts</code> looks like this: <pre><code>127.0.0.1 localhost\n127.0.1.1 free5gc\n...\n</code></pre></p> <p>The changes will take effect after next reboot.</p>"},{"location":"guide/2-config-vm-en/#4-setting-static-ip-address","title":"4. Setting Static IP Address","text":"<p>The Host-only network interface, by default, gets its IP address through DHCP. The cloned free5gc VM seems to have trouble obtaining new IP address. We can change the host-only interface to use static IP address instead, which can save a lot of trouble later.</p> <p>Here let\u2019s fix the static IP address as <code>192.168.56.101</code>: <pre><code>cd /etc/netplan\nls\n00-installer-config.yaml\ncat 00-installer-config.yaml\n</code></pre> The original content of the file <code>00-installer-config.yaml</code> looks like: <pre><code># This is the network config written by 'subiquity'\nnetwork:\n  ethernets:\n    enp0s3:\n      dhcp4: true\n    enp0s8:\n      dhcp4: true\n  version: 2\n</code></pre> meaning the VM has two network interfaces. Using <code>ifconfig</code> we know that <code>enp0s8</code> is the name of the Host-only network interface. We can edit the file: <pre><code>sudo nano 00-installer-config.yaml\n</code></pre> and change it into: <pre><code># This is the network config written by 'subiquity'\nnetwork:\n  ethernets:\n    enp0s3:\n      dhcp4: true\n    enp0s8:\n      dhcp4: no\n      addresses: [192.168.56.101/24]\n  version: 2\n</code></pre> First check if the new content is correct: <pre><code>sudo netplan try\n</code></pre> Press enter to exit, if successful. The apply tne new interface setting: <pre><code>sudo netplan apply\n</code></pre> Run <code>ifconfig</code> to see if the network setting has been changed correctly: <pre><code>enp0s3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\n        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255\n        inet6 fe80::a00:27ff:fec4:254f  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether 08:00:27:c4:25:4f  txqueuelen 1000  (Ethernet)\n        RX packets 2  bytes 1180 (1.1 KB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 18  bytes 1894 (1.8 KB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nenp0s8: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\n        inet 192.168.56.101  netmask 255.255.255.0  broadcast 192.168.56.255\n        inet6 fe80::a00:27ff:fe7e:ada6  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether 08:00:27:7e:ad:a6  txqueuelen 1000  (Ethernet)\n        RX packets 8420  bytes 531867 (531.8 KB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 10887  bytes 823487 (823.4 KB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nlo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\n        inet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\n        RX packets 6621  bytes 596035 (596.0 KB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 6621  bytes 596035 (596.0 KB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre> We can also check the routing table, just to have a grasp of what is going on regarding the network setting: <pre><code>route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.0.2.2        0.0.0.0         UG    100    0        0 enp0s3\n10.0.2.0        0.0.0.0         255.255.255.0   U     0      0        0 enp0s3\n10.0.2.2        0.0.0.0         255.255.255.255 UH    100    0        0 enp0s3\n192.168.56.0    0.0.0.0         255.255.255.0   U     0      0        0 enp0s8\n</code></pre></p> <p>For the display above, we learn that the Host-only network <code>192.168.56.0/24</code> does not have internet access by itself (even though we can access it using SSH from the host machine). Internet access is through the NAT network <code>10.0.2.0/24</code>, with the gateway being <code>10.0.2.2</code> (provided by VirtualBox). Now we can SSH into free5gc VM using <code>192.168.56.101</code>: <pre><code>ssh 192.168.56.101 -l ubuntu\n</code></pre> This is also how we interact with free5gc VM from now on.</p>"},{"location":"guide/3-install-free5gc/","title":"3 install free5gc","text":""},{"location":"guide/3-install-free5gc/#installation","title":"Installation","text":""},{"location":"guide/3-install-free5gc/#a-prerequisites","title":"A. Prerequisites","text":"<p>1. Linux Kernel Version</p> <ul> <li>In order to use the UPF element, you must use the <code>5.0.0-23-generic</code> or <code>5.4.x</code> version of the Linux kernel.  free5gc uses the gtp5g kernel module, which has been tested and compiled against that kernel versions only. If you installed Ubuntu 20.04, the version should be like 5.4.x. To determine the version of the Linux kernel you are using:</li> </ul> <pre><code>uname -r\n5.4.0-65-generic\n</code></pre> <p>You will not be able to run most of the tests in Test page unless you deploy a UPF.</p> <p>2. Golang Version</p> <ul> <li>As noted above, free5gc is built and tested with Go 1.25.5</li> <li> <p>To check the version of Go on your system, from a command prompt: <pre><code>go version\n</code></pre></p> </li> <li> <p>If another version of Go is installed, remove the existing version and install Go 1.25.5:</p> </li> </ul> <pre><code># this assumes your current version of Go is in the default location:\nsudo rm -rf /usr/local/go\nwget https://dl.google.com/go/go1.25.5.linux-amd64.tar.gz\nsudo tar -C /usr/local -zxvf go1.25.5.linux-amd64.tar.gz\n</code></pre> <ul> <li>If Go is not installed on your system:</li> </ul> <pre><code>wget https://dl.google.com/go/go1.25.5.linux-amd64.tar.gz\nsudo tar -C /usr/local -zxvf go1.25.5.linux-amd64.tar.gz\nmkdir -p ~/go/{bin,pkg,src}\n# The following assume that your shell is bash:\necho 'export GOPATH=$HOME/go' &gt;&gt; ~/.bashrc\necho 'export GOROOT=/usr/local/go' &gt;&gt; ~/.bashrc\necho 'export PATH=$PATH:$GOPATH/bin:$GOROOT/bin' &gt;&gt; ~/.bashrc\necho 'export GO111MODULE=auto' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre> <ul> <li>Further information and installation instructions for <code>golang</code> are available at the official golang site.</li> </ul> <p>3. Control-plane Supporting Packages</p> <pre><code>sudo apt -y update\nsudo apt -y install wget git\n</code></pre> <ul> <li>To check whether AVX is supported by the CPU, you can use the command: <pre><code>lscpu | grep avx\n</code></pre></li> <li>Install MongoDB Community Edition (check this appendix section for more information)<ol> <li>Import the public key used by the package management system <pre><code>sudo apt install -y gnupg curl\ncurl -fsSL https://www.mongodb.org/static/pgp/server-7.0.asc | \\\nsudo gpg -o /usr/share/keyrings/mongodb-server-7.0.gpg --dearmor\n</code></pre></li> <li>Create a list file for MongoDB <pre><code># Ubuntu 22.04 (Jammy)\necho \"deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb-server-7.0.gpg ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/7.0 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list\n# Ubuntu 20.04 (Focal)\necho \"deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb-server-7.0.gpg ] https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/7.0 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list\n</code></pre><ul> <li>you can determine the release by running <code>cat /etc/lsb-release</code></li> </ul> </li> <li>Reload local package database &amp; Install the MongoDB packages <pre><code>sudo apt update\nsudo apt install -y mongodb-org\n</code></pre></li> <li>Run MongoDB Community Edition <pre><code># using systemd\nsudo systemctl start mongod\nsudo systemctl status mongod\nsudo systemctl enable mongod    # optional\n# using init\nsudo service mongod start\nsudo service mongod status\n</code></pre></li> </ol> </li> <li>WARNING: MongoDB 5.0+ requires a CPU with AVX support. Or downgrade your MongoDB to 4.4<ul> <li>see this post on MongoDB's official forum</li> <li>see also docker-library/mongo#485 (comment)</li> <li>When you are using <code>Ubuntu 20.04</code> and a CPU without AVX support, you can use the <code>mongodb</code> package provided by Ubuntu.  <pre><code>sudo apt install mongodb # MongoDB Server v3.6.8\n</code></pre></li> </ul> </li> </ul> <p>4. User-plane Supporting Packages</p> <pre><code>sudo apt -y update\nsudo apt -y install git gcc g++ cmake autoconf libtool pkg-config libmnl-dev libyaml-dev\n</code></pre> <p>5. Linux Host Network Settings</p> <pre><code>sudo sysctl -w net.ipv4.ip_forward=1\nsudo iptables -t nat -A POSTROUTING -o &lt;dn_interface&gt; -j MASQUERADE\nsudo iptables -A FORWARD -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss 1400\nsudo systemctl stop ufw\nsudo systemctl disable ufw # prevents the firewall to wake up after a OS reboot\n</code></pre> <p>Or use <code>reload_host_config.sh</code> from free5GC <pre><code>sudo ./&lt;PATH-TO-free5GC&gt;/reload_host_config.sh &lt;dn_interface&gt;\n# Example\nsudo ./free5gc/reload_host_config.sh enp0s3\n</code></pre></p> <p>Note: For more information regarding the reload script, please, check this appendix section</p>"},{"location":"guide/3-install-free5gc/#b-install-control-plane-elements","title":"B. Install Control Plane Elements","text":"<ol> <li> <p>Clone the free5GC repository</p> <ul> <li> <p>To install the latest stable build (v4.2.0):</p> <pre><code>cd ~\ngit clone --recursive -b v4.2.0 -j `nproc` https://github.com/free5gc/free5gc.git\ncd free5gc\n</code></pre> </li> <li> <p>(Alternatively) to install the latest nightly build:</p> <pre><code>cd ~/free5gc\ngit checkout main\ngit submodule sync\ngit submodule update --init --jobs `nproc`\ngit submodule foreach git checkout main\ngit submodule foreach git pull --jobs `nproc`\n</code></pre> </li> </ul> </li> <li> <p>Compile network function services in <code>free5gc</code></p> <ul> <li> <p>To do so individually (e.g., AMF only):</p> <pre><code>cd ~/free5gc\nmake amf\n</code></pre> </li> <li> <p>To build all network functions:</p> <pre><code>cd ~/free5gc\nmake\n</code></pre> </li> </ul> </li> </ol>"},{"location":"guide/3-install-free5gc/#c-install-user-plane-function-upf","title":"C. Install User Plane Function (UPF)","text":"<ol> <li> <p>As noted above, the GTP kernel module used by the UPF requires that you use Linux kernel version <code>5.0.0-23-generic</code> or <code>5.4.x</code>.  To verify your version:</p> <pre><code>uname -r\n</code></pre> </li> <li> <p>Retrieve the 5G GTP-U kernel module using <code>git</code> and build it</p> <pre><code>git clone -b v0.9.14 https://github.com/free5gc/gtp5g.git\ncd gtp5g\nmake\nsudo make install\n</code></pre> </li> <li> <p>Build the UPF (you may skip this step if you built all network functions above):</p> <ul> <li> <p>to build using make:</p> <pre><code>cd ~/free5gc\nmake upf\n</code></pre> </li> </ul> </li> <li> <p>Customize the UPF as desired. The UPF configuration file in <code>run.sh</code> is <code>free5gc/config/upfcfg.yaml</code>.</p> </li> </ol>"},{"location":"guide/3-install-free5gc/#d-install-webconsole","title":"D. Install WebConsole","text":"<ol> <li> <p>Before building WebConsole, install nodejs first:</p> <pre><code>curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash - \nsudo apt update\nsudo apt install -y nodejs\ncorepack enable # setup yarn automatically\n</code></pre> </li> <li> <p>Build WebConsole</p> <ul> <li> <p>to build using make:</p> <pre><code>cd ~/free5gc\nmake webconsole\n</code></pre> </li> <li> <p>(Alternatively) to build manually:</p> <pre><code>cd ~/free5gc/webconsole/frontend\nyarn install\nyarn build\nrm -rf ../public\ncp -R build ../public\ncd ..\ngo build -o bin/webconsole server.go\n</code></pre> </li> </ul> </li> </ol> <p>Note: An OS with 2GB or more of RAM is recommended. WebConsole may fail to build if available RAM is below 1GB.</p>"},{"location":"guide/4-test-free5gc/","title":"4 test free5gc","text":""},{"location":"guide/4-test-free5gc/#test-free5gc","title":"Test free5GC","text":"<p>Start a Wireshark capture on any core-connected interface, applying the filter <code>'pfcp||icmp||gtp'</code>.</p> <p>In order to run the tests, first do this:</p> <pre><code>cd ~/free5gc\nmake upf\nchmod +x ./test.sh\n</code></pre> <p>The tests are all run from within <code>~/free5gc</code>.</p> <p>a. TestRegistration</p> <pre><code>./test.sh TestRegistration\n</code></pre> <p>b. TestGUTIRegistration</p> <pre><code>./test.sh TestGUTIRegistration\n</code></pre> <p>c. TestServiceRequest</p> <pre><code>./test.sh TestServiceRequest\n</code></pre> <p>d. TestXnHandover</p> <pre><code>./test.sh TestXnHandover\n</code></pre> <p>e. TestDeregistration</p> <pre><code>./test.sh TestDeregistration\n</code></pre> <p>f. TestPDUSessionReleaseRequest</p> <pre><code>./test.sh TestPDUSessionReleaseRequest\n</code></pre> <p>g. TestPaging</p> <pre><code>./test.sh TestPaging\n</code></pre> <p>h. TestN2Handover</p> <pre><code>./test.sh TestN2Handover\n</code></pre> <p>i. TestNon3GPP</p> <pre><code>./test.sh TestNon3GPP\n</code></pre> <p>j. TestReSynchronization</p> <pre><code>./test.sh TestReSynchronization\n</code></pre> <p>k. TestULCL</p> <pre><code>./test_ulcl.sh TestRequestTwoPDUSessions\n</code></pre>"},{"location":"guide/5-install-ueransim/","title":"5 install ueransim","text":""},{"location":"guide/5-install-ueransim/#installing-ueransim-a-ueran-simulator","title":"Installing UERANSIM - a UE/RAN Simulator","text":"<p>In this demo we will practice:</p> <ul> <li>Installing UERANSIM</li> <li>Configuring free5GC and UERANSIM</li> <li>Running UERANSIM against free5GC</li> </ul>"},{"location":"guide/5-install-ueransim/#1-install-ueramsim-vm","title":"1. Install ueramsim VM","text":"<p>Repeat the steps of cloning <code>free5gc</code> VM from the base VM, create a new VM for the UERANSIM simulator:</p> <ul> <li>Name the VM <code>ueransim</code>, and create new MAC addresses for all network cards.</li> <li>Make sure the VM has internet access and can log in using SSH.</li> <li>Change the hostname to <code>ueransim</code>.</li> <li>Make the Host-only network interface have static IP address <code>192.168.56.102</code>.</li> <li>Reboot the ueransim VM, as well as the free5gc VM.</li> <li>You can ping <code>192.168.56.101</code> from the ueransim VM, and also <code>ping 192.168.56.102</code> from the free5gc VM.</li> </ul>"},{"location":"guide/5-install-ueransim/#2-install-ueransim","title":"2. Install UERANSIM","text":"<p>Search \u201cueransim\u201d on the web, and get the web site. On the web site, check what the UERANSIM open-source project is about. Then navigate to the installation page or follow the instructions below.</p> <p>To download UERANSIM: <pre><code>cd ~\ngit clone https://github.com/aligungr/UERANSIM\ncd UERANSIM\n# if using free5GC v3.3.0 or below\ngit checkout 3a96298\n# if using free5GC v3.4.0 or above\ngit checkout e4c492d\n# if using free5GC v3.4.x and to get EAP-AKA-PRIME fix\ngit checkout 85a0fbf\n</code></pre></p> <p>Update and upgrade UERANSIM VM first: <pre><code>sudo apt update\nsudo apt upgrade\n</code></pre></p> <p>Install required tools: <pre><code>sudo apt install make\nsudo apt install g++\nsudo apt install libsctp-dev lksctp-tools\nsudo apt install iproute2\nsudo snap install cmake --classic\n</code></pre></p> <p>Build UERANSIM: <pre><code>cd ~/UERANSIM\nmake\n</code></pre></p>"},{"location":"guide/5-install-ueransim/#3-install-free5gc-webconsole","title":"3. Install free5GC WebConsole","text":"<p>free5GC provides a simple web tool WebConsole to help creating and managing UE registrations to be used by various 5G network functions (NF). </p> <p>If WebConsole isn't installed yet, please, SSH into free5gc's VM (<code>192.168.56.101</code>) and follow the instructions contained on this section here.</p>"},{"location":"guide/5-install-ueransim/#4-use-webconsole-to-add-an-ue","title":"4. Use WebConsole to Add an UE","text":"<p>First start up the WebConsole server: <pre><code>cd ~/free5gc/webconsole\n./bin/webconsole\n</code></pre></p> <p>The screen shows the port number <code>:5000</code> at the end. Open your web browser from your host machine, and enter the URL <code>http://192.168.56.101:5000</code></p> <ul> <li>On the login page, enter username <code>admin</code> and password <code>free5gc</code>.</li> <li>Once logged in, widen the page until you see \u201cSubscribers\u201d on the left-hand side column.</li> <li>Click on the <code>Subscribers</code> tab and then on the <code>New Subscriber</code> button<ul> <li>Scroll down to <code>Operator Code Type</code> and change it from \"OPc\" to \"OP\".</li> <li>Leave the other fields unchanged. This registration data is used for ease of testing and actual use later.</li> <li>Scroll all the way down and click on <code>Submit</code>.</li> </ul> </li> <li>Once the data shows up on the \"Subscribers\" table, you can press <code>Ctrl-C</code> on the terminal to kill the WebConsole process on the free5gc VM</li> <li>You can view more tutorials through this link. </li> </ul> <p>Note</p> <p>You have to make sure that the parameters on the webconsole are consistent with the UE.</p>"},{"location":"guide/5-install-ueransim/#5-setting-free5gc-and-ueransim-parameters","title":"5. Setting free5GC and UERANSIM Parameters","text":"<p>In free5gc VM, we need to edit three files:</p> <ul> <li><code>~/free5gc/config/amfcfg.yaml</code></li> <li><code>~/free5gc/config/smfcfg.yaml</code></li> <li><code>~/free5gc/config/upfcfg.yaml</code></li> </ul> <p>First SSH into free5gc VM, and change <code>~/free5gc/config/amfcfg.yaml</code>: <pre><code>cd ~/free5gc\nnano config/amfcfg.yaml\n</code></pre></p> <p>Replace ngapIpList IP from <code>127.0.0.1</code> to <code>192.168.56.101</code>, namely from: <pre><code>...\n  ngapIpList:  # the IP list of N2 interfaces on this AMF\n  - 127.0.0.1\n</code></pre> into: <pre><code>...\n  ngapIpList:  # the IP list of N2 interfaces on this AMF\n  - 192.168.56.101  # 127.0.0.1\n</code></pre></p> <p>Next edit <code>~/free5gc/config/smfcfg.yaml</code>: <pre><code>nano config/smfcfg.yaml\n</code></pre> and in the entry inside <code>userplaneInformation / upNodes / UPF / interfaces / endpoints</code>, change the IP from <code>127.0.0.8</code> to <code>192.168.56.101</code>, namely from: <pre><code>...\n  interfaces: # Interface list for this UPF\n   - interfaceType: N3 # the type of the interface (N3 or N9)\n     endpoints: # the IP address of this N3/N9 interface on this UPF\n       - 127.0.0.8\n</code></pre> into: <pre><code>...\n  interfaces: # Interface list for this UPF\n   - interfaceType: N3 # the type of the interface (N3 or N9)\n     endpoints: # the IP address of this N3/N9 interface on this UPF\n       - 192.168.56.101  # 127.0.0.8\n</code></pre> Finally, edit <code>~/free5gc/config/upfcfg.yaml</code>\uff0cand chage gtpu IP from <code>127.0.0.8</code> into <code>192.168.56.101</code>, namely from: <pre><code>...\n  gtpu:\n    forwarder: gtp5g\n    # The IP list of the N3/N9 interfaces on this UPF\n    # If there are multiple connection, set addr to 0.0.0.0 or list all the addresses\n    ifList:\n      - addr: 127.0.0.8\n        type: N3\n</code></pre> into: <pre><code>...\n  gtpu:\n    forwarder: gtp5g\n    # The IP list of the N3/N9 interfaces on this UPF\n    # If there are multiple connection, set addr to 0.0.0.0 or list all the addresses\n    ifList:\n      - addr: 192.168.56.101  # 127.0.0.8\n        type: N3\n</code></pre></p>"},{"location":"guide/5-install-ueransim/#6-setting-ueransim","title":"6. Setting UERANSIM","text":"<p>In the ueransim VM, there are two files related to free5GC\uff1a</p> <ul> <li><code>~/UERANSIM/config/free5gc-gnb.yaml</code></li> <li><code>~/UERANSIM/config/free5gc-ue.yaml</code></li> </ul> <p>The second file is for UE, which we don\u2019t have to change if the data inside is consistent with the (default) registration data we set using WebConsole previously.</p> <p>First SSH into ueransim, and edit the file <code>~/UERANSIM/config/free5gc-gnb.yaml</code>, and change the ngapIp IP, as well as the gtpIp IP, from <code>127.0.0.1</code> to <code>192.168.56.102</code>\uff0cand also change the IP in amfConfigs into <code>192.168.56.101</code>, that is, from: <pre><code>...\n  ngapIp: 127.0.0.1   # gNB's local IP address for N2 Interface (Usually same with local IP)\n  gtpIp: 127.0.0.1    # gNB's local IP address for N3 Interface (Usually same with local IP)\n\n  # List of AMF address information\n  amfConfigs:\n    - address: 127.0.0.1\n</code></pre> into: <pre><code>...\n  ngapIp: 192.168.56.102  # 127.0.0.1   # gNB's local IP address for N2 Interface (Usually same with local IP)\n  gtpIp: 192.168.56.102  # 127.0.0.1    # gNB's local IP address for N3 Interface (Usually same with local IP)\n\n  # List of AMF address information\n  amfConfigs:\n    - address: 192.168.56.101  # 127.0.0.1\n</code></pre> Next we examine the file <code>~/UERANSIM/config/free5gc-ue.yaml</code>\uff0cand see if the settings is consistent with those in free5GC (via WebConsole), for example: <pre><code># IMSI number of the UE. IMSI = [MCC|MNC|MSISDN] (In total 15 or 16 digits)\nsupi: 'imsi-208930000000003'\n# Mobile Country Code value\nmcc: '208'\n# Mobile Network Code value (2 or 3 digits)\nmnc: '93'\n\n# Permanent subscription key\nkey: '8baf473f2f8fd09487cccbd7097c6862'\n# Operator code (OP or OPC) of the UE\nop: '8e27b6af0e692e750f32667a3b14605d'\n# This value specifies the OP type and it can be either 'OP' or 'OPC'\nopType: 'OP'\n\n...\n\n# Initial PDU sessions to be established\nsessions:\n  - type: 'IPv4'\n    apn: 'internet'\n    slice:\n      sst: 0x01\n      sd: 0x010203\n\n# List of requested S-NSSAIs by this UE\nslices:\n  - sst: 0x01\n    sd: 0x010203\n\n...\n</code></pre> The data appear to be the same as what we set in WebConsole.</p>"},{"location":"guide/5-install-ueransim/#7-testing-ueransim-against-free5gc","title":"7. Testing UERANSIM against free5GC","text":"<p>SSH into free5gc. If you have rebooted free5gc, remember to run: <pre><code>sudo sysctl -w net.ipv4.ip_forward=1\nsudo iptables -t nat -A POSTROUTING -o &lt;dn_interface&gt; -j MASQUERADE\nsudo systemctl stop ufw\n</code></pre></p> <p>Note: In Ubuntu Server 20.04 and 22.04 the dn_interface may be called <code>enp0s3</code> or <code>enp0s4</code> by default. Use the command <code>ip a</code> to help to figure it out</p> <p>In addition, execute the following command: <pre><code>sudo iptables -I FORWARD 1 -j ACCEPT\n</code></pre></p> <p>Tip: As per the information on the appendix page, it's possible to use a script to reload the config above automatically after reboot</p> <p>Also, make sure you have make proper changes to the free5GC configuration files, then run <code>./run.sh</code>: <pre><code>cd ~/free5gc\n./run.sh\n</code></pre></p> <p>At this time free5GC has been started.</p> <p>Next, prepare three additional SSH terminals from your host machine (if you know how to use <code>tmux</code>, you can use just one).</p> <p>In terminal 1: SSH into ueransim, make sure UERANSIM is built, and configuration files have been changed correctly, then execute <code>nr-gnb</code>: <pre><code>cd ~/UERANSIM\nbuild/nr-gnb -c config/free5gc-gnb.yaml\n</code></pre></p> <p>In terminal 2, SSH into ueransim, and execute <code>nr-ue</code> with admin right: <pre><code>cd ~/UERANSIM\nsudo build/nr-ue -c config/free5gc-ue.yaml # for multiple-UEs, use -n and -t for number and delay\n</code></pre></p> <p>In terminal 3, SSH into ueransim, and ping <code>192.168.56.101</code> to see free5gc is alive. Then, use ifconfig to see if the tunnel <code>uesimtun0</code> has been created (by nr-ue): <pre><code>ifconfig\n\nenp0s3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\n        inet 10.0.2.15  netmask 255.255.255.0  broadcast 10.0.2.255\n        inet6 fe80::a00:27ff:fe65:1472  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether 08:00:27:65:14:72  txqueuelen 1000  (Ethernet)\n        RX packets 80  bytes 32423 (32.4 KB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 90  bytes 12860 (12.8 KB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nenp0s8: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\n        inet 192.168.56.102  netmask 255.255.255.0  broadcast 192.168.56.255\n        inet6 fe80::a00:27ff:fe5e:be64  prefixlen 64  scopeid 0x20&lt;link&gt;\n        ether 08:00:27:5e:be:64  txqueuelen 1000  (Ethernet)\n        RX packets 1515  bytes 130490 (130.4 KB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 1010  bytes 206670 (206.6 KB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nlo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\n        inet 127.0.0.1  netmask 255.0.0.0\n        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;\n        loop  txqueuelen 1000  (Local Loopback)\n        RX packets 3445  bytes 174416 (174.4 KB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 3445  bytes 174416 (174.4 KB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nuesimtun0: flags=4305&lt;UP,POINTOPOINT,RUNNING,NOARP,MULTICAST&gt;  mtu 1500\n        inet 60.60.0.1  netmask 255.255.255.255  destination 60.60.0.1\n        inet6 fe80::2034:d00:a76:84b7  prefixlen 64  scopeid 0x20&lt;link&gt;\n        unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  txqueuelen 500  (UNSPEC)\n        RX packets 3  bytes 252 (252.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 13  bytes 732 (732.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre></p> <p>Now use <code>ping</code>: <pre><code>ping -I uesimtun0 google.com\n</code></pre> If <code>ping</code> gets replies, then free5GC is running properly. Congratulations!</p>"},{"location":"guide/5-install-ueransim/#8-testing-ueransim-deregister-via-nr-cli","title":"8. Testing UERANSIM deregister via nr-cli","text":"<p>Create new terminal, use nr-cli to show the running device <pre><code>./build/nr-cli --dump\nUERANSIM-gnb-208-93-1\nimsi-208930000000001\n</code></pre></p> <p>Control <code>imsi-208930000000001</code> to send dereg normal to the free5GC <pre><code>sudo ./build/nr-cli imsi-208930000000001 --exec \"deregister normal\"\n</code></pre> And you would see the De-registration signal/logs in UE: <pre><code>[2024-05-21 08:01:57.175] [nas] [debug] De-registration required due to [NORMAL]\n[2024-05-21 08:01:57.185] [nas] [debug] Starting de-registration procedure due to [NORMAL]\n[2024-05-21 08:01:57.185] [nas] [debug] Performing local release of PDU session[1]\n[2024-05-21 08:01:57.185] [nas] [debug] Performing local release of PDU session[2]\n[2024-05-21 08:01:57.185] [nas] [info] UE switches to state [MM-DEREGISTER-INITIATED]\n</code></pre></p>"},{"location":"guide/6-simple-app/","title":"6 simple app","text":""},{"location":"guide/6-simple-app/#free5gc-simple-apps","title":"free5GC Simple Apps","text":"<p>In this demo we will use free5GC together with UERANSIM to exercise on some simple network applications:</p> <ul> <li><code>ping</code> + <code>tcpdump</code></li> <li><code>wget</code> and <code>curl</code></li> </ul>"},{"location":"guide/6-simple-app/#ping-tcpdump","title":"ping + tcpdump","text":"<p>First start up free5GC and ueransim VMs. This requires one SSH terminal for free5gc, and two for ueransim.</p> <p>Open another SSH terminal and log in into ueransim: <pre><code>ssh 192.168.56.102 -l ubuntu\n</code></pre> Use <code>ifconfig</code> to check if <code>uesimtun0</code> tunnel has been created, and use ping to check if we can <code>ping</code> through it\uff1a <pre><code>ping google.com\n\nPING google.com (172.217.27.142) 56(84) bytes of data.\n64 bytes from tsa03s02-in-f14.1e100.net (172.217.27.142): icmp_seq=1 ttl=63 time=3.98 ms\n64 bytes from tsa03s02-in-f14.1e100.net (172.217.27.142): icmp_seq=2 ttl=63 time=3.87 ms\n64 bytes from tsa03s02-in-f14.1e100.net (172.217.27.142): icmp_seq=3 ttl=63 time=4.06 ms\n^C\n--- google.com ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2003ms\nrtt min/avg/max/mdev = 3.872/3.970/4.060/0.076 ms\n</code></pre></p> <pre><code>ping -I uesimtun0 google.com\n\nPING google.com (172.217.27.142) from 60.60.0.1 uesimtun0: 56(84) bytes of data.\n64 bytes from tsa03s02-in-f14.1e100.net (172.217.27.142): icmp_seq=1 ttl=61 time=5.85 ms\n64 bytes from tsa03s02-in-f14.1e100.net (172.217.27.142): icmp_seq=2 ttl=61 time=4.87 ms\n64 bytes from tsa03s02-in-f14.1e100.net (172.217.27.142): icmp_seq=3 ttl=61 time=4.76 ms\n^C\n--- google.com ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2004ms\nrtt min/avg/max/mdev = 4.760/5.160/5.847/0.487 ms\n</code></pre> <p>Also use <code>route -n</code> to observe if current routing table shows some routing rules regarding the two network interfaces <code>enp0s3</code> and <code>enp0s8</code>: <pre><code>route -n\n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.0.2.2        0.0.0.0         UG    100    0        0 enp0s3\n10.0.2.0        0.0.0.0         255.255.255.0   U     0      0        0 enp0s3\n10.0.2.2        0.0.0.0         255.255.255.255 UH    100    0        0 enp0s3\n192.168.56.0    0.0.0.0         255.255.255.0   U     0      0        0 enp0s8\n</code></pre></p> <p>The network <code>10.0.2.0/24</code> and its <code>enp0s3</code> interface are related to VirtualBox NAT network card. We can bring down this interface: <pre><code>sudo ifconfig enp0s3 down\nroute -n\n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n192.168.56.0    0.0.0.0         255.255.255.0   U     0      0        0 enp0s8\n</code></pre> As shown aboe we have only Host-only network <code>192.168.56.0/24</code> left. Run <code>ping</code> again: <pre><code>ping 8.8.8.8\n\nping: connect: Network is unreachable\n</code></pre></p> <p>And see that it can not ping through, but runing: <pre><code>ping -I uesimtun0 8.8.8.8\n\nPING 8.8.8.8 (8.8.8.8) from 60.60.0.1 uesimtun0: 56(84) bytes of data.\n64 bytes from 8.8.8.8: icmp_seq=1 ttl=61 time=7.17 ms\n64 bytes from 8.8.8.8: icmp_seq=2 ttl=61 time=5.41 ms\n64 bytes from 8.8.8.8: icmp_seq=3 ttl=61 time=5.15 ms\n^C\n--- 8.8.8.8 ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2005ms\nrtt min/avg/max/mdev = 5.150/5.907/7.165/0.895 ms\n</code></pre></p> <p>shows some responses, since we ask <code>ping</code> to go through the free5GC core network. To make <code>ping 8.8.8.8</code> in addition to <code>ping -I uesimtun0 8.8.8.8</code> work, we can set the <code>uesimtun0</code> interface (IP <code>60.60.0.1</code>) as the new default gateway: <pre><code>sudo ip r add default dev uesimtun0\nroute -n\n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         0.0.0.0         0.0.0.0         U     0      0        0 uesimtun0\n192.168.56.0    0.0.0.0         255.255.255.0   U     0      0        0 enp0s8\n</code></pre> Now traffic not for the <code>192.168.56.0/24</code> network will go to <code>uesimtun0</code>, and <code>ping 8.8.8.8</code> works this time: <pre><code>ping 8.8.8.8\n\nPING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.\n64 bytes from 8.8.8.8: icmp_seq=1 ttl=61 time=5.02 ms\n64 bytes from 8.8.8.8: icmp_seq=2 ttl=61 time=6.31 ms\n64 bytes from 8.8.8.8: icmp_seq=3 ttl=61 time=5.41 ms\n^C\n--- 8.8.8.8 ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2004ms\nrtt min/avg/max/mdev = 5.017/5.581/6.312/0.541 ms\n...\n</code></pre></p> <p>Note that normally we are using ueransim to simulate \u201cterminal\u201d UE device, not as a network device or proxy, therefore the above two routing rules suffice.</p> <p>Now if we still want to run: <pre><code>ping google.com\n\nping: google.com: Temporary failure in name resolution\n</code></pre></p> <p>we will get unresolved domain name. To solve this, we can modify the file <code>/etc/resolv.conf</code>: <pre><code>sudo nano /etc/resolv.conf\n</code></pre></p> <p>and change the nameserver IP to <code>8.8.8.8</code>: <pre><code>nameserver 8.8.8.8\n</code></pre></p> <p>After the change, we can see <code>ping</code> getting responses: <pre><code>ping google.com\n\nPING google.com (216.58.200.46) 56(84) bytes of data.\n64 bytes from tsa01s08-in-f46.1e100.net (216.58.200.46): icmp_seq=1 ttl=61 time=5.19 ms\n64 bytes from tsa01s08-in-f46.1e100.net (216.58.200.46): icmp_seq=2 ttl=61 time=50.4 ms\n64 bytes from tsa01s08-in-f46.1e100.net (216.58.200.46): icmp_seq=3 ttl=61 time=5.66 ms\n^C\n--- google.com ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2004ms\nrtt min/avg/max/mdev = 5.191/20.423/50.414/21.207 ms\n</code></pre></p> <p>We can also examine the network traffic happening underneath in the scenario above. First we open another SSH terminal into ueransim, and run the following command: <pre><code>sudo tcpdump -n -i any host 60.60.0.1 or 192.168.56.101\n\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on any, link-type LINUX_SLL (Linux cooked v1), capture size 262144 bytes\n</code></pre></p> <p>then run <code>ping 8.8.8.8</code> again, wait for a couple seconds, then <code>Ctrl-C</code> to exit. We see the data packets actually going in and out <code>uesimtun0</code>. <pre><code>sudo tcpdump -n -i any host 60.60.0.1 or 192.168.56.101\n\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on any, link-type LINUX_SLL (Linux cooked v1), capture size 262144 bytes\n10:24:56.138729 IP 192.168.56.101.38412 &gt; 192.168.56.102.38740: sctp (1) [HB REQ]\n10:24:56.138783 IP 192.168.56.102.38740 &gt; 192.168.56.101.38412: sctp (1) [HB ACK]\n10:24:58.456532 IP 60.60.0.1 &gt; 8.8.8.8: ICMP echo request, id 33, seq 1, length 64\n10:24:58.457416 IP 192.168.56.102.2152 &gt; 192.168.56.101.2152: UDP, length 100\n10:24:58.462136 IP 192.168.56.101.2152 &gt; 192.168.56.102.2152: UDP, length 92\n10:24:58.462324 IP 8.8.8.8 &gt; 60.60.0.1: ICMP echo reply, id 33, seq 1, length 64\n10:24:59.458823 IP 60.60.0.1 &gt; 8.8.8.8: ICMP echo request, id 33, seq 2, length 64\n10:24:59.459031 IP 192.168.56.102.2152 &gt; 192.168.56.101.2152: UDP, length 100\n10:24:59.464214 IP 192.168.56.101.2152 &gt; 192.168.56.102.2152: UDP, length 92\n10:24:59.464396 IP 8.8.8.8 &gt; 60.60.0.1: ICMP echo reply, id 33, seq 2, length 64\n10:25:00.461293 IP 60.60.0.1 &gt; 8.8.8.8: ICMP echo request, id 33, seq 3, length 64\n10:25:00.462178 IP 192.168.56.102.2152 &gt; 192.168.56.101.2152: UDP, length 100\n10:25:00.474941 IP 192.168.56.101.2152 &gt; 192.168.56.102.2152: UDP, length 92\n10:25:00.475561 IP 8.8.8.8 &gt; 60.60.0.1: ICMP echo reply, id 33, seq 3, length 64\n10:25:01.463946 IP 60.60.0.1 &gt; 8.8.8.8: ICMP echo request, id 33, seq 4, length 64\n10:25:01.464523 IP 192.168.56.102.2152 &gt; 192.168.56.101.2152: UDP, length 100\n10:25:01.469297 IP 192.168.56.101.2152 &gt; 192.168.56.102.2152: UDP, length 92\n10:25:01.470314 IP 8.8.8.8 &gt; 60.60.0.1: ICMP echo reply, id 33, seq 4, length 64\n</code></pre></p>"},{"location":"guide/6-simple-app/#wget","title":"wget","text":"<p>Simply look for any web page for file download on the web. For example, if we choose Golang web site as an example, we may find the URL: <pre><code>https://golang.org/dl/go1.15.8.darwin-amd64.pkg\n</code></pre> Using the same network settings is the previous exercise, just <pre><code>wget https://golang.org/dl/go1.15.8.darwin-amd64.pkg\n</code></pre> And see if you can download a Golang 1.15.8 install file.</p>"},{"location":"guide/6-simple-app/#ptt-ssh-bbsupttcc","title":"ptt (<code>ssh bbsu@ptt.cc</code>)","text":"<p>You can actually use SSH in the ueransim VM to access remote site. For example, you can SSH to a well-known terminal-based BBS site in Taiwan: <pre><code>ssh bbsu@ppt.cc\n</code></pre></p>"},{"location":"guide/6-simple-app/#youtube","title":"Youtube","text":"<p>You can also use Youtube as an example app. To achieve this goal, you can install a desktop VM with graphical UI, such as Ubuntu Desktop, and follow the same procedure to install and start up UERANSIM, then access Youtube through <code>uesimtun0</code> and free5GC.</p> <p>To reduce resource consumption on your host machine, you may install Lubuntu (at https://lubuntu.me), a more light-weight Ubuntu desktop distro instead. But since viewing free5GC YouTube Channel requires quite sime CPU consumption, you may have to set at least 2 CPUs and 2048 MB memory for the VM.</p> <p>Refer to videos Access Youtube on Lubuntu (1, 2, 3, 4 and 5).</p>"},{"location":"guide/7-free5gc-helm/","title":"free5gc-helm","text":""},{"location":"guide/7-free5gc-helm/#prerequirements","title":"Prerequirements","text":"<ul> <li> <p>Install</p> <ul> <li> <p>MicroK8s</p> <pre><code>sudo snap install microk8s --classic --channel=1.28/stable\n</code></pre> </li> <li> <p>kubectl</p> <pre><code> sudo snap install kubectl --classic\n</code></pre> </li> <li> <p>helm</p> <pre><code>sudo snap install helm --classic\n</code></pre> </li> </ul> </li> <li> <p>Set <code>sudo</code> group and join</p> <pre><code>sudo groupadd microk8s\nsudo usermod -aG microk8s $USER\nnewgrp microk8s\n</code></pre> </li> <li> <p>Set <code>microk8s</code> work with local <code>kubectl</code></p> <pre><code>mkdir -p ~/.kube\nchmod 0700 ~/.kube\nmicrok8s config &gt; ~/.kube/config\n</code></pre> </li> </ul>"},{"location":"guide/7-free5gc-helm/#ip-forward-configuration","title":"IP Forward Configuration","text":"<p>Note</p> <p>Reference: Calico CNI Docs.</p> <ul> <li> <p>Starting from version 1.19, MicroK8s clusters use the Calico CNI by default.</p> <ul> <li>To enable IP forwarding on UPF, Calico CNI needs some necessary configurations.</li> <li>Some CNI plugin, like Flannel, kube-ovn, allow this funtionality by default.</li> </ul> </li> <li> <p>Setup Calico CNI for IP forwarding:</p> <ul> <li> <p>Edit <code>/var/snap/microk8s/current/args/cni-network/cni.yaml</code></p> <pre><code>...\nkind: ConfigMap\n...\ndata:\n    ...\n    cni_network_config: |-\n        {\n            ...\n            \"plugins\": [\n                {\n                    \"type\": \"calico\",\n                    ...\n                    \"kubernetes\": {\n                        \"kubeconfig\": \"__KUBECONFIG_FILEPATH__\"\n                    },\n                    # append IP forwarding settings\n                    \"container_settings\": {\n                        \"allow_ip_forwarding\": true\n                    },\n                }\n            ]\n        }\n</code></pre> </li> </ul> </li> <li> <p>Setup kubelet args for IP fowarding:</p> <ul> <li> <p>Edit <code>/var/snap/microk8s/current/args/kubelet</code></p> <pre><code># append this arg\n--allowed-unsafe-sysctls \"net.ipv4.ip_forward\"\n</code></pre> </li> </ul> </li> <li> <p>Apply settings and restart MicroK8s</p> <pre><code># apply cni configuration\nkubectl apply -f /var/snap/microk8s/current/args/cni-network/cni.yaml\n# restart MicroK8s\nmicrok8s stop\nmicrok8s start\n</code></pre> </li> </ul>"},{"location":"guide/7-free5gc-helm/#addons-enable","title":"Addons Enable","text":"<p>Note</p> <p>Reference:</p> <ul> <li>MicroK8s multus addons</li> <li>Multus - Create Network Definitions</li> <li>Multus - Tell pods to use those networks via annotations</li> </ul> <pre><code>microk8s enable community\nmicrok8s enable multus\nmicrok8s enable hostpath-storage\n</code></pre>"},{"location":"guide/7-free5gc-helm/#create-persistent-volumn","title":"Create Persistent Volumn","text":"<ul> <li> <p>Create two storage directories:</p> <ul> <li>One for mongo: <code>/home/usr/mongo</code> &lt;= just an example</li> <li>One for cert: <code>/home/use/cert</code> &lt;= just an example</li> </ul> </li> <li> <p>For mongodb</p> <ul> <li>Create an storage directory: <code>/home/usr/mongo</code> &lt;= just an example</li> <li> <p>Create an YAML file: <code>persistent-vol-for-mongodb.yaml</code></p> <pre><code>apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: free5gc-pv-mongo\n  labels:\n    project: free5gc\nspec:\n  capacity:\n    storage: 8Gi\n  accessModes:\n  - ReadWriteOnce\n  persistentVolumeReclaimPolicy: Retain\n  storageClassName: microk8s-hostpath\n  local:\n    path: &lt;mongo_storage_dir&gt; # edit to your own path, like: /home/use/mongo\n  nodeAffinity:\n    required:\n      nodeSelectorTerms:\n      - matchExpressions:\n        - key: kubernetes.io/hostname\n          operator: In\n          values:\n          - &lt;work_node_name&gt; # edit to you node name\n</code></pre> </li> <li> <p>Apply via <code>kubectl</code></p> <pre><code>kubectl apply -f persistent-vol-for-mongodb.yaml\n</code></pre> </li> </ul> </li> <li> <p>For cert</p> <ul> <li>Create an storage directory: <code>/home/usr/cert</code> &lt;= just an example</li> <li> <p>Create an YAML file: <code>persistent-vol-for-cert.yaml</code></p> <pre><code>apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: free5gc-pv-cert\n  labels:\n    project: free5gc\nspec:\n  capacity:\n    storage: 2Mi\n  accessModes:\n  - ReadOnlyMany\n  persistentVolumeReclaimPolicy: Retain\n  storageClassName: microk8s-hostpath\n  local:\n    path: &lt;cert_storage_dir&gt; # edit to your own path, like: /home/use/cert\n  nodeAffinity:\n    required:\n      nodeSelectorTerms:\n      - matchExpressions:\n        - key: kubernetes.io/hostname\n          operator: In\n          values:\n          - &lt;work-node-name&gt; # edit to you node name\n</code></pre> </li> <li> <p>Apply via <code>kubectl</code></p> <pre><code>kubectl apply -f persistent-vol-for-cert.yaml\n</code></pre> </li> </ul> </li> <li> <p>Check it</p> <pre><code>kubectl get pv\n</code></pre> </li> </ul>"},{"location":"guide/7-free5gc-helm/#helm-chart","title":"Helm Chart","text":"<ul> <li> <p>Clone from github</p> <pre><code>git clone https://github.com/free5gc/free5gc-helm.git\n</code></pre> </li> </ul>"},{"location":"guide/7-free5gc-helm/#network-configuration","title":"Network configuration","text":"<p>Note</p> <p>Reference: Toward5Gs -- Network Configuration</p> <ul> <li> <p>In summary, the <code>value.yaml</code> in each configuration should be set up correctly.</p> <ul> <li>free5gc-helm offered a network configuration YAML file at <code>free5gc-helm/charts/free5gc/value.yaml</code>.</li> <li>For <code>N2</code>/<code>N3</code>/<code>N4</code>/<code>N6</code>/<code>N9</code> interfaces, the <code>masterIf</code> and other <code>IP</code> field should be modified for customized deployment.</li> </ul> </li> <li> <p>(Optional) These values could also be setup by using <code>helm install --set</code>.</p> <pre><code>helm install -n free5gc free5gc-helm ./free5gc/ \\\n    --set global.n6network.subnetIP=\"x.x.x.x\" \\\n    --set global.n6network.gatewayIP=\"y.y.y.y\" \\\n    --set free5gc-upf.upf.n6if.ipAddress=\"z.z.z.z\"\n</code></pre> </li> </ul>"},{"location":"guide/7-free5gc-helm/#install-chart","title":"Install Chart","text":"<ul> <li> <p>Set working namespace for free5GC</p> <pre><code>kubectl create ns free5gc\n</code></pre> </li> <li> <p>Install free5GC charts</p> <pre><code>cd free5gc-helm/charts\nhelm install -n free5gc free5gc-helm ./free5gc/ \n</code></pre> </li> <li> <p>Install UERANSIM chart</p> <pre><code>cd free5gc-helm/charts\nhelm install -n free5gc ueransim ./ueransim/ \n</code></pre> </li> <li> <p>Check installation</p> <ul> <li> <p>Check installed charts</p> <pre><code>helm ls -A\n</code></pre> </li> <li> <p>Check services, pods, replicates and deployments</p> <pre><code># status at each pod is expected as \"Running\"\nkubectl get all -n free5gc\n</code></pre> </li> </ul> </li> <li> <p>Check IP forwarding is available at UPF</p> <pre><code># output should be '1'\nkubectl exec -it -n free5gc deployment/free5gc-helm-free5gc-upf-upf \\\n    -- cat /proc/sys/net/ipv4/ip_forward\n</code></pre> </li> </ul>"},{"location":"guide/7-free5gc-helm/#test","title":"Test","text":"<ul> <li> <p>Add subscribers via web console</p> <ul> <li> <p>Access <code>`&lt;external_ip&gt;:30500</code></p> <p></p> </li> </ul> </li> <li> <p>Ping external network with GTP-Tunnel</p> <pre><code>kubectl exec -it -n free5gc deployment/ueransim-ue \\\n    -- ping -I uesimtun0 8.8.8.8\n</code></pre> <p></p> </li> </ul>"},{"location":"guide/8-traffic-influence/","title":"Influence Traffic Routing","text":"<ul> <li>The SMF may control the data path of a PDU Session so that the PDU Session may simultaneously correspond to multiple N6 interfaces.</li> <li>We have provided some smaple scripts under the free5gc-compose, you can test the content in this note with <pre><code>sudo docker run --rm --network &lt;free5gc-nw-name&gt; \\\n    -v \"$(pwd):/mnt\" -w /mnt curlimages/curl &lt;script.sh&gt;\n</code></pre></li> </ul>"},{"location":"guide/8-traffic-influence/#influence-traffic-routing-by-udr","title":"Influence traffic routing by UDR","text":"<ul> <li>Traffic routing can be triggered by storing/updating/removing the information in UDR.</li> </ul>"},{"location":"guide/8-traffic-influence/#example-usage-of-traffic-influence","title":"Example usage of traffic influence","text":"<ul> <li>In the free5gc-compose, we have a compose file for ulcl, with two default UPFs: I-UPF and PSA-UPF.</li> <li> <p>Suppose that we want to let mec traffic go through the I-UPF, others go through the PSA-UPF.</p> Others (Default) MEC (after TI) </li> <li> <p>We could put the influence data to UDR, triggering traffic influence process and influence the traffic routing.</p> <ul> <li>Sample traffic influence data: <code>ti_data.json</code> <pre><code>{\n    \"dnn\": \"internet\",\n    \"snssai\": {\n        \"sst\": 1,\n        \"sd\": \"010203\"\n    },\n    \"interGroupId\": \"AnyUE\",\n    \"trafficFilters\": [\n    {\n        \"flowId\": 1,\n        \"flowDescriptions\": [\n            \"permit out ip from &lt;server-cidr&gt; to 10.60.0.0/16\"\n        ]\n    }\n    ],\n    \"trafficRoutes\": [\n        {\n            \"dnai\": \"mec\"\n        }\n    ]\n}\n</code></pre></li> <li>Use curl to put the data to the UDR. <pre><code>curl -X PUT -H \"Content-Type: application/json\" --data @./ti_data.json \\\n    http://&lt;udr-interface&gt;:8000/nudr-dr/v1/application-data/influenceData/1\n</code></pre></li> <li>To check the created influence data, use the following command. <pre><code>curl -X GET -H \"Content-Type: application/json\" \\\n    http://&lt;udr-interface&gt;:8000/nudr-dr/v1/application-data/influenceData?dnns=internet\n</code></pre></li> <li>You can also remove the traffic influence data by the following command. <pre><code>curl -X DELETE -H \"Content-Type: application/json\" \\\n    http://&lt;udr-interface&gt;:8000/nudr-dr/v1/application-data/influenceData/1\n</code></pre></li> </ul> </li> </ul>"},{"location":"guide/8-traffic-influence/#screenshots","title":"Screenshots","text":"<ul> <li>We use this sample topology to show the example usage of traffic influence </li> <li>Traffic routing before influence<ul> <li>ping <code>1.1.1.1</code> (UERANSIM &lt;-&gt; I-UPF &lt;-&gt; PSA-UPF &lt;-&gt; Server) </li> <li>ping <code>remote server</code> (UERANSIM &lt;-&gt; I-UPF &lt;-&gt; PSA-UPF &lt;-&gt; Server) </li> </ul> </li> <li>Traffic routing after influence<ul> <li>ping <code>1.1.1.1</code> (UERANSIM &lt;-&gt; I-UPF &lt;-&gt; PSA-UPF &lt;-&gt; Server) </li> <li>ping <code>remote server</code> (UERANSIM &lt;-&gt; I-UPF &lt;-&gt; Server) </li> </ul> </li> </ul>"},{"location":"guide/8-traffic-influence/#influence-traffic-routing-by-nef","title":"Influence traffic routing by NEF","text":"<ul> <li>An Application Function (AF) may send requests to influence SMF routing decisions for User Plane traffic of PDU Sessions. </li> <li>The AF requests may influence UPF (re)selection and allow routing of user traffic to a local access (identified by a DNAI) to a Data Network.</li> </ul>"},{"location":"guide/8-traffic-influence/#af-requests-targeting-a-group-of-ue","title":"AF requests targeting a group of UE","text":"<p>TS 23.502 figure 4.3.6.2-1 Processing AF requests to influence traffic routing for Sessions not identified by an an UE address</p> <ul> <li>Example usage in free5GC<ul> <li>AF send JSON data to NEF, e.g. <code>af_ti_anyUE.json</code> <pre><code>{\n    \"afServiceId\": \"Service1\",\n    \"dnn\": \"internet\",\n    \"snssai\": {\n        \"sst\": 1,\n        \"sd\": \"010203\"\n    },\n    \"anyUeInd\": true,\n    \"notificationDestination\": \"http://af:8000/test123\",\n    \"trafficFilters\": [{\n        \"flowId\": 1,\n        \"flowDescriptions\": [\n            \"permit out ip from &lt;server-cidr&gt; to 10.60.0.0/16\"\n        ]\n    }],\n    \"trafficRoutes\": [\n        {\n            \"dnai\": \"mec\"\n        }\n    ]\n}\n</code></pre></li> <li>Use curl to POST the data to NEF. <pre><code>curl -X POST -H \"Content-Type: application/json\" --data @./af_ti_anyUE.json \\\n    http://&lt;nef-interface&gt;:8000/3gpp-traffic-influence/v1/af001/subscriptions\n</code></pre></li> </ul> </li> </ul>"},{"location":"guide/8-traffic-influence/#af-requests-targeting-an-individual-ue","title":"AF requests targeting an individual UE","text":"<p>TS 23.502 figure 4.3.6.4-1 Handling an AF request targeting an individual UE address to the relevant PCF</p> <ul> <li> <p>Example usage in free5GC</p> <ul> <li> <p>Provide PFDs in <code>uerouting.yaml</code> before SMF start up <pre><code>//...\npfdDataForApp: # PFDs for an Application\n    - applicationId: app1 # Application identifier\n        pfds: # PFDs for the Application\n          - pfdID: pfd1 # PFD identifier\n            flowDescriptions: \n              - permit out ip from &lt;server-cidr&gt; to 10.60.0.0/16\n</code></pre></p> <ul> <li>Packet Flow Description (PFD): A set of information enabling the detection of application traffic provided by a 3rd party service provider. </li> </ul> </li> <li> <p>AF send JSON data to NEF, e.g. <code>af_ti_singleUE.json</code> <pre><code>{\n    \"afServiceId\": \"Service1\",\n    \"AfAppId\": \"app1\",\n    \"dnn\": \"internet\",\n    \"snssai\": {\n        \"sst\": 1,\n        \"sd\": \"010203\"\n    },\n    \"ipv4Addr\": \"10.60.0.1\",\n    \"notificationDestination\": \"http://af:8000/test123\",\n    \"trafficRoutes\": [{\n        \"dnai\": \"mec\"\n    }],\n    \"suppFeat\": \"01\"\n}\n</code></pre></p> </li> <li>Use curl to POST the data to NEF. <pre><code>curl -X POST -H \"Content-Type: application/json\" --data @./af_ti_singleUE.json \\\n    http://&lt;nef-interface&gt;:8000/3gpp-traffic-influence/v1/af001/subscriptions\n</code></pre></li> </ul> </li> </ul>"},{"location":"guide/9-nr-dc/","title":"NR-DC(New Radio-Dual Connectivity)","text":"<p>Note</p> <ul> <li>Introduction for NR-DC, please refer to: Introducing NR-DC: Dual Connectivity for Next-Gen 5G Capabilities</li> <li>About Implementation details, please refer to: NR-DC(New Radio-Dual Connectivity)</li> </ul> <p></p>"},{"location":"guide/9-nr-dc/#types","title":"Types","text":"<p>In real 5G networks, the NR-DC feature can be triggered in two ways:</p> <ol> <li>Static Approach: Two tunnels are established when the gNB and UE's PDU session starts.</li> <li>Dynamic Approach: After the PDU session is established, the gNB can dynamically offload QoS traffic to the secondary gNB or retrieve the traffic at any time.</li> </ol>"},{"location":"guide/9-nr-dc/#static-approach","title":"Static Approach","text":""},{"location":"guide/9-nr-dc/#expected-behavior","title":"Expected Behavior","text":"<ul> <li>After PDU session established, there will be TWO TUNNELs in this PDU session:<ol> <li>The first tunnel (handled by Master-gNB): forward the default(non-specified QoS traffic) traffic.</li> <li>The second tunnel (handled by Secondary-gNB): forward the specified QoS traffic configured via webconsole.</li> </ol> </li> </ul>"},{"location":"guide/9-nr-dc/#how-to-trigger-nr-dc","title":"How to trigger NR-DC?","text":"<p>In the PDU session establishment procedure, we need to prepare TWO TUNNELs' information (one is for Master-gNB, and te other is for Secondary-gNB) after step 12(N2 PDU Session Request) and encapsulate them in step 14(N2 PDU Session Response):</p> <p></p> <p>Warning</p> <p>You may need to do Xn-interface communication between gNBs or hardcode the informations in development environment. Communications include:</p> <ul> <li>Master-gNB sends UPLINK Tunnel information to Secondary-gNB.</li> <li>Master-gNB retrieve DOWNLINK TEID information from Secondary-gNB.</li> </ul> <p>Here we take <code>buildPDUSessionResourceSetupResponseTransfer</code> function under free5GC's integration test as an example, this function will be called before step 14 for building the data of the response:</p> <ul> <li> <p>For basic, no NR-DC, it only contains FIRST_DOWNLINK_TEID and MASTER_GNB_IP:</p> <pre><code>func buildPDUSessionResourceSetupResponseTransfer() (data ngapType.PDUSessionResourceSetupResponseTransfer) {\n    var data ngapType.PDUSessionResourceSetupResponseTransfer\n    // QoS Flow per TNL Information\n    qosFlowPerTNLInformation := &amp;data.QosFlowPerTNLInformation\n    qosFlowPerTNLInformation.UPTransportLayerInformation.Present = ngapType.UPTransportLayerInformationPresentGTPTunnel\n    // UP Transport Layer Information in QoS Flow per TNL Information\n    upTransportLayerInformation := &amp;qosFlowPerTNLInformation.UPTransportLayerInformation\n    upTransportLayerInformation.Present = ngapType.UPTransportLayerInformationPresentGTPTunnel\n    upTransportLayerInformation.GTPTunnel = new(ngapType.GTPTunnel)\n=&gt;  dowlinkTeid := binary.BigEndian.AppendUint32(nil, &lt;FIRST_DOWNLINK_TEID&gt;)\n    upTransportLayerInformation.GTPTunnel.GTPTEID.Value = dowlinkTeid\n=&gt;  upTransportLayerInformation.GTPTunnel.TransportLayerAddress = ngapConvert.IPAddressToNgap(&lt;MASTER_GNB_IP&gt;, \"\")\n    // Associated QoS Flow List in QoS Flow per TNL Information\n    associatedQosFlowList := &amp;qosFlowPerTNLInformation.AssociatedQosFlowList\n    associatedQosFlowItem := ngapType.AssociatedQosFlowItem{}\n    associatedQosFlowItem.QosFlowIdentifier.Value = qosId\n    associatedQosFlowList.List = append(associatedQosFlowList.List, associatedQosFlowItem)\n    return\n}\n</code></pre> </li> <li> <p>For NR-DC, we need to add the SECOND_DOWNLINK_TEID and SECONDARY_GNB_IP(ignore the basic part which is same with above):</p> <pre><code>func buildPDUSessionResourceSetupResponseTransferWithDC() (data ngapType.PDUSessionResourceSetupResponseTransfer) {\n    // QoS Flow per TNL Information\n    ...\n    // UP Transport Layer Information in QoS Flow per TNL Information\n    ...\n    // Associated QoS Flow List in QoS Flow per TNL Information\n    ...\n    // DC QoS Flow per TNL Information\n    DCQosFlowPerTNLInformationItem := ngapType.QosFlowPerTNLInformationItem{}\n    DCQosFlowPerTNLInformationItem.QosFlowPerTNLInformation.UPTransportLayerInformation.Present = ngapType.UPTransportLayerInformationPresentGTPTunnel\n    // DC Transport Layer Information in QoS Flow per TNL Information\n    DCUpTransportLayerInformation := &amp;DCQosFlowPerTNLInformationItem.QosFlowPerTNLInformation.UPTransportLayerInformation\n    DCUpTransportLayerInformation.Present = ngapType.UPTransportLayerInformationPresentGTPTunnel\n    DCUpTransportLayerInformation.GTPTunnel = new(ngapType.GTPTunnel)\n=&gt;  DCUpTransportLayerInformation.GTPTunnel.GTPTEID.Value = aper.OctetString(&lt;SECOND_DOWNLINK_TEID&gt;)\n=&gt;  DCUpTransportLayerInformation.GTPTunnel.TransportLayerAddress = ngapConvert.IPAddressToNgap(&lt;SECONDARY_GNB_IP&gt;, \"\")\n    // DC Associated QoS Flow List in QoS Flow per TNL Information\n    DCAssociatedQosFlowList := &amp;DCQosFlowPerTNLInformationItem.QosFlowPerTNLInformation.AssociatedQosFlowList\n    DCAssociatedQosFlowItem := ngapType.AssociatedQosFlowItem{}\n    DCAssociatedQosFlowItem.QosFlowIdentifier.Value = qosId\n    DCAssociatedQosFlowList.List = append(DCAssociatedQosFlowList.List, DCAssociatedQosFlowItem)\n    // Additional DL QoS Flow per TNL Information\n    data.AdditionalDLQosFlowPerTNLInformation = new(ngapType.QosFlowPerTNLInformationList)\n    data.AdditionalDLQosFlowPerTNLInformation.List = append(data.AdditionalDLQosFlowPerTNLInformation.List, DCQosFlowPerTNLInformationItem)\n    return\n}\n</code></pre> </li> </ul> <p>After the response received by AMF, core network will create the DC Tunnel for specifed QoS traffics and update the corresponding forwarding rules in UPF via N4 session.</p>"},{"location":"guide/9-nr-dc/#dynamic-approach","title":"Dynamic Approach","text":""},{"location":"guide/9-nr-dc/#expected-behaviors","title":"Expected Behaviors","text":"<ul> <li> <p>When dual connectivity is not activated:</p> <ul> <li>The specified traffic flow will be offloaded to the secondary gNB.</li> <li>Two tunnels will exist within a single PDU session.</li> </ul> </li> <li> <p>When dual connectivity is being activated:</p> <ul> <li>The second tunnel will be merged back into the master tunnel and subsequently released.</li> <li>The PDU session will revert to a single tunnel configuration.</li> </ul> </li> </ul>"},{"location":"guide/9-nr-dc/#how-to-trigger-offload","title":"How to trigger offload?","text":"<p>Warning</p> <p>Before initiating the offload procedure, you must first specify the desired traffic flow settings through the web console.</p> <p>To illustrate how to trigger offload, we use the <code>buildPDUSessionResourceModifyIndicationTransferWithDC</code> function from free5GC's integration test as an example. This function can be invoked at any time when you wish to initiate an offload operation.</p> <p></p> <p>When the master gNB decides to offload specific traffic to the secondary gNB, it should first interact with the secondary gNB via the Xn interface to obtain the second tunnel's information.</p> <p>Subsequently, the master gNB encapsulates the tunnel information into a <code>ngapType.PDUSessionResourceModifyIndicationTransfer</code> structure. This data type is used to carry tunnel information and is formatted as an NGAPPDU.</p> <pre><code>func buildPDUSessionResourceModifyIndicationTransferWithDC(enbaleDC bool) ngapType.PDUSessionResourceModifyIndicationTransfer {\n    var data ngapType.PDUSessionResourceModifyIndicationTransfer\n    // QoS Flow per TNL Information\n    \u00b7\u00b7\u00b7\n    // UP Transport Layer Information in QoS Flow per TNL Information\n    \u00b7\u00b7\u00b7\n    // Associated QoS Flow List in QoS Flow per TNL Information\n    \u00b7\u00b7\u00b7\n=&gt;  if enableDC {\n        // DC QoS Flow per TNL Information\n        DCQosFlowPerTNLInformationItem := ngapType.QosFlowPerTNLInformationItem{}\n        DCQosFlowPerTNLInformationItem.QosFlowPerTNLInformation.UPTransportLayerInformation.Present = ngapType.UPTransportLayerInformationPresentGTPTunnel\n        // DC Transport Layer Information in QoS Flow per TNL Information\n        DCUpTransportLayerInformation := &amp;DCQosFlowPerTNLInformationItem.QosFlowPerTNLInformation.UPTransportLayerInformation\n        DCUpTransportLayerInformation.Present = ngapType.UPTransportLayerInformationPresentGTPTunnel\n        DCUpTransportLayerInformation.GTPTunnel = new(ngapType.GTPTunnel)\n        DCUpTransportLayerInformation.GTPTunnel.GTPTEID.Value = aper.OctetString(&lt;SECOND_DOWNLINK_TEID&gt;)\n        DCUpTransportLayerInformation.GTPTunnel.TransportLayerAddress = ngapConvert.IPAddressToNgap(&lt;SECONDARY_GNB_IP&gt;, \"\")\n        // DC Associated QoS Flow List in QoS Flow per TNL Information\n        DCAssociatedQosFlowList := &amp;DCQosFlowPerTNLInformationItem.QosFlowPerTNLInformation.AssociatedQosFlowList\n        DCAssociatedQosFlowItem := ngapType.AssociatedQosFlowItem{}\n        DCAssociatedQosFlowItem.QosFlowIdentifier.Value = qosId\n        DCAssociatedQosFlowList.List = append(DCAssociatedQosFlowList.List, DCAssociatedQosFlowItem)\n        // Additional DL QoS Flow per TNL Information\n        data.AdditionalDLQosFlowPerTNLInformation = new(ngapType.QosFlowPerTNLInformationList)\n        data.AdditionalDLQosFlowPerTNLInformation.List = append(data.AdditionalDLQosFlowPerTNLInformation.List, DCQosFlowPerTNLInformationItem)\n    }\n    return data\n}\n</code></pre> <p>If the transition is from a single connection to dual connectivity, the <code>enableDC</code> parameter should be set to include the second tunnel's information. This instructs the core network to create and update the PDR/FAR in the data plane, thereby configuring the second tunnel.</p> <p>Conversely, if the transition is from dual connectivity back to a single connection, the modify indication transfer message does not need to include the <code>enableDC</code> section. The core network will detect the current state and, upon parsing the transfer message, will disable the second tunnel accordingly.</p> <p>Once the modify indication transfer request is accepted and successfully processed, the core network will respond with an <code>ngapType.PDUSessionResourceModifyConfirmTransfer</code> message. This message contains the modified tunnel information, including its TEID. The master gNB can then use this information to update the secondary gNB.</p>"},{"location":"guide/9-nr-dc/#quickstart","title":"Quickstart","text":"<p>Please refer to: free-ran-ue User Guide</p> <p>Currently, it support:</p> <ul> <li>Static NR-DC</li> <li>Dynamic NR-DC</li> <li>Docker Deployment</li> </ul>"},{"location":"guide/9-nr-dc/#reference","title":"Reference","text":"<ul> <li>TS 23.502 Procedure for the 5G System</li> <li>TS 37.340 E-UTRA and NR \u2013 Multi-connectivity \u2013 Overall description \u2013 Stage 2</li> </ul>"},{"location":"guide/Appendix/","title":"Appendix","text":""},{"location":"guide/Appendix/#appendix","title":"Appendix","text":""},{"location":"guide/Appendix/#appendix-a-oam","title":"Appendix A: OAM","text":"<ol> <li>Run the OAM server <pre><code>cd webconsole\ngo run server.go\n</code></pre></li> <li>Access the OAM by <pre><code>URL: http://localhost:5000\nUsername: admin\nPassword: free5gc\n</code></pre></li> <li>Now you can see the information of currently registered UEs (e.g. Supi, connected state, etc.) in the core network at the tab \"DASHBOARD\" of free5GC webconsole</li> </ol> <p>Note: You can add the subscribers here too</p>"},{"location":"guide/Appendix/#appendix-b-orchestrator","title":"Appendix B: Orchestrator","text":"<p>Please refer to free5gmano</p>"},{"location":"guide/Appendix/#appendix-c-iptv","title":"Appendix C: IPTV","text":"<p>Please refer to free5GC/IPTV</p>"},{"location":"guide/Appendix/#appendix-d-system-environment-cleaning","title":"Appendix D: System Environment Cleaning","text":"<p>The below commands may be helpful for development purposes.</p> <ol> <li>Remove POSIX message queues<ul> <li><code>ls /dev/mqueue/</code></li> <li><code>rm /dev/mqueue/*</code></li> </ul> </li> <li>Remove gtp5g tunnels (using tools in libgtp5gnl)<ul> <li><code>cd ./src/upf/lib/libgtp5gnl/tools</code></li> <li><code>./gtp5g-tunnel list pdr</code></li> <li><code>./gtp5g-tunnel list far</code></li> </ul> </li> <li>Remove gtp5g devices (using tools in libgtp5gnl)<ul> <li><code>cd ./src/upf/lib/libgtp5gnl/tools</code></li> <li><code>sudo ./gtp5g-link del {Dev-Name}</code></li> </ul> </li> </ol>"},{"location":"guide/Appendix/#appendix-e-change-kernel-version","title":"Appendix E: Change Kernel Version","text":"<ol> <li>Check the previous kernel version: <code>uname -r</code></li> <li>Search for a specific kernel version and install (e.g. <code>5.0.0-23-generic</code>) <pre><code>sudo apt update # make sure package lists are up to date\nsudo apt search 'linux-image-5.0.0-23-generic'\n</code></pre> Example output for the command above: <pre><code>Sorting... Done\nFull Text Search... Done\nlinux-image-5.0.0-23-generic/focal-updates,focal-security 5.0.0-23.126~20.04.1 amd64\n  Signed kernel image generic\n</code></pre> Install the new kernel image: <pre><code>sudo apt install linux-image-5.0.0-23-generic linux-headers-5.0.0-23-generic\n</code></pre></li> <li>Update initramfs and GRUB <pre><code>sudo update-initramfs -u -k all\nsudo update-grub\n</code></pre></li> <li>Reboot, enter GRUB, and select the newly installed kernel version <code>5.0.0-23-generic</code> <pre><code>sudo reboot\n</code></pre></li> <li>Reinstall the GTP-U kernel module on the new kernel version</li> </ol> <p>Follow the <code>Retrieve the 5G GTP-U kernel module using git and build it</code> instructions of the install guide</p>"},{"location":"guide/Appendix/#optional-remove-kernel-image","title":"Optional: Remove Kernel Image","text":"<pre><code>sudo apt remove linux-image-5.0.0-23-generic linux-headers-5.0.0-23-generic\n</code></pre>"},{"location":"guide/Appendix/#appendix-f-program-the-sim-card","title":"Appendix F: Program the SIM Card","text":"<p>Install packages: <pre><code>sudo apt-get install pcscd pcsc-tools libccid python-dev swig python-setuptools python-pip libpcsclite-dev\nsudo pip install pycrypto\n</code></pre></p> <p>Download PySIM <pre><code>git clone git://git.osmocom.org/pysim.git\n</code></pre></p> <p>Change to pyscard folder and install <pre><code>cd &lt;pyscard-path&gt;\nsudo /usr/bin/python setup.py build_ext install\n</code></pre></p> <p>Verify your reader is ready</p> <pre><code>sudo pcsc_scan\n</code></pre> <p>Check whether your reader can read the SIM card <pre><code>cd &lt;pysim-path&gt;\n./pySim-read.py \u2013p 0\n</code></pre></p> <p>Program your SIM card information <pre><code>./pySim-prog.py -p 0 -x 208 -y 93 -t sysmoUSIM-SJS1 -i 208930000000003 --op=8e27b6af0e692e750f32667a3b14605d -k 8baf473f2f8fd09487cccbd7097c6862 -s 8988211000000088313 -a 23605945\n</code></pre></p> <p>You can get your SIM card from sysmocom.</p>"},{"location":"guide/Appendix/#appendix-g-install-mongodb-70x-on-ubuntu-server-220403","title":"Appendix G: Install MongoDB 7.0.x on Ubuntu Server 22.04.03","text":"<p>Check that the system CPU supports AVX instructions as it's required since MongoDB 5.0. If not (i.e. the command below returns empty output), use MongoDB 4.4.x (see step 3 from installation prerequisites instructions)</p> <pre><code>grep --color avx /proc/cpuinfo\n</code></pre> <p>Before you begin the installation, update the package manager database and make sure MongoDB prerequisites are installed <pre><code>sudo apt update\nsudo apt install gnupg curl\n</code></pre> Add MongoDB public GPG key <pre><code>curl -fsSL https://pgp.mongodb.com/server-7.0.asc | \\\n   sudo gpg -o /usr/share/keyrings/mongodb-server-7.0.gpg --dearmor\n</code></pre> Note: if you are installing a version other than 7.0, remember, change it on the command above</p> <p>Create the APT list entry file using the command below <pre><code>echo \"deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb-server-7.0.gpg ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/7.0 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list\n</code></pre></p> <p>Refresh the package database then install MongoDB</p> <pre><code>sudo apt update\nsudo apt install -y mongodb-org\n</code></pre> <p>For detailed instructions on how to freeze the installed version or install a specific version of MongoDB, please, check the reference below or follow this direct URL</p> <p>Don't forget to load the DB service using</p> <pre><code>sudo systemctl start mongod\n</code></pre> <p>Reference: MongoDB official website</p>"},{"location":"guide/Appendix/#appendix-h-using-the-reload_host_configsh-script","title":"Appendix H: Using the <code>reload_host_config.sh</code> script","text":"<p>The script was designed to help reapplying the configurations after a VM reboot</p>"},{"location":"guide/Appendix/#usage","title":"Usage","text":"<p>Its usage is fairly simple, just run</p> <pre><code>cd ~/free5gc # go back to free5gc's main folder\nsudo reload_host_config.sh &lt;dn_interface&gt;\n</code></pre> <p>For example, if your DN interface (e.g. free5GC's VM LAN interface) is called <code>enp0s4</code>, the command above will be</p> <pre><code>sudo reload_host_config.sh enp0s4\n</code></pre> <p>Note: In Ubuntu Server 20.04 and 22.04 the dn_interface may be called <code>enp0s3</code> or <code>enp0s4</code> by default</p> <p>If you are unsure about the interface name, run <code>ip a</code> to help to figure it out (see the image below)</p> <p></p> <p>An example of the expected output is depicted above</p>"},{"location":"guide/Appendix/#reset-iptables-rules","title":"Reset iptables rules","text":"<p>There is a parameter to completely reset the firewall rules (by default, the script only appends free5gc's required rules)</p> <p>Just add <code>-reset-firewall</code> to the script input</p> <pre><code>sudo reload_host_config.sh enp0s4 -reset-firewall\n</code></pre> <p>So it will clear all rules, then apply the required rules</p>"},{"location":"guide/Configuration/","title":"Configuration","text":""},{"location":"guide/Configuration/#configuration","title":"Configuration","text":""},{"location":"guide/Configuration/#sbi-configuration","title":"SBI Configuration","text":""},{"location":"guide/Configuration/#nf-ip","title":"NF IP","text":"<p>There are registerIP and bindingIP design on every NF's sbi interface.</p> <pre><code>configuration:\n  sbi: # Service-based interface information\n    scheme: http # the protocol for sbi (http or https)\n    registerIPv4: 127.0.0.18 # IP used to register to NRF\n    bindingIPv4: 127.0.0.18  # IP used to bind the service\n    port: 8000 # port used to bind the service\n</code></pre> <p>This is due to some orchestration, such as Kubernetes or OpenStack, has the design of service IP mapping.</p> <p></p> <p>Use Kubernetes as an example. K8s has the service type that enable users to define the service IP outside the pod. But the service IP may be different from the IP assigned inside the pod. Therefore, if we register the binding IP inside the pod to NRF, NRF cannot know which service IP outside the pod has attached. As the result, we need to separate registerIP from bindingIP in this scenario.</p> <p>If you are not sure what IP you should set, just configure it as the same IP address.</p>"},{"location":"guide/Configuration/#oauth2","title":"OAuth2","text":"<ul> <li>Enable OAuth2 setting in NRF config (nrfcfg.yaml): <pre><code>configuration:\n  sbi: # Service-based interface information\n    oauth: true\n</code></pre></li> <li>Set NRF's certificate path in each NF: <pre><code>configuration:\n    nrfCertPem: cert/nrf.pem # NRF Certificate\n</code></pre></li> <li>For more detailed information about OAuth2 in free5GC, please refer to the Design Document.</li> </ul>"},{"location":"guide/Configuration/#sample-configuration","title":"Sample configuration","text":"<p>We provide a sample config to connect to outer ran under <code>/sample/ran_attach_config/</code>. The architecture is as following.</p> <p></p> <p>As the result, user's RAN IP must set to 192.168.0.0/24 subnet or let the routing route to this subnet.</p> <p>Notice: If user wants to use the setting, aware to set 192.168.0.1 to your host as well.</p>"},{"location":"guide/Configuration/#smf-configuration","title":"SMF Configuration","text":""},{"location":"guide/Configuration/#a-configure-smf-with-s-nssai","title":"A. Configure SMF with S-NSSAI","text":"<ol> <li>Configure NF Registration SMF S-NSSAI in <code>smfcfg.yaml</code></li> </ol>"},{"location":"guide/Configuration/#b-configure-uplink-classifier-ulcl-information-in-smf","title":"B. Configure Uplink Classifier (ULCL) information in SMF","text":"<ol> <li>Configure UE routing path in <code>uerouting.yaml</code></li> </ol> <ul> <li>DestinationIP and DestinationPort will be the packet destination.</li> <li>UPF field will be the packet datapath when it match the destination above.</li> </ul> <p>For more detail of SMF config, please refer to here.</p>"},{"location":"guide/Environment/","title":"Environment","text":""},{"location":"guide/Environment/#recommended-environment","title":"Recommended Environment","text":"<p>free5gc has been tested against the following environment:</p> <ul> <li>Software<ul> <li>OS: Ubuntu 20.04.6 LTS</li> <li>gcc 9.4.0</li> <li>go 1.18.10 linux/amd64</li> <li>kernel version 5.4.0-169-generic</li> </ul> </li> </ul> <p>Note: The listed kernel version is required for the UPF element.</p> <ul> <li> <p>Minimum Hardware</p> <ul> <li>CPU: Intel i5 processor</li> <li>RAM: 4GB</li> <li>Hard drive: 160GB</li> <li>NIC: Any 1Gbps Ethernet card supported in the Linux kernel</li> </ul> </li> <li> <p>Recommended Hardware</p> <ul> <li>CPU: Intel i7 processor</li> <li>RAM: 8GB</li> <li>Hard drive: 160GB</li> <li>NIC: Any 10Gbps Ethernet card supported in the Linux kernel</li> </ul> </li> </ul> <p>This guide assumes that you will run all 5GC elements on a single machine.</p>"},{"location":"guide/SMF-Config/","title":"SMF Config","text":""},{"location":"guide/SMF-Config/#smf-config-ulcl-config","title":"SMF Config / ULCL Config","text":"<p>This document explains the detail of SMF config. Also provide some examples about conversion between config file and real User Plane topology</p> <p>ULCL limitation: The branching UPF now can't connect to the Internet.  It only serves as a Intranet in the UPF topology. (Please refers to the topology of example 2)</p>"},{"location":"guide/SMF-Config/#sbi","title":"SBI","text":"Field meaning scheme The protocol for SBI registerIPv4 IP used to register to NRF bindingIPv4 IP used to bind the service port SMF bind the SBI service to this port"},{"location":"guide/SMF-Config/#pfcp","title":"PFCP","text":"Field meaning addr The IP address of N4 interface on the SMF (PFCP)"},{"location":"guide/SMF-Config/#userplane-information","title":"Userplane Information","text":"Field meaning userplane_information Includes topology and information of RAN and UPFs which are controlled by this SMF up_nodes The node in the user plane topology. Includes gNodeB, I-UPF and A-UPF links The edge in the user plane topology type Indicate it is RAN or specific kind of  UPF node_id The PFCP IPv4 address for UPF <p>Note: up_resource_ip serves as default user plane IP for the UPF. In this version, UPF will determine its user plane IP by itself. So setting up_resource_ip in SMF config won't affect real config in user plane.</p>"},{"location":"guide/SMF-Config/#amf-config","title":"AMF Config","text":"<p>To understand whole PDU session config, we must take a step forward to understand the AMF config.</p> Field meaning NGAPIPList The IP list of N2 interfaces on the AMF SBI Same meaning with SMF/SBI."},{"location":"guide/SMF-Config/#example-1","title":"Example 1","text":""},{"location":"guide/SMF-Config/#smf-config","title":"SMF Config","text":"<ul> <li>sbi:<ul> <li>scheme: http</li> <li>registerIPv4: 127.0.0.2</li> <li>bindingIPv4: 127.0.0.2</li> <li>port: 8000</li> </ul> </li> <li>pfcp:<ul> <li>addr: 10.200.200.1</li> </ul> </li> <li>userplane_information:<ul> <li>up_nodes:<ul> <li>gNB1:<ul> <li>type: AN</li> </ul> </li> <li>UPF:<ul> <li>type: UPF</li> <li>node_id: 10.200.200.102</li> </ul> </li> </ul> </li> <li>links:<ul> <li>A: gNB1</li> <li>B: UPF</li> </ul> </li> </ul> </li> </ul>"},{"location":"guide/SMF-Config/#amf-config_1","title":"AMF Config","text":"<ul> <li>ngapIpList:<ul> <li>127.0.0.1</li> </ul> </li> <li>sbi:<ul> <li>scheme: http</li> <li>registerIPv4: 127.0.0.18</li> <li>bindingIPv4: 127.0.0.18</li> <li>port: 8000</li> </ul> </li> </ul>"},{"location":"guide/SMF-Config/#representing-topology","title":"Representing Topology","text":""},{"location":"guide/SMF-Config/#example-2","title":"Example 2","text":""},{"location":"guide/SMF-Config/#smf-config_1","title":"SMF Config","text":"<ul> <li>sbi:<ul> <li>scheme: https</li> <li>registerIPv4: 127.0.0.2</li> <li>bindingIPv4: 127.0.0.2</li> <li>port: 29502</li> </ul> </li> <li>pfcp:<ul> <li>addr: 10.200.200.1</li> </ul> </li> <li>userplane_information:<ul> <li>up_nodes:<ul> <li>gNB1:<ul> <li>type: AN</li> </ul> </li> <li>BranchingUPF:<ul> <li>type: UPF</li> <li>node_id: 10.200.200.102</li> </ul> </li> <li>AnchorUPF1:<ul> <li>type: UPF</li> <li>node_id: 10.200.200.101</li> </ul> </li> <li>AnchorUPF2:<ul> <li>type: UPF</li> <li>node_id: 10.200.200.103</li> </ul> </li> <li>links:</li> <li>A: gNB1     B: BranchingUPF</li> <li>A: BranchingUPF     B: AnchorUPF1</li> <li>A: BranchingUPF     B: AnchorUPF2</li> </ul> </li> </ul> </li> </ul>"},{"location":"guide/SMF-Config/#amf-config_2","title":"AMF Config","text":"<ul> <li>ngapIpList:<ul> <li>127.0.0.1</li> </ul> </li> <li>sbi:<ul> <li>scheme: https</li> <li>registerIPv4: 127.0.0.18</li> <li>bindingIPv4: 127.0.0.18</li> <li>port: 8000</li> </ul> </li> </ul>"},{"location":"guide/SMF-Config/#representing-topology_1","title":"Representing Topology","text":""},{"location":"guide/Troubleshooting/","title":"Troubleshooting","text":""},{"location":"guide/Troubleshooting/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guide/Troubleshooting/#1-error-sctp-failed-to-connect-given-amf-n3iwfngap","title":"1. <code>ERROR: [SCTP] Failed to connect given AMF    N3IWF=NGAP</code>","text":"<p>This error occured when N3IWF was started before AMF finishing initialization. This error usually appears when you run the TestNon3GPP in the first time.</p> <p>Rerun the test should be fine. If it still not be solved, larger the sleeping time in line 110 of <code>test.sh</code>.</p>"},{"location":"guide/Troubleshooting/#2-testnon3gpp","title":"2. TestNon3GPP","text":"<p>TestNon3GPP will modify the <code>config/amfcfg.conf</code>. So, if you had killed the TestNon3GPP test before it finished, you might need to copy <code>config/amfcfg.conf.bak</code> back to <code>config/amfcfg.conf</code> to let other tests pass.</p> <p><code>cp config/amfcfg.conf.bak config/amfcfg.conf</code></p>"},{"location":"guide/Troubleshooting/#3-db-on-tls-to-h2c","title":"3. DB on TLS to H2C","text":"<p>If you meet any problems about https or mogodb, it maybe couse our new version from v3.0.1 to v3.0.2 has change http to H2C verion. Try the command below.</p> <p><code>mongo --eval \"db.NfProfile.drop()\" free5gc</code></p>"},{"location":"guide/Troubleshooting/#4-mqcreate-error-creating-message-queue-too-many-open-files-upfutil-upf","title":"4. <code>MQCreate() Error creating message queue: Too many open files UPF=Util</code> (UPF)","text":"<p>Remove POSIX message queues</p> <pre><code>ls /dev/mqueue/\nrm /dev/mqueue/*\n</code></pre>"},{"location":"guide/Troubleshooting/#5-remove-gtp-devices-using-tools-in-libgtp5gnl-upf","title":"5. Remove gtp devices (using tools in libgtp5gnl) (UPF)","text":"<pre><code>cd lib/libgtp5gnl/tools\nsudo ./gtp5g-link del {Dev-Name}\n</code></pre>"},{"location":"guide/Troubleshooting/#6-upf-cli-run-error-open-gtp5g-open-link-create-file-exists","title":"6. <code>UPF Cli Run Error: open Gtp5g: open link: create: file exists</code>","text":"<pre><code>sudo ip link del upfgtp\n</code></pre>"},{"location":"guide/Troubleshooting/#7-smf-cannot-communicate-with-upf-upf-cannot-start-after-a-reboot-or-crash","title":"7. SMF cannot communicate with UPF / UPF cannot start after a reboot or crash","text":"<p>The message below shows up on the logs:</p> <pre><code>[WARN][SMF][Main] Failed to setup an association with UPF[127.0.0.8], error:Request Transaction [1]: retry-out\n</code></pre> <p>Verify on the logs if you got this message:</p> <pre><code>[ERRO][UPF][Main] UPF Cli Run Error: open Gtp5g: open link: create: operation not supported\n</code></pre> <p>If yes, then try to load the GTP module on the system:</p> <pre><code>modprobe gtp5g\n</code></pre> <p>If this outputs an error like this:</p> <pre><code>modprobe: FATAL: Module gtp5g not found in directory /lib/modules/5.4.0-xxx-generic\n</code></pre> <p>Reinstall the GTP-U kernel module (refer to these instructions)</p> <p>Then, once running the core <code>run.sh</code> script, you should obtain the message on the logs:</p> <pre><code>[INFO][SMF][Main] Received PFCP Association Setup Accepted Response from UPF[127.0.0.8]\n</code></pre> <p>and it should work as normal</p> <p>After that, if it's required to reload the module, just run <code>modprobe gtp5g</code> again</p> <p>Note: The symptoms described above may happen if the host machine updated it's kernel version recently</p> <p>References: Free5GC Forum and Install Guide</p>"},{"location":"guide/Troubleshooting/#8-decode-http2-packet-in-wireshark","title":"8. Decode HTTP/2 packet in Wireshark","text":"<ol> <li> <p>Run Network Function</p> <p>Check has XXFsslkey.log</p> </li> <li> <p>Edit &gt;&gt; Preference &gt;&gt; Protocols &gt;&gt; SSL (TLS)</p> <p></p> </li> <li> <p>Add keylog</p> <p></p> </li> <li> <p>Filter http2</p> <p></p> </li> </ol>"},{"location":"guide/Troubleshooting/#9-decode-h2c-http2-clear-text-without-tls","title":"9. Decode H2C (HTTP2 clear text without TLS)","text":"<p>The similar reason as NEA0 NAS message. Althrough H2C is clear text, wirshark still considers these packets as the normal TCP packets and does not decode them by HTTP2.</p> <p>To see the details of H2C packets, do the following configuration.</p> <ol> <li> <p>Analyze \u2192 Decode As\u2026</p> <p></p> </li> <li> <p>click Add button to add the decode rules</p> <p></p> <p>Decode the packets from the TCP ports listened by each NF as HTTP2 packets.</p> </li> </ol>"},{"location":"guide/Troubleshooting/#10-clear-all-iptables-rules","title":"10. Clear all iptables rules","text":"<p>If something went wrong, it's possible to reset iptables' rules back using: <pre><code>sudo iptables -P INPUT ACCEPT\nsudo iptables -P FORWARD ACCEPT\nsudo iptables -P OUTPUT ACCEPT\nsudo iptables -t nat -F\nsudo iptables -t mangle -F\nsudo iptables -F\nsudo iptables -X\n</code></pre></p> <p>Then remember to add back the rules required by the free5GC.</p> <p>Note: You may consider using the <code>reload_host_config.sh</code> script for this task (see this appendix section)</p>"},{"location":"guide/Troubleshooting/#11-fix-ueransims-eap-aka-behavior","title":"11. Fix UERANSIM's EAP-AKA' behavior","text":"<p>If you face issues similar to the one reported on the forum or the message <code>SEMANTICALLY_INCORRECT_MESSAGE</code> when seting up UERANSIM's UE after configuring it to use EAP-AKA-PRIME as authentication method on Webconsole, check the solution below:</p>"},{"location":"guide/Troubleshooting/#first-method","title":"First method","text":"<p>Clone the nightly version from commit <code>85a0fbf</code>:</p> <p>Follow the cloning instructions from this guide page here</p>"},{"location":"guide/Troubleshooting/#second-method","title":"Second method","text":"<p>Update your UERANSIM installation with the fix:</p> <ol> <li> <p>Enter UERANSIM's folder (the folder where the source code is already cloned): <pre><code>cd UERANSIM\n</code></pre></p> </li> <li> <p>Move the version of your source code to the commit where the fixes were merged: <pre><code>git checkout 85a0fbf\n</code></pre></p> </li> <li> <p>Rebuild UERANSIM <pre><code>make\n</code></pre></p> </li> </ol>"},{"location":"guide/Troubleshooting/#12-n3iwue-fails-to-connect-with-erron3ueike-not-success-message","title":"12. N3IWUE fails to connect with <code>[ERRO][N3UE][IKE] Not Success</code> message","text":"<p>As per the instructions on N3IWUE install guide, the parameters of the configuration file <code>n3ue.yaml</code> must match those on free5GC's database. </p> <p>If you get log messages like those below:</p> <pre><code># on free5GC\n[WARN][AMF][Gmm][amf_ue_ngap_id:RU:6,AU:8(Non3GPP)][supi:SUPI:imsi-208930000001234] NAS MAC verification failed(received: 0xc0c0d135, expected: 0x6f1f9365)\n[ERRO][AMF][Gmm][amf_ue_ngap_id:RU:6,AU:8(Non3GPP)][supi:SUPI:imsi-208930000001234] NAS message is ciphered, but MAC verification failed\n# on N3IWUE\n[INFO][N3UE][IKE] Get EAP\n[ERRO][N3UE][IKE] Not Success\n^C4 packets captured\n4 packets received by filter\n0 packets dropped by kernel\n[FATA][N3UE][Init] panic: runtime error: invalid memory address or nil pointer dereference\n</code></pre> <p>Double check if SQN matches. If not, update it on N3IWUE's side using:</p> <pre><code>nano n3iwue/config/n3ue.yaml # adjust this path if needed\n</code></pre> <p>Refer to the <code>Security</code> section on the file:</p> <pre><code>info:\n    version: 1.0.1\n    description: Non-3GPP UE configuration\nconfiguration:\n    N3IWFInformation:\n...\n    Security:\n                K: b73a90cbcf3afb622dba83c58a8415df\n                RAND: b120f1c1a0102a2f507dd543de68281f\n                SQN: 16f3b3f71005\n                AMF: 8000\n                OP: b672047e003bb952dca6cb8af0e5b779\n                OPC: df0c67868fa25f748b7044c6e7c245b8\n</code></pre> <p>Note that SQN is dinamically updated while N3IWUE is running, so this issue might get caused by the N3IWUE being killed during the authentication phase which may cause the value to not match (e.g. it was updated on just one side).</p> <p>Once the parameters are updated, save and close the configuration file. Now N3IWUE should work correctly.</p>"},{"location":"guide/Troubleshooting/#13-unable-to-find-wpa2-eap-encryption-option-in-openwrt-installation","title":"13. Unable to find WPA2-EAP encryption option in OpenWrt installation","text":"<p>According to OpenWrt Wiki, 802.1x authentication is probably missing. This is due <code>wpad-mini</code> package not having it. To solve this, install <code>wpad</code> instead: 1. Login to AP as <code>root</code> using SSH</p> <p><pre><code>ssh root@&lt;IP&gt;\n# Example:\nssh root@192.168.1.1\n</code></pre> Tip: The default IP address is 192.168.1.1, change IP in the command above if your setup requires it. 2. Update package database</p> <p><pre><code>opkg update\n</code></pre> 3. Add WPA-EAP support</p> <p>Note: Executing the steps below will remove the support for WPA3-SAE on your AP (which may be used by other wireless networks), remember to change the affected Wi-Fi networks to WPA2-PSK</p> <p>Tip: To add WPA3 support back, install <code>wpad-openssl</code> instead of <code>wpad</code></p> <p>A. First Method</p> <p>Remove <code>wpad-mini</code> and install <code>wpad</code> <pre><code>opkg remove wpad-mini\nopkg install wpad\n</code></pre></p> <p>If the commands above fail with the messages <code>No packages removed.</code> or <code>[...] Cannot install package wpad.</code>, try the second method</p> <p>B. Second Method</p> <p>Remove <code>wpad-basic-mbedtls</code> and install <code>wpad</code> <pre><code>opkg remove wpad-basic-mbedtls\nopkg install wpad\n</code></pre> 4. Reboot the AP to make sure the new configuration was applied <pre><code>reboot\n</code></pre> References: OpenWrt Wiki and OpenWrt Github Issue #3363</p>"},{"location":"guide/Troubleshooting/#14-troubleshooting-missing-packages-when-trying-to-build-tngfue-on-ubuntu","title":"14. Troubleshooting missing packages when trying to build TNGFUE on Ubuntu","text":"<p>First, remember to update packages source before installing packages <pre><code>sudo apt update\n</code></pre></p> <p>To install all prerequisites in one line: <pre><code>sudo apt install libssl-dev libdbus-1-dev libnl-3-dev libnl-genl-3-dev libnl-route-3-dev\n</code></pre></p> <p>(Alternatively) Error messages and their related packages:</p> <ul> <li>openssl/ssl.h: No such file or directory <pre><code>sudo apt install libssl-dev\n</code></pre></li> <li>dbus/dbus.h: No such file or directory <pre><code>sudo apt install libdbus-1-dev\n</code></pre></li> <li>netlink/netlink.h: No such file or directory <pre><code>sudo apt install libnl-3-dev\n</code></pre></li> <li>/usr/bin/ld: cannot find -lnl-genl-3 <pre><code>sudo apt install libnl-genl-3-dev\n</code></pre></li> <li>/usr/bin/ld: cannot find -lnl-route-3 <pre><code>sudo apt install libnl-route-3-dev\n</code></pre></li> </ul>"},{"location":"guide/contribute/","title":"Contribute","text":""},{"location":"guide/contribute/#how-to-contribute","title":"How to contribute","text":"<p>To contribute to free5GC project, you can consider to:</p> <p>1. Raise the GitHub issue</p> <p>You can create the Issue on the free5GC repo directly. A issue could be 1. bugs report or 2. feature request, each issue would be assigned to the free5GC commiter by project owner, then assignee will solve the problem asap.</p> <p>2. Create the Patch (Pull Request)</p> <p>The source code of the free5GC is stored at https://github.com/free5gc/free5gc. Please follow the GitHub flow for collaboration.</p> <p>Note</p> <p>Our pull request commit messages must comply with the Conventional Commit Message format. This will be checked by the pull request CI action.</p> <p>3. Become a Contributor</p> <p>Once your pull request is accepted, you will be added to the contributor list in the free5GC governance.</p>"},{"location":"guide/contribute/#recommended-articles","title":"Recommended Articles","text":"<ul> <li>How to Contribute to Open Source</li> </ul>"},{"location":"guide/contribute/#development-skills","title":"Development Skills","text":"<ul> <li>Golang<ul> <li>A tour of go</li> <li>https://github.com/uber-go/guide</li> </ul> </li> <li>Version Control<ul> <li>https://git-scm.com/</li> <li>https://docs.github.com/en/get-started/using-github/github-flow</li> </ul> </li> </ul>"},{"location":"guide/features/","title":"Features","text":""},{"location":"guide/features/#free5gc-specification","title":"free5GC Specification","text":"<ul> <li>3GPP TS 23.501/23.502-Rel-15 (<code>main</code> branch)</li> <li>3GPP TS 23.501/23.502-Rel-17 (<code>next</code> branch)</li> <li>5G Standalone (SA) supported</li> <li>Serviced-Based Interface (SBI) supported<ul> <li>Namf, Nsmf, Nausf, Nudm, Nudr, Nnssf, Nnrf, Npcf, Nchf, Nnef</li> </ul> </li> <li>N1, N2, N3, N4, N6, N9, interfaces supported</li> <li>5G SA Network Functions supported:<ul> <li>AMF: Access and Mobility Management Function<ul> <li>Registration Management, Connection Management, Reachability Management, Mobility Management, and Authentication</li> </ul> </li> <li>SMF: Session Management Function<ul> <li>Session Management, IP Assigning/Management</li> </ul> </li> <li>UPF: User Plane Function<ul> <li>Support multiple UPF and ULCL (uplink classifier)</li> <li>Session and Service Continuity (SSC) mode 1</li> <li>Packet Routing/Forwarding</li> </ul> </li> <li>CHF: Charging Function<ul> <li>Online/Offline Charging</li> <li>Webconsole acts as BD (Billing Domain)</li> <li>Flow-Based Charging on PDU Session</li> </ul> </li> <li>AUSF: Authentication Server Function</li> <li>NRF: NF Repository Function</li> <li>UDM: Unified Data Management</li> <li>UDR: Unified Data Repository</li> <li>PCF: Policy and Charging Function</li> <li>NSSF: Network Slice Selection Function</li> <li>N3IWF: Non-3GPP Interworking Function</li> <li>N3IWUE: Non-3GPP Interworking User Equipment</li> <li>TNGF: Trusted Non-3GPP Gateway Function</li> <li>TNGFUE: Trusted Non-3GPP Gateway Function User Equipment</li> <li>NEF: Network Exposure Function (v3.4.4)</li> </ul> </li> </ul>"},{"location":"guide/features/#supported-features","title":"Supported features","text":"<ul> <li>Registration<ul> <li>Initial Registration</li> <li>Periodic Registration</li> <li>Mobility Registration</li> <li>Registration without authentication, due to RAN did the AMF reselection</li> </ul> </li> <li>NAS Reroute when serving AMF can not handle UE registration with unmatch NSSAI</li> <li>Authentication<ul> <li>5G-AKA</li> <li>EAP-AKA'</li> </ul> </li> <li>NAS Security<ul> <li>Ciphering: NEA0, NEA1, NEA2, NEA3</li> <li>Integrity: NIA0, NIA1, NIA2, NIA3</li> </ul> </li> <li>Deregistration:<ul> <li>UE-initiated Deregistration</li> </ul> </li> <li>Service Request:<ul> <li>UE triggered Service Request</li> <li>Network Triggered Service Request</li> </ul> </li> <li>AN Release</li> <li>PDU Session Establishment</li> <li>PDU Session Modification (v3.3.0)</li> <li>Converged Charging<ul> <li>Billing Domain (webconsole)</li> <li>ABMF, RF, and CGF built-in CHF</li> <li>Flow-based Charging (FBC)</li> </ul> </li> <li>PDU Session Release</li> <li>Handover<ul> <li>N2 Handover (Indirect mode not supported)</li> <li>Xn Handover</li> </ul> </li> <li>QoS<ul> <li>Control Plane only:<ol> <li>5QI, ARP, GBR, MBR of QoS Flow (v3.3.0)</li> <li>Session-AMBR supported</li> </ol> </li> </ul> </li> <li>Collection and reporting of usage data over N4 interface<ul> <li>Volume measurement periodically</li> </ul> </li> <li>UP Security</li> <li>Multiple UPFs and ULCL (Uplink Classifier)</li> <li>Multiple Slice and DNN</li> <li>Dynamic/Static IPv4 address allocation</li> <li>OAuth2 on SBI <ul> <li>Design Document</li> </ul> </li> <li>Traffic Influence (v3.4.4)</li> </ul>"},{"location":"guide/hardware/","title":"Hardware","text":""},{"location":"guide/hardware/#tested-hardware","title":"Tested Hardware","text":"<p>Some 5G UE and gNodeB hardware have been tested with free5GC by partners or community members:</p> <ul> <li> <p>5G UE (Support 5G SA):</p> <ul> <li>APAL 5G Dongle</li> <li>APAL 5G MiFi</li> <li>Samsung S21 5G</li> <li>Huawei P40 5G (forum link)</li> <li>Huawei Mate30 5G (forum link)</li> <li>iPhone13 mini (test link written in japanese)</li> </ul> </li> <li> <p>gNodeB:</p> <ul> <li>Alpha gNodeB</li> <li>Compal gNodeB</li> <li>FII gNodeB</li> <li>ITRI gNodeB</li> <li>Lions gNodeB</li> <li>Amarisoft gNodeB (forum link)</li> <li>Nokia gNodeB (forum link)</li> <li>Nokia (AMIA AirScale Indoor Subrack 473098A)</li> <li>OpenAirInterface</li> <li>Open Source RAN Project - srsRAN</li> </ul> </li> </ul> <p>Reports of tested hardware not listed above on Github issue or free5GC forum are welcome.</p> <p>PS: if you don't have any hardware available, we suggest to use UERANSIM to simulate.</p> <p>(Refer to Advanced environment setup section)</p>"},{"location":"guide/n3iwue-installation/","title":"N3iwue installation","text":""},{"location":"guide/n3iwue-installation/#installing-n3iwue","title":"Installing N3IWUE","text":"<p>In this demo we will practice:</p> <ul> <li>Installing N3IWUE</li> <li>Configuring free5GC and N3IWUE</li> <li>Running N3IWUE to connect free5GC</li> </ul>"},{"location":"guide/n3iwue-installation/#1-install-n3iwue-vm","title":"1. Install N3IWUE VM","text":"<p>Repeat the steps of cloning <code>free5gc</code> VM from the base VM, create a new VM for the N3IWUE:</p> <ul> <li>You can refer to Installing free5gc to install free5gc VM.</li> <li>Name the VM <code>N3IWUE</code>, and create new MAC addresses for all network cards.</li> <li>Make sure the VM has internet access and can log in using SSH.</li> <li>Change the hostname to <code>N3IWUE</code>.</li> <li>Make the Host-only network interface have static IP address <code>192.168.56.103</code>.</li> <li>Reboot the N3IWUE VM, as well as the free5gc VM.</li> <li>You can ping <code>192.168.56.101</code> from the N3IWUE VM, and also <code>ping 192.168.56.103</code> from the free5gc VM.</li> </ul>"},{"location":"guide/n3iwue-installation/#2-install-n3iwue","title":"2. Install N3IWUE","text":"<p>Go to N3IWUE GitHub Repo.</p> <p>To download N3IWUE in home directory:</p> <pre><code>cd ~\ngit clone https://github.com/free5gc/n3iwue.git\ncd n3iwue\n</code></pre> <p>Update and upgrade the VM of N3IWUE:</p> <pre><code>sudo apt update\nsudo apt upgrade\n</code></pre> <p>Install required tools:</p> <pre><code>sudo apt install make\nsudo apt install libsctp-dev lksctp-tools\nsudo apt install iproute2\n</code></pre> <p>Install Golang (use <code>1.21.6</code> version in this demonstrate):</p> <pre><code>wget https://dl.google.com/go/go1.21.6.linux-amd64.tar.gz\nsudo tar -C /usr/local -zxvf go1.21.6.linux-amd64.tar.gz\nmkdir -p ~/go/{bin,pkg,src}\necho 'export GOPATH=$HOME/go' &gt;&gt; ~/.bashrc\necho 'export GOROOT=/usr/local/go' &gt;&gt; ~/.bashrc\necho 'export PATH=$PATH:$GOPATH/bin:$GOROOT/bin' &gt;&gt; ~/.bashrc\necho 'export GO111MODULE=auto' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n\n# check your go installation\ngo version\n</code></pre> <p>Build N3IWUE</p> <pre><code>cd ~/n3iwue\nmake\n</code></pre>"},{"location":"guide/n3iwue-installation/#3-use-webconsole-to-add-ue","title":"3. Use WebConsole to Add UE","text":"<p>Open your web browser from your host machine, and enter the URL <code>http://192.168.56.101:5000</code></p> <ul> <li>On the login page, enter username <code>admin</code> and password <code>free5gc</code>.</li> <li>Once logged in, widen the page until you see \u201cSubscribers\u201d on the left-hand side column.</li> <li>Click on the <code>Subscribers</code> tab and then on the <code>New Subscriber</code> button</li> <li>Scroll down to <code>Operator Code Type</code> and change it from \"OPc\" to \"OP\".</li> <li>Make sure the following config between <code>n3iwue/config/n3ue.yaml</code> and the <code>Subscriber</code> you are creating are the same:<ul> <li>SUPI(IMSI) (ex. 208930000001234)</li> <li>K</li> <li>SQN</li> <li>OP value (Operator Code Value)</li> </ul> </li> <li>Scroll the page all the way down and click on <code>Create</code>.</li> </ul>"},{"location":"guide/n3iwue-installation/#4-setting-n3iwf-config","title":"4. Setting N3IWF Config","text":"<p>In free5gc VM, we need to edit N3IWF config file <code>~/free5gc/config/n3iwfcfg.yaml</code></p> <p>Replace IKEBindAddress from <code>172.16.2.100</code> to <code>192.168.56.101</code>, namely from:</p> <pre><code>  IKEBindAddress: 172.16.2.100 # Nwu interface  IP address (IKE) on this N3IWF\n</code></pre> <p>into:</p> <pre><code>  IKEBindAddress: 192.168.56.101 # Nwu interface  IP address (IKE) on this N3IWF\n</code></pre>"},{"location":"guide/n3iwue-installation/#5-setting-n3iwue","title":"5. Setting N3IWUE","text":"<p>To let N3IWUE knows where is the N3IWF is, we need to edit the UE config file <code>~/n3iwue/config/n3ue.yaml</code> in N3IWUE VM</p> <p>Replace these parameters:</p> <pre><code>N3IWFInformation:\n  IPSecIfaceAddr: 10.0.1.1 # IP address of Nwu interface (IKE) on N3IWF\n\nN3UEInformation:\n  IPSecIfaceName: ens38 # Name of Nwu interface (IKE) on this N3UE\n  IPSecIfaceAddr: 10.0.1.4 # IP address of Nwu interface (IKE) on this N3UE\n</code></pre> <p>into:</p> <pre><code>N3IWFInformation:\n  IPSecIfaceAddr: 192.168.56.101 # IP address of Nwu interface (IKE) on N3IWF\n\nN3UEInformation:\n  IPSecIfaceName: enp0s8 # Name of Nwu interface (IKE) on this N3UE (your interface name)\n  IPSecIfaceAddr: 192.168.56.103 # IP address of Nwu interface (IKE) on this N3UE\n</code></pre>"},{"location":"guide/n3iwue-installation/#6-testing-n3iwue-with-free5gc","title":"6. Testing N3IWUE with free5GC","text":"<p>SSH into free5gc. If you have rebooted free5gc, remember to run:</p> <pre><code>cd free5gc\nsudo ./reload_host_config.sh &lt;Interface Name&gt;\n\neg: sudo ./reload_host_config.sh ens18\n</code></pre> <p>Tip: Set <code>net.ipv4.ip_forward=1</code> in <code>/etc/sysctl.conf</code> to enable packet forwarding permanently</p> <p>In free5gc VM:</p> <pre><code>cd ~/free5gc\n./run.sh -n3iwf\n</code></pre> <p>In N3IWUE VM:</p> <pre><code>cd ~/n3iwue\n./run.sh\n</code></pre>"},{"location":"guide/n3iwue-installation/#7-result","title":"7. Result","text":"<p>Success: N3IWUE can ping data network through N3IWF </p>"},{"location":"guide/n3iwue-installation/#appendix","title":"Appendix","text":"<ul> <li>Design Document</li> </ul>"},{"location":"guide/Charging/setting/","title":"Setup Charing for UE","text":"<p>In this demo, we will practice:</p> <ul> <li>Set Slice-level and Flow-level Online charging in webconsole.</li> <li>Set Slice-level and Flow-level Offline charging in webconsole.</li> <li>Test with UERANSIM </li> </ul> <p>Notice: The charging function was released in free5GC v3.4.1.</p>"},{"location":"guide/Charging/setting/#0-preface","title":"0. Preface","text":"<ul> <li>free5GC provides Converge Charging, which includes Online and Offline.  </li> <li>Support Slice-level and Flow-level Charging.</li> <li>Offline<ul> <li>After network resource usage, charging information is transmitted from the network to the Billing Domain (BD).</li> </ul> </li> <li>Online<ul> <li>Before network resource usage, the network sends an authentication request to the Online Charging System (OCS) and gets quota.</li> </ul> </li> </ul>"},{"location":"guide/Charging/setting/#1-create-subscriber","title":"1. Create Subscriber","text":"<ul> <li> <p>The basic setting for subscribers will be ignored in this article; you can refer to this if you needed. </p> </li> <li> <p>The default would create two slices, 01010203 and 01112233.</p> </li> <li> <p>Click Create.</p> </li> </ul>"},{"location":"guide/Charging/setting/#01010203","title":"01010203","text":"<ul> <li> <p>We could change the charging Method from Offline to Online if you needed. </p> <p></p> </li> <li> <p>We keep using Offline for now.</p> </li> <li> <p>By default, there would be one flow rule to 1.1.1.1/32.</p> <p></p> </li> <li> <p>Remember to use the same Charing Method as slice-level charing. </p> </li> <li> <p>For now, we will keep it Offline. </p> </li> </ul>"},{"location":"guide/Charging/setting/#01112233","title":"01112233","text":"<ul> <li> <p>We use Online Charging for this slice.</p> </li> <li> <p>Create flow rules.</p> <ul> <li>Remember to use the same charging method as Slice-level.</li> </ul> <p></p> </li> </ul>"},{"location":"guide/Charging/setting/#2-check-charging-data-in-webconsole","title":"2. Check Charging Data in Webconsole","text":"<ul> <li> <p>Click UE CHARGING in webconsole sidebar</p> <p></p> </li> <li> <p>We would see the Charging Data we set in Step 1. </p> <ul> <li>Expand</li> </ul> <p></p> <ul> <li>Fold</li> </ul> <p></p> </li> </ul> <p>\u200b    </p> <p>\u200b       </p>"},{"location":"guide/Charging/setting/#3-test-with-ueransim","title":"3. Test with UERANSIM","text":"<ul> <li> <p>Refer to this to set up your environment.</p> </li> <li> <p>Provide <code>free5gc-ue.yaml</code> I use for your reference.</p> <pre><code># IMSI number of the UE. IMSI = [MCC|MNC|MSISDN] (In total 15 digits)\nsupi: 'imsi-208930000000001'\n# Mobile Country Code value of HPLMN\nmcc: '208'\n# Mobile Network Code value of HPLMN (2 or 3 digits)\nmnc: '93'\n# SUCI Protection Scheme : 0 for Null-scheme, 1 for Profile A and 2 for Profile B\nprotectionScheme: 0\n# Home Network Public Key for protecting with SUCI Profile A\nhomeNetworkPublicKey: '5a8d38864820197c3394b92613b20b91633cbd897119273bf8e4a6f4eec0a650'\n# Home Network Public Key ID for protecting with SUCI Profile A\nhomeNetworkPublicKeyId: 1\n# Routing Indicator\nroutingIndicator: '0000'\n\n# Permanent subscription key\nkey: '8baf473f2f8fd09487cccbd7097c6862'\n# Operator code (OP or OPC) of the UE\nop: '8e27b6af0e692e750f32667a3b14605d'\n# This value specifies the OP type and it can be either 'OP' or 'OPC'\nopType: 'OPC'\n# Authentication Management Field (AMF) value\namf: '8000'\n# IMEI number of the device. It is used if no SUPI is provided\nimei: '356938035643803'\n# IMEISV number of the device. It is used if no SUPI and IMEI is provided\nimeiSv: '4370816125816151'\n\n# List of gNB IP addresses for Radio Link Simulation\ngnbSearchList:\n  - 127.0.0.1\n\n# UAC Access Identities Configuration\nuacAic:\n  mps: false\n  mcs: false\n\n# UAC Access Control Class\nuacAcc:\n  normalClass: 0\n  class11: false\n  class12: false\n  class13: false\n  class14: false\n  class15: false\n\n# Initial PDU sessions to be established\nsessions:\n  - type: 'IPv4'\n    apn: 'internet'\n    slice:\n      sst: 0x01\n      sd: 0x010203\n  - type: 'IPv4'\n    apn: 'internet'\n    slice:\n      sst: 0x01\n      sd: 0x112233\n\n# Configured NSSAI for this UE by HPLMN\nconfigured-nssai:\n  - sst: 0x01\n    sd: 0x010203\n  - sst: 0x01\n    sd: 0x112233\n\n# Default Configured NSSAI for this UE\ndefault-nssai:\n  - sst: 1\n    sd: 1\n\n# Supported integrity algorithms by this UE\nintegrity:\n  IA1: true\n  IA2: true\n  IA3: true\n\n# Supported encryption algorithms by this UE\nciphering:\n  EA0: true\n  EA1: true\n  EA2: true\n  EA3: true\n\n# Integrity protection maximum data rate for user plane\nintegrityMaxRate:\n  uplink: 'full'\n  downlink: 'full'\n</code></pre> </li> <li> <p>If you set it up successfully, you will see the UERANSIM create two tunnels, <code>uesimtun0</code>, and <code>uesimtun1</code>.</p> </li> <li> <p>The following is a Demo GIF for Charing</p> <p></p> </li> <li> <p>Result</p> <p></p> </li> <li> <p>You can try it out for the Charing Functionality now!</p> </li> </ul>"},{"location":"guide/Charging/setting/#appendix","title":"Appendix","text":"<ul> <li>CHF Design Document</li> <li>CHarging Function(CHF) Overview</li> </ul>"},{"location":"guide/Static-IP/set-static-ip/","title":"Set Static IP for UE","text":"<p>In this demo, we will practice:</p> <ul> <li>Static IP Pool settings</li> <li>Set Static IP address for UE in webconsole</li> <li>Verify the IP address settings</li> </ul>"},{"location":"guide/Static-IP/set-static-ip/#1-static-ip-pool-settings","title":"1. Static IP pool settings","text":"<p>We first have to know the static IP pool for specific DNN. </p> <ul> <li>In <code>smfcfg.yaml</code>, the userplaneInformation is what we need now:<ul> <li>The following files remove some settings; please refer to the sample configuration file.</li> <li>We set two slices with one DNN each for this demo:<ul> <li>01010203<ul> <li>internet<ul> <li>pools: 10.60.0.0/16</li> <li>staticPools: 10.60.100.0/24</li> </ul> </li> </ul> </li> <li>01112233<ul> <li>internet<ul> <li>pools: 10.61.0.0/16</li> <li>staticPools: 10.61.100.0/24</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> <pre><code>configuration:\n  userplaneInformation:         # list of userplane information\n    upNodes:                     # information of user-plane node (AN or UPF)\n      UPF:                       # the name of the node\n        type: UPF                # the type of the node (AN or UPF)\n        sNssaiUpfInfos:          # S-NSSAI information list for this UPF\n          - sNssai:              # S-NSSAI(Single Network Slice Selection Assistance Information)\n              sst: 1             # Slice/Service Type (uinteger, range: 0~255)\n              sd: 010203         # Slice Differentiator(3 bytes hex string, range: 000000~FFFFFF)\n            dnnUpfInfoList:      # DNN information list for this S-NSSAI\n              - dnn: internet\n                pools:\n                  - cidr: 10.60.0.0/16\n                staticPools:\n                  - cidr: 10.60.100.0/24\n          - sNssai:\n              sst: 1\n              sd: 112233\n            dnnUpfInfoList:\n              - dnn: internet\n                pools:\n                  - cidr: 10.61.0.0/16\n                staticPools:\n                  - cidr: 10.61.100.0/24\n</code></pre>"},{"location":"guide/Static-IP/set-static-ip/#2-create-subscribers-with-static-ip","title":"2. Create Subscribers with Static-IP","text":"<p>In this step, we would go through how to set static IP addresses for subscribers and verify the settings. </p> <ul> <li>You could also refer to this for how to create subscribers.</li> <li>We would create two subscribers:<ul> <li>imsi-208930000000001</li> <li>imsi-208930000000002</li> <li>Both have slices 010203 and 112233, but have different IP address settings.</li> </ul> </li> </ul>"},{"location":"guide/Static-IP/set-static-ip/#imsi-208930000000001","title":"imsi-208930000000001","text":"<ul> <li> <p>010203 </p> <ul> <li>A Static IPv4 Address toggle under the slices' DNN section would be displayed. </li> </ul> <p></p> <ul> <li> <p>Turn it one, and set the IPv4 address you want to use for this UE of this DNN.</p> <ul> <li> <p>We set 10.60.100.163</p> <p></p> </li> <li> <p>Click Verify</p> <ul> <li>If the setting is OK, the webconsole will show \"OK\" in an alert box.</li> </ul> <p></p> </li> </ul> </li> </ul> </li> <li> <p>112233 </p> <ul> <li> <p>Set the IPv4 address you want for this UE of this DNN.</p> <ul> <li> <p>We set 10.60.100.150</p> <ul> <li>Note that 10.60.100.150 is not in 10.61.100.0/24 (The Static-IP pool for this DNN)</li> </ul> <p></p> </li> <li> <p>Click Verify</p> <ul> <li>Since the IP address is not in the Static-IP pool for this DNN, it would pop up \"No\" with the reason.</li> </ul> <p></p> </li> <li> <p>Correct the IP and Verify again: 10.61.100.150</p> <p></p> </li> </ul> </li> </ul> </li> </ul>"},{"location":"guide/Static-IP/set-static-ip/#imsi-208930000000002","title":"imsi-208930000000002","text":"<ul> <li> <p>010203 </p> <ul> <li> <p>Set 10.60.100.163 for this DNN and click Verify.</p> <ul> <li>Note that 10.60.100.163 was set to another UE</li> </ul> <p> - Change to  10.60.100.165</p> </li> </ul> </li> <li> <p>112233 </p> <ul> <li>Keep the Static IPv4 Address toggle off, as Dynamic IPv4 address for this DNN.</li> </ul> </li> </ul>"},{"location":"guide/Static-IP/set-static-ip/#test-with-ueransim","title":"Test with UERANSIM","text":"<ul> <li>You can refer to this for instructions on how to use UERANSIM.</li> </ul>"},{"location":"guide/Static-IP/set-static-ip/#imsi-208930000000001_1","title":"imsi-208930000000001","text":"<ul> <li>This UE gets 10.60.100.163 for slice 010203, which is what we assigned before.</li> <li>This UE gets 10.61.100.165 for slice 112233, which is what we assigned before</li> </ul>"},{"location":"guide/Static-IP/set-static-ip/#imsi-208930000000002_1","title":"imsi-208930000000002","text":"<ul> <li>This UE gets 10.60.100.165 for slice 010203, which is what we assigned before</li> <li>This UE gets 10.61.0.1 for slice 112233, the IP address in pools assigned by SMF.</li> </ul>"},{"location":"guide/TNGF/tngfue-installation/","title":"Tngfue installation","text":""},{"location":"guide/TNGF/tngfue-installation/#1-free5gc-installation","title":"1. free5GC installation","text":"<p>(Optional) If you install free5GC on a VM, add a network adapter set to bridged mode, and set the card name to your AP. Some additional information on how to configure multiple network interfaces on the VM are available on the docs and on Ubuntu docs page.</p>"},{"location":"guide/TNGF/tngfue-installation/#follow-the-tutorial-in-free5gc-official-site","title":"Follow the tutorial in free5GC official site:","text":"<ul> <li>Installing free5GC and webconsole</li> </ul>"},{"location":"guide/TNGF/tngfue-installation/#configuration-for-nfs","title":"Configuration for NFs","text":"<p>Modify <code>~/free5gc/config/tngfcfg.yaml</code> file <pre><code># --- Bind Interfaces ---\nIKEBindAddress: &lt;YOUR_FREE5GC_IP&gt; # IP address of Nwu interface (IKE) on this TNGF\nRadiusBindAddress: &lt;YOUR_FREE5GC_IP&gt; # IP address of Nwu interface (IKE) on this TNGF\n</code></pre></p>"},{"location":"guide/TNGF/tngfue-installation/#2-use-webconsole-to-add-ue","title":"2. Use WebConsole to Add UE","text":"<ul> <li>Start your webconsole server <pre><code>cd ~/free5gc/webconsole/\nmake # If webconsole was not previously compiled\n./bin/webconsole\n</code></pre></li> <li>Open your web browser from your host machine, and enter the URL <code>http://&lt;FREE5GC_IP&gt;:5000</code></li> <li>On the login page, enter username <code>admin</code> and password <code>free5gc</code></li> <li>Go to <code>SUBSCRIBERS</code> and click on <code>CREATE</code></li> <li>Check that the <code>SUPI (IMSI)</code> field is unique and modify other fields as necessary to ensure data consistency with sec.conf file </li> <li>Then, scroll the page all the way down and click on <code>CREATE</code>.</li> </ul>"},{"location":"guide/TNGF/tngfue-installation/#3-access-point-setup","title":"3. Access Point Setup","text":"<p>Follow Section 3.1 to set up an Access Point using OpenWRT firmware or, alternatively,  Section 3.2 to build an AP on Ubuntu 22.04 using the hostapd daemon.</p>"},{"location":"guide/TNGF/tngfue-installation/#31-openwrt","title":"3.1 OpenWRT","text":"<p>Note: The steps of this section were tested using OpenWrt as AP firmware (see screenshot below)</p>"},{"location":"guide/TNGF/tngfue-installation/#ap-information","title":"AP information","text":""},{"location":"guide/TNGF/tngfue-installation/#configuring-wi-fi-network-essid","title":"Configuring Wi-Fi Network ESSID","text":"<p>Network \u2192 Wireless \u2192 Edit \u2192 Interface Configuration \u2192 General Setup </p>"},{"location":"guide/TNGF/tngfue-installation/#configuring-wi-fi-network-security","title":"Configuring Wi-Fi Network Security","text":"<p>Interface Configuration \u2192 Wireless Security </p> <p>Note: <code>RADIUS Authentication Server</code> is free5GC's IP. <code>RADIUS Authentication Secret</code> must match the one from <code>RadiusSecret</code> parameter on tngfcfg.yaml file</p> <p>Tip: If WPA2-EAP isn't available on the OpenWrt firmware installed, check this troubleshooting section.</p>"},{"location":"guide/TNGF/tngfue-installation/#32-hostapd-cli","title":"3.2 Hostapd (CLI)","text":"<p>Note: This section explains how to use hostapd to set up an access point. Hostapd is an open-source daemon that can be used on Linux systems (like Ubuntu) to build a DIY alternative to OpenWRT.</p> <p>To install hostapd on Ubuntu 22.04 (it requires a Wi-Fi interface available): <pre><code>sudo apt install hostapd\n</code></pre></p> <p>Write a new config file for hostapd: <pre><code>sudo nano /etc/hostapd/hostapd.conf\n</code></pre></p> <p>Paste the following content into it:  <pre><code>interface=wlan0\ndriver=nl80211\nssid=free5gc-ap\nhw_mode=g\nchannel=6\nieee8021x=1\nauth_algs=1\nwpa=2\nwpa_key_mgmt=WPA-EAP\nrsn_pairwise=CCMP\n\n# RADIUS config\nauth_server_addr=192.168.1.102\nauth_server_port=1812\nauth_server_shared_secret=free5gctngf\n\nnas_identifier=myhostapd\n</code></pre> Note 1: Ensure that <code>auth_server_addr</code> and <code>auth_server_shared_secret</code> must match <code>RadiusBindAddress</code> and <code>RadiusSecret</code> parameters on tngfcfg.yaml file.</p> <p>Note 2: Ensure that <code>interface</code> matches the name of the WiFi interface of your device.</p> <p>Start the hostapd service: <pre><code>sudo systemctl unmask hostapd\nsudo systemctl enable --now hostapd\n</code></pre></p>"},{"location":"guide/TNGF/tngfue-installation/#4-tngfue-installation","title":"4. TNGFUE Installation","text":"<p>Install TNGFUE in another device with a Wi-Fi interface available</p>"},{"location":"guide/TNGF/tngfue-installation/#get-source-code","title":"Get Source Code","text":"<pre><code>git clone https://github.com/free5gc/tngfue.git\ncd tngfue\n</code></pre>"},{"location":"guide/TNGF/tngfue-installation/#tngfue-configuration","title":"TNGFUE Configuration","text":""},{"location":"guide/TNGF/tngfue-installation/#a-automated-setup","title":"A. Automated Setup","text":"<p>Use the <code>prepare</code> script:</p> <p>(Optional) Open the script and adjust it with the desired parameters/vars <pre><code>nano prepare.sh\n</code></pre></p> <p>Note: Confirm the Wi-Fi interface name (i.e. <code>IFACE_NAME</code>) is the same as the OS name</p> <p>Run the script to begin building TNGFUE <pre><code>./prepare.sh\n</code></pre></p>"},{"location":"guide/TNGF/tngfue-installation/#b-advanced-manual-setup","title":"B. Advanced Manual Setup","text":"<p>(Alternatively) To configure and build manually:</p> <p>Note: The <code>prepare</code> script executed the steps below, you may skip to the next section</p>"},{"location":"guide/TNGF/tngfue-installation/#buildcompile-configuration","title":"Build/Compile Configuration","text":"<p>Make sure the flag <code>CONFIG_EAP_VENDOR_TEST</code> of the <code>.config</code> file inside <code>wpa_supplicant</code> folder is enabled as shown below: <pre><code>...\nCONFIG_EAP_VENDOR_TEST=y\n...\n</code></pre> Tip: This setting is already enabled</p>"},{"location":"guide/TNGF/tngfue-installation/#tngfue-settings","title":"TNGFUE Settings","text":"<p>Modify <code>~/tngfue/wpa_supplicant.conf</code></p> <ul> <li><code>ssid:</code> your ap/wifi name  (same as the AP setting part)</li> <li><code>identity:</code> identity information for this ue  (set whatever you want)</li> <li><code>password:</code> wifi/ap password (same as the AP setting part)</li> </ul> <pre><code>ctrl_interface=udp\nupdate_config=1\nnetwork={\n    ssid=\"&lt;YOUR_AP_NAME&gt;\"\n    key_mgmt=WPA-EAP\n    eap=VENDOR-TEST IKEV2\n    identity=\"&lt;YOUR_IDENTITY_INFO&gt;\"\n    password=\"&lt;YOUR_PASSWORD&gt;\"\n}\n</code></pre> <p>E.g. <pre><code>ctrl_interface=udp\nupdate_config=1\nnetwork={\n    ssid=\"free5gc-ap\"\n    key_mgmt=WPA-EAP\n    eap=VENDOR-TEST IKEV2\n    identity=\"tngfue\"\n    password=\"free5gctngf\"\n}\n</code></pre></p>"},{"location":"guide/TNGF/tngfue-installation/#security-parameters","title":"Security Parameters","text":"<p>In <code>tngfue/wpa_supplicant/sec.conf</code>:</p> <ul> <li><code>wifiifname:</code> your wifi interface name  (you can find this by typing <code>ifconfig</code> in terminal)</li> </ul> <p>You can find all the parameters listed below on the Web Console subscriber page.</p> <ul> <li><code>imsi_identity:</code> SUPI(IMSI)</li> <li><code>MSIN:</code> SUPI without the PLMN part</li> </ul> <p>Format:  <pre><code>wifiifname: &lt;YOUR_WIFI_INTERFACE_NAME&gt;\nK:&lt;UE_K_IN_WEBCONSOLE&gt;\nimsi_identity:&lt;UE_SUPI_IN_WEBCONSOLE&gt;\nnai_username:type0.rid61695.schid0.userid&lt;MSIN&gt;\nSQN:&lt;UE_SQN_IN_WEBCONSOLE&gt;\nAMF:&lt;AMF_IN_WEBCONSOLE&gt;\nOPC:&lt;UE_OPCV_IN_WEBCONSOLE&gt;\n</code></pre></p> <p>E.g. <pre><code>wifiifname:wlp3s0\nK:8baf473f2f8fd09487cccbd7097c6862\nimsi_identity:208930000000007\nnai_username:type0.rid61695.schid0.userid000000000007\nSQN:16f3b3f70fe1\nAMF:8000\nOPC:8e27b6af0e692e750f32667a3b14605d\n</code></pre></p>"},{"location":"guide/TNGF/tngfue-installation/#build-binary","title":"Build binary","text":"<p><pre><code>cd ~/tngfue/wpa_supplicant/\nmake\n</code></pre> For more information, see this troubleshooting section</p>"},{"location":"guide/TNGF/tngfue-installation/#5-testing","title":"5. Testing","text":""},{"location":"guide/TNGF/tngfue-installation/#a-run-free5gc-with-tngf","title":"A. Run free5GC with TNGF","text":"<p>On free5GC's machine: <pre><code>cd ~/free5gc\n./run.sh -tngf\n</code></pre></p>"},{"location":"guide/TNGF/tngfue-installation/#b-run-tngfue","title":"B. Run TNGFUE","text":"<p>On TNGFUE's machine:</p>"},{"location":"guide/TNGF/tngfue-installation/#run-using-the-run-script","title":"Run using the <code>run</code> script","text":"<p><pre><code>./run.sh\n</code></pre> Then skip to the next section</p>"},{"location":"guide/TNGF/tngfue-installation/#alternatively-run-manually","title":"(Alternatively) Run manually","text":""},{"location":"guide/TNGF/tngfue-installation/#make-sure-xfrm-and-gretun0-does-not-exist","title":"Make sure xfrm and greTun0 does not exist","text":"<p>If you have not successfully connected to TNGF yet, you can skip this step</p> <p>Delete both interfaces using: <pre><code>sudo ip l del greTun0\nsudo ip l del xfrm-1\n</code></pre></p>"},{"location":"guide/TNGF/tngfue-installation/#set-wi-fi-interface-ip-to-the-same-lan-as-free5gc","title":"Set Wi-Fi interface IP to the same LAN as free5GC","text":"<pre><code>ip a add 192.168.1.202/24 brd 192.168.1.255 dev &lt;YOUR_WIFI_INTERFACE_NAME&gt;\nip r add default via 192.168.1.202 dev &lt;YOUR_WIFI_INTERFACE_NAME&gt;\n</code></pre>"},{"location":"guide/TNGF/tngfue-installation/#run","title":"Run","text":"<pre><code>cd ~/tngfue/wpa_supplicant\nsudo ./wpa_supplicant -c ../wpa_supplicant.conf -i &lt;YOUR_WIFI_INTERFACE_NAME&gt;\n</code></pre>"},{"location":"guide/TNGF/tngfue-installation/#example-output","title":"Example output","text":"<p>When the session successfully connects, it will be possible to see these five interfaces established.  </p> <p>And TNGFUE will show that connection is completed. </p>"},{"location":"guide/TNGF/tngfue-installation/#c-transfer-data-over-the-gretun0-interface","title":"C. Transfer data over the greTun0 interface","text":"<p><pre><code>ping -I greTun0 8.8.8.8\n</code></pre> </p>"},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/","title":"Create Subscriber via webconsole","text":""},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/#create-subscriber-via-webconsole","title":"Create Subscriber via Webconsole","text":""},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/#1-install-webconsole","title":"1. Install Webconsole","text":"<p>If Webconsole isn't installed yet, please, follow the instructions from GitHub page.</p>"},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/#2-optional-delete-mongodb-database","title":"2. (Optional) Delete MongoDB database","text":"<p>If another version of free5GC was ran before, you have to delete MongoDB. <pre><code>$ mongo --eval \"db.dropDatabase()\" free5gc\n</code></pre></p>"},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/#3-run-webconsole-server","title":"3. Run Webconsole server","text":"<pre><code>$ cd ~/free5gc/webconsole\n$ go run server.go\n</code></pre>"},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/#4-open-webconsole","title":"4. Open Webconsole","text":"<p>Enter URL: <code>&lt;Webconsole server's IP&gt;:5000</code> in browser</p> <p></p> <p>Default credential: <pre><code>Username: admin\nPassword: free5gc\n</code></pre></p>"},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/#5-add-new-subscriber","title":"5. Add new subscriber","text":"<p>There are two options to add a new subscriber:</p> <ul> <li>Directly create subscriber in create subscriber page</li> <li>Create profile first, then create subscriber with the profile</li> </ul>"},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/#51-directly-create-subscriber-in-create-subscriber-page","title":"5.1. Directly create subscriber in create subscriber page","text":"<p>Click <code>SUBSCRIBERS</code> -&gt; <code>CREATE</code></p> <p></p> <p>Edit the Subscriber's data and click <code>CREATE</code>, here you can configure the </p> <ul> <li>Network Slicing Configuration<ul> <li>SST/SD (Slice/Service Type and Slice Differentiator)</li> <li>DNN (Data Network Name) Configuration<ul> <li>AMBR (Aggregate Maximum Bit Rate)<ul> <li>Maximum total uplink/downlink bitrate limits</li> </ul> </li> <li>Default 5QI (5G QoS Identifier)<ul> <li>Default Quality of Service identifier</li> <li>GBR type (5QI values: 1-4, 65-67, 71-76)</li> <li>Non-GBR type (5QI values: 5-9, 69-70, 79-80)</li> </ul> </li> <li>Flow Configuration<ul> <li>IP Filter<ul> <li>Source/destination IP address ranges</li> <li>CIDR Format (eg: \"140.113.0.0/16\") </li> </ul> </li> <li>Precedence<ul> <li>Priority of flow rules (lower value means higher priority)</li> </ul> </li> <li>5QI (Flow-specific QoS identifier)<ul> <li>Non-GBR flows: Best effort traffic, no bandwidth guarantee</li> <li>GBR flows: Guaranteed bit rate for specific services</li> </ul> </li> <li>Uplink GBR/MBR (Guaranteed/Maximum Bit Rate)<ul> <li>Applicable for GBR 5QI flows</li> </ul> </li> <li>Downlink GBR/MBR (Guaranteed/Maximum Bit Rate)<ul> <li>Applicable for GBR 5QI flows</li> </ul> </li> <li>Flow-Based Charging Config</li> </ul> </li> </ul> </li> </ul> </li> </ul> <p> </p> <p>Check that the new subscriber was added successfully</p> <p></p>"},{"location":"guide/Webconsole/Create-Subscriber-via-webconsole/#52-create-profile-first-then-create-subscriber-with-the-profile","title":"5.2. Create profile first, then create subscriber with the profile","text":"<ul> <li>Profile is a pre-configured data, which can be used to create multiple subscribers with the same data quickly.</li> <li>For these basic subscriber information, please remember to customize them in the <code>CREATE SUBSCRIBER</code> page:</li> <li>Subscriber data number</li> <li>SUPI (IMSI)</li> <li>PLMNID</li> <li>GPSI (MSISDN)</li> <li>Authentication Management Field (AMF)</li> <li>Authentication Method</li> <li>Operator Code Type</li> <li>Operator Code Value</li> <li>SQN</li> <li>Permanent Authentication Key</li> </ul> <p>Click <code>PROFILE</code> -&gt; <code>CREATE</code></p> <p></p> <p>Edit the Profile's data and click <code>CREATE</code></p> <p> </p> <p>Check that the new profile was added successfully</p> <p></p> <p>Click <code>SUBSCRIBERS</code> -&gt; <code>CREATE</code></p> <p>Click <code>SELECT PROFILE</code> -&gt; Select the profile you just created and customize some basic subscriber information -&gt; <code>CREATE</code></p> <p></p> <p>Check that the new subscriber was added successfully</p> <p></p>"},{"location":"support/","title":"Index","text":""},{"location":"support/#technical-support","title":"Technical Support","text":"<p>If you encounter the usage problem on free5GC, please join our official forum forum.free5gc.org and initiate a new discussion.</p> <p>Otherwise, you can raise the issue on our GitHub repository for reporting the bugs/suggestions (related to vulnerability/functionality/deployment/testing), or create the pull request for contributing to our community!</p> <p>Tips</p> <p>If your problem can not be solved via the platforms listed above, please send an email directly to <code>free5GC.org@gmail.com</code>. Thanks.</p>"}]}